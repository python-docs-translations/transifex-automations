# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-19 14:16+0000\n"
"PO-Revision-Date: 2025-09-16 00:00+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../c-api/typeobj.rst:6
msgid "Type Object Structures"
msgstr "Estruturas de Objetos de Tipo"

#: ../../c-api/typeobj.rst:8
msgid ""
"Perhaps one of the most important structures of the Python object system is "
"the structure that defines a new type: the :c:type:`PyTypeObject` "
"structure.  Type objects can be handled using any of the ``PyObject_*`` or "
"``PyType_*`` functions, but do not offer much that's interesting to most "
"Python applications. These objects are fundamental to how objects behave, so "
"they are very important to the interpreter itself and to any extension "
"module that implements new types."
msgstr ""
"Uma das estruturas mais importantes do sistema de objetos do Python é a "
"estrutura que define um novo tipo: a estrutura :c:type:`PyTypeObject`. Os "
"objetos de tipo podem ser manipulados usando qualquer uma das funções "
"``PyObject_*`` ou ``PyType_*``, mas não oferecem muita coisa interessante "
"para a maioria das aplicações Python. Estes objetos são fundamentais para o "
"comportamento dos objetos, pelo que são muito importantes para o próprio "
"interpretador e para qualquer módulo de extensão que implemente novos tipos."

#: ../../c-api/typeobj.rst:16
msgid ""
"Type objects are fairly large compared to most of the standard types. The "
"reason for the size is that each type object stores a large number of "
"values, mostly C function pointers, each of which implements a small part of "
"the type's functionality.  The fields of the type object are examined in "
"detail in this section.  The fields will be described in the order in which "
"they occur in the structure."
msgstr ""
"Os objetos de tipo são relativamente grandes em comparação com a maioria dos "
"tipos padrão. A razão para o tamanho é que cada objeto de tipo armazena um "
"grande número de valores, maioritariamente ponteiros para funções C, cada um "
"dos quais implementa uma pequena parte da funcionalidade do tipo. Os campos "
"do objeto de tipo são examinados em detalhe nesta secção. Os campos serão "
"descritos pela ordem em que ocorrem na estrutura."

#: ../../c-api/typeobj.rst:23
msgid ""
"In addition to the following quick reference, the :ref:`typedef-examples` "
"section provides at-a-glance insight into the meaning and use of :c:type:"
"`PyTypeObject`."
msgstr ""
"Para além da seguinte referência rápida, a secção :ref:`typedef-examples` "
"fornece uma visão geral do significado e uso de :c:type:`PyTypeObject`."

#: ../../c-api/typeobj.rst:29
msgid "Quick Reference"
msgstr "Referência Rápida"

#: ../../c-api/typeobj.rst:34
msgid "\"tp slots\""
msgstr "\"slots de tp\""

#: ../../c-api/typeobj.rst:40
msgid "PyTypeObject Slot [#slots]_"
msgstr "Slot de PyTypeObject [#slots]_"

#: ../../c-api/typeobj.rst:40 ../../c-api/typeobj.rst:201
msgid ":ref:`Type <slot-typedefs-table>`"
msgstr ":ref:`Tipo <slot-typedefs-table>`"

#: ../../c-api/typeobj.rst:40
msgid "special methods/attrs"
msgstr "métodos/atributos especiais"

#: ../../c-api/typeobj.rst:40
msgid "Info [#cols]_"
msgstr "Informação [#cols]_"

#: ../../c-api/typeobj.rst:42
msgid "O"
msgstr "O"

#: ../../c-api/typeobj.rst:42
msgid "T"
msgstr "T"

#: ../../c-api/typeobj.rst:42
msgid "D"
msgstr "D"

#: ../../c-api/typeobj.rst:42
msgid "I"
msgstr "I"

#: ../../c-api/typeobj.rst:44
msgid "<R> :c:member:`~PyTypeObject.tp_name`"
msgstr "<R> :c:member:`~PyTypeObject.tp_name`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:44
#: ../../c-api/typeobj.rst:86
msgid "const char *"
msgstr "const char *"

#: ../../c-api/typeobj.rst:44
msgid "__name__"
msgstr "__name__"

#: ../../c-api/typeobj.rst:44 ../../c-api/typeobj.rst:46
#: ../../c-api/typeobj.rst:48 ../../c-api/typeobj.rst:50
#: ../../c-api/typeobj.rst:52 ../../c-api/typeobj.rst:62
#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:72
#: ../../c-api/typeobj.rst:74 ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:84
#: ../../c-api/typeobj.rst:86 ../../c-api/typeobj.rst:88
#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:92
#: ../../c-api/typeobj.rst:99 ../../c-api/typeobj.rst:101
#: ../../c-api/typeobj.rst:103 ../../c-api/typeobj.rst:105
#: ../../c-api/typeobj.rst:107 ../../c-api/typeobj.rst:109
#: ../../c-api/typeobj.rst:111 ../../c-api/typeobj.rst:115
#: ../../c-api/typeobj.rst:117 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:122 ../../c-api/typeobj.rst:124
#: ../../c-api/typeobj.rst:126 ../../c-api/typeobj.rst:128
#: ../../c-api/typeobj.rst:130 ../../c-api/typeobj.rst:146
msgid "X"
msgstr "X"

#: ../../c-api/typeobj.rst:46
msgid ":c:member:`~PyTypeObject.tp_basicsize`"
msgstr ":c:member:`~PyTypeObject.tp_basicsize`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:46
#: ../../c-api/typeobj.rst:48 ../../c-api/typeobj.rst:52
#: ../../c-api/typeobj.rst:99 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:417
msgid ":c:type:`Py_ssize_t`"
msgstr ":c:type:`Py_ssize_t`"

#: ../../c-api/typeobj.rst:48
msgid ":c:member:`~PyTypeObject.tp_itemsize`"
msgstr ":c:member:`~PyTypeObject.tp_itemsize`"

#: ../../c-api/typeobj.rst:50
msgid ":c:member:`~PyTypeObject.tp_dealloc`"
msgstr ":c:member:`~PyTypeObject.tp_dealloc`"

#: ../../c-api/typeobj.rst:50 ../../c-api/typeobj.rst:142
#: ../../c-api/typeobj.rst:146 ../../c-api/typeobj.rst:347
msgid ":c:type:`destructor`"
msgstr ":c:type:`destructor`"

#: ../../c-api/typeobj.rst:52
msgid ":c:member:`~PyTypeObject.tp_vectorcall_offset`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall_offset`"

#: ../../c-api/typeobj.rst:54
msgid "(:c:member:`~PyTypeObject.tp_getattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_getattr`)"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:371
msgid ":c:type:`getattrfunc`"
msgstr ":c:type:`getattrfunc`"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:76
msgid "__getattribute__, __getattr__"
msgstr "__getattribute__, __getattr__"

#: ../../c-api/typeobj.rst:54 ../../c-api/typeobj.rst:57
#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:76
#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:88
#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:92
msgid "G"
msgstr "G"

#: ../../c-api/typeobj.rst:57
msgid "(:c:member:`~PyTypeObject.tp_setattr`)"
msgstr "(:c:member:`~PyTypeObject.tp_setattr`)"

#: ../../c-api/typeobj.rst:57 ../../c-api/typeobj.rst:376
msgid ":c:type:`setattrfunc`"
msgstr ":c:type:`setattrfunc`"

#: ../../c-api/typeobj.rst:57 ../../c-api/typeobj.rst:79
msgid "__setattr__, __delattr__"
msgstr "__setattr__, __delattr__"

#: ../../c-api/typeobj.rst:60
msgid ":c:member:`~PyTypeObject.tp_as_async`"
msgstr ":c:member:`~PyTypeObject.tp_as_async`"

#: ../../c-api/typeobj.rst:60
msgid ":c:type:`PyAsyncMethods` *"
msgstr ":c:type:`PyAsyncMethods` *"

#: ../../c-api/typeobj.rst:60 ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66 ../../c-api/typeobj.rst:68
#: ../../c-api/typeobj.rst:82
msgid ":ref:`sub-slots`"
msgstr ":ref:`sub-slots`"

#: ../../c-api/typeobj.rst:60 ../../c-api/typeobj.rst:64
#: ../../c-api/typeobj.rst:66 ../../c-api/typeobj.rst:68
#: ../../c-api/typeobj.rst:82
msgid "%"
msgstr "%"

#: ../../c-api/typeobj.rst:62
msgid ":c:member:`~PyTypeObject.tp_repr`"
msgstr ":c:member:`~PyTypeObject.tp_repr`"

#: ../../c-api/typeobj.rst:62 ../../c-api/typeobj.rst:74
#: ../../c-api/typeobj.rst:369
msgid ":c:type:`reprfunc`"
msgstr ":c:type:`reprfunc`"

#: ../../c-api/typeobj.rst:62
msgid "__repr__"
msgstr "__repr__"

#: ../../c-api/typeobj.rst:64
msgid ":c:member:`~PyTypeObject.tp_as_number`"
msgstr ":c:member:`~PyTypeObject.tp_as_number`"

#: ../../c-api/typeobj.rst:64
msgid ":c:type:`PyNumberMethods` *"
msgstr ":c:type:`PyNumberMethods` *"

#: ../../c-api/typeobj.rst:66
msgid ":c:member:`~PyTypeObject.tp_as_sequence`"
msgstr ":c:member:`~PyTypeObject.tp_as_sequence`"

#: ../../c-api/typeobj.rst:66
msgid ":c:type:`PySequenceMethods` *"
msgstr ":c:type:`PySequenceMethods` *"

#: ../../c-api/typeobj.rst:68
msgid ":c:member:`~PyTypeObject.tp_as_mapping`"
msgstr ":c:member:`~PyTypeObject.tp_as_mapping`"

#: ../../c-api/typeobj.rst:68
msgid ":c:type:`PyMappingMethods` *"
msgstr ":c:type:`PyMappingMethods` *"

#: ../../c-api/typeobj.rst:70
msgid ":c:member:`~PyTypeObject.tp_hash`"
msgstr ":c:member:`~PyTypeObject.tp_hash`"

#: ../../c-api/typeobj.rst:70 ../../c-api/typeobj.rst:405
msgid ":c:type:`hashfunc`"
msgstr ":c:type:`hashfunc`"

#: ../../c-api/typeobj.rst:70
msgid "__hash__"
msgstr "__hash__"

#: ../../c-api/typeobj.rst:72
msgid ":c:member:`~PyTypeObject.tp_call`"
msgstr ":c:member:`~PyTypeObject.tp_call`"

#: ../../c-api/typeobj.rst:72 ../../c-api/typeobj.rst:237
#: ../../c-api/typeobj.rst:240 ../../c-api/typeobj.rst:441
msgid ":c:type:`ternaryfunc`"
msgstr ":c:type:`ternaryfunc`"

#: ../../c-api/typeobj.rst:72
msgid "__call__"
msgstr "__call__"

#: ../../c-api/typeobj.rst:74
msgid ":c:member:`~PyTypeObject.tp_str`"
msgstr ":c:member:`~PyTypeObject.tp_str`"

#: ../../c-api/typeobj.rst:74
msgid "__str__"
msgstr "__str__"

#: ../../c-api/typeobj.rst:76
msgid ":c:member:`~PyTypeObject.tp_getattro`"
msgstr ":c:member:`~PyTypeObject.tp_getattro`"

#: ../../c-api/typeobj.rst:76 ../../c-api/typeobj.rst:382
msgid ":c:type:`getattrofunc`"
msgstr ":c:type:`getattrofunc`"

#: ../../c-api/typeobj.rst:79
msgid ":c:member:`~PyTypeObject.tp_setattro`"
msgstr ":c:member:`~PyTypeObject.tp_setattro`"

#: ../../c-api/typeobj.rst:79 ../../c-api/typeobj.rst:387
msgid ":c:type:`setattrofunc`"
msgstr ":c:type:`setattrofunc`"

#: ../../c-api/typeobj.rst:82
msgid ":c:member:`~PyTypeObject.tp_as_buffer`"
msgstr ":c:member:`~PyTypeObject.tp_as_buffer`"

#: ../../c-api/typeobj.rst:82
msgid ":c:type:`PyBufferProcs` *"
msgstr ":c:type:`PyBufferProcs` *"

#: ../../c-api/typeobj.rst:84
msgid ":c:member:`~PyTypeObject.tp_flags`"
msgstr ":c:member:`~PyTypeObject.tp_flags`"

#: ../../c-api/typeobj.rst:84
msgid "unsigned long"
msgstr "unsigned long"

#: ../../c-api/typeobj.rst:84 ../../c-api/typeobj.rst:99
#: ../../c-api/typeobj.rst:113 ../../c-api/typeobj.rst:120
#: ../../c-api/typeobj.rst:124 ../../c-api/typeobj.rst:126
#: ../../c-api/typeobj.rst:128
msgid "?"
msgstr "?"

#: ../../c-api/typeobj.rst:86
msgid ":c:member:`~PyTypeObject.tp_doc`"
msgstr ":c:member:`~PyTypeObject.tp_doc`"

#: ../../c-api/typeobj.rst:86
msgid "__doc__"
msgstr "__doc__"

#: ../../c-api/typeobj.rst:88
msgid ":c:member:`~PyTypeObject.tp_traverse`"
msgstr ":c:member:`~PyTypeObject.tp_traverse`"

#: ../../c-api/typeobj.rst:88 ../../c-api/typeobj.rst:351
msgid ":c:type:`traverseproc`"
msgstr ":c:type:`traverseproc`"

#: ../../c-api/typeobj.rst:90
msgid ":c:member:`~PyTypeObject.tp_clear`"
msgstr ":c:member:`~PyTypeObject.tp_clear`"

#: ../../c-api/typeobj.rst:90 ../../c-api/typeobj.rst:130
#: ../../c-api/typeobj.rst:248 ../../c-api/typeobj.rst:430
msgid ":c:type:`inquiry`"
msgstr ":c:type:`inquiry`"

#: ../../c-api/typeobj.rst:92
msgid ":c:member:`~PyTypeObject.tp_richcompare`"
msgstr ":c:member:`~PyTypeObject.tp_richcompare`"

#: ../../c-api/typeobj.rst:92 ../../c-api/typeobj.rst:407
msgid ":c:type:`richcmpfunc`"
msgstr ":c:type:`richcmpfunc`"

#: ../../c-api/typeobj.rst:92
msgid "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"
msgstr "__lt__, __le__, __eq__, __ne__, __gt__, __ge__"

#: ../../c-api/typeobj.rst:99
msgid "(:c:member:`~PyTypeObject.tp_weaklistoffset`)"
msgstr "(:c:member:`~PyTypeObject.tp_weaklistoffset`)"

#: ../../c-api/typeobj.rst:101
msgid ":c:member:`~PyTypeObject.tp_iter`"
msgstr ":c:member:`~PyTypeObject.tp_iter`"

#: ../../c-api/typeobj.rst:101 ../../c-api/typeobj.rst:413
msgid ":c:type:`getiterfunc`"
msgstr ":c:type:`getiterfunc`"

#: ../../c-api/typeobj.rst:101
msgid "__iter__"
msgstr "__iter__"

#: ../../c-api/typeobj.rst:103
msgid ":c:member:`~PyTypeObject.tp_iternext`"
msgstr ":c:member:`~PyTypeObject.tp_iternext`"

#: ../../c-api/typeobj.rst:103 ../../c-api/typeobj.rst:415
msgid ":c:type:`iternextfunc`"
msgstr ":c:type:`iternextfunc`"

#: ../../c-api/typeobj.rst:103
msgid "__next__"
msgstr "__next__"

#: ../../c-api/typeobj.rst:105
msgid ":c:member:`~PyTypeObject.tp_methods`"
msgstr ":c:member:`~PyTypeObject.tp_methods`"

#: ../../c-api/typeobj.rst:105
msgid ":c:type:`PyMethodDef` []"
msgstr ":c:type:`PyMethodDef` []"

#: ../../c-api/typeobj.rst:107
msgid ":c:member:`~PyTypeObject.tp_members`"
msgstr ":c:member:`~PyTypeObject.tp_members`"

#: ../../c-api/typeobj.rst:107
msgid ":c:type:`PyMemberDef` []"
msgstr ":c:type:`PyMemberDef` []"

#: ../../c-api/typeobj.rst:109
msgid ":c:member:`~PyTypeObject.tp_getset`"
msgstr ":c:member:`~PyTypeObject.tp_getset`"

#: ../../c-api/typeobj.rst:109
msgid ":c:type:`PyGetSetDef` []"
msgstr ":c:type:`PyGetSetDef` []"

#: ../../c-api/typeobj.rst:111
msgid ":c:member:`~PyTypeObject.tp_base`"
msgstr ":c:member:`~PyTypeObject.tp_base`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:111
msgid ":c:type:`PyTypeObject` *"
msgstr ":c:type:`PyTypeObject` *"

#: ../../c-api/typeobj.rst:111
msgid "__base__"
msgstr "__base__"

#: ../../c-api/typeobj.rst:113
msgid ":c:member:`~PyTypeObject.tp_dict`"
msgstr ":c:member:`~PyTypeObject.tp_dict`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:113
#: ../../c-api/typeobj.rst:132 ../../c-api/typeobj.rst:134
#: ../../c-api/typeobj.rst:136 ../../c-api/typeobj.rst:140
#: ../../c-api/typeobj.rst:342 ../../c-api/typeobj.rst:347
#: ../../c-api/typeobj.rst:357 ../../c-api/typeobj.rst:369
#: ../../c-api/typeobj.rst:371 ../../c-api/typeobj.rst:382
#: ../../c-api/typeobj.rst:393 ../../c-api/typeobj.rst:405
#: ../../c-api/typeobj.rst:407 ../../c-api/typeobj.rst:413
#: ../../c-api/typeobj.rst:415 ../../c-api/typeobj.rst:417
#: ../../c-api/typeobj.rst:430 ../../c-api/typeobj.rst:432
#: ../../c-api/typeobj.rst:436 ../../c-api/typeobj.rst:441
#: ../../c-api/typeobj.rst:447
msgid ":c:type:`PyObject` *"
msgstr ":c:type:`PyObject` *"

#: ../../c-api/typeobj.rst:113
msgid "__dict__"
msgstr "__dict__"

#: ../../c-api/typeobj.rst:115
msgid ":c:member:`~PyTypeObject.tp_descr_get`"
msgstr ":c:member:`~PyTypeObject.tp_descr_get`"

#: ../../c-api/typeobj.rst:115 ../../c-api/typeobj.rst:393
msgid ":c:type:`descrgetfunc`"
msgstr ":c:type:`descrgetfunc`"

#: ../../c-api/typeobj.rst:115
msgid "__get__"
msgstr "__get__"

#: ../../c-api/typeobj.rst:117
msgid ":c:member:`~PyTypeObject.tp_descr_set`"
msgstr ":c:member:`~PyTypeObject.tp_descr_set`"

#: ../../c-api/typeobj.rst:117 ../../c-api/typeobj.rst:399
msgid ":c:type:`descrsetfunc`"
msgstr ":c:type:`descrsetfunc`"

#: ../../c-api/typeobj.rst:117
msgid "__set__, __delete__"
msgstr "__set__, __delete__"

#: ../../c-api/typeobj.rst:120
msgid "(:c:member:`~PyTypeObject.tp_dictoffset`)"
msgstr "(:c:member:`~PyTypeObject.tp_dictoffset`)"

#: ../../c-api/typeobj.rst:122
msgid ":c:member:`~PyTypeObject.tp_init`"
msgstr ":c:member:`~PyTypeObject.tp_init`"

#: ../../c-api/typeobj.rst:122 ../../c-api/typeobj.rst:363
msgid ":c:type:`initproc`"
msgstr ":c:type:`initproc`"

#: ../../c-api/typeobj.rst:122
msgid "__init__"
msgstr "__init__"

#: ../../c-api/typeobj.rst:124
msgid ":c:member:`~PyTypeObject.tp_alloc`"
msgstr ":c:member:`~PyTypeObject.tp_alloc`"

#: ../../c-api/typeobj.rst:124 ../../c-api/typeobj.rst:342
msgid ":c:type:`allocfunc`"
msgstr ":c:type:`allocfunc`"

#: ../../c-api/typeobj.rst:126
msgid ":c:member:`~PyTypeObject.tp_new`"
msgstr ":c:member:`~PyTypeObject.tp_new`"

#: ../../c-api/typeobj.rst:126 ../../c-api/typeobj.rst:357
msgid ":c:type:`newfunc`"
msgstr ":c:type:`newfunc`"

#: ../../c-api/typeobj.rst:126
msgid "__new__"
msgstr "__new__"

#: ../../c-api/typeobj.rst:128
msgid ":c:member:`~PyTypeObject.tp_free`"
msgstr ":c:member:`~PyTypeObject.tp_free`"

#: ../../c-api/typeobj.rst:128 ../../c-api/typeobj.rst:349
msgid ":c:type:`freefunc`"
msgstr ":c:type:`freefunc`"

#: ../../c-api/typeobj.rst:130
msgid ":c:member:`~PyTypeObject.tp_is_gc`"
msgstr ":c:member:`~PyTypeObject.tp_is_gc`"

#: ../../c-api/typeobj.rst:132
msgid "<:c:member:`~PyTypeObject.tp_bases`>"
msgstr "<:c:member:`~PyTypeObject.tp_bases`>"

#: ../../c-api/typeobj.rst:132
msgid "__bases__"
msgstr "__bases__"

#: ../../c-api/typeobj.rst:132 ../../c-api/typeobj.rst:134
msgid "~"
msgstr "~"

#: ../../c-api/typeobj.rst:134
msgid "<:c:member:`~PyTypeObject.tp_mro`>"
msgstr "<:c:member:`~PyTypeObject.tp_mro`>"

#: ../../c-api/typeobj.rst:134
msgid "__mro__"
msgstr "__mro__"

#: ../../c-api/typeobj.rst:136
msgid "[:c:member:`~PyTypeObject.tp_cache`]"
msgstr "[:c:member:`~PyTypeObject.tp_cache`]"

#: ../../c-api/typeobj.rst:138
msgid "[:c:member:`~PyTypeObject.tp_subclasses`]"
msgstr "[:c:member:`~PyTypeObject.tp_subclasses`]"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:138
#: ../../c-api/typeobj.rst:279 ../../c-api/typeobj.rst:349
msgid "void *"
msgstr "void *"

#: ../../c-api/typeobj.rst:138
msgid "__subclasses__"
msgstr "__subclasses__"

#: ../../c-api/typeobj.rst:140
msgid "[:c:member:`~PyTypeObject.tp_weaklist`]"
msgstr "[:c:member:`~PyTypeObject.tp_weaklist`]"

#: ../../c-api/typeobj.rst:142
msgid "(:c:member:`~PyTypeObject.tp_del`)"
msgstr "(:c:member:`~PyTypeObject.tp_del`)"

#: ../../c-api/typeobj.rst:144
msgid "[:c:member:`~PyTypeObject.tp_version_tag`]"
msgstr "[:c:member:`~PyTypeObject.tp_version_tag`]"

#: ../../c-api/typeobj.rst:144
msgid "unsigned int"
msgstr "unsigned int"

#: ../../c-api/typeobj.rst:146
msgid ":c:member:`~PyTypeObject.tp_finalize`"
msgstr ":c:member:`~PyTypeObject.tp_finalize`"

#: ../../c-api/typeobj.rst:146
msgid "__del__"
msgstr "__del__"

#: ../../c-api/typeobj.rst:148
msgid ":c:member:`~PyTypeObject.tp_vectorcall`"
msgstr ":c:member:`~PyTypeObject.tp_vectorcall`"

#: ../../c-api/typeobj.rst:148
msgid ":c:type:`vectorcallfunc`"
msgstr ":c:type:`vectorcallfunc`"

#: ../../c-api/typeobj.rst:150
msgid "[:c:member:`~PyTypeObject.tp_watched`]"
msgstr "[:c:member:`~PyTypeObject.tp_watched`]"

#: ../../c-api/typeobj.rst:150
msgid "unsigned char"
msgstr "unsigned char"

#: ../../c-api/typeobj.rst:155
msgid ""
"**()**: A slot name in parentheses indicates it is (effectively) deprecated."
msgstr ""
"**()**: Um nome de slot entre parênteses indica que está (efetivamente) "
"obsoleto."

#: ../../c-api/typeobj.rst:157
msgid ""
"**<>**: Names in angle brackets should be initially set to ``NULL`` and "
"treated as read-only."
msgstr ""
"**<>**: Nomes entre parênteses angulares devem ser inicialmente definidos "
"como ``NULL`` e tratados como apenas de leitura."

#: ../../c-api/typeobj.rst:160
msgid "**[]**: Names in square brackets are for internal use only."
msgstr "**[]**: Nomes entre parênteses retos são apenas para uso interno."

#: ../../c-api/typeobj.rst:162
msgid ""
"**<R>** (as a prefix) means the field is required (must be non-``NULL``)."
msgstr ""
"**<R>** (como prefixo) significa que o campo é obrigatório (deve ser não-"
"``NULL``)."

#: ../../c-api/typeobj.rst:164
msgid "Columns:"
msgstr "Colunas:"

#: ../../c-api/typeobj.rst:166
msgid "**\"O\"**:  set on :c:data:`PyBaseObject_Type`"
msgstr "**\"O\"**: definido em :c:data:`PyBaseObject_Type`"

#: ../../c-api/typeobj.rst:168
msgid "**\"T\"**:  set on :c:data:`PyType_Type`"
msgstr "**\"T\"**: definido em :c:data:`PyType_Type`"

#: ../../c-api/typeobj.rst:170
msgid "**\"D\"**:  default (if slot is set to ``NULL``)"
msgstr "**\"D\"**: predefinido (se o slot estiver definido como ``NULL``)"

#: ../../c-api/typeobj.rst:172
msgid ""
"X - PyType_Ready sets this value if it is NULL\n"
"~ - PyType_Ready always sets this value (it should be NULL)\n"
"? - PyType_Ready may set this value depending on other slots\n"
"\n"
"Also see the inheritance column (\"I\")."
msgstr ""
"X - PyType_Ready define este valor se for NULL\n"
"~ - PyType_Ready define sempre este valor (deve ser NULL)\n"
"? - PyType_Ready pode definir este valor dependendo de outros slots\n"
"\n"
"Ver também a coluna de herança (\"I\")."

#: ../../c-api/typeobj.rst:180
msgid "**\"I\"**:  inheritance"
msgstr "**\"I\"**: herança"

#: ../../c-api/typeobj.rst:182
msgid ""
"X - type slot is inherited via *PyType_Ready* if defined with a *NULL* "
"value\n"
"% - the slots of the sub-struct are inherited individually\n"
"G - inherited, but only in combination with other slots; see the slot's "
"description\n"
"? - it's complicated; see the slot's description"
msgstr ""
"X - o slot de tipo é herdado via *PyType_Ready* se definido com um valor "
"*NULL*\n"
"% - os slots da subestrutura são herdados individualmente\n"
"G - herdado, mas apenas em combinação com outros slots; ver a descrição do "
"slot\n"
"? - é complicado; ver a descrição do slot"

#: ../../c-api/typeobj.rst:189
msgid ""
"Note that some slots are effectively inherited through the normal attribute "
"lookup chain."
msgstr ""
"Note que alguns slots são efetivamente herdados através da cadeia normal de "
"pesquisa de atributos."

#: ../../c-api/typeobj.rst:195
msgid "sub-slots"
msgstr "sub-slots"

#: ../../c-api/typeobj.rst:201
msgid "Slot"
msgstr "Slot"

#: ../../c-api/typeobj.rst:201
msgid "special methods"
msgstr "métodos especiais"

#: ../../c-api/typeobj.rst:204
msgid ":c:member:`~PyAsyncMethods.am_await`"
msgstr ":c:member:`~PyAsyncMethods.am_await`"

#: ../../c-api/typeobj.rst:204 ../../c-api/typeobj.rst:206
#: ../../c-api/typeobj.rst:208 ../../c-api/typeobj.rst:242
#: ../../c-api/typeobj.rst:244 ../../c-api/typeobj.rst:246
#: ../../c-api/typeobj.rst:250 ../../c-api/typeobj.rst:277
#: ../../c-api/typeobj.rst:281 ../../c-api/typeobj.rst:291
#: ../../c-api/typeobj.rst:432
msgid ":c:type:`unaryfunc`"
msgstr ":c:type:`unaryfunc`"

#: ../../c-api/typeobj.rst:204
msgid "__await__"
msgstr "__await__"

#: ../../c-api/typeobj.rst:206
msgid ":c:member:`~PyAsyncMethods.am_aiter`"
msgstr ":c:member:`~PyAsyncMethods.am_aiter`"

#: ../../c-api/typeobj.rst:206
msgid "__aiter__"
msgstr "__aiter__"

#: ../../c-api/typeobj.rst:208
msgid ":c:member:`~PyAsyncMethods.am_anext`"
msgstr ":c:member:`~PyAsyncMethods.am_anext`"

#: ../../c-api/typeobj.rst:208
msgid "__anext__"
msgstr "__anext__"

#: ../../c-api/typeobj.rst:210
msgid ":c:member:`~PyAsyncMethods.am_send`"
msgstr ":c:member:`~PyAsyncMethods.am_send`"

#: ../../c-api/typeobj.rst:210
msgid ":c:type:`sendfunc`"
msgstr ":c:type:`sendfunc`"

#: ../../c-api/typeobj.rst:214
msgid ":c:member:`~PyNumberMethods.nb_add`"
msgstr ":c:member:`~PyNumberMethods.nb_add`"

#: ../../c-api/typeobj.rst:214 ../../c-api/typeobj.rst:217
#: ../../c-api/typeobj.rst:219 ../../c-api/typeobj.rst:222
#: ../../c-api/typeobj.rst:224 ../../c-api/typeobj.rst:227
#: ../../c-api/typeobj.rst:229 ../../c-api/typeobj.rst:232
#: ../../c-api/typeobj.rst:234 ../../c-api/typeobj.rst:252
#: ../../c-api/typeobj.rst:255 ../../c-api/typeobj.rst:257
#: ../../c-api/typeobj.rst:260 ../../c-api/typeobj.rst:262
#: ../../c-api/typeobj.rst:265 ../../c-api/typeobj.rst:267
#: ../../c-api/typeobj.rst:270 ../../c-api/typeobj.rst:272
#: ../../c-api/typeobj.rst:275 ../../c-api/typeobj.rst:283
#: ../../c-api/typeobj.rst:285 ../../c-api/typeobj.rst:287
#: ../../c-api/typeobj.rst:289 ../../c-api/typeobj.rst:293
#: ../../c-api/typeobj.rst:296 ../../c-api/typeobj.rst:302
#: ../../c-api/typeobj.rst:311 ../../c-api/typeobj.rst:322
#: ../../c-api/typeobj.rst:436
msgid ":c:type:`binaryfunc`"
msgstr ":c:type:`binaryfunc`"

#: ../../c-api/typeobj.rst:214
msgid "__add__ __radd__"
msgstr "__add__ __radd__"

#: ../../c-api/typeobj.rst:217
msgid ":c:member:`~PyNumberMethods.nb_inplace_add`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_add`"

#: ../../c-api/typeobj.rst:217 ../../c-api/typeobj.rst:322
msgid "__iadd__"
msgstr "__iadd__"

#: ../../c-api/typeobj.rst:219
msgid ":c:member:`~PyNumberMethods.nb_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_subtract`"

#: ../../c-api/typeobj.rst:219
msgid "__sub__ __rsub__"
msgstr "__sub__ __rsub__"

#: ../../c-api/typeobj.rst:222
msgid ":c:member:`~PyNumberMethods.nb_inplace_subtract`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_subtract`"

#: ../../c-api/typeobj.rst:222
msgid "__isub__"
msgstr "__isub__"

#: ../../c-api/typeobj.rst:224
msgid ":c:member:`~PyNumberMethods.nb_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_multiply`"

#: ../../c-api/typeobj.rst:224
msgid "__mul__ __rmul__"
msgstr "__mul__ __rmul__"

#: ../../c-api/typeobj.rst:227
msgid ":c:member:`~PyNumberMethods.nb_inplace_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_multiply`"

#: ../../c-api/typeobj.rst:227 ../../c-api/typeobj.rst:324
msgid "__imul__"
msgstr "__imul__"

#: ../../c-api/typeobj.rst:229
msgid ":c:member:`~PyNumberMethods.nb_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_remainder`"

#: ../../c-api/typeobj.rst:229
msgid "__mod__ __rmod__"
msgstr "__mod__ __rmod__"

#: ../../c-api/typeobj.rst:232
msgid ":c:member:`~PyNumberMethods.nb_inplace_remainder`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_remainder`"

#: ../../c-api/typeobj.rst:232
msgid "__imod__"
msgstr "__imod__"

#: ../../c-api/typeobj.rst:234
msgid ":c:member:`~PyNumberMethods.nb_divmod`"
msgstr ":c:member:`~PyNumberMethods.nb_divmod`"

#: ../../c-api/typeobj.rst:234
msgid "__divmod__ __rdivmod__"
msgstr "__divmod__ __rdivmod__"

#: ../../c-api/typeobj.rst:237
msgid ":c:member:`~PyNumberMethods.nb_power`"
msgstr ":c:member:`~PyNumberMethods.nb_power`"

#: ../../c-api/typeobj.rst:237
msgid "__pow__ __rpow__"
msgstr "__pow__ __rpow__"

#: ../../c-api/typeobj.rst:240
msgid ":c:member:`~PyNumberMethods.nb_inplace_power`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_power`"

#: ../../c-api/typeobj.rst:240
msgid "__ipow__"
msgstr "__ipow__"

#: ../../c-api/typeobj.rst:242
msgid ":c:member:`~PyNumberMethods.nb_negative`"
msgstr ":c:member:`~PyNumberMethods.nb_negative`"

#: ../../c-api/typeobj.rst:242
msgid "__neg__"
msgstr "__neg__"

#: ../../c-api/typeobj.rst:244
msgid ":c:member:`~PyNumberMethods.nb_positive`"
msgstr ":c:member:`~PyNumberMethods.nb_positive`"

#: ../../c-api/typeobj.rst:244
msgid "__pos__"
msgstr "__pos__"

#: ../../c-api/typeobj.rst:246
msgid ":c:member:`~PyNumberMethods.nb_absolute`"
msgstr ":c:member:`~PyNumberMethods.nb_absolute`"

#: ../../c-api/typeobj.rst:246
msgid "__abs__"
msgstr "__abs__"

#: ../../c-api/typeobj.rst:248
msgid ":c:member:`~PyNumberMethods.nb_bool`"
msgstr ":c:member:`~PyNumberMethods.nb_bool`"

#: ../../c-api/typeobj.rst:248
msgid "__bool__"
msgstr "__bool__"

#: ../../c-api/typeobj.rst:250
msgid ":c:member:`~PyNumberMethods.nb_invert`"
msgstr ":c:member:`~PyNumberMethods.nb_invert`"

#: ../../c-api/typeobj.rst:250
msgid "__invert__"
msgstr "__invert__"

#: ../../c-api/typeobj.rst:252
msgid ":c:member:`~PyNumberMethods.nb_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_lshift`"

#: ../../c-api/typeobj.rst:252
msgid "__lshift__ __rlshift__"
msgstr "__lshift__ __rlshift__"

#: ../../c-api/typeobj.rst:255
msgid ":c:member:`~PyNumberMethods.nb_inplace_lshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_lshift`"

#: ../../c-api/typeobj.rst:255
msgid "__ilshift__"
msgstr "__ilshift__"

#: ../../c-api/typeobj.rst:257
msgid ":c:member:`~PyNumberMethods.nb_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_rshift`"

#: ../../c-api/typeobj.rst:257
msgid "__rshift__ __rrshift__"
msgstr "__rshift__ __rrshift__"

#: ../../c-api/typeobj.rst:260
msgid ":c:member:`~PyNumberMethods.nb_inplace_rshift`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_rshift`"

#: ../../c-api/typeobj.rst:260
msgid "__irshift__"
msgstr "__irshift__"

#: ../../c-api/typeobj.rst:262
msgid ":c:member:`~PyNumberMethods.nb_and`"
msgstr ":c:member:`~PyNumberMethods.nb_and`"

#: ../../c-api/typeobj.rst:262
msgid "__and__ __rand__"
msgstr "__and__ __rand__"

#: ../../c-api/typeobj.rst:265
msgid ":c:member:`~PyNumberMethods.nb_inplace_and`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_and`"

#: ../../c-api/typeobj.rst:265
msgid "__iand__"
msgstr "__iand__"

#: ../../c-api/typeobj.rst:267
msgid ":c:member:`~PyNumberMethods.nb_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_xor`"

#: ../../c-api/typeobj.rst:267
msgid "__xor__ __rxor__"
msgstr "__xor__ __rxor__"

#: ../../c-api/typeobj.rst:270
msgid ":c:member:`~PyNumberMethods.nb_inplace_xor`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_xor`"

#: ../../c-api/typeobj.rst:270
msgid "__ixor__"
msgstr "__ixor__"

#: ../../c-api/typeobj.rst:272
msgid ":c:member:`~PyNumberMethods.nb_or`"
msgstr ":c:member:`~PyNumberMethods.nb_or`"

#: ../../c-api/typeobj.rst:272
msgid "__or__ __ror__"
msgstr "__or__ __ror__"

#: ../../c-api/typeobj.rst:275
msgid ":c:member:`~PyNumberMethods.nb_inplace_or`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_or`"

#: ../../c-api/typeobj.rst:275
msgid "__ior__"
msgstr "__ior__"

#: ../../c-api/typeobj.rst:277
msgid ":c:member:`~PyNumberMethods.nb_int`"
msgstr ":c:member:`~PyNumberMethods.nb_int`"

#: ../../c-api/typeobj.rst:277
msgid "__int__"
msgstr "__int__"

#: ../../c-api/typeobj.rst:279
msgid ":c:member:`~PyNumberMethods.nb_reserved`"
msgstr ":c:member:`~PyNumberMethods.nb_reserved`"

#: ../../c-api/typeobj.rst:281
msgid ":c:member:`~PyNumberMethods.nb_float`"
msgstr ":c:member:`~PyNumberMethods.nb_float`"

#: ../../c-api/typeobj.rst:281
msgid "__float__"
msgstr "__float__"

#: ../../c-api/typeobj.rst:283
msgid ":c:member:`~PyNumberMethods.nb_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_floor_divide`"

#: ../../c-api/typeobj.rst:283
msgid "__floordiv__"
msgstr "__floordiv__"

#: ../../c-api/typeobj.rst:285
msgid ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_floor_divide`"

#: ../../c-api/typeobj.rst:285
msgid "__ifloordiv__"
msgstr "__ifloordiv__"

#: ../../c-api/typeobj.rst:287
msgid ":c:member:`~PyNumberMethods.nb_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_true_divide`"

#: ../../c-api/typeobj.rst:287
msgid "__truediv__"
msgstr "__truediv__"

#: ../../c-api/typeobj.rst:289
msgid ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_true_divide`"

#: ../../c-api/typeobj.rst:289
msgid "__itruediv__"
msgstr "__itruediv__"

#: ../../c-api/typeobj.rst:291
msgid ":c:member:`~PyNumberMethods.nb_index`"
msgstr ":c:member:`~PyNumberMethods.nb_index`"

#: ../../c-api/typeobj.rst:291
msgid "__index__"
msgstr "__index__"

#: ../../c-api/typeobj.rst:293
msgid ":c:member:`~PyNumberMethods.nb_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_matrix_multiply`"

#: ../../c-api/typeobj.rst:293
msgid "__matmul__ __rmatmul__"
msgstr "__matmul__ __rmatmul__"

#: ../../c-api/typeobj.rst:296
msgid ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"
msgstr ":c:member:`~PyNumberMethods.nb_inplace_matrix_multiply`"

#: ../../c-api/typeobj.rst:296
msgid "__imatmul__"
msgstr "__imatmul__"

#: ../../c-api/typeobj.rst:300
msgid ":c:member:`~PyMappingMethods.mp_length`"
msgstr ":c:member:`~PyMappingMethods.mp_length`"

#: ../../c-api/typeobj.rst:300 ../../c-api/typeobj.rst:309
#: ../../c-api/typeobj.rst:417
msgid ":c:type:`lenfunc`"
msgstr ":c:type:`lenfunc`"

#: ../../c-api/typeobj.rst:300 ../../c-api/typeobj.rst:309
msgid "__len__"
msgstr "__len__"

#: ../../c-api/typeobj.rst:302
msgid ":c:member:`~PyMappingMethods.mp_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_subscript`"

#: ../../c-api/typeobj.rst:302 ../../c-api/typeobj.rst:315
msgid "__getitem__"
msgstr "__getitem__"

#: ../../c-api/typeobj.rst:304
msgid ":c:member:`~PyMappingMethods.mp_ass_subscript`"
msgstr ":c:member:`~PyMappingMethods.mp_ass_subscript`"

#: ../../c-api/typeobj.rst:304 ../../c-api/typeobj.rst:463
msgid ":c:type:`objobjargproc`"
msgstr ":c:type:`objobjargproc`"

#: ../../c-api/typeobj.rst:304
msgid "__setitem__, __delitem__"
msgstr "__setitem__, __delitem__"

#: ../../c-api/typeobj.rst:309
msgid ":c:member:`~PySequenceMethods.sq_length`"
msgstr ":c:member:`~PySequenceMethods.sq_length`"

#: ../../c-api/typeobj.rst:311
msgid ":c:member:`~PySequenceMethods.sq_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_concat`"

#: ../../c-api/typeobj.rst:311
msgid "__add__"
msgstr "__add__"

#: ../../c-api/typeobj.rst:313
msgid ":c:member:`~PySequenceMethods.sq_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_repeat`"

#: ../../c-api/typeobj.rst:313 ../../c-api/typeobj.rst:315
#: ../../c-api/typeobj.rst:324 ../../c-api/typeobj.rst:447
msgid ":c:type:`ssizeargfunc`"
msgstr ":c:type:`ssizeargfunc`"

#: ../../c-api/typeobj.rst:313
msgid "__mul__"
msgstr "__mul__"

#: ../../c-api/typeobj.rst:315
msgid ":c:member:`~PySequenceMethods.sq_item`"
msgstr ":c:member:`~PySequenceMethods.sq_item`"

#: ../../c-api/typeobj.rst:317
msgid ":c:member:`~PySequenceMethods.sq_ass_item`"
msgstr ":c:member:`~PySequenceMethods.sq_ass_item`"

#: ../../c-api/typeobj.rst:317 ../../c-api/typeobj.rst:452
msgid ":c:type:`ssizeobjargproc`"
msgstr ":c:type:`ssizeobjargproc`"

#: ../../c-api/typeobj.rst:317
msgid "__setitem__ __delitem__"
msgstr "__setitem__ __delitem__"

#: ../../c-api/typeobj.rst:320
msgid ":c:member:`~PySequenceMethods.sq_contains`"
msgstr ":c:member:`~PySequenceMethods.sq_contains`"

#: ../../c-api/typeobj.rst:320 ../../c-api/typeobj.rst:458
msgid ":c:type:`objobjproc`"
msgstr ":c:type:`objobjproc`"

#: ../../c-api/typeobj.rst:320
msgid "__contains__"
msgstr "__contains__"

#: ../../c-api/typeobj.rst:322
msgid ":c:member:`~PySequenceMethods.sq_inplace_concat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_concat`"

#: ../../c-api/typeobj.rst:324
msgid ":c:member:`~PySequenceMethods.sq_inplace_repeat`"
msgstr ":c:member:`~PySequenceMethods.sq_inplace_repeat`"

#: ../../c-api/typeobj.rst:328
msgid ":c:member:`~PyBufferProcs.bf_getbuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_getbuffer`"

#: ../../c-api/typeobj.rst:328
msgid ":c:func:`getbufferproc`"
msgstr ":c:func:`getbufferproc`"

#: ../../c-api/typeobj.rst:328
msgid "__buffer__"
msgstr "__buffer__"

#: ../../c-api/typeobj.rst:330
msgid ":c:member:`~PyBufferProcs.bf_releasebuffer`"
msgstr ":c:member:`~PyBufferProcs.bf_releasebuffer`"

#: ../../c-api/typeobj.rst:330
msgid ":c:func:`releasebufferproc`"
msgstr ":c:func:`releasebufferproc`"

#: ../../c-api/typeobj.rst:330
msgid "__release_\\ buffer\\__"
msgstr "__release_\\ buffer\\__"

#: ../../c-api/typeobj.rst:337
msgid "slot typedefs"
msgstr "definições de tipos de slot"

#: ../../c-api/typeobj.rst:340
msgid "typedef"
msgstr "typedef"

#: ../../c-api/typeobj.rst:340
msgid "Parameter Types"
msgstr "Tipos de Parâmetros"

#: ../../c-api/typeobj.rst:340
msgid "Return Type"
msgstr "Tipo de Retorno"

#: ../../c-api/typeobj.rst:347 ../../c-api/typeobj.rst:349
#: ../../c-api/typeobj.rst:425
msgid "void"
msgstr "void"

#: ../../c-api/typeobj.rst:0
msgid ":c:type:`visitproc`"
msgstr ":c:type:`visitproc`"

#: ../../c-api/typeobj.rst:0 ../../c-api/typeobj.rst:351
#: ../../c-api/typeobj.rst:363 ../../c-api/typeobj.rst:376
#: ../../c-api/typeobj.rst:387 ../../c-api/typeobj.rst:399
#: ../../c-api/typeobj.rst:419 ../../c-api/typeobj.rst:430
#: ../../c-api/typeobj.rst:452 ../../c-api/typeobj.rst:458
#: ../../c-api/typeobj.rst:463
msgid "int"
msgstr "int"

#: ../../c-api/typeobj.rst:405
msgid "Py_hash_t"
msgstr "Py_hash_t"

#: ../../c-api/typeobj.rst:419
msgid ":c:type:`getbufferproc`"
msgstr ":c:type:`getbufferproc`"

#: ../../c-api/typeobj.rst:0
msgid ":c:type:`Py_buffer` *"
msgstr ":c:type:`Py_buffer` *"

#: ../../c-api/typeobj.rst:425
msgid ":c:type:`releasebufferproc`"
msgstr ":c:type:`releasebufferproc`"

#: ../../c-api/typeobj.rst:470
msgid "See :ref:`slot-typedefs` below for more detail."
msgstr "Ver :ref:`slot-typedefs` abaixo para mais detalhes."

#: ../../c-api/typeobj.rst:474
msgid "PyTypeObject Definition"
msgstr "Definição de PyTypeObject"

#: ../../c-api/typeobj.rst:476
msgid ""
"The structure definition for :c:type:`PyTypeObject` can be found in :file:"
"`Include/cpython/object.h`.  For convenience of reference, this repeats the "
"definition found there:"
msgstr ""
"A definição da estrutura para :c:type:`PyTypeObject` pode ser encontrada em :"
"file:`Include/cpython/object.h`. Para facilidade de referência, esta secção "
"repete a definição encontrada lá:"

#: ../../c-api/typeobj.rst:482
msgid ""
"typedef struct _typeobject {\n"
"    PyObject_VAR_HEAD\n"
"    const char *tp_name; /* For printing, in format \"<module>.<name>\" */\n"
"    Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */\n"
"\n"
"    /* Methods to implement standard operations */\n"
"\n"
"    destructor tp_dealloc;\n"
"    Py_ssize_t tp_vectorcall_offset;\n"
"    getattrfunc tp_getattr;\n"
"    setattrfunc tp_setattr;\n"
"    PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2)\n"
"                                    or tp_reserved (Python 3) */\n"
"    reprfunc tp_repr;\n"
"\n"
"    /* Method suites for standard classes */\n"
"\n"
"    PyNumberMethods *tp_as_number;\n"
"    PySequenceMethods *tp_as_sequence;\n"
"    PyMappingMethods *tp_as_mapping;\n"
"\n"
"    /* More standard operations (here for binary compatibility) */\n"
"\n"
"    hashfunc tp_hash;\n"
"    ternaryfunc tp_call;\n"
"    reprfunc tp_str;\n"
"    getattrofunc tp_getattro;\n"
"    setattrofunc tp_setattro;\n"
"\n"
"    /* Functions to access object as input/output buffer */\n"
"    PyBufferProcs *tp_as_buffer;\n"
"\n"
"    /* Flags to define presence of optional/expanded features */\n"
"    unsigned long tp_flags;\n"
"\n"
"    const char *tp_doc; /* Documentation string */\n"
"\n"
"    /* Assigned meaning in release 2.0 */\n"
"    /* call function for all accessible objects */\n"
"    traverseproc tp_traverse;\n"
"\n"
"    /* delete references to contained objects */\n"
"    inquiry tp_clear;\n"
"\n"
"    /* Assigned meaning in release 2.1 */\n"
"    /* rich comparisons */\n"
"    richcmpfunc tp_richcompare;\n"
"\n"
"    /* weak reference enabler */\n"
"    Py_ssize_t tp_weaklistoffset;\n"
"\n"
"    /* Iterators */\n"
"    getiterfunc tp_iter;\n"
"    iternextfunc tp_iternext;\n"
"\n"
"    /* Attribute descriptor and subclassing stuff */\n"
"    PyMethodDef *tp_methods;\n"
"    PyMemberDef *tp_members;\n"
"    PyGetSetDef *tp_getset;\n"
"    // Strong reference on a heap type, borrowed reference on a static type\n"
"    PyTypeObject *tp_base;\n"
"    PyObject *tp_dict;\n"
"    descrgetfunc tp_descr_get;\n"
"    descrsetfunc tp_descr_set;\n"
"    Py_ssize_t tp_dictoffset;\n"
"    initproc tp_init;\n"
"    allocfunc tp_alloc;\n"
"    newfunc tp_new;\n"
"    freefunc tp_free; /* Low-level free-memory routine */\n"
"    inquiry tp_is_gc; /* For PyObject_IS_GC */\n"
"    PyObject *tp_bases;\n"
"    PyObject *tp_mro; /* method resolution order */\n"
"    PyObject *tp_cache; /* no longer used */\n"
"    void *tp_subclasses;  /* for static builtin types this is an index */\n"
"    PyObject *tp_weaklist; /* not used for static builtin types */\n"
"    destructor tp_del;\n"
"\n"
"    /* Type attribute cache version tag. Added in version 2.6.\n"
"     * If zero, the cache is invalid and must be initialized.\n"
"     */\n"
"    unsigned int tp_version_tag;\n"
"\n"
"    destructor tp_finalize;\n"
"    vectorcallfunc tp_vectorcall;\n"
"\n"
"    /* bitset of which type-watchers care about this type */\n"
"    unsigned char tp_watched;\n"
"\n"
"    /* Number of tp_version_tag values used.\n"
"     * Set to _Py_ATTR_CACHE_UNUSED if the attribute cache is\n"
"     * disabled for this type (e.g. due to custom MRO entries).\n"
"     * Otherwise, limited to MAX_VERSIONS_PER_CLASS (defined elsewhere).\n"
"     */\n"
"    uint16_t tp_versions_used;\n"
"} PyTypeObject;\n"
msgstr ""
"typedef struct _typeobject {\n"
"    PyObject_VAR_HEAD\n"
"    const char *tp_name; /* Para impressão, no formato \"<module>.<name>\" "
"*/\n"
"    Py_ssize_t tp_basicsize, tp_itemsize; /* Para alocação */\n"
"\n"
"    /* Métodos para implementar operações padrão */\n"
"\n"
"    destructor tp_dealloc;\n"
"    Py_ssize_t tp_vectorcall_offset;\n"
"    getattrfunc tp_getattr;\n"
"    setattrfunc tp_setattr;\n"
"    PyAsyncMethods *tp_as_async; /* anteriormente conhecido como tp_compare "
"(Python 2)\n"
"                                    ou tp_reserved (Python 3) */\n"
"    reprfunc tp_repr;\n"
"\n"
"    /* Suítes de métodos para classes padrão */\n"
"\n"
"    PyNumberMethods *tp_as_number;\n"
"    PySequenceMethods *tp_as_sequence;\n"
"    PyMappingMethods *tp_as_mapping;\n"
"\n"
"    /* Mais operações padrão (aqui por compatibilidade binária) */\n"
"\n"
"    hashfunc tp_hash;\n"
"    ternaryfunc tp_call;\n"
"    reprfunc tp_str;\n"
"    getattrofunc tp_getattro;\n"
"    setattrofunc tp_setattro;\n"
"\n"
"    /* Funções para aceder ao objeto como buffer de entrada/saída */\n"
"    PyBufferProcs *tp_as_buffer;\n"
"\n"
"    /* Flags para definir a presença de funcionalidades opcionais/expandidas "
"*/\n"
"    unsigned long tp_flags;\n"
"\n"
"    const char *tp_doc; /* Cadeia de caracteres de documentação */\n"
"\n"
"    /* Atribuído significado na versão 2.0 */\n"
"    /* função de chamada para todos os objetos acessíveis */\n"
"    traverseproc tp_traverse;\n"
"\n"
"    /* apagar referências a objetos contidos */\n"
"    inquiry tp_clear;\n"
"\n"
"    /* Atribuído significado na versão 2.1 */\n"
"    /* comparações ricas */\n"
"    richcmpfunc tp_richcompare;\n"
"\n"
"    /* ativador de referências fracas */\n"
"    Py_ssize_t tp_weaklistoffset;\n"
"\n"
"    /* Iteradores */\n"
"    getiterfunc tp_iter;\n"
"    iternextfunc tp_iternext;\n"
"\n"
"    /* Descritores de atributos e material de subclasses */\n"
"    PyMethodDef *tp_methods;\n"
"    PyMemberDef *tp_members;\n"
"    PyGetSetDef *tp_getset;\n"
"    // Referência forte num tipo de heap, referência emprestada num tipo "
"estático\n"
"    PyTypeObject *tp_base;\n"
"    PyObject *tp_dict;\n"
"    descrgetfunc tp_descr_get;\n"
"    descrsetfunc tp_descr_set;\n"
"    Py_ssize_t tp_dictoffset;\n"
"    initproc tp_init;\n"
"    allocfunc tp_alloc;\n"
"    newfunc tp_new;\n"
"    freefunc tp_free; /* Rotina de libertação de memória de baixo nível */\n"
"    inquiry tp_is_gc; /* Para PyObject_IS_GC */\n"
"    PyObject *tp_bases;\n"
"    PyObject *tp_mro; /* ordem de resolução de métodos */\n"
"    PyObject *tp_cache; /* já não é usado */\n"
"    void *tp_subclasses;  /* para tipos incorporados estáticos, isto é um "
"índice */\n"
"    PyObject *tp_weaklist; /* não é usado para tipos incorporados estáticos "
"*/\n"
"    destructor tp_del;\n"
"\n"
"    /* Etiqueta de versão da cache de atributos de tipo. Adicionado na "
"versão 2.6.\n"
"     * Se zero, a cache é inválida e deve ser inicializada.\n"
"     */\n"
"    unsigned int tp_version_tag;\n"
"\n"
"    destructor tp_finalize;\n"
"    vectorcallfunc tp_vectorcall;\n"
"\n"
"    /* bitset de quais observadores de tipo se preocupam com este tipo */\n"
"    unsigned char tp_watched;\n"
"\n"
"    /* Número de valores tp_version_tag usados.\n"
"     * Definido como _Py_ATTR_CACHE_UNUSED se a cache de atributos estiver\n"
"     * desativada para este tipo (por exemplo, devido a entradas MRO "
"personalizadas).\n"
"     * Caso contrário, limitado a MAX_VERSIONS_PER_CLASS (definido noutro "
"local).\n"
"     */\n"
"    uint16_t tp_versions_used;\n"
"} PyTypeObject;\n"

#: ../../c-api/typeobj.rst:486
msgid "PyObject Slots"
msgstr "Slots de PyObject"

#: ../../c-api/typeobj.rst:488
msgid ""
"The type object structure extends the :c:type:`PyVarObject` structure. The :"
"c:member:`~PyVarObject.ob_size` field is used for dynamic types (created by :"
"c:func:`!type_new`, usually called from a class statement). Note that :c:"
"data:`PyType_Type` (the metatype) initializes :c:member:`~PyTypeObject."
"tp_itemsize`, which means that its instances (i.e. type objects) *must* have "
"the :c:member:`~PyVarObject.ob_size` field."
msgstr ""
"A estrutura do objeto de tipo estende a estrutura :c:type:`PyVarObject`. O "
"campo :c:member:`~PyVarObject.ob_size` é usado para tipos dinâmicos (criados "
"por :c:func:`!type_new`, normalmente chamados a partir de uma declaração de "
"classe). Note que :c:data:`PyType_Type` (o metatipo) inicializa :c:member:"
"`~PyTypeObject.tp_itemsize`, o que significa que as suas instâncias (ou "
"seja, objetos de tipo) *devem* ter o campo :c:member:`~PyVarObject.ob_size`."

#: ../../c-api/typeobj.rst:495
msgid ":c:member:`PyObject.ob_refcnt`"
msgstr ":c:member:`PyObject.ob_refcnt`"

#: ../../c-api/typeobj.rst:497
msgid ""
"The type object's reference count is initialized to ``1`` by the "
"``PyObject_HEAD_INIT`` macro.  Note that for :ref:`statically allocated type "
"objects <static-types>`, the type's instances (objects whose :c:member:"
"`~PyObject.ob_type` points back to the type) do *not* count as references.  "
"But for :ref:`dynamically allocated type objects <heap-types>`, the "
"instances *do* count as references."
msgstr ""
"A contagem de referências do objeto de tipo é inicializada para ``1`` pela "
"macro ``PyObject_HEAD_INIT``. Note que para :ref:`objetos de tipo alocados "
"estaticamente <static-types>`, as instâncias do tipo (objetos cujo :c:member:"
"`~PyObject.ob_type` aponta de volta para o tipo) *não* contam como "
"referências. Mas para :ref:`objetos de tipo alocados dinamicamente <heap-"
"types>`, as instâncias *contam* como referências."

#: ../../c-api/typeobj.rst:504 ../../c-api/typeobj.rst:527
#: ../../c-api/typeobj.rst:543 ../../c-api/typeobj.rst:587
#: ../../c-api/typeobj.rst:665 ../../c-api/typeobj.rst:807
#: ../../c-api/typeobj.rst:852 ../../c-api/typeobj.rst:869
#: ../../c-api/typeobj.rst:886 ../../c-api/typeobj.rst:904
#: ../../c-api/typeobj.rst:928 ../../c-api/typeobj.rst:945
#: ../../c-api/typeobj.rst:957 ../../c-api/typeobj.rst:969
#: ../../c-api/typeobj.rst:1002 ../../c-api/typeobj.rst:1024
#: ../../c-api/typeobj.rst:1044 ../../c-api/typeobj.rst:1065
#: ../../c-api/typeobj.rst:1091 ../../c-api/typeobj.rst:1110
#: ../../c-api/typeobj.rst:1126 ../../c-api/typeobj.rst:1166
#: ../../c-api/typeobj.rst:1177 ../../c-api/typeobj.rst:1187
#: ../../c-api/typeobj.rst:1197 ../../c-api/typeobj.rst:1211
#: ../../c-api/typeobj.rst:1229 ../../c-api/typeobj.rst:1252
#: ../../c-api/typeobj.rst:1270 ../../c-api/typeobj.rst:1283
#: ../../c-api/typeobj.rst:1305 ../../c-api/typeobj.rst:1349
#: ../../c-api/typeobj.rst:1370 ../../c-api/typeobj.rst:1389
#: ../../c-api/typeobj.rst:1419 ../../c-api/typeobj.rst:1441
#: ../../c-api/typeobj.rst:1467 ../../c-api/typeobj.rst:1558
#: ../../c-api/typeobj.rst:1702 ../../c-api/typeobj.rst:1767
#: ../../c-api/typeobj.rst:1803 ../../c-api/typeobj.rst:1828
#: ../../c-api/typeobj.rst:1851 ../../c-api/typeobj.rst:1864
#: ../../c-api/typeobj.rst:1879 ../../c-api/typeobj.rst:1893
#: ../../c-api/typeobj.rst:1923 ../../c-api/typeobj.rst:1955
#: ../../c-api/typeobj.rst:1981 ../../c-api/typeobj.rst:1999
#: ../../c-api/typeobj.rst:2028 ../../c-api/typeobj.rst:2072
#: ../../c-api/typeobj.rst:2089 ../../c-api/typeobj.rst:2129
#: ../../c-api/typeobj.rst:2152 ../../c-api/typeobj.rst:2190
#: ../../c-api/typeobj.rst:2218 ../../c-api/typeobj.rst:2231
#: ../../c-api/typeobj.rst:2241 ../../c-api/typeobj.rst:2258
#: ../../c-api/typeobj.rst:2275 ../../c-api/typeobj.rst:2289
#: ../../c-api/typeobj.rst:2431 ../../c-api/typeobj.rst:2489
msgid "**Inheritance:**"
msgstr "**Herança:**"

#: ../../c-api/typeobj.rst:506 ../../c-api/typeobj.rst:545
#: ../../c-api/typeobj.rst:589
msgid "This field is not inherited by subtypes."
msgstr "Este campo não é herdado por subtipos."

#: ../../c-api/typeobj.rst:509
msgid ":c:member:`PyObject.ob_type`"
msgstr ":c:member:`PyObject.ob_type`"

#: ../../c-api/typeobj.rst:511
msgid ""
"This is the type's type, in other words its metatype.  It is initialized by "
"the argument to the ``PyObject_HEAD_INIT`` macro, and its value should "
"normally be ``&PyType_Type``.  However, for dynamically loadable extension "
"modules that must be usable on Windows (at least), the compiler complains "
"that this is not a valid initializer.  Therefore, the convention is to pass "
"``NULL`` to the ``PyObject_HEAD_INIT`` macro and to initialize this field "
"explicitly at the start of the module's initialization function, before "
"doing anything else.  This is typically done like this::"
msgstr ""
"Este é o tipo do tipo, em outras palavras, o seu metatipo. É inicializado "
"pelo argumento da macro ``PyObject_HEAD_INIT``, e o seu valor deve "
"normalmente ser ``&PyType_Type``. No entanto, para módulos de extensão "
"carregáveis dinamicamente que devem ser utilizáveis no Windows (pelo menos), "
"o compilador reclama que isto não é um inicializador válido. Portanto, a "
"convenção é passar ``NULL`` para a macro ``PyObject_HEAD_INIT`` e "
"inicializar este campo explicitamente no início da função de inicialização "
"do módulo, antes de fazer mais nada. Isto é tipicamente feito assim::"

#: ../../c-api/typeobj.rst:520
msgid "Foo_Type.ob_type = &PyType_Type;"
msgstr "Foo_Type.ob_type = &PyType_Type;"

#: ../../c-api/typeobj.rst:522
msgid ""
"This should be done before any instances of the type are created. :c:func:"
"`PyType_Ready` checks if :c:member:`~PyObject.ob_type` is ``NULL``, and if "
"so, initializes it to the :c:member:`~PyObject.ob_type` field of the base "
"class. :c:func:`PyType_Ready` will not change this field if it is non-zero."
msgstr ""
"Isto deve ser feito antes de qualquer instância do tipo ser criada. :c:func:"
"`PyType_Ready` verifica se :c:member:`~PyObject.ob_type` é ``NULL``, e, se "
"for, inicializa-o para o campo :c:member:`~PyObject.ob_type` da classe "
"base. :c:func:`PyType_Ready` não alterará este campo se não for zero."

#: ../../c-api/typeobj.rst:529 ../../c-api/typeobj.rst:809
#: ../../c-api/typeobj.rst:930 ../../c-api/typeobj.rst:1026
#: ../../c-api/typeobj.rst:1046 ../../c-api/typeobj.rst:1830
#: ../../c-api/typeobj.rst:1853 ../../c-api/typeobj.rst:1983
#: ../../c-api/typeobj.rst:2001 ../../c-api/typeobj.rst:2074
#: ../../c-api/typeobj.rst:2192 ../../c-api/typeobj.rst:2433
msgid "This field is inherited by subtypes."
msgstr "Este campo é herdado por subtipos."

#: ../../c-api/typeobj.rst:533
msgid "PyVarObject Slots"
msgstr "Slots de PyVarObject"

#: ../../c-api/typeobj.rst:535
msgid ":c:member:`PyVarObject.ob_size`"
msgstr ":c:member:`PyVarObject.ob_size`"

#: ../../c-api/typeobj.rst:537
msgid ""
"For :ref:`statically allocated type objects <static-types>`, this should be "
"initialized to zero. For :ref:`dynamically allocated type objects <heap-"
"types>`, this field has a special internal meaning."
msgstr ""
"Para :ref:`objetos de tipo alocados estaticamente <static-types>`, isto deve "
"ser inicializado para zero. Para :ref:`objetos de tipo alocados "
"dinamicamente <heap-types>`, este campo tem um significado interno especial."

#: ../../c-api/typeobj.rst:541
msgid "This field should be accessed using the :c:func:`Py_SIZE()` macro."
msgstr "Este campo deve ser acedido usando a macro :c:func:`Py_SIZE()`."

#: ../../c-api/typeobj.rst:549
msgid "PyTypeObject Slots"
msgstr "Slots de PyTypeObject"

#: ../../c-api/typeobj.rst:551
msgid ""
"Each slot has a section describing inheritance.  If :c:func:`PyType_Ready` "
"may set a value when the field is set to ``NULL`` then there will also be a "
"\"Default\" section.  (Note that many fields set on :c:data:"
"`PyBaseObject_Type` and :c:data:`PyType_Type` effectively act as defaults.)"
msgstr ""
"Cada slot tem uma secção que descreve a herança. Se :c:func:`PyType_Ready` "
"pode definir um valor quando o campo é definido como ``NULL``, então também "
"haverá uma secção \"Predefinição\". (Note que muitos campos definidos em :c:"
"data:`PyBaseObject_Type` e :c:data:`PyType_Type` atuam efetivamente como "
"predefinições.)"

#: ../../c-api/typeobj.rst:558
msgid ""
"Pointer to a NUL-terminated string containing the name of the type. For "
"types that are accessible as module globals, the string should be the full "
"module name, followed by a dot, followed by the type name; for built-in "
"types, it should be just the type name.  If the module is a submodule of a "
"package, the full package name is part of the full module name.  For "
"example, a type named :class:`!T` defined in module :mod:`!M` in subpackage :"
"mod:`!Q` in package :mod:`!P` should have the :c:member:`~PyTypeObject."
"tp_name` initializer ``\"P.Q.M.T\"``."
msgstr ""
"Ponteiro para uma cadeia de caracteres terminada por NUL que contém o nome "
"do tipo. Para tipos que são acessíveis como globais de módulo, a cadeia de "
"caracteres deve ser o nome completo do módulo, seguido de um ponto, seguido "
"do nome do tipo; para tipos incorporados, deve ser apenas o nome do tipo. Se "
"o módulo é um submódulo de um pacote, o nome completo do pacote faz parte do "
"nome completo do módulo. Por exemplo, um tipo chamado :class:`!T` definido "
"no módulo :mod:`!M` no subpacote :mod:`!Q` no pacote :mod:`!P` deve ter o "
"inicializador :c:member:`~PyTypeObject.tp_name` ``\"P.Q.M.T\"``."

#: ../../c-api/typeobj.rst:566
msgid ""
"For :ref:`dynamically allocated type objects <heap-types>`, this should just "
"be the type name, and the module name explicitly stored in the type dict as "
"the value for key ``'__module__'``."
msgstr ""
"Para :ref:`objetos de tipo alocados dinamicamente <heap-types>`, isto deve "
"ser apenas o nome do tipo, e o nome do módulo armazenado explicitamente no "
"dicionário do tipo como o valor para a chave ``'__module__'``."

#: ../../c-api/typeobj.rst:571
msgid ""
"For :ref:`statically allocated type objects <static-types>`, the *tp_name* "
"field should contain a dot. Everything before the last dot is made "
"accessible as the :attr:`~type.__module__` attribute, and everything after "
"the last dot is made accessible as the :attr:`~type.__name__` attribute."
msgstr ""
"Para :ref:`objetos de tipo alocados estaticamente <static-types>`, o campo "
"*tp_name* deve conter um ponto. Tudo antes do último ponto é tornado "
"acessível como o atributo :attr:`~type.__module__`, e tudo depois do último "
"ponto é tornado acessível como o atributo :attr:`~type.__name__`."

#: ../../c-api/typeobj.rst:577
msgid ""
"If no dot is present, the entire :c:member:`~PyTypeObject.tp_name` field is "
"made accessible as the :attr:`~type.__name__` attribute, and the :attr:"
"`~type.__module__` attribute is undefined (unless explicitly set in the "
"dictionary, as explained above).  This means your type will be impossible to "
"pickle.  Additionally, it will not be listed in module documentations "
"created with pydoc."
msgstr ""
"Se não houver ponto, todo o campo :c:member:`~PyTypeObject.tp_name` é "
"tornado acessível como o atributo :attr:`~type.__name__`, e o atributo :attr:"
"`~type.__module__` é indefinido (a menos que seja definido explicitamente no "
"dicionário, como explicado acima). Isto significa que o seu tipo será "
"impossível de serializar. Além disso, não será listado na documentação do "
"módulo criada com pydoc."

#: ../../c-api/typeobj.rst:583
msgid ""
"This field must not be ``NULL``.  It is the only required field in :c:func:"
"`PyTypeObject` (other than potentially :c:member:`~PyTypeObject."
"tp_itemsize`)."
msgstr ""
"Este campo não pode ser ``NULL``. É o único campo obrigatório em :c:func:"
"`PyTypeObject` (além de potencialmente :c:member:`~PyTypeObject."
"tp_itemsize`)."

#: ../../c-api/typeobj.rst:595
msgid ""
"These fields allow calculating the size in bytes of instances of the type."
msgstr ""
"Estes campos permitem calcular o tamanho em bytes das instâncias do tipo."

#: ../../c-api/typeobj.rst:597
msgid ""
"There are two kinds of types: types with fixed-length instances have a zero :"
"c:member:`!tp_itemsize` field, types with variable-length instances have a "
"non-zero :c:member:`!tp_itemsize` field.  For a type with fixed-length "
"instances, all instances have the same size, given in :c:member:`!"
"tp_basicsize`. (Exceptions to this rule can be made using :c:func:"
"`PyUnstable_Object_GC_NewWithExtraData`.)"
msgstr ""
"Existem dois tipos de tipos: tipos com instâncias de comprimento fixo têm um "
"campo :c:member:`!tp_itemsize` zero, tipos com instâncias de comprimento "
"variável têm um campo :c:member:`!tp_itemsize` não-zero. Para um tipo com "
"instâncias de comprimento fixo, todas as instâncias têm o mesmo tamanho, "
"dado em :c:member:`!tp_basicsize`. (Exceções a esta regra podem ser feitas "
"usando :c:func:`PyUnstable_Object_GC_NewWithExtraData`.)"

#: ../../c-api/typeobj.rst:604
msgid ""
"For a type with variable-length instances, the instances must have an :c:"
"member:`~PyVarObject.ob_size` field, and the instance size is :c:member:`!"
"tp_basicsize` plus N times :c:member:`!tp_itemsize`, where N is the "
"\"length\" of the object."
msgstr ""
"Para um tipo com instâncias de comprimento variável, as instâncias devem ter "
"um campo :c:member:`~PyVarObject.ob_size`, e o tamanho da instância é :c:"
"member:`!tp_basicsize` mais N vezes :c:member:`!tp_itemsize`, onde N é o "
"\"comprimento\" do objeto."

#: ../../c-api/typeobj.rst:609
msgid ""
"Functions like :c:func:`PyObject_NewVar` will take the value of N as an "
"argument, and store in the instance's :c:member:`~PyVarObject.ob_size` "
"field. Note that the :c:member:`~PyVarObject.ob_size` field may later be "
"used for other purposes. For example, :py:type:`int` instances use the bits "
"of :c:member:`~PyVarObject.ob_size` in an implementation-defined way; the "
"underlying storage and its size should be accessed using :c:func:"
"`PyLong_Export`."
msgstr ""
"Funções como :c:func:`PyObject_NewVar` irão tomar o valor de N como um "
"argumento, e armazenar no campo :c:member:`~PyVarObject.ob_size` da "
"instância. Note que o campo :c:member:`~PyVarObject.ob_size` pode mais tarde "
"ser usado para outros fins. Por exemplo, instâncias de :py:type:`int` usam "
"os bits de :c:member:`~PyVarObject.ob_size` de uma forma definida pela "
"implementação; o armazenamento subjacente e o seu tamanho devem ser acedidos "
"usando :c:func:`PyLong_Export`."

#: ../../c-api/typeobj.rst:619
msgid ""
"The :c:member:`~PyVarObject.ob_size` field should be accessed using the :c:"
"func:`Py_SIZE()` and :c:func:`Py_SET_SIZE()` macros."
msgstr ""
"O campo :c:member:`~PyVarObject.ob_size` deve ser acedido usando as macros :"
"c:func:`Py_SIZE()` e :c:func:`Py_SET_SIZE()`."

#: ../../c-api/typeobj.rst:622
msgid ""
"Also, the presence of an :c:member:`~PyVarObject.ob_size` field in the "
"instance layout doesn't mean that the instance structure is variable-length. "
"For example, the :py:type:`list` type has fixed-length instances, yet those "
"instances have a :c:member:`~PyVarObject.ob_size` field. (As with :py:type:"
"`int`, avoid reading lists' :c:member:`!ob_size` directly. Call :c:func:"
"`PyList_Size` instead.)"
msgstr ""
"Além disso, a presença de um campo :c:member:`~PyVarObject.ob_size` no "
"layout da instância não significa que a estrutura da instância é de "
"comprimento variável. Por exemplo, o tipo :py:type:`list` tem instâncias de "
"comprimento fixo, no entanto essas instâncias têm um campo :c:member:"
"`~PyVarObject.ob_size`. (Como com :py:type:`int`, evite ler diretamente :c:"
"member:`!ob_size` de listas. Chame :c:func:`PyList_Size` em vez disso.)"

#: ../../c-api/typeobj.rst:629
msgid ""
"The :c:member:`!tp_basicsize` includes size needed for data of the type's :c:"
"member:`~PyTypeObject.tp_base`, plus any extra data needed by each instance."
msgstr ""
"O :c:member:`!tp_basicsize` inclui o tamanho necessário para os dados do :c:"
"member:`~PyTypeObject.tp_base` do tipo, mais quaisquer dados extra "
"necessários por cada instância."

#: ../../c-api/typeobj.rst:633
msgid ""
"The  correct way to set :c:member:`!tp_basicsize` is to use the ``sizeof`` "
"operator on the struct used to declare the instance layout. This struct must "
"include the struct used to declare the base type. In other words, :c:member:"
"`!tp_basicsize` must be greater than or equal to the base's :c:member:`!"
"tp_basicsize`."
msgstr ""
"A forma correta de definir :c:member:`!tp_basicsize` é usar o operador "
"``sizeof`` na struct usada para declarar o layout da instância. Esta struct "
"deve incluir a struct usada para declarar o tipo base. Em outras palavras, :"
"c:member:`!tp_basicsize` deve ser maior ou igual ao :c:member:`!"
"tp_basicsize` da base."

#: ../../c-api/typeobj.rst:639
msgid ""
"Since every type is a subtype of :py:type:`object`, this struct must "
"include :c:type:`PyObject` or :c:type:`PyVarObject` (depending on whether :c:"
"member:`~PyVarObject.ob_size` should be included). These are usually defined "
"by the macro :c:macro:`PyObject_HEAD` or :c:macro:`PyObject_VAR_HEAD`, "
"respectively."
msgstr ""
"Como todos os tipos são subtipos de :py:type:`object`, esta struct deve "
"incluir :c:type:`PyObject` ou :c:type:`PyVarObject` (dependendo se :c:member:"
"`~PyVarObject.ob_size` deve ser incluído). Estes são normalmente definidos "
"pela macro :c:macro:`PyObject_HEAD` ou :c:macro:`PyObject_VAR_HEAD`, "
"respetivamente."

#: ../../c-api/typeobj.rst:645
msgid ""
"The basic size does not include the GC header size, as that header is not "
"part of :c:macro:`PyObject_HEAD`."
msgstr ""
"O tamanho básico não inclui o tamanho do cabeçalho GC, uma vez que esse "
"cabeçalho não faz parte de :c:macro:`PyObject_HEAD`."

#: ../../c-api/typeobj.rst:648
msgid ""
"For cases where struct used to declare the base type is unknown, see :c:"
"member:`PyType_Spec.basicsize` and :c:func:`PyType_FromMetaclass`."
msgstr ""
"Para casos em que a struct usada para declarar o tipo base é desconhecida, "
"ver :c:member:`PyType_Spec.basicsize` e :c:func:`PyType_FromMetaclass`."

#: ../../c-api/typeobj.rst:651
msgid "Notes about alignment:"
msgstr "Notas sobre alinhamento:"

#: ../../c-api/typeobj.rst:653
msgid ""
":c:member:`!tp_basicsize` must be a multiple of ``_Alignof(PyObject)``. When "
"using ``sizeof`` on a ``struct`` that includes :c:macro:`PyObject_HEAD`, as "
"recommended, the compiler ensures this. When not using a C ``struct``, or "
"when using compiler extensions like ``__attribute__((packed))``, it is up to "
"you."
msgstr ""
":c:member:`!tp_basicsize` deve ser um múltiplo de ``_Alignof(PyObject)``. Ao "
"usar ``sizeof`` numa ``struct`` que inclui :c:macro:`PyObject_HEAD`, como "
"recomendado, o compilador garante isto. Quando não se usa uma ``struct`` C, "
"ou quando se usam extensões do compilador como ``__attribute__((packed))``, "
"é da sua responsabilidade."

#: ../../c-api/typeobj.rst:658
msgid ""
"If the variable items require a particular alignment, :c:member:`!"
"tp_basicsize` and :c:member:`!tp_itemsize` must each be a multiple of that "
"alignment. For example, if a type's variable part stores a ``double``, it is "
"your responsibility that both fields are a multiple of ``_Alignof(double)``."
msgstr ""
"Se os itens variáveis requerem um alinhamento específico, :c:member:`!"
"tp_basicsize` e :c:member:`!tp_itemsize` devem cada um ser um múltiplo desse "
"alinhamento. Por exemplo, se a parte variável de um tipo armazena um "
"``double``, é da sua responsabilidade que ambos os campos sejam múltiplos de "
"``_Alignof(double)``."

#: ../../c-api/typeobj.rst:667
msgid ""
"These fields are inherited separately by subtypes. (That is, if the field is "
"set to zero, :c:func:`PyType_Ready` will copy the value from the base type, "
"indicating that the instances do not need additional storage.)"
msgstr ""
"Estes campos são herdados separadamente por subtipos. (Ou seja, se o campo "
"for definido como zero, :c:func:`PyType_Ready` copiará o valor do tipo base, "
"indicando que as instâncias não precisam de armazenamento adicional.)"

#: ../../c-api/typeobj.rst:672
msgid ""
"If the base type has a non-zero :c:member:`~PyTypeObject.tp_itemsize`, it is "
"generally not safe to set :c:member:`~PyTypeObject.tp_itemsize` to a "
"different non-zero value in a subtype (though this depends on the "
"implementation of the base type)."
msgstr ""
"Se o tipo base tiver um :c:member:`~PyTypeObject.tp_itemsize` não-zero, "
"geralmente não é seguro definir :c:member:`~PyTypeObject.tp_itemsize` para "
"um valor não-zero diferente num subtipo (embora isto dependa da "
"implementação do tipo base)."

#: ../../c-api/typeobj.rst:679
msgid ""
"A pointer to the instance destructor function.  The function signature is::"
msgstr ""
"Um ponteiro para a função destrutora da instância. A assinatura da função é::"

#: ../../c-api/typeobj.rst:681
msgid "void tp_dealloc(PyObject *self);"
msgstr "void tp_dealloc(PyObject *self);"

#: ../../c-api/typeobj.rst:683
msgid ""
"The destructor function should remove all references which the instance owns "
"(e.g., call :c:func:`Py_CLEAR`), free all memory buffers owned by the "
"instance, and call the type's :c:member:`~PyTypeObject.tp_free` function to "
"free the object itself."
msgstr ""
"A função destrutora deve remover todas as referências que a instância possui "
"(por exemplo, chamar :c:func:`Py_CLEAR`), libertar todos os buffers de "
"memória pertencentes à instância, e chamar a função :c:member:`~PyTypeObject."
"tp_free` do tipo para libertar o objeto em si."

#: ../../c-api/typeobj.rst:688
msgid ""
"If you may call functions that may set the error indicator, you must use :c:"
"func:`PyErr_GetRaisedException` and :c:func:`PyErr_SetRaisedException` to "
"ensure you don't clobber a preexisting error indicator (the deallocation "
"could have occurred while processing a different error):"
msgstr ""
"Se puder chamar funções que podem definir o indicador de erro, deve usar :c:"
"func:`PyErr_GetRaisedException` e :c:func:`PyErr_SetRaisedException` para "
"garantir que não sobrescreve um indicador de erro pré-existente (a "
"desalocação pode ter ocorrido enquanto processava um erro diferente):"

#: ../../c-api/typeobj.rst:693
msgid ""
"static void\n"
"foo_dealloc(foo_object *self)\n"
"{\n"
"    PyObject *et, *ev, *etb;\n"
"    PyObject *exc = PyErr_GetRaisedException();\n"
"    ...\n"
"    PyErr_SetRaisedException(exc);\n"
"}"
msgstr ""
"static void\n"
"foo_dealloc(foo_object *self)\n"
"{\n"
"    PyObject *et, *ev, *etb;\n"
"    PyObject *exc = PyErr_GetRaisedException();\n"
"    ...\n"
"    PyErr_SetRaisedException(exc);\n"
"}"

#: ../../c-api/typeobj.rst:704
msgid ""
"The dealloc handler itself must not raise an exception; if it hits an error "
"case it should call :c:func:`PyErr_FormatUnraisable` to log (and clear) an "
"unraisable exception."
msgstr ""
"O próprio manipulador de desalocação não deve levantar uma exceção; se "
"encontrar um caso de erro, deve chamar :c:func:`PyErr_FormatUnraisable` para "
"registar (e limpar) uma exceção não levantável."

#: ../../c-api/typeobj.rst:708
msgid "No guarantees are made about when an object is destroyed, except:"
msgstr "Não são feitas garantias sobre quando um objeto é destruído, exceto:"

#: ../../c-api/typeobj.rst:710
msgid ""
"Python will destroy an object immediately or some time after the final "
"reference to the object is deleted, unless its finalizer (:c:member:"
"`~PyTypeObject.tp_finalize`) subsequently resurrects the object."
msgstr ""
"O Python destruirá um objeto imediatamente ou algum tempo depois de a última "
"referência ao objeto ser eliminada, a menos que o seu finalizador (:c:member:"
"`~PyTypeObject.tp_finalize`) posteriormente ressuscite o objeto."

#: ../../c-api/typeobj.rst:714
msgid ""
"An object will not be destroyed while it is being automatically finalized (:"
"c:member:`~PyTypeObject.tp_finalize`) or automatically cleared (:c:member:"
"`~PyTypeObject.tp_clear`)."
msgstr ""
"Um objeto não será destruído enquanto estiver a ser finalizado "
"automaticamente (:c:member:`~PyTypeObject.tp_finalize`) ou limpo "
"automaticamente (:c:member:`~PyTypeObject.tp_clear`)."

#: ../../c-api/typeobj.rst:718
msgid ""
"CPython currently destroys an object immediately from :c:func:`Py_DECREF` "
"when the new reference count is zero, but this may change in a future "
"version."
msgstr ""
"O CPython atualmente destrói um objeto imediatamente a partir de :c:func:"
"`Py_DECREF` quando a nova contagem de referências é zero, mas isto pode "
"mudar numa versão futura."

#: ../../c-api/typeobj.rst:722
msgid ""
"It is recommended to call :c:func:`PyObject_CallFinalizerFromDealloc` at the "
"beginning of :c:member:`!tp_dealloc` to guarantee that the object is always "
"finalized before destruction."
msgstr ""
"É recomendado chamar :c:func:`PyObject_CallFinalizerFromDealloc` no início "
"de :c:member:`!tp_dealloc` para garantir que o objeto é sempre finalizado "
"antes da destruição."

#: ../../c-api/typeobj.rst:726
msgid ""
"If the type supports garbage collection (the :c:macro:`Py_TPFLAGS_HAVE_GC` "
"flag is set), the destructor should call :c:func:`PyObject_GC_UnTrack` "
"before clearing any member fields."
msgstr ""
"Se o tipo suportar recolha de lixo (a flag :c:macro:`Py_TPFLAGS_HAVE_GC` "
"está definida), o destrutor deve chamar :c:func:`PyObject_GC_UnTrack` antes "
"de limpar quaisquer campos membro."

#: ../../c-api/typeobj.rst:730
msgid ""
"It is permissible to call :c:member:`~PyTypeObject.tp_clear` from :c:member:"
"`!tp_dealloc` to reduce code duplication and to guarantee that the object is "
"always cleared before destruction.  Beware that :c:member:`!tp_clear` might "
"have already been called."
msgstr ""
"É permitido chamar :c:member:`~PyTypeObject.tp_clear` a partir de :c:member:"
"`!tp_dealloc` para reduzir a duplicação de código e para garantir que o "
"objeto é sempre limpo antes da destruição. Tenha em atenção que :c:member:`!"
"tp_clear` pode já ter sido chamado."

#: ../../c-api/typeobj.rst:735
msgid ""
"If the type is heap allocated (:c:macro:`Py_TPFLAGS_HEAPTYPE`), the "
"deallocator should release the owned reference to its type object (via :c:"
"func:`Py_DECREF`) after calling the type deallocator.  See the example code "
"below.::"
msgstr ""
"Se o tipo for alocado em heap (:c:macro:`Py_TPFLAGS_HEAPTYPE`), o "
"desalocador deve libertar a referência possuída para o seu objeto de tipo "
"(via :c:func:`Py_DECREF`) após chamar o desalocador do tipo. Veja o código "
"de exemplo abaixo.::"

#: ../../c-api/typeobj.rst:740
msgid ""
"static void\n"
"foo_dealloc(PyObject *op)\n"
"{\n"
"   foo_object *self = (foo_object *) op;\n"
"   PyObject_GC_UnTrack(self);\n"
"   Py_CLEAR(self->ref);\n"
"   Py_TYPE(self)->tp_free(self);\n"
"}"
msgstr ""
"static void\n"
"foo_dealloc(PyObject *op)\n"
"{\n"
"   foo_object *self = (foo_object *) op;\n"
"   PyObject_GC_UnTrack(self);\n"
"   Py_CLEAR(self->ref);\n"
"   Py_TYPE(self)->tp_free(self);\n"
"}"

#: ../../c-api/typeobj.rst:749
msgid ""
":c:member:`!tp_dealloc` must leave the exception status unchanged.  If it "
"needs to call something that might raise an exception, the exception state "
"must be backed up first and restored later (after logging any exceptions "
"with :c:func:`PyErr_WriteUnraisable`)."
msgstr ""
":c:member:`!tp_dealloc` deve deixar o estado da exceção inalterado. Se "
"precisar de chamar algo que possa levantar uma exceção, o estado da exceção "
"deve ser guardado primeiro e restaurado mais tarde (após registar quaisquer "
"exceções com :c:func:`PyErr_WriteUnraisable`)."

#: ../../c-api/typeobj.rst:754
msgid "Example::"
msgstr "Exemplo::"

#: ../../c-api/typeobj.rst:756
msgid ""
"static void\n"
"foo_dealloc(PyObject *self)\n"
"{\n"
"    PyObject *exc = PyErr_GetRaisedException();\n"
"\n"
"    if (PyObject_CallFinalizerFromDealloc(self) < 0) {\n"
"        // self was resurrected.\n"
"        goto done;\n"
"    }\n"
"\n"
"    PyTypeObject *tp = Py_TYPE(self);\n"
"\n"
"    if (tp->tp_flags & Py_TPFLAGS_HAVE_GC) {\n"
"        PyObject_GC_UnTrack(self);\n"
"    }\n"
"\n"
"    // Optional, but convenient to avoid code duplication.\n"
"    if (tp->tp_clear && tp->tp_clear(self) < 0) {\n"
"        PyErr_WriteUnraisable(self);\n"
"    }\n"
"\n"
"    // Any additional destruction goes here.\n"
"\n"
"    tp->tp_free(self);\n"
"    self = NULL;  // In case PyErr_WriteUnraisable() is called below.\n"
"\n"
"    if (tp->tp_flags & Py_TPFLAGS_HEAPTYPE) {\n"
"        Py_CLEAR(tp);\n"
"    }\n"
"\n"
"done:\n"
"    // Optional, if something was called that might have raised an\n"
"    // exception.\n"
"    if (PyErr_Occurred()) {\n"
"        PyErr_WriteUnraisable(self);\n"
"    }\n"
"    PyErr_SetRaisedException(exc);\n"
"}"
msgstr ""
"static void\n"
"foo_dealloc(PyObject *self)\n"
"{\n"
"    PyObject *exc = PyErr_GetRaisedException();\n"
"\n"
"    if (PyObject_CallFinalizerFromDealloc(self) < 0) {\n"
"        // self foi ressuscitado.\n"
"        goto done;\n"
"    }\n"
"\n"
"    PyTypeObject *tp = Py_TYPE(self);\n"
"\n"
"    if (tp->tp_flags & Py_TPFLAGS_HAVE_GC) {\n"
"        PyObject_GC_UnTrack(self);\n"
"    }\n"
"\n"
"    // Opcional, mas conveniente para evitar duplicação de código.\n"
"    if (tp->tp_clear && tp->tp_clear(self) < 0) {\n"
"        PyErr_WriteUnraisable(self);\n"
"    }\n"
"\n"
"    // Qualquer destruição adicional vai aqui.\n"
"\n"
"    tp->tp_free(self);\n"
"    self = NULL;  // Caso PyErr_WriteUnraisable() seja chamado abaixo.\n"
"\n"
"    if (tp->tp_flags & Py_TPFLAGS_HEAPTYPE) {\n"
"        Py_CLEAR(tp);\n"
"    }\n"
"\n"
"done:\n"
"    // Opcional, se algo foi chamado que possa ter levantado uma\n"
"    // exceção.\n"
"    if (PyErr_Occurred()) {\n"
"        PyErr_WriteUnraisable(self);\n"
"    }\n"
"    PyErr_SetRaisedException(exc);\n"
"}"

#: ../../c-api/typeobj.rst:795
msgid ""
":c:member:`!tp_dealloc` may be called from any Python thread, not just the "
"thread which created the object (if the object becomes part of a refcount "
"cycle, that cycle might be collected by a garbage collection on any "
"thread).  This is not a problem for Python API calls, since the thread on "
"which :c:member:`!tp_dealloc` is called with an :term:`attached thread "
"state`.  However, if the object being destroyed in turn destroys objects "
"from some other C library, care should be taken to ensure that destroying "
"those objects on the thread which called :c:member:`!tp_dealloc` will not "
"violate any assumptions of the library."
msgstr ""
":c:member:`!tp_dealloc` pode ser chamado a partir de qualquer thread Python, "
"não apenas o thread que criou o objeto (se o objeto se tornar parte de um "
"ciclo de contagem de referências, esse ciclo pode ser recolhido por uma "
"recolha de lixo em qualquer thread). Isto não é um problema para chamadas à "
"API Python, uma vez que o thread no qual :c:member:`!tp_dealloc` é chamado "
"tem um :term:`estado de thread anexado`. No entanto, se o objeto a ser "
"destruído, por sua vez, destruir objetos de alguma outra biblioteca C, deve-"
"se ter cuidado para garantir que a destruição desses objetos no thread que "
"chamou :c:member:`!tp_dealloc` não viole quaisquer pressupostos da "
"biblioteca."

#: ../../c-api/typeobj.rst:813 ../../c-api/typeobj.rst:1713
#: ../../c-api/typeobj.rst:2446
msgid ""
":ref:`life-cycle` for details about how this slot relates to other slots."
msgstr ""
":ref:`life-cycle` para detalhes sobre como este slot se relaciona com outros "
"slots."

#: ../../c-api/typeobj.rst:818
msgid ""
"An optional offset to a per-instance function that implements calling the "
"object using the :ref:`vectorcall protocol <vectorcall>`, a more efficient "
"alternative of the simpler :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"Um deslocamento opcional para uma função por instância que implementa a "
"chamada do objeto usando o :ref:`protocolo vectorcall <vectorcall>`, uma "
"alternativa mais eficiente ao :c:member:`~PyTypeObject.tp_call` mais simples."

#: ../../c-api/typeobj.rst:823
msgid ""
"This field is only used if the flag :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` is "
"set. If so, this must be a positive integer containing the offset in the "
"instance of a :c:type:`vectorcallfunc` pointer."
msgstr ""
"Este campo é apenas usado se a flag :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` "
"estiver definida. Se assim for, deve ser um inteiro positivo contendo o "
"deslocamento na instância de um ponteiro :c:type:`vectorcallfunc`."

#: ../../c-api/typeobj.rst:827
msgid ""
"The *vectorcallfunc* pointer may be ``NULL``, in which case the instance "
"behaves as if :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` was not set: calling the "
"instance falls back to :c:member:`~PyTypeObject.tp_call`."
msgstr ""
"O ponteiro *vectorcallfunc* pode ser ``NULL``, caso em que a instância se "
"comporta como se :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` não estivesse "
"definida: chamar a instância recorre a :c:member:`~PyTypeObject.tp_call`."

#: ../../c-api/typeobj.rst:831
msgid ""
"Any class that sets ``Py_TPFLAGS_HAVE_VECTORCALL`` must also set :c:member:"
"`~PyTypeObject.tp_call` and make sure its behaviour is consistent with the "
"*vectorcallfunc* function. This can be done by setting *tp_call* to :c:func:"
"`PyVectorcall_Call`."
msgstr ""
"Qualquer classe que defina ``Py_TPFLAGS_HAVE_VECTORCALL`` também deve "
"definir :c:member:`~PyTypeObject.tp_call` e garantir que o seu comportamento "
"é consistente com a função *vectorcallfunc*. Isto pode ser feito definindo "
"*tp_call* para :c:func:`PyVectorcall_Call`."

#: ../../c-api/typeobj.rst:838
msgid ""
"Before version 3.8, this slot was named ``tp_print``. In Python 2.x, it was "
"used for printing to a file. In Python 3.0 to 3.7, it was unused."
msgstr ""
"Antes da versão 3.8, este slot chamava-se ``tp_print``. No Python 2.x, era "
"usado para imprimir para um ficheiro. Nas versões 3.0 a 3.7 do Python, não "
"era usado."

#: ../../c-api/typeobj.rst:844
msgid ""
"Before version 3.12, it was not recommended for :ref:`mutable heap types "
"<heap-types>` to implement the vectorcall protocol. When a user sets :attr:"
"`~object.__call__` in Python code, only *tp_call* is updated, likely making "
"it inconsistent with the vectorcall function. Since 3.12, setting "
"``__call__`` will disable vectorcall optimization by clearing the :c:macro:"
"`Py_TPFLAGS_HAVE_VECTORCALL` flag."
msgstr ""
"Antes da versão 3.12, não era recomendado que :ref:`tipos de heap mutáveis "
"<heap-types>` implementassem o protocolo vectorcall. Quando um utilizador "
"define :attr:`~object.__call__` em código Python, apenas *tp_call* é "
"atualizado, provavelmente tornando-o inconsistente com a função vectorcall. "
"Desde a versão 3.12, definir ``__call__`` desativará a otimização "
"vectorcall, limpando a flag :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL`."

#: ../../c-api/typeobj.rst:854
msgid ""
"This field is always inherited. However, the :c:macro:"
"`Py_TPFLAGS_HAVE_VECTORCALL` flag is not always inherited. If it's not set, "
"then the subclass won't use :ref:`vectorcall <vectorcall>`, except when :c:"
"func:`PyVectorcall_Call` is explicitly called."
msgstr ""
"Este campo é sempre herdado. No entanto, a flag :c:macro:"
"`Py_TPFLAGS_HAVE_VECTORCALL` não é sempre herdada. Se não estiver definida, "
"então a subclasse não usará :ref:`vectorcall <vectorcall>`, exceto quando :c:"
"func:`PyVectorcall_Call` for explicitamente chamada."

#: ../../c-api/typeobj.rst:863
msgid "An optional pointer to the get-attribute-string function."
msgstr ""
"Um ponteiro opcional para a função de obtenção de atributo por cadeia de "
"caracteres."

#: ../../c-api/typeobj.rst:865
msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_getattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"Este campo está obsoleto. Quando definido, deve apontar para uma função que "
"aja da mesma forma que a função :c:member:`~PyTypeObject.tp_getattro`, mas "
"que recebe uma cadeia de caracteres C em vez de um objeto de cadeia de "
"caracteres Python para fornecer o nome do atributo."

#: ../../c-api/typeobj.rst:871 ../../c-api/typeobj.rst:1067
msgid ""
"Group: :c:member:`~PyTypeObject.tp_getattr`, :c:member:`~PyTypeObject."
"tp_getattro`"
msgstr ""
"Grupo: :c:member:`~PyTypeObject.tp_getattr`, :c:member:`~PyTypeObject."
"tp_getattro`"

#: ../../c-api/typeobj.rst:873
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_getattro`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject."
"tp_getattro` are both ``NULL``."
msgstr ""
"Este campo é herdado por subtipos juntamente com :c:member:`~PyTypeObject."
"tp_getattro`: um subtipo herda ambos :c:member:`~PyTypeObject.tp_getattr` e :"
"c:member:`~PyTypeObject.tp_getattro` do seu tipo base quando os :c:member:"
"`~PyTypeObject.tp_getattr` e :c:member:`~PyTypeObject.tp_getattro` do "
"subtipo são ambos ``NULL``."

#: ../../c-api/typeobj.rst:880 ../../c-api/typeobj.rst:1080
msgid ""
"An optional pointer to the function for setting and deleting attributes."
msgstr ""
"Um ponteiro opcional para a função de definição e eliminação de atributos."

#: ../../c-api/typeobj.rst:882
msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :c:member:`~PyTypeObject.tp_setattro` function, "
"but taking a C string instead of a Python string object to give the "
"attribute name."
msgstr ""
"Este campo está obsoleto. Quando definido, deve apontar para uma função que "
"aja da mesma forma que a função :c:member:`~PyTypeObject.tp_setattro`, mas "
"que recebe uma cadeia de caracteres C em vez de um objeto de cadeia de "
"caracteres Python para fornecer o nome do atributo."

#: ../../c-api/typeobj.rst:888 ../../c-api/typeobj.rst:1093
msgid ""
"Group: :c:member:`~PyTypeObject.tp_setattr`, :c:member:`~PyTypeObject."
"tp_setattro`"
msgstr ""
"Grupo: :c:member:`~PyTypeObject.tp_setattr`, :c:member:`~PyTypeObject."
"tp_setattro`"

#: ../../c-api/typeobj.rst:890
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_setattro`: a subtype inherits both :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject."
"tp_setattro` are both ``NULL``."
msgstr ""
"Este campo é herdado por subtipos juntamente com :c:member:`~PyTypeObject."
"tp_setattro`: um subtipo herda ambos :c:member:`~PyTypeObject.tp_setattr` e :"
"c:member:`~PyTypeObject.tp_setattro` do seu tipo base quando os :c:member:"
"`~PyTypeObject.tp_setattr` e :c:member:`~PyTypeObject.tp_setattro` do "
"subtipo são ambos ``NULL``."

#: ../../c-api/typeobj.rst:897
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement :term:`awaitable` and :term:`asynchronous iterator` "
"protocols at the C-level.  See :ref:`async-structs` for details."
msgstr ""
"Ponteiro para uma estrutura adicional que contém campos relevantes apenas "
"para objetos que implementam os protocolos :term:`awaitable` e :term:"
"`iterador assíncrono` ao nível de C. Ver :ref:`async-structs` para detalhes."

#: ../../c-api/typeobj.rst:901
msgid "Formerly known as ``tp_compare`` and ``tp_reserved``."
msgstr "Anteriormente conhecido como ``tp_compare`` e ``tp_reserved``."

#: ../../c-api/typeobj.rst:906
msgid ""
"The :c:member:`~PyTypeObject.tp_as_async` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"O campo :c:member:`~PyTypeObject.tp_as_async` não é herdado, mas os campos "
"contidos são herdados individualmente."

#: ../../c-api/typeobj.rst:914
msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`repr`."
msgstr ""
"Um ponteiro opcional para uma função que implementa a função incorporada :"
"func:`repr`."

#: ../../c-api/typeobj.rst:917
msgid "The signature is the same as for :c:func:`PyObject_Repr`::"
msgstr "A assinatura é a mesma que para :c:func:`PyObject_Repr`::"

#: ../../c-api/typeobj.rst:919
msgid "PyObject *tp_repr(PyObject *self);"
msgstr "PyObject *tp_repr(PyObject *self);"

#: ../../c-api/typeobj.rst:921
msgid ""
"The function must return a string or a Unicode object.  Ideally, this "
"function should return a string that, when passed to :func:`eval`, given a "
"suitable environment, returns an object with the same value.  If this is not "
"feasible, it should return a string starting with ``'<'`` and ending with "
"``'>'`` from which both the type and the value of the object can be deduced."
msgstr ""
"A função deve retornar uma cadeia de caracteres ou um objeto Unicode. "
"Idealmente, esta função deve retornar uma cadeia de caracteres que, quando "
"passada para :func:`eval`, dado um ambiente adequado, retorne um objeto com "
"o mesmo valor. Se isto não for viável, deve retornar uma cadeia de "
"caracteres que comece com ``'<'`` e termine com ``'>'``, da qual tanto o "
"tipo como o valor do objeto possam ser deduzidos."

#: ../../c-api/typeobj.rst:932 ../../c-api/typeobj.rst:1011
#: ../../c-api/typeobj.rst:1048 ../../c-api/typeobj.rst:1073
#: ../../c-api/typeobj.rst:1099 ../../c-api/typeobj.rst:1141
#: ../../c-api/typeobj.rst:1776 ../../c-api/typeobj.rst:1810
#: ../../c-api/typeobj.rst:1927 ../../c-api/typeobj.rst:1960
#: ../../c-api/typeobj.rst:2035 ../../c-api/typeobj.rst:2076
#: ../../c-api/typeobj.rst:2096 ../../c-api/typeobj.rst:2135
#: ../../c-api/typeobj.rst:2163 ../../c-api/typeobj.rst:2194
msgid "**Default:**"
msgstr "**Predefinição:**"

#: ../../c-api/typeobj.rst:934
msgid ""
"When this field is not set, a string of the form ``<%s object at %p>`` is "
"returned, where ``%s`` is replaced by the type name, and ``%p`` by the "
"object's memory address."
msgstr ""
"Quando este campo não está definido, é retornada uma cadeia de caracteres do "
"formato ``<%s object at %p>``, onde ``%s`` é substituído pelo nome do tipo, "
"e ``%p`` pelo endereço de memória do objeto."

#: ../../c-api/typeobj.rst:941
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the number protocol.  These fields are documented "
"in :ref:`number-structs`."
msgstr ""
"Ponteiro para uma estrutura adicional que contém campos relevantes apenas "
"para objetos que implementam o protocolo numérico. Estes campos estão "
"documentados em :ref:`number-structs`."

#: ../../c-api/typeobj.rst:947
msgid ""
"The :c:member:`~PyTypeObject.tp_as_number` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"O campo :c:member:`~PyTypeObject.tp_as_number` não é herdado, mas os campos "
"contidos são herdados individualmente."

#: ../../c-api/typeobj.rst:953
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the sequence protocol.  These fields are documented "
"in :ref:`sequence-structs`."
msgstr ""
"Ponteiro para uma estrutura adicional que contém campos relevantes apenas "
"para objetos que implementam o protocolo de sequência. Estes campos estão "
"documentados em :ref:`sequence-structs`."

#: ../../c-api/typeobj.rst:959
msgid ""
"The :c:member:`~PyTypeObject.tp_as_sequence` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"O campo :c:member:`~PyTypeObject.tp_as_sequence` não é herdado, mas os "
"campos contidos são herdados individualmente."

#: ../../c-api/typeobj.rst:965
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the mapping protocol.  These fields are documented "
"in :ref:`mapping-structs`."
msgstr ""
"Ponteiro para uma estrutura adicional que contém campos relevantes apenas "
"para objetos que implementam o protocolo de mapeamento. Estes campos estão "
"documentados em :ref:`mapping-structs`."

#: ../../c-api/typeobj.rst:971
msgid ""
"The :c:member:`~PyTypeObject.tp_as_mapping` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"O campo :c:member:`~PyTypeObject.tp_as_mapping` não é herdado, mas os campos "
"contidos são herdados individualmente."

#: ../../c-api/typeobj.rst:979
msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`hash`."
msgstr ""
"Um ponteiro opcional para uma função que implementa a função incorporada :"
"func:`hash`."

#: ../../c-api/typeobj.rst:982
msgid "The signature is the same as for :c:func:`PyObject_Hash`::"
msgstr "A assinatura é a mesma que para :c:func:`PyObject_Hash`::"

#: ../../c-api/typeobj.rst:984
msgid "Py_hash_t tp_hash(PyObject *);"
msgstr "Py_hash_t tp_hash(PyObject *);"

#: ../../c-api/typeobj.rst:986
msgid ""
"The value ``-1`` should not be returned as a normal return value; when an "
"error occurs during the computation of the hash value, the function should "
"set an exception and return ``-1``."
msgstr ""
"O valor ``-1`` não deve ser retornado como um valor de retorno normal; "
"quando ocorrer um erro durante o cálculo do valor de hash, a função deve "
"definir uma exceção e retornar ``-1``."

#: ../../c-api/typeobj.rst:990
msgid ""
"When this field is not set (*and* :c:member:`~PyTypeObject.tp_richcompare` "
"is not set), an attempt to take the hash of the object raises :exc:"
"`TypeError`. This is the same as setting it to :c:func:"
"`PyObject_HashNotImplemented`."
msgstr ""
"Quando este campo não está definido (*e* :c:member:`~PyTypeObject."
"tp_richcompare` não está definido), uma tentativa de obter o hash do objeto "
"levanta :exc:`TypeError`. Isto é o mesmo que defini-lo para :c:func:"
"`PyObject_HashNotImplemented`."

#: ../../c-api/typeobj.rst:994
msgid ""
"This field can be set explicitly to :c:func:`PyObject_HashNotImplemented` to "
"block inheritance of the hash method from a parent type. This is interpreted "
"as the equivalent of ``__hash__ = None`` at the Python level, causing "
"``isinstance(o, collections.Hashable)`` to correctly return ``False``. Note "
"that the converse is also true - setting ``__hash__ = None`` on a class at "
"the Python level will result in the ``tp_hash`` slot being set to :c:func:"
"`PyObject_HashNotImplemented`."
msgstr ""
"Este campo pode ser definido explicitamente para :c:func:"
"`PyObject_HashNotImplemented` para bloquear a herança do método hash de um "
"tipo pai. Isto é interpretado como o equivalente a ``__hash__ = None`` ao "
"nível do Python, fazendo com que ``isinstance(o, collections.Hashable)`` "
"retorne corretamente ``False``. Note que o inverso também é verdadeiro - "
"definir ``__hash__ = None`` numa classe ao nível do Python resultará no slot "
"``tp_hash`` ser definido para :c:func:`PyObject_HashNotImplemented`."

#: ../../c-api/typeobj.rst:1004 ../../c-api/typeobj.rst:1769
msgid ""
"Group: :c:member:`~PyTypeObject.tp_hash`, :c:member:`~PyTypeObject."
"tp_richcompare`"
msgstr ""
"Grupo: :c:member:`~PyTypeObject.tp_hash`, :c:member:`~PyTypeObject."
"tp_richcompare`"

#: ../../c-api/typeobj.rst:1006
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_richcompare`: a subtype inherits both of :c:member:`~PyTypeObject."
"tp_richcompare` and :c:member:`~PyTypeObject.tp_hash`, when the subtype's :c:"
"member:`~PyTypeObject.tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` "
"are both ``NULL``."
msgstr ""
"Este campo é herdado por subtipos juntamente com :c:member:`~PyTypeObject."
"tp_richcompare`: um subtipo herda ambos :c:member:`~PyTypeObject."
"tp_richcompare` e :c:member:`~PyTypeObject.tp_hash`, quando os :c:member:"
"`~PyTypeObject.tp_richcompare` e :c:member:`~PyTypeObject.tp_hash` do "
"subtipo são ambos ``NULL``."

#: ../../c-api/typeobj.rst:1013
msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericHash`."
msgstr ":c:data:`PyBaseObject_Type` usa :c:func:`PyObject_GenericHash`."

#: ../../c-api/typeobj.rst:1018
msgid ""
"An optional pointer to a function that implements calling the object.  This "
"should be ``NULL`` if the object is not callable.  The signature is the same "
"as for :c:func:`PyObject_Call`::"
msgstr ""
"Um ponteiro opcional para uma função que implementa a chamada do objeto. "
"Isto deve ser ``NULL`` se o objeto não for chamável. A assinatura é a mesma "
"que para :c:func:`PyObject_Call`::"

#: ../../c-api/typeobj.rst:1022
msgid "PyObject *tp_call(PyObject *self, PyObject *args, PyObject *kwargs);"
msgstr "PyObject *tp_call(PyObject *self, PyObject *args, PyObject *kwargs);"

#: ../../c-api/typeobj.rst:1031
msgid ""
"An optional pointer to a function that implements the built-in operation :"
"func:`str`.  (Note that :class:`str` is a type now, and :func:`str` calls "
"the constructor for that type.  This constructor calls :c:func:"
"`PyObject_Str` to do the actual work, and :c:func:`PyObject_Str` will call "
"this handler.)"
msgstr ""
"Um ponteiro opcional para uma função que implementa a operação incorporada :"
"func:`str`. (Note que :class:`str` é agora um tipo, e :func:`str` chama o "
"construtor para esse tipo. Este construtor chama :c:func:`PyObject_Str` para "
"fazer o trabalho real, e :c:func:`PyObject_Str` chamará este manipulador.)"

#: ../../c-api/typeobj.rst:1036
msgid "The signature is the same as for :c:func:`PyObject_Str`::"
msgstr "A assinatura é a mesma que para :c:func:`PyObject_Str`::"

#: ../../c-api/typeobj.rst:1038
msgid "PyObject *tp_str(PyObject *self);"
msgstr "PyObject *tp_str(PyObject *self);"

#: ../../c-api/typeobj.rst:1040
msgid ""
"The function must return a string or a Unicode object.  It should be a "
"\"friendly\" string representation of the object, as this is the "
"representation that will be used, among other things, by the :func:`print` "
"function."
msgstr ""
"A função deve retornar uma cadeia de caracteres ou um objeto Unicode. Deve "
"ser uma representação de cadeia de caracteres \"amigável\" do objeto, uma "
"vez que esta é a representação que será usada, entre outras coisas, pela "
"função :func:`print`."

#: ../../c-api/typeobj.rst:1050
msgid ""
"When this field is not set, :c:func:`PyObject_Repr` is called to return a "
"string representation."
msgstr ""
"Quando este campo não está definido, :c:func:`PyObject_Repr` é chamado para "
"retornar uma representação de cadeia de caracteres."

#: ../../c-api/typeobj.rst:1056
msgid "An optional pointer to the get-attribute function."
msgstr "Um ponteiro opcional para a função de obtenção de atributo."

#: ../../c-api/typeobj.rst:1058
msgid "The signature is the same as for :c:func:`PyObject_GetAttr`::"
msgstr "A assinatura é a mesma que para :c:func:`PyObject_GetAttr`::"

#: ../../c-api/typeobj.rst:1060
msgid "PyObject *tp_getattro(PyObject *self, PyObject *attr);"
msgstr "PyObject *tp_getattro(PyObject *self, PyObject *attr);"

#: ../../c-api/typeobj.rst:1062
msgid ""
"It is usually convenient to set this field to :c:func:"
"`PyObject_GenericGetAttr`, which implements the normal way of looking for "
"object attributes."
msgstr ""
"É normalmente conveniente definir este campo para :c:func:"
"`PyObject_GenericGetAttr`, que implementa a forma normal de procurar "
"atributos de objeto."

#: ../../c-api/typeobj.rst:1069
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_getattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_getattr` "
"and :c:member:`~PyTypeObject.tp_getattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject."
"tp_getattro` are both ``NULL``."
msgstr ""
"Este campo é herdado por subtipos juntamente com :c:member:`~PyTypeObject."
"tp_getattr`: um subtipo herda ambos :c:member:`~PyTypeObject.tp_getattr` e :"
"c:member:`~PyTypeObject.tp_getattro` do seu tipo base quando os :c:member:"
"`~PyTypeObject.tp_getattr` e :c:member:`~PyTypeObject.tp_getattro` do "
"subtipo são ambos ``NULL``."

#: ../../c-api/typeobj.rst:1075
msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericGetAttr`."
msgstr ":c:data:`PyBaseObject_Type` usa :c:func:`PyObject_GenericGetAttr`."

#: ../../c-api/typeobj.rst:1082
msgid "The signature is the same as for :c:func:`PyObject_SetAttr`::"
msgstr "A assinatura é a mesma que para :c:func:`PyObject_SetAttr`::"

#: ../../c-api/typeobj.rst:1084
msgid "int tp_setattro(PyObject *self, PyObject *attr, PyObject *value);"
msgstr "int tp_setattro(PyObject *self, PyObject *attr, PyObject *value);"

#: ../../c-api/typeobj.rst:1086
msgid ""
"In addition, setting *value* to ``NULL`` to delete an attribute must be "
"supported.  It is usually convenient to set this field to :c:func:"
"`PyObject_GenericSetAttr`, which implements the normal way of setting object "
"attributes."
msgstr ""
"Além disso, definir *value* para ``NULL`` para eliminar um atributo deve ser "
"suportado. É normalmente conveniente definir este campo para :c:func:"
"`PyObject_GenericSetAttr`, que implementa a forma normal de definir "
"atributos de objeto."

#: ../../c-api/typeobj.rst:1095
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_setattr`: a subtype inherits both :c:member:`~PyTypeObject.tp_setattr` "
"and :c:member:`~PyTypeObject.tp_setattro` from its base type when the "
"subtype's :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject."
"tp_setattro` are both ``NULL``."
msgstr ""
"Este campo é herdado por subtipos juntamente com :c:member:`~PyTypeObject."
"tp_setattr`: um subtipo herda ambos :c:member:`~PyTypeObject.tp_setattr` e :"
"c:member:`~PyTypeObject.tp_setattro` do seu tipo base quando os :c:member:"
"`~PyTypeObject.tp_setattr` e :c:member:`~PyTypeObject.tp_setattro` do "
"subtipo são ambos ``NULL``."

#: ../../c-api/typeobj.rst:1101
msgid ":c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericSetAttr`."
msgstr ":c:data:`PyBaseObject_Type` usa :c:func:`PyObject_GenericSetAttr`."

#: ../../c-api/typeobj.rst:1106
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the buffer interface.  These fields are documented "
"in :ref:`buffer-structs`."
msgstr ""
"Ponteiro para uma estrutura adicional que contém campos relevantes apenas "
"para objetos que implementam a interface de buffer. Estes campos estão "
"documentados em :ref:`buffer-structs`."

#: ../../c-api/typeobj.rst:1112
msgid ""
"The :c:member:`~PyTypeObject.tp_as_buffer` field is not inherited, but the "
"contained fields are inherited individually."
msgstr ""
"O campo :c:member:`~PyTypeObject.tp_as_buffer` não é herdado, mas os campos "
"contidos são herdados individualmente."

#: ../../c-api/typeobj.rst:1118
msgid ""
"This field is a bit mask of various flags.  Some flags indicate variant "
"semantics for certain situations; others are used to indicate that certain "
"fields in the type object (or in the extension structures referenced via :c:"
"member:`~PyTypeObject.tp_as_number`, :c:member:`~PyTypeObject."
"tp_as_sequence`, :c:member:`~PyTypeObject.tp_as_mapping`, and :c:member:"
"`~PyTypeObject.tp_as_buffer`) that were historically not always present are "
"valid; if such a flag bit is clear, the type fields it guards must not be "
"accessed and must be considered to have a zero or ``NULL`` value instead."
msgstr ""
"Este campo é uma máscara de bits de várias flags. Algumas flags indicam "
"semânticas variantes para certas situações; outras são usadas para indicar "
"que certos campos no objeto de tipo (ou nas estruturas de extensão "
"referenciadas via :c:member:`~PyTypeObject.tp_as_number`, :c:member:"
"`~PyTypeObject.tp_as_sequence`, :c:member:`~PyTypeObject.tp_as_mapping`, e :"
"c:member:`~PyTypeObject.tp_as_buffer`) que historicamente nem sempre estavam "
"presentes são válidos; se tal bit de flag não estiver definido, os campos de "
"tipo que protege não devem ser acedidos e devem ser considerados como tendo "
"um valor zero ou ``NULL``."

#: ../../c-api/typeobj.rst:1128
msgid ""
"Inheritance of this field is complicated.  Most flag bits are inherited "
"individually, i.e. if the base type has a flag bit set, the subtype inherits "
"this flag bit.  The flag bits that pertain to extension structures are "
"strictly inherited if the extension structure is inherited, i.e. the base "
"type's value of the flag bit is copied into the subtype together with a "
"pointer to the extension structure.  The :c:macro:`Py_TPFLAGS_HAVE_GC` flag "
"bit is inherited together with the :c:member:`~PyTypeObject.tp_traverse` "
"and :c:member:`~PyTypeObject.tp_clear` fields, i.e. if the :c:macro:"
"`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the :c:member:"
"`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` fields in "
"the subtype exist and have ``NULL`` values."
msgstr ""
"A herança deste campo é complicada. A maioria dos bits de flag são herdados "
"individualmente, ou seja, se o tipo base tiver um bit de flag definido, o "
"subtipo herda esse bit de flag. Os bits de flag que dizem respeito a "
"estruturas de extensão são estritamente herdados se a estrutura de extensão "
"for herdada, ou seja, o valor do bit de flag do tipo base é copiado para o "
"subtipo juntamente com um ponteiro para a estrutura de extensão. O bit de "
"flag :c:macro:`Py_TPFLAGS_HAVE_GC` é herdado juntamente com os campos :c:"
"member:`~PyTypeObject.tp_traverse` e :c:member:`~PyTypeObject.tp_clear`, ou "
"seja, se o bit de flag :c:macro:`Py_TPFLAGS_HAVE_GC` não estiver definido no "
"subtipo e os campos :c:member:`~PyTypeObject.tp_traverse` e :c:member:"
"`~PyTypeObject.tp_clear` no subtipo existirem e tiverem valores ``NULL``."

#: ../../c-api/typeobj.rst:1143
msgid ""
":c:data:`PyBaseObject_Type` uses ``Py_TPFLAGS_DEFAULT | "
"Py_TPFLAGS_BASETYPE``."
msgstr ""
":c:data:`PyBaseObject_Type` usa ``Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE``."

#: ../../c-api/typeobj.rst:1146
msgid "**Bit Masks:**"
msgstr "**Máscaras de Bit:**"

#: ../../c-api/typeobj.rst:1150
msgid ""
"The following bit masks are currently defined; these can be ORed together "
"using the ``|`` operator to form the value of the :c:member:`~PyTypeObject."
"tp_flags` field.  The macro :c:func:`PyType_HasFeature` takes a type and a "
"flags value, *tp* and *f*, and checks whether ``tp->tp_flags & f`` is non-"
"zero."
msgstr ""
"As seguintes máscaras de bit estão atualmente definidas; estas podem ser "
"combinadas usando o operador ``|`` para formar o valor do campo :c:member:"
"`~PyTypeObject.tp_flags`. A macro :c:func:`PyType_HasFeature` recebe um tipo "
"e um valor de flags, *tp* e *f*, e verifica se ``tp->tp_flags & f`` é não-"
"zero."

#: ../../c-api/typeobj.rst:1157
msgid ""
"This bit is set when the type object itself is allocated on the heap, for "
"example, types created dynamically using :c:func:`PyType_FromSpec`.  In this "
"case, the :c:member:`~PyObject.ob_type` field of its instances is considered "
"a reference to the type, and the type object is INCREF'ed when a new "
"instance is created, and DECREF'ed when an instance is destroyed (this does "
"not apply to instances of subtypes; only the type referenced by the "
"instance's ob_type gets INCREF'ed or DECREF'ed). Heap types should also :ref:"
"`support garbage collection <supporting-cycle-detection>` as they can form a "
"reference cycle with their own module object."
msgstr ""
"Este bit é definido quando o objeto de tipo em si é alocado na heap, por "
"exemplo, tipos criados dinamicamente usando :c:func:`PyType_FromSpec`. Neste "
"caso, o campo :c:member:`~PyObject.ob_type` das suas instâncias é "
"considerado uma referência para o tipo, e o objeto de tipo é INCREF'ed "
"quando uma nova instância é criada, e DECREF'ed quando uma instância é "
"destruída (isto não se aplica a instâncias de subtipos; apenas o tipo "
"referenciado pelo ob_type da instância é INCREF'ed ou DECREF'ed). Tipos de "
"heap também devem :ref:`suportar recolha de lixo <supporting-cycle-"
"detection>` uma vez que podem formar um ciclo de referência com o seu "
"próprio objeto de módulo."

#: ../../c-api/typeobj.rst:1168 ../../c-api/typeobj.rst:1179
#: ../../c-api/typeobj.rst:1189 ../../c-api/typeobj.rst:1199
#: ../../c-api/typeobj.rst:1231
msgid "???"
msgstr "???"

#: ../../c-api/typeobj.rst:1173
msgid ""
"This bit is set when the type can be used as the base type of another type.  "
"If this bit is clear, the type cannot be subtyped (similar to a \"final\" "
"class in Java)."
msgstr ""
"Este bit é definido quando o tipo pode ser usado como o tipo base de outro "
"tipo. Se este bit não estiver definido, o tipo não pode ser subtipado "
"(semelhante a uma classe \"final\" em Java)."

#: ../../c-api/typeobj.rst:1184
msgid ""
"This bit is set when the type object has been fully initialized by :c:func:"
"`PyType_Ready`."
msgstr ""
"Este bit é definido quando o objeto de tipo foi totalmente inicializado por :"
"c:func:`PyType_Ready`."

#: ../../c-api/typeobj.rst:1194
msgid ""
"This bit is set while :c:func:`PyType_Ready` is in the process of "
"initializing the type object."
msgstr ""
"Este bit é definido enquanto :c:func:`PyType_Ready` está no processo de "
"inicializar o objeto de tipo."

#: ../../c-api/typeobj.rst:1204
msgid ""
"This bit is set when the object supports garbage collection.  If this bit is "
"set, memory for new instances (see :c:member:`~PyTypeObject.tp_alloc`) must "
"be allocated using :c:macro:`PyObject_GC_New` or :c:func:"
"`PyType_GenericAlloc` and deallocated (see :c:member:`~PyTypeObject."
"tp_free`) using :c:func:`PyObject_GC_Del`.  More information in section :ref:"
"`supporting-cycle-detection`."
msgstr ""
"Este bit é definido quando o objeto suporta recolha de lixo. Se este bit "
"estiver definido, a memória para novas instâncias (ver :c:member:"
"`~PyTypeObject.tp_alloc`) deve ser alocada usando :c:macro:`PyObject_GC_New` "
"ou :c:func:`PyType_GenericAlloc` e desalocada (ver :c:member:`~PyTypeObject."
"tp_free`) usando :c:func:`PyObject_GC_Del`. Mais informações na secção :ref:"
"`supporting-cycle-detection`."

#: ../../c-api/typeobj.rst:1213 ../../c-api/typeobj.rst:1560
#: ../../c-api/typeobj.rst:1704
msgid ""
"Group: :c:macro:`Py_TPFLAGS_HAVE_GC`, :c:member:`~PyTypeObject."
"tp_traverse`, :c:member:`~PyTypeObject.tp_clear`"
msgstr ""
"Grupo: :c:macro:`Py_TPFLAGS_HAVE_GC`, :c:member:`~PyTypeObject."
"tp_traverse`, :c:member:`~PyTypeObject.tp_clear`"

#: ../../c-api/typeobj.rst:1215
msgid ""
"The :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is inherited together with the :c:"
"member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` "
"fields, i.e.  if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is clear in the "
"subtype and the :c:member:`~PyTypeObject.tp_traverse` and :c:member:"
"`~PyTypeObject.tp_clear` fields in the subtype exist and have ``NULL`` "
"values."
msgstr ""
"O bit de flag :c:macro:`Py_TPFLAGS_HAVE_GC` é herdado juntamente com os "
"campos :c:member:`~PyTypeObject.tp_traverse` e :c:member:`~PyTypeObject."
"tp_clear`, ou seja, se o bit de flag :c:macro:`Py_TPFLAGS_HAVE_GC` não "
"estiver definido no subtipo e os campos :c:member:`~PyTypeObject."
"tp_traverse` e :c:member:`~PyTypeObject.tp_clear` no subtipo existirem e "
"tiverem valores ``NULL``."

#: ../../c-api/typeobj.rst:1225
msgid ""
"This is a bitmask of all the bits that pertain to the existence of certain "
"fields in the type object and its extension structures. Currently, it "
"includes the following bits: :c:macro:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`."
msgstr ""
"Esta é uma máscara de bits de todos os bits que dizem respeito à existência "
"de certos campos no objeto de tipo e nas suas estruturas de extensão. "
"Atualmente, inclui os seguintes bits: :c:macro:"
"`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`."

#: ../../c-api/typeobj.rst:1236
msgid "This bit indicates that objects behave like unbound methods."
msgstr ""
"Este bit indica que os objetos se comportam como métodos desvinculados."

#: ../../c-api/typeobj.rst:1238
msgid "If this flag is set for ``type(meth)``, then:"
msgstr "Se esta flag estiver definida para ``type(meth)``, então:"

#: ../../c-api/typeobj.rst:1240
msgid ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (with ``obj`` not None) must be "
"equivalent to ``meth(obj, *args, **kwds)``."
msgstr ""
"``meth.__get__(obj, cls)(*args, **kwds)`` (com ``obj`` não None) deve ser "
"equivalente a ``meth(obj, *args, **kwds)``."

#: ../../c-api/typeobj.rst:1243
msgid ""
"``meth.__get__(None, cls)(*args, **kwds)`` must be equivalent to "
"``meth(*args, **kwds)``."
msgstr ""
"``meth.__get__(None, cls)(*args, **kwds)`` deve ser equivalente a "
"``meth(*args, **kwds)``."

#: ../../c-api/typeobj.rst:1246
msgid ""
"This flag enables an optimization for typical method calls like ``obj."
"meth()``: it avoids creating a temporary \"bound method\" object for ``obj."
"meth``."
msgstr ""
"Esta flag permite uma otimização para chamadas típicas de métodos como ``obj."
"meth()``: evita a criação de um objeto temporário de \"método vinculado\" "
"para ``obj.meth``."

#: ../../c-api/typeobj.rst:1254
msgid ""
"This flag is never inherited by types without the :c:macro:"
"`Py_TPFLAGS_IMMUTABLETYPE` flag set.  For extension types, it is inherited "
"whenever :c:member:`~PyTypeObject.tp_descr_get` is inherited."
msgstr ""
"Esta flag nunca é herdada por tipos sem a flag :c:macro:"
"`Py_TPFLAGS_IMMUTABLETYPE` definida. Para tipos de extensão, é herdada "
"sempre que :c:member:`~PyTypeObject.tp_descr_get` é herdado."

#: ../../c-api/typeobj.rst:1260
msgid ""
"This bit indicates that instances of the class have a :attr:`~object."
"__dict__` attribute, and that the space for the dictionary is managed by the "
"VM."
msgstr ""
"Este bit indica que as instâncias da classe têm um atributo :attr:`~object."
"__dict__`, e que o espaço para o dicionário é gerido pela VM."

#: ../../c-api/typeobj.rst:1263
msgid "If this flag is set, :c:macro:`Py_TPFLAGS_HAVE_GC` should also be set."
msgstr ""
"Se esta flag estiver definida, :c:macro:`Py_TPFLAGS_HAVE_GC` também deve "
"estar definida."

#: ../../c-api/typeobj.rst:1265
msgid ""
"The type traverse function must call :c:func:`PyObject_VisitManagedDict` and "
"its clear function must call :c:func:`PyObject_ClearManagedDict`."
msgstr ""
"A função de travessia do tipo deve chamar :c:func:"
"`PyObject_VisitManagedDict` e a sua função de limpeza deve chamar :c:func:"
"`PyObject_ClearManagedDict`."

#: ../../c-api/typeobj.rst:1272
msgid ""
"This flag is inherited unless the :c:member:`~PyTypeObject.tp_dictoffset` "
"field is set in a superclass."
msgstr ""
"Esta flag é herdada a menos que o campo :c:member:`~PyTypeObject."
"tp_dictoffset` esteja definido numa superclasse."

#: ../../c-api/typeobj.rst:1278
msgid ""
"This bit indicates that instances of the class should be weakly "
"referenceable."
msgstr ""
"Este bit indica que as instâncias da classe devem ser referenciáveis "
"fracamente."

#: ../../c-api/typeobj.rst:1285
msgid ""
"This flag is inherited unless the :c:member:`~PyTypeObject."
"tp_weaklistoffset` field is set in a superclass."
msgstr ""
"Esta flag é herdada a menos que o campo :c:member:`~PyTypeObject."
"tp_weaklistoffset` esteja definido numa superclasse."

#: ../../c-api/typeobj.rst:1291
msgid ""
"Only usable with variable-size types, i.e. ones with non-zero :c:member:"
"`~PyTypeObject.tp_itemsize`."
msgstr ""
"Apenas utilizável com tipos de tamanho variável, ou seja, aqueles com :c:"
"member:`~PyTypeObject.tp_itemsize` não-zero."

#: ../../c-api/typeobj.rst:1294
msgid ""
"Indicates that the variable-sized portion of an instance of this type is at "
"the end of the instance's memory area, at an offset of ``Py_TYPE(obj)-"
">tp_basicsize`` (which may be different in each subclass)."
msgstr ""
"Indica que a porção de tamanho variável de uma instância deste tipo está no "
"final da área de memória da instância, num deslocamento de ``Py_TYPE(obj)-"
">tp_basicsize`` (que pode ser diferente em cada subclasse)."

#: ../../c-api/typeobj.rst:1299
msgid ""
"When setting this flag, be sure that all superclasses either use this memory "
"layout, or are not variable-sized. Python does not check this."
msgstr ""
"Ao definir esta flag, certifique-se de que todas as superclasses usam este "
"layout de memória ou não são de tamanho variável. O Python não verifica isto."

#: ../../c-api/typeobj.rst:1307
msgid "This flag is inherited."
msgstr "Esta flag é herdada."

#: ../../c-api/typeobj.rst:1321
msgid ""
"These flags are used by functions such as :c:func:`PyLong_Check` to quickly "
"determine if a type is a subclass of a built-in type; such specific checks "
"are faster than a generic check, like :c:func:`PyObject_IsInstance`. Custom "
"types that inherit from built-ins should have their :c:member:`~PyTypeObject."
"tp_flags` set appropriately, or the code that interacts with such types will "
"behave differently depending on what kind of check is used."
msgstr ""
"Estas flags são usadas por funções como :c:func:`PyLong_Check` para "
"determinar rapidamente se um tipo é uma subclasse de um tipo incorporado; "
"tais verificações específicas são mais rápidas do que uma verificação "
"genérica, como :c:func:`PyObject_IsInstance`. Tipos personalizados que "
"herdam de tipos incorporados devem ter as suas :c:member:`~PyTypeObject."
"tp_flags` definidas apropriadamente, ou o código que interage com tais tipos "
"comportar-se-á de forma diferente dependendo do tipo de verificação usado."

#: ../../c-api/typeobj.rst:1332
msgid ""
"This bit is set when the :c:member:`~PyTypeObject.tp_finalize` slot is "
"present in the type structure."
msgstr ""
"Este bit é definido quando o slot :c:member:`~PyTypeObject.tp_finalize` está "
"presente na estrutura do tipo."

#: ../../c-api/typeobj.rst:1337
msgid ""
"This flag isn't necessary anymore, as the interpreter assumes the :c:member:"
"`~PyTypeObject.tp_finalize` slot is always present in the type structure."
msgstr ""
"Esta flag já não é necessária, uma vez que o interpretador assume que o "
"slot :c:member:`~PyTypeObject.tp_finalize` está sempre presente na estrutura "
"do tipo."

#: ../../c-api/typeobj.rst:1345
msgid ""
"This bit is set when the class implements the :ref:`vectorcall protocol "
"<vectorcall>`. See :c:member:`~PyTypeObject.tp_vectorcall_offset` for "
"details."
msgstr ""
"Este bit é definido quando a classe implementa o :ref:`protocolo vectorcall "
"<vectorcall>`. Ver :c:member:`~PyTypeObject.tp_vectorcall_offset` para "
"detalhes."

#: ../../c-api/typeobj.rst:1351
msgid ""
"This bit is inherited if :c:member:`~PyTypeObject.tp_call` is also inherited."
msgstr ""
"Este bit é herdado se :c:member:`~PyTypeObject.tp_call` também for herdado."

#: ../../c-api/typeobj.rst:1358
msgid ""
"This flag is now removed from a class when the class's :py:meth:`~object."
"__call__` method is reassigned."
msgstr ""
"Esta flag é agora removida de uma classe quando o método :py:meth:`~object."
"__call__` da classe é reatribuído."

#: ../../c-api/typeobj.rst:1361
msgid "This flag can now be inherited by mutable classes."
msgstr "Esta flag pode agora ser herdada por classes mutáveis."

#: ../../c-api/typeobj.rst:1365
msgid ""
"This bit is set for type objects that are immutable: type attributes cannot "
"be set nor deleted."
msgstr ""
"Este bit é definido para objetos de tipo que são imutáveis: os atributos de "
"tipo não podem ser definidos nem eliminados."

#: ../../c-api/typeobj.rst:1367
msgid ""
":c:func:`PyType_Ready` automatically applies this flag to :ref:`static types "
"<static-types>`."
msgstr ""
":c:func:`PyType_Ready` aplica automaticamente este sinalizador aos :ref:"
"`tipos estáticos <static-types>`."

#: ../../c-api/typeobj.rst:1372
msgid "This flag is not inherited."
msgstr "Esta flag não é herdada."

#: ../../c-api/typeobj.rst:1378
msgid ""
"Disallow creating instances of the type: set :c:member:`~PyTypeObject."
"tp_new` to NULL and don't create the ``__new__`` key in the type dictionary."
msgstr ""
"Proibir a criação de instâncias do tipo: defina :c:member:`~PyTypeObject."
"tp_new` para NULL e não crie a chave ``__new__`` no dicionário do tipo."

#: ../../c-api/typeobj.rst:1382
msgid ""
"The flag must be set before creating the type, not after. For example, it "
"must be set before :c:func:`PyType_Ready` is called on the type."
msgstr ""
"A flag deve ser definida antes de criar o tipo, não depois. Por exemplo, "
"deve ser definida antes de :c:func:`PyType_Ready` ser chamada no tipo."

#: ../../c-api/typeobj.rst:1385
msgid ""
"The flag is set automatically on :ref:`static types <static-types>` if :c:"
"member:`~PyTypeObject.tp_base` is NULL or ``&PyBaseObject_Type`` and :c:"
"member:`~PyTypeObject.tp_new` is NULL."
msgstr ""
"A flag é definida automaticamente em :ref:`tipos estáticos <static-types>` "
"se :c:member:`~PyTypeObject.tp_base` for NULL ou ``&PyBaseObject_Type`` e :c:"
"member:`~PyTypeObject.tp_new` for NULL."

#: ../../c-api/typeobj.rst:1391
msgid ""
"This flag is not inherited. However, subclasses will not be instantiable "
"unless they provide a non-NULL :c:member:`~PyTypeObject.tp_new` (which is "
"only possible via the C API)."
msgstr ""
"Esta flag não é herdada. No entanto, as subclasses não serão instanciáveis a "
"menos que forneçam um :c:member:`~PyTypeObject.tp_new` não-NULL (o que só é "
"possível via API C)."

#: ../../c-api/typeobj.rst:1398
msgid ""
"To disallow instantiating a class directly but allow instantiating its "
"subclasses (e.g. for an :term:`abstract base class`), do not use this flag. "
"Instead, make :c:member:`~PyTypeObject.tp_new` only succeed for subclasses."
msgstr ""
"Para proibir a instanciação direta de uma classe, mas permitir a "
"instanciação das suas subclasses (por exemplo, para uma :term:`classe base "
"abstrata`), não use esta flag. Em vez disso, faça com que :c:member:"
"`~PyTypeObject.tp_new` só tenha sucesso para subclasses."

#: ../../c-api/typeobj.rst:1409
msgid ""
"This bit indicates that instances of the class may match mapping patterns "
"when used as the subject of a :keyword:`match` block. It is automatically "
"set when registering or subclassing :class:`collections.abc.Mapping`, and "
"unset when registering :class:`collections.abc.Sequence`."
msgstr ""
"Este bit indica que as instâncias da classe podem corresponder a padrões de "
"mapeamento quando usadas como assunto de um bloco :keyword:`match`. É "
"definido automaticamente ao registar ou subtipar :class:`collections.abc."
"Mapping`, e desdefinido ao registar :class:`collections.abc.Sequence`."

#: ../../c-api/typeobj.rst:1416 ../../c-api/typeobj.rst:1438
msgid ""
":c:macro:`Py_TPFLAGS_MAPPING` and :c:macro:`Py_TPFLAGS_SEQUENCE` are "
"mutually exclusive; it is an error to enable both flags simultaneously."
msgstr ""
":c:macro:`Py_TPFLAGS_MAPPING` e :c:macro:`Py_TPFLAGS_SEQUENCE` são "
"mutuamente exclusivos; é um erro ativar ambas as flags simultaneamente."

#: ../../c-api/typeobj.rst:1421
msgid ""
"This flag is inherited by types that do not already set :c:macro:"
"`Py_TPFLAGS_SEQUENCE`."
msgstr ""
"Esta flag é herdada por tipos que não definem já :c:macro:"
"`Py_TPFLAGS_SEQUENCE`."

#: ../../c-api/typeobj.rst:1424 ../../c-api/typeobj.rst:1446
msgid ":pep:`634` -- Structural Pattern Matching: Specification"
msgstr ":pep:`634` -- Correspondência de Padrões Estruturais: Especificação"

#: ../../c-api/typeobj.rst:1431
msgid ""
"This bit indicates that instances of the class may match sequence patterns "
"when used as the subject of a :keyword:`match` block. It is automatically "
"set when registering or subclassing :class:`collections.abc.Sequence`, and "
"unset when registering :class:`collections.abc.Mapping`."
msgstr ""
"Este bit indica que as instâncias da classe podem corresponder a padrões de "
"sequência quando usadas como assunto de um bloco :keyword:`match`. É "
"definido automaticamente ao registar ou subtipar :class:`collections.abc."
"Sequence`, e desdefinido ao registar :class:`collections.abc.Mapping`."

#: ../../c-api/typeobj.rst:1443
msgid ""
"This flag is inherited by types that do not already set :c:macro:"
"`Py_TPFLAGS_MAPPING`."
msgstr ""
"Esta flag é herdada por tipos que não definem já :c:macro:"
"`Py_TPFLAGS_MAPPING`."

#: ../../c-api/typeobj.rst:1453
msgid ""
"Internal. Do not set or unset this flag. To indicate that a class has "
"changed call :c:func:`PyType_Modified`"
msgstr ""
"Interno. Não defina nem desdefina esta flag. Para indicar que uma classe "
"mudou, chame :c:func:`PyType_Modified`"

#: ../../c-api/typeobj.rst:1457
msgid ""
"This flag is present in header files, but is not be used. It will be removed "
"in a future version of CPython"
msgstr ""
"Esta flag está presente nos ficheiros de cabeçalho, mas não é usada. Será "
"removida numa versão futura do CPython."

#: ../../c-api/typeobj.rst:1463
msgid ""
"An optional pointer to a NUL-terminated C string giving the docstring for "
"this type object.  This is exposed as the :attr:`~type.__doc__` attribute on "
"the type and instances of the type."
msgstr ""
"Um ponteiro opcional para uma cadeia de caracteres C terminada por NUL que "
"fornece a docstring para este objeto de tipo. Isto é exposto como o "
"atributo :attr:`~type.__doc__` no tipo e nas instâncias do tipo."

#: ../../c-api/typeobj.rst:1469
msgid "This field is *not* inherited by subtypes."
msgstr "Este campo *não* é herdado por subtipos."

#: ../../c-api/typeobj.rst:1474
msgid ""
"An optional pointer to a traversal function for the garbage collector.  This "
"is only used if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The "
"signature is::"
msgstr ""
"Um ponteiro opcional para uma função de travessia para o recolhedor de lixo. "
"Isto é usado apenas se o bit de flag :c:macro:`Py_TPFLAGS_HAVE_GC` estiver "
"definido. A assinatura é::"

#: ../../c-api/typeobj.rst:1477
msgid "int tp_traverse(PyObject *self, visitproc visit, void *arg);"
msgstr "int tp_traverse(PyObject *self, visitproc visit, void *arg);"

#: ../../c-api/typeobj.rst:1479 ../../c-api/typeobj.rst:1699
msgid ""
"More information about Python's garbage collection scheme can be found in "
"section :ref:`supporting-cycle-detection`."
msgstr ""
"Mais informações sobre o esquema de recolha de lixo do Python podem ser "
"encontradas na secção :ref:`supporting-cycle-detection`."

#: ../../c-api/typeobj.rst:1482
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` pointer is used by the garbage "
"collector to detect reference cycles. A typical implementation of a :c:"
"member:`~PyTypeObject.tp_traverse` function simply calls :c:func:`Py_VISIT` "
"on each of the instance's members that are Python objects that the instance "
"owns. For example, this is function :c:func:`!local_traverse` from the :mod:"
"`!_thread` extension module::"
msgstr ""
"O ponteiro :c:member:`~PyTypeObject.tp_traverse` é usado pelo recolhedor de "
"lixo para detetar ciclos de referência. Uma implementação típica de uma "
"função :c:member:`~PyTypeObject.tp_traverse` chama simplesmente :c:func:"
"`Py_VISIT` em cada um dos membros da instância que são objetos Python "
"pertencentes à instância. Por exemplo, esta é a função :c:func:`!"
"local_traverse` do módulo de extensão :mod:`!_thread`::"

#: ../../c-api/typeobj.rst:1488
msgid ""
"static int\n"
"local_traverse(PyObject *op, visitproc visit, void *arg)\n"
"{\n"
"    localobject *self = (localobject *) op;\n"
"    Py_VISIT(self->args);\n"
"    Py_VISIT(self->kw);\n"
"    Py_VISIT(self->dict);\n"
"    return 0;\n"
"}"
msgstr ""
"static int\n"
"local_traverse(PyObject *op, visitproc visit, void *arg)\n"
"{\n"
"    localobject *self = (localobject *) op;\n"
"    Py_VISIT(self->args);\n"
"    Py_VISIT(self->kw);\n"
"    Py_VISIT(self->dict);\n"
"    return 0;\n"
"}"

#: ../../c-api/typeobj.rst:1498
msgid ""
"Note that :c:func:`Py_VISIT` is called only on those members that can "
"participate in reference cycles.  Although there is also a ``self->key`` "
"member, it can only be ``NULL`` or a Python string and therefore cannot be "
"part of a reference cycle."
msgstr ""
"Note que :c:func:`Py_VISIT` é chamado apenas nos membros que podem "
"participar em ciclos de referência. Embora também exista um membro ``self-"
">key``, este só pode ser ``NULL`` ou uma cadeia de caracteres Python e, "
"portanto, não pode fazer parte de um ciclo de referência."

#: ../../c-api/typeobj.rst:1502
msgid ""
"On the other hand, even if you know a member can never be part of a cycle, "
"as a debugging aid you may want to visit it anyway just so the :mod:`gc` "
"module's :func:`~gc.get_referents` function will include it."
msgstr ""
"Por outro lado, mesmo que saiba que um membro nunca pode fazer parte de um "
"ciclo, como auxílio de depuração, pode querer visitá-lo de qualquer forma "
"para que a função :func:`~gc.get_referents` do módulo :mod:`gc` o inclua."

#: ../../c-api/typeobj.rst:1506
msgid ""
"Heap types (:c:macro:`Py_TPFLAGS_HEAPTYPE`) must visit their type with::"
msgstr ""
"Tipos de heap (:c:macro:`Py_TPFLAGS_HEAPTYPE`) devem visitar o seu tipo com::"

#: ../../c-api/typeobj.rst:1508
msgid "Py_VISIT(Py_TYPE(self));"
msgstr "Py_VISIT(Py_TYPE(self));"

#: ../../c-api/typeobj.rst:1510
msgid ""
"It is only needed since Python 3.9. To support Python 3.8 and older, this "
"line must be conditional::"
msgstr ""
"É apenas necessário desde o Python 3.9. Para suportar o Python 3.8 e versões "
"anteriores, esta linha deve ser condicional::"

#: ../../c-api/typeobj.rst:1513
msgid ""
"#if PY_VERSION_HEX >= 0x03090000\n"
"    Py_VISIT(Py_TYPE(self));\n"
"#endif"
msgstr ""
"#if PY_VERSION_HEX >= 0x03090000\n"
"    Py_VISIT(Py_TYPE(self));\n"
"#endif"

#: ../../c-api/typeobj.rst:1517
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit is set in the :c:member:"
"`~PyTypeObject.tp_flags` field, the traverse function must call :c:func:"
"`PyObject_VisitManagedDict` like this::"
msgstr ""
"Se o bit :c:macro:`Py_TPFLAGS_MANAGED_DICT` estiver definido no campo :c:"
"member:`~PyTypeObject.tp_flags`, a função de travessia deve chamar :c:func:"
"`PyObject_VisitManagedDict` assim::"

#: ../../c-api/typeobj.rst:1521
msgid "PyObject_VisitManagedDict((PyObject*)self, visit, arg);"
msgstr "PyObject_VisitManagedDict((PyObject*)self, visit, arg);"

#: ../../c-api/typeobj.rst:1524
msgid ""
"When implementing :c:member:`~PyTypeObject.tp_traverse`, only the members "
"that the instance *owns* (by having :term:`strong references <strong "
"reference>` to them) must be visited. For instance, if an object supports "
"weak references via the :c:member:`~PyTypeObject.tp_weaklist` slot, the "
"pointer supporting the linked list (what *tp_weaklist* points to) must "
"**not** be visited as the instance does not directly own the weak references "
"to itself (the weakreference list is there to support the weak reference "
"machinery, but the instance has no strong reference to the elements inside "
"it, as they are allowed to be removed even if the instance is still alive)."
msgstr ""
"Ao implementar :c:member:`~PyTypeObject.tp_traverse`, apenas os membros que "
"a instância *possui* (ao ter :term:`referências fortes <strong reference>` "
"para eles) devem ser visitados. Por exemplo, se um objeto suporta "
"referências fracas via o slot :c:member:`~PyTypeObject.tp_weaklist`, o "
"ponteiro que suporta a lista ligada (para o qual *tp_weaklist* aponta) "
"**não** deve ser visitado, uma vez que a instância não possui diretamente as "
"referências fracas a si mesma (a lista de referências fracas está lá para "
"suportar a maquinaria de referências fracas, mas a instância não tem uma "
"referência forte para os elementos dentro dela, uma vez que estes podem ser "
"removidos mesmo que a instância ainda esteja ativa)."

#: ../../c-api/typeobj.rst:1535
msgid ""
"Note that :c:func:`Py_VISIT` requires the *visit* and *arg* parameters to :c:"
"func:`!local_traverse` to have these specific names; don't name them just "
"anything."
msgstr ""
"Note que :c:func:`Py_VISIT` requer que os parâmetros *visit* e *arg* para :c:"
"func:`!local_traverse` tenham estes nomes específicos; não os nomeie de "
"qualquer forma."

#: ../../c-api/typeobj.rst:1539
msgid ""
"Instances of :ref:`heap-allocated types <heap-types>` hold a reference to "
"their type. Their traversal function must therefore either visit :c:func:"
"`Py_TYPE(self) <Py_TYPE>`, or delegate this responsibility by calling "
"``tp_traverse`` of another heap-allocated type (such as a heap-allocated "
"superclass). If they do not, the type object may not be garbage-collected."
msgstr ""
"Instâncias de :ref:`tipos alocados em heap <heap-types>` mantêm uma "
"referência ao seu tipo. A sua função de travessia deve, portanto, visitar :c:"
"func:`Py_TYPE(self) <Py_TYPE>`, ou delegar esta responsabilidade chamando "
"``tp_traverse`` de outro tipo alocado em heap (como uma superclasse alocada "
"em heap). Se não o fizerem, o objeto de tipo pode não ser recolhido pelo "
"recolhedor de lixo."

#: ../../c-api/typeobj.rst:1548
msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` function can be called from any "
"thread."
msgstr ""
"A função :c:member:`~PyTypeObject.tp_traverse` pode ser chamada a partir de "
"qualquer thread."

#: ../../c-api/typeobj.rst:1553
msgid ""
"Heap-allocated types are expected to visit ``Py_TYPE(self)`` in "
"``tp_traverse``.  In earlier versions of Python, due to `bug 40217 <https://"
"bugs.python.org/issue40217>`_, doing this may lead to crashes in subclasses."
msgstr ""
"Espera-se que os tipos alocados em heap visitem ``Py_TYPE(self)`` em "
"``tp_traverse``. Em versões anteriores do Python, devido ao `bug 40217 "
"<https://bugs.python.org/issue40217>`_, fazer isto pode levar a falhas em "
"subclasses."

#: ../../c-api/typeobj.rst:1562
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_clear` and the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :c:"
"member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` "
"are all inherited from the base type if they are all zero in the subtype."
msgstr ""
"Este campo é herdado por subtipos juntamente com :c:member:`~PyTypeObject."
"tp_clear` e o bit de flag :c:macro:`Py_TPFLAGS_HAVE_GC`: o bit de flag, :c:"
"member:`~PyTypeObject.tp_traverse` e :c:member:`~PyTypeObject.tp_clear` são "
"todos herdados do tipo base se forem todos zero no subtipo."

#: ../../c-api/typeobj.rst:1570
msgid "An optional pointer to a clear function.  The signature is::"
msgstr "Um ponteiro opcional para uma função de limpeza. A assinatura é::"

#: ../../c-api/typeobj.rst:1572
msgid "int tp_clear(PyObject *);"
msgstr "int tp_clear(PyObject *);"

#: ../../c-api/typeobj.rst:1574
msgid ""
"The purpose of this function is to break reference cycles that are causing "
"a :term:`cyclic isolate` so that the objects can be safely destroyed.  A "
"cleared object is a partially destroyed object; the object is not obligated "
"to satisfy design invariants held during normal use."
msgstr ""
"O objetivo desta função é quebrar ciclos de referência que estão a causar "
"um :term:`isolado cíclico` para que os objetos possam ser destruídos em "
"segurança. Um objeto limpo é um objeto parcialmente destruído; o objeto não "
"é obrigado a satisfazer invariantes de design mantidos durante o uso normal."

#: ../../c-api/typeobj.rst:1579
msgid ""
":c:member:`!tp_clear` does not need to delete references to objects that "
"can't participate in reference cycles, such as Python strings or Python "
"integers.  However, it may be convenient to clear all references, and write "
"the type's :c:member:`~PyTypeObject.tp_dealloc` function to invoke :c:member:"
"`!tp_clear` to avoid code duplication.  (Beware that :c:member:`!tp_clear` "
"might have already been called. Prefer calling idempotent functions like :c:"
"func:`Py_CLEAR`.)"
msgstr ""
":c:member:`!tp_clear` não precisa de eliminar referências a objetos que não "
"podem participar em ciclos de referência, como cadeias de caracteres Python "
"ou inteiros Python. No entanto, pode ser conveniente limpar todas as "
"referências e escrever a função :c:member:`~PyTypeObject.tp_dealloc` do tipo "
"para invocar :c:member:`!tp_clear` para evitar duplicação de código. (Tenha "
"cuidado, :c:member:`!tp_clear` pode já ter sido chamado. Prefira chamar "
"funções idempotentes como :c:func:`Py_CLEAR`.)"

#: ../../c-api/typeobj.rst:1587
msgid ""
"Any non-trivial cleanup should be performed in :c:member:`~PyTypeObject."
"tp_finalize` instead of :c:member:`!tp_clear`."
msgstr ""
"Qualquer limpeza não trivial deve ser realizada em :c:member:`~PyTypeObject."
"tp_finalize` em vez de :c:member:`!tp_clear`."

#: ../../c-api/typeobj.rst:1592
msgid ""
"If :c:member:`!tp_clear` fails to break a reference cycle then the objects "
"in the :term:`cyclic isolate` may remain indefinitely uncollectable "
"(\"leak\").  See :data:`gc.garbage`."
msgstr ""
"Se :c:member:`!tp_clear` falhar em quebrar um ciclo de referência, então os "
"objetos no :term:`isolado cíclico` podem permanecer indefinidamente não "
"recolhíveis (\"fuga\"). Ver :data:`gc.garbage`."

#: ../../c-api/typeobj.rst:1598
msgid ""
"Referents (direct and indirect) might have already been cleared; they are "
"not guaranteed to be in a consistent state."
msgstr ""
"Os referenciados (diretos e indiretos) podem já ter sido limpos; não é "
"garantido que estejam num estado consistente."

#: ../../c-api/typeobj.rst:1603
msgid ""
"The :c:member:`~PyTypeObject.tp_clear` function can be called from any "
"thread."
msgstr ""
"A função :c:member:`~PyTypeObject.tp_clear` pode ser chamada a partir de "
"qualquer thread."

#: ../../c-api/typeobj.rst:1608
msgid ""
"An object is not guaranteed to be automatically cleared before its "
"destructor (:c:member:`~PyTypeObject.tp_dealloc`) is called."
msgstr ""
"Não é garantido que um objeto seja limpo automaticamente antes de o seu "
"destrutor (:c:member:`~PyTypeObject.tp_dealloc`) ser chamado."

#: ../../c-api/typeobj.rst:1611
msgid ""
"This function differs from the destructor (:c:member:`~PyTypeObject."
"tp_dealloc`) in the following ways:"
msgstr ""
"Esta função difere do destrutor (:c:member:`~PyTypeObject.tp_dealloc`) nas "
"seguintes formas:"

#: ../../c-api/typeobj.rst:1614
msgid ""
"The purpose of clearing an object is to remove references to other objects "
"that might participate in a reference cycle.  The purpose of the destructor, "
"on the other hand, is a superset: it must release *all* resources it owns, "
"including references to objects that cannot participate in a reference cycle "
"(e.g., integers) as well as the object's own memory (by calling :c:member:"
"`~PyTypeObject.tp_free`)."
msgstr ""
"O objetivo de limpar um objeto é remover referências a outros objetos que "
"possam participar num ciclo de referência. O objetivo do destrutor, por "
"outro lado, é um superconjunto: deve libertar *todos* os recursos que "
"possui, incluindo referências a objetos que não podem participar num ciclo "
"de referência (por exemplo, inteiros) bem como a memória do próprio objeto "
"(chamando :c:member:`~PyTypeObject.tp_free`)."

#: ../../c-api/typeobj.rst:1620
msgid ""
"When :c:member:`!tp_clear` is called, other objects might still hold "
"references to the object being cleared.  Because of this, :c:member:`!"
"tp_clear` must not deallocate the object's own memory (:c:member:"
"`~PyTypeObject.tp_free`).  The destructor, on the other hand, is only called "
"when no (strong) references exist, and as such, must safely destroy the "
"object itself by deallocating it."
msgstr ""
"Quando :c:member:`!tp_clear` é chamado, outros objetos podem ainda ter "
"referências ao objeto a ser limpo. Por causa disso, :c:member:`!tp_clear` "
"não deve desalocar a memória do próprio objeto (:c:member:`~PyTypeObject."
"tp_free`). O destrutor, por outro lado, é chamado apenas quando não existem "
"(fortes) referências, e como tal, deve destruir o objeto em si desalocando-o "
"em segurança."

#: ../../c-api/typeobj.rst:1626
msgid ""
":c:member:`!tp_clear` might never be automatically called.  An object's "
"destructor, on the other hand, will be automatically called some time after "
"the object becomes unreachable (i.e., either there are no references to the "
"object or the object is a member of a :term:`cyclic isolate`)."
msgstr ""
":c:member:`!tp_clear` pode nunca ser chamado automaticamente. O destrutor de "
"um objeto, por outro lado, será chamado automaticamente algum tempo depois "
"de o objeto se tornar inacessível (ou seja, ou não há referências ao objeto "
"ou o objeto é membro de um :term:`isolado cíclico`)."

#: ../../c-api/typeobj.rst:1631
msgid ""
"No guarantees are made about when, if, or how often Python automatically "
"clears an object, except:"
msgstr ""
"Não são feitas garantias sobre quando, se, ou com que frequência o Python "
"limpa automaticamente um objeto, exceto:"

#: ../../c-api/typeobj.rst:1634
msgid ""
"Python will not automatically clear an object if it is reachable, i.e., "
"there is a reference to it and it is not a member of a :term:`cyclic "
"isolate`."
msgstr ""
"O Python não limpará automaticamente um objeto se este for acessível, ou "
"seja, se houver uma referência a ele e não for membro de um :term:`isolado "
"cíclico`."

#: ../../c-api/typeobj.rst:1637
msgid ""
"Python will not automatically clear an object if it has not been "
"automatically finalized (see :c:member:`~PyTypeObject.tp_finalize`).  (If "
"the finalizer resurrected the object, the object may or may not be "
"automatically finalized again before it is cleared.)"
msgstr ""
"O Python não limpará automaticamente um objeto se este não tiver sido "
"finalizado automaticamente (ver :c:member:`~PyTypeObject.tp_finalize`). (Se "
"o finalizador ressuscitou o objeto, o objeto pode ou não ser finalizado "
"automaticamente novamente antes de ser limpo.)"

#: ../../c-api/typeobj.rst:1641
msgid ""
"If an object is a member of a :term:`cyclic isolate`, Python will not "
"automatically clear it if any member of the cyclic isolate has not yet been "
"automatically finalized (:c:member:`~PyTypeObject.tp_finalize`)."
msgstr ""
"Se um objeto for membro de um :term:`isolado cíclico`, o Python não o "
"limpará automaticamente se algum membro do isolado cíclico ainda não tiver "
"sido finalizado automaticamente (:c:member:`~PyTypeObject.tp_finalize`)."

#: ../../c-api/typeobj.rst:1644
msgid ""
"Python will not destroy an object until after any automatic calls to its :c:"
"member:`!tp_clear` function have returned.  This ensures that the act of "
"breaking a reference cycle does not invalidate the ``self`` pointer while :c:"
"member:`!tp_clear` is still executing."
msgstr ""
"O Python não destruirá um objeto até que todas as chamadas automáticas à sua "
"função :c:member:`!tp_clear` tenham retornado. Isto garante que o ato de "
"quebrar um ciclo de referência não invalida o ponteiro ``self`` enquanto :c:"
"member:`!tp_clear` ainda está a ser executado."

#: ../../c-api/typeobj.rst:1648
msgid ""
"Python will not automatically call :c:member:`!tp_clear` multiple times "
"concurrently."
msgstr ""
"O Python não chamará automaticamente :c:member:`!tp_clear` várias vezes em "
"simultâneo."

#: ../../c-api/typeobj.rst:1651
msgid ""
"CPython currently only automatically clears objects as needed to break "
"reference cycles in a :term:`cyclic isolate`, but future versions might "
"clear objects regularly before their destruction."
msgstr ""
"O CPython atualmente limpa automaticamente objetos apenas conforme "
"necessário para quebrar ciclos de referência num :term:`isolado cíclico`, "
"mas versões futuras podem limpar objetos regularmente antes da sua "
"destruição."

#: ../../c-api/typeobj.rst:1655
msgid ""
"Taken together, all :c:member:`~PyTypeObject.tp_clear` functions in the "
"system must combine to break all reference cycles.  This is subtle, and if "
"in any doubt supply a :c:member:`~PyTypeObject.tp_clear` function.  For "
"example, the tuple type does not implement a :c:member:`~PyTypeObject."
"tp_clear` function, because it's possible to prove that no reference cycle "
"can be composed entirely of tuples.  Therefore the :c:member:`~PyTypeObject."
"tp_clear` functions of other types are responsible for breaking any cycle "
"containing a tuple.  This isn't immediately obvious, and there's rarely a "
"good reason to avoid implementing :c:member:`~PyTypeObject.tp_clear`."
msgstr ""
"Em conjunto, todas as funções :c:member:`~PyTypeObject.tp_clear` no sistema "
"devem combinar-se para quebrar todos os ciclos de referência. Isto é subtil, "
"e em caso de dúvida, forneça uma função :c:member:`~PyTypeObject.tp_clear`. "
"Por exemplo, o tipo tuplo não implementa uma função :c:member:`~PyTypeObject."
"tp_clear`, porque é possível provar que nenhum ciclo de referência pode ser "
"composto inteiramente por tuplos. Portanto, as funções :c:member:"
"`~PyTypeObject.tp_clear` de outros tipos são responsáveis por quebrar "
"qualquer ciclo que contenha um tuplo. Isto não é imediatamente óbvio, e "
"raramente há uma boa razão para evitar implementar :c:member:`~PyTypeObject."
"tp_clear`."

#: ../../c-api/typeobj.rst:1666
msgid ""
"Implementations of :c:member:`~PyTypeObject.tp_clear` should drop the "
"instance's references to those of its members that may be Python objects, "
"and set its pointers to those members to ``NULL``, as in the following "
"example::"
msgstr ""
"As implementações de :c:member:`~PyTypeObject.tp_clear` devem largar as "
"referências da instância para os seus membros que podem ser objetos Python, "
"e definir os seus ponteiros para esses membros como ``NULL``, como no "
"seguinte exemplo::"

#: ../../c-api/typeobj.rst:1670
msgid ""
"static int\n"
"local_clear(PyObject *op)\n"
"{\n"
"    localobject *self = (localobject *) op;\n"
"    Py_CLEAR(self->key);\n"
"    Py_CLEAR(self->args);\n"
"    Py_CLEAR(self->kw);\n"
"    Py_CLEAR(self->dict);\n"
"    return 0;\n"
"}"
msgstr ""
"static int\n"
"local_clear(PyObject *op)\n"
"{\n"
"    localobject *self = (localobject *) op;\n"
"    Py_CLEAR(self->key);\n"
"    Py_CLEAR(self->args);\n"
"    Py_CLEAR(self->kw);\n"
"    Py_CLEAR(self->dict);\n"
"    return 0;\n"
"}"

#: ../../c-api/typeobj.rst:1681
msgid ""
"The :c:func:`Py_CLEAR` macro should be used, because clearing references is "
"delicate:  the reference to the contained object must not be released (via :"
"c:func:`Py_DECREF`) until after the pointer to the contained object is set "
"to ``NULL``.  This is because releasing the reference may cause the "
"contained object to become trash, triggering a chain of reclamation activity "
"that may include invoking arbitrary Python code (due to finalizers, or "
"weakref callbacks, associated with the contained object). If it's possible "
"for such code to reference *self* again, it's important that the pointer to "
"the contained object be ``NULL`` at that time, so that *self* knows the "
"contained object can no longer be used.  The :c:func:`Py_CLEAR` macro "
"performs the operations in a safe order."
msgstr ""
"A macro :c:func:`Py_CLEAR` deve ser usada, porque limpar referências é "
"delicado: a referência ao objeto contido não deve ser libertada (via :c:func:"
"`Py_DECREF`) até depois de o ponteiro para o objeto contido ser definido "
"para ``NULL``. Isto porque libertar a referência pode fazer com que o objeto "
"contido se torne lixo, desencadeando uma cadeia de atividades de reclamação "
"que podem incluir a invocação de código Python arbitrário (devido a "
"finalizadores ou callbacks de weakref, associados ao objeto contido). Se for "
"possível que tal código refira *self* novamente, é importante que o ponteiro "
"para o objeto contido seja ``NULL`` nessa altura, para que *self* saiba que "
"o objeto contido já não pode ser usado. A macro :c:func:`Py_CLEAR` realiza "
"as operações por uma ordem segura."

#: ../../c-api/typeobj.rst:1693
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit is set in the :c:member:"
"`~PyTypeObject.tp_flags` field, the traverse function must call :c:func:"
"`PyObject_ClearManagedDict` like this::"
msgstr ""
"Se o bit :c:macro:`Py_TPFLAGS_MANAGED_DICT` estiver definido no campo :c:"
"member:`~PyTypeObject.tp_flags`, a função de travessia deve chamar :c:func:"
"`PyObject_ClearManagedDict` assim::"

#: ../../c-api/typeobj.rst:1697
msgid "PyObject_ClearManagedDict((PyObject*)self);"
msgstr "PyObject_ClearManagedDict((PyObject*)self);"

#: ../../c-api/typeobj.rst:1706
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_traverse` and the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :"
"c:member:`~PyTypeObject.tp_traverse`, and :c:member:`~PyTypeObject.tp_clear` "
"are all inherited from the base type if they are all zero in the subtype."
msgstr ""
"Este campo é herdado por subtipos juntamente com :c:member:`~PyTypeObject."
"tp_traverse` e o bit de flag :c:macro:`Py_TPFLAGS_HAVE_GC`: o bit de flag, :"
"c:member:`~PyTypeObject.tp_traverse` e :c:member:`~PyTypeObject.tp_clear` "
"são todos herdados do tipo base se forem todos zero no subtipo."

#: ../../c-api/typeobj.rst:1718
msgid ""
"An optional pointer to the rich comparison function, whose signature is::"
msgstr ""
"Um ponteiro opcional para a função de comparação rica, cuja assinatura é::"

#: ../../c-api/typeobj.rst:1720
msgid "PyObject *tp_richcompare(PyObject *self, PyObject *other, int op);"
msgstr "PyObject *tp_richcompare(PyObject *self, PyObject *other, int op);"

#: ../../c-api/typeobj.rst:1722
msgid ""
"The first parameter is guaranteed to be an instance of the type that is "
"defined by :c:type:`PyTypeObject`."
msgstr ""
"O primeiro parâmetro é garantidamente uma instância do tipo que é definido "
"por :c:type:`PyTypeObject`."

#: ../../c-api/typeobj.rst:1725
msgid ""
"The function should return the result of the comparison (usually ``Py_True`` "
"or ``Py_False``).  If the comparison is undefined, it must return "
"``Py_NotImplemented``, if another error occurred it must return ``NULL`` and "
"set an exception condition."
msgstr ""
"A função deve retornar o resultado da comparação (normalmente ``Py_True`` ou "
"``Py_False``). Se a comparação não estiver definida, deve retornar "
"``Py_NotImplemented``; se ocorrer outro erro, deve retornar ``NULL`` e "
"definir uma condição de exceção."

#: ../../c-api/typeobj.rst:1730
msgid ""
"The following constants are defined to be used as the third argument for :c:"
"member:`~PyTypeObject.tp_richcompare` and for :c:func:`PyObject_RichCompare`:"
msgstr ""
"As seguintes constantes são definidas para serem usadas como terceiro "
"argumento para :c:member:`~PyTypeObject.tp_richcompare` e para :c:func:"
"`PyObject_RichCompare`:"

#: ../../c-api/typeobj.rst:1736
msgid "Constant"
msgstr "Constante"

#: ../../c-api/typeobj.rst:1736
msgid "Comparison"
msgstr "Comparação"

#: ../../c-api/typeobj.rst:1738
msgid "``<``"
msgstr "``<``"

#: ../../c-api/typeobj.rst:1740
msgid "``<=``"
msgstr "``<=``"

#: ../../c-api/typeobj.rst:1742
msgid "``==``"
msgstr "``==``"

#: ../../c-api/typeobj.rst:1744
msgid "``!=``"
msgstr "``!=``"

#: ../../c-api/typeobj.rst:1746
msgid "``>``"
msgstr "``>``"

#: ../../c-api/typeobj.rst:1748
msgid "``>=``"
msgstr "``>=``"

#: ../../c-api/typeobj.rst:1751
msgid ""
"The following macro is defined to ease writing rich comparison functions:"
msgstr ""
"A seguinte macro é definida para facilitar a escrita de funções de "
"comparação rica:"

#: ../../c-api/typeobj.rst:1755
msgid ""
"Return ``Py_True`` or ``Py_False`` from the function, depending on the "
"result of a comparison. VAL_A and VAL_B must be orderable by C comparison "
"operators (for example, they may be C ints or floats). The third argument "
"specifies the requested operation, as for :c:func:`PyObject_RichCompare`."
msgstr ""
"Retorne ``Py_True`` ou ``Py_False`` da função, dependendo do resultado de "
"uma comparação. VAL_A e VAL_B devem ser ordenáveis por operadores de "
"comparação C (por exemplo, podem ser ints ou floats C). O terceiro argumento "
"especifica a operação solicitada, como para :c:func:`PyObject_RichCompare`."

#: ../../c-api/typeobj.rst:1761
msgid "The returned value is a new :term:`strong reference`."
msgstr "O valor retornado é uma nova :term:`referência forte`."

#: ../../c-api/typeobj.rst:1763
msgid "On error, sets an exception and returns ``NULL`` from the function."
msgstr "Em caso de erro, define uma exceção e retorna ``NULL`` da função."

#: ../../c-api/typeobj.rst:1771
msgid ""
"This field is inherited by subtypes together with :c:member:`~PyTypeObject."
"tp_hash`: a subtype inherits :c:member:`~PyTypeObject.tp_richcompare` and :c:"
"member:`~PyTypeObject.tp_hash` when the subtype's :c:member:`~PyTypeObject."
"tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` are both ``NULL``."
msgstr ""
"Este campo é herdado por subtipos juntamente com :c:member:`~PyTypeObject."
"tp_hash`: um subtipo herda :c:member:`~PyTypeObject.tp_richcompare` e :c:"
"member:`~PyTypeObject.tp_hash` quando os :c:member:`~PyTypeObject."
"tp_richcompare` e :c:member:`~PyTypeObject.tp_hash` do subtipo são ambos "
"``NULL``."

#: ../../c-api/typeobj.rst:1778
msgid ""
":c:data:`PyBaseObject_Type` provides a :c:member:`~PyTypeObject."
"tp_richcompare` implementation, which may be inherited.  However, if only :c:"
"member:`~PyTypeObject.tp_hash` is defined, not even the inherited function "
"is used and instances of the type will not be able to participate in any "
"comparisons."
msgstr ""
":c:data:`PyBaseObject_Type` fornece uma implementação de :c:member:"
"`~PyTypeObject.tp_richcompare`, que pode ser herdada. No entanto, se apenas :"
"c:member:`~PyTypeObject.tp_hash` estiver definido, nem mesmo a função "
"herdada é usada e as instâncias do tipo não serão capazes de participar em "
"quaisquer comparações."

#: ../../c-api/typeobj.rst:1787
msgid ""
"While this field is still supported, :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` "
"should be used instead, if at all possible."
msgstr ""
"Embora este campo ainda seja suportado, :c:macro:"
"`Py_TPFLAGS_MANAGED_WEAKREF` deve ser usado em vez disso, se possível."

#: ../../c-api/typeobj.rst:1790
msgid ""
"If the instances of this type are weakly referenceable, this field is "
"greater than zero and contains the offset in the instance structure of the "
"weak reference list head (ignoring the GC header, if present); this offset "
"is used by :c:func:`PyObject_ClearWeakRefs` and the ``PyWeakref_*`` "
"functions.  The instance structure needs to include a field of type :c:expr:"
"`PyObject*` which is initialized to ``NULL``."
msgstr ""
"Se as instâncias deste tipo forem referenciáveis fracamente, este campo é "
"maior que zero e contém o deslocamento na estrutura da instância do "
"cabeçalho da lista de referências fracas (ignorando o cabeçalho GC, se "
"presente); este deslocamento é usado por :c:func:`PyObject_ClearWeakRefs` e "
"pelas funções ``PyWeakref_*``. A estrutura da instância precisa de incluir "
"um campo do tipo :c:expr:`PyObject*` que é inicializado para ``NULL``."

#: ../../c-api/typeobj.rst:1797
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_weaklist`; that "
"is the list head for weak references to the type object itself."
msgstr ""
"Não confunda este campo com :c:member:`~PyTypeObject.tp_weaklist`; esse é o "
"cabeçalho da lista para referências fracas ao próprio objeto de tipo."

#: ../../c-api/typeobj.rst:1800
msgid ""
"It is an error to set both the :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` bit "
"and :c:member:`~PyTypeObject.tp_weaklistoffset`."
msgstr ""
"É um erro definir tanto o bit :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` como :c:"
"member:`~PyTypeObject.tp_weaklistoffset`."

#: ../../c-api/typeobj.rst:1805
msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype uses a "
"different weak reference list head than the base type.  Since the list head "
"is always found via :c:member:`~PyTypeObject.tp_weaklistoffset`, this should "
"not be a problem."
msgstr ""
"Este campo é herdado por subtipos, mas ver as regras listadas abaixo. Um "
"subtipo pode substituir este deslocamento; isto significa que o subtipo usa "
"um cabeçalho de lista de referências fracas diferente do tipo base. Uma vez "
"que o cabeçalho da lista é sempre encontrado via :c:member:`~PyTypeObject."
"tp_weaklistoffset`, isto não deve ser um problema."

#: ../../c-api/typeobj.rst:1812
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` bit is set in the :c:member:"
"`~PyTypeObject.tp_flags` field, then :c:member:`~PyTypeObject."
"tp_weaklistoffset` will be set to a negative value, to indicate that it is "
"unsafe to use this field."
msgstr ""
"Se o bit :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` estiver definido no campo :c:"
"member:`~PyTypeObject.tp_flags`, então :c:member:`~PyTypeObject."
"tp_weaklistoffset` será definido para um valor negativo, para indicar que "
"não é seguro usar este campo."

#: ../../c-api/typeobj.rst:1820
msgid ""
"An optional pointer to a function that returns an :term:`iterator` for the "
"object.  Its presence normally signals that the instances of this type are :"
"term:`iterable` (although sequences may be iterable without this function)."
msgstr ""
"Um ponteiro opcional para uma função que retorna um :term:`iterador` para o "
"objeto. A sua presença normalmente sinaliza que as instâncias deste tipo "
"são :term:`iteráveis` (embora as sequências possam ser iteráveis sem esta "
"função)."

#: ../../c-api/typeobj.rst:1824
msgid "This function has the same signature as :c:func:`PyObject_GetIter`::"
msgstr "Esta função tem a mesma assinatura que :c:func:`PyObject_GetIter`::"

#: ../../c-api/typeobj.rst:1826
msgid "PyObject *tp_iter(PyObject *self);"
msgstr "PyObject *tp_iter(PyObject *self);"

#: ../../c-api/typeobj.rst:1835
msgid ""
"An optional pointer to a function that returns the next item in an :term:"
"`iterator`. The signature is::"
msgstr ""
"Um ponteiro opcional para uma função que retorna o próximo item num :term:"
"`iterador`. A assinatura é::"

#: ../../c-api/typeobj.rst:1838
msgid "PyObject *tp_iternext(PyObject *self);"
msgstr "PyObject *tp_iternext(PyObject *self);"

#: ../../c-api/typeobj.rst:1840
msgid ""
"When the iterator is exhausted, it must return ``NULL``; a :exc:"
"`StopIteration` exception may or may not be set.  When another error occurs, "
"it must return ``NULL`` too.  Its presence signals that the instances of "
"this type are iterators."
msgstr ""
"Quando o iterador estiver esgotado, deve retornar ``NULL``; uma exceção :exc:"
"`StopIteration` pode ou não ser definida. Quando ocorrer outro erro, também "
"deve retornar ``NULL``. A sua presença sinaliza que as instâncias deste tipo "
"são iteradores."

#: ../../c-api/typeobj.rst:1845
msgid ""
"Iterator types should also define the :c:member:`~PyTypeObject.tp_iter` "
"function, and that function should return the iterator instance itself (not "
"a new iterator instance)."
msgstr ""
"Os tipos de iterador também devem definir a função :c:member:`~PyTypeObject."
"tp_iter`, e essa função deve retornar a própria instância do iterador (não "
"uma nova instância de iterador)."

#: ../../c-api/typeobj.rst:1849
msgid "This function has the same signature as :c:func:`PyIter_Next`."
msgstr "Esta função tem a mesma assinatura que :c:func:`PyIter_Next`."

#: ../../c-api/typeobj.rst:1858
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyMethodDef` structures, declaring regular methods of this type."
msgstr ""
"Um ponteiro opcional para um array estático terminado por ``NULL`` de "
"estruturas :c:type:`PyMethodDef`, declarando métodos regulares deste tipo."

#: ../../c-api/typeobj.rst:1861
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a method descriptor."
msgstr ""
"Para cada entrada no array, uma entrada é adicionada ao dicionário do tipo "
"(ver :c:member:`~PyTypeObject.tp_dict` abaixo) contendo um descritor de "
"método."

#: ../../c-api/typeobj.rst:1866
msgid ""
"This field is not inherited by subtypes (methods are inherited through a "
"different mechanism)."
msgstr ""
"Este campo não é herdado por subtipos (os métodos são herdados através de um "
"mecanismo diferente)."

#: ../../c-api/typeobj.rst:1872
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyMemberDef` structures, declaring regular data members (fields or slots) "
"of instances of this type."
msgstr ""
"Um ponteiro opcional para um array estático terminado por ``NULL`` de "
"estruturas :c:type:`PyMemberDef`, declarando membros de dados regulares "
"(campos ou slots) de instâncias deste tipo."

#: ../../c-api/typeobj.rst:1876
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a member descriptor."
msgstr ""
"Para cada entrada no array, uma entrada é adicionada ao dicionário do tipo "
"(ver :c:member:`~PyTypeObject.tp_dict` abaixo) contendo um descritor de "
"membro."

#: ../../c-api/typeobj.rst:1881
msgid ""
"This field is not inherited by subtypes (members are inherited through a "
"different mechanism)."
msgstr ""
"Este campo não é herdado por subtipos (os membros são herdados através de um "
"mecanismo diferente)."

#: ../../c-api/typeobj.rst:1887
msgid ""
"An optional pointer to a static ``NULL``-terminated array of :c:type:"
"`PyGetSetDef` structures, declaring computed attributes of instances of this "
"type."
msgstr ""
"Um ponteiro opcional para um array estático terminado por ``NULL`` de "
"estruturas :c:type:`PyGetSetDef`, declarando atributos calculados de "
"instâncias deste tipo."

#: ../../c-api/typeobj.rst:1890
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :c:member:`~PyTypeObject.tp_dict` below) containing a getset descriptor."
msgstr ""
"Para cada entrada no array, uma entrada é adicionada ao dicionário do tipo "
"(ver :c:member:`~PyTypeObject.tp_dict` abaixo) contendo um descritor getset."

#: ../../c-api/typeobj.rst:1895
msgid ""
"This field is not inherited by subtypes (computed attributes are inherited "
"through a different mechanism)."
msgstr ""
"Este campo não é herdado por subtipos (os atributos calculados são herdados "
"através de um mecanismo diferente)."

#: ../../c-api/typeobj.rst:1901
msgid ""
"An optional pointer to a base type from which type properties are "
"inherited.  At this level, only single inheritance is supported; multiple "
"inheritance require dynamically creating a type object by calling the "
"metatype."
msgstr ""
"Um ponteiro opcional para um tipo base do qual as propriedades do tipo são "
"herdadas. Neste nível, apenas a herança simples é suportada; a herança "
"múltipla requer a criação dinâmica de um objeto de tipo chamando o metatipo."

#: ../../c-api/typeobj.rst:1909
msgid ""
"Slot initialization is subject to the rules of initializing globals. C99 "
"requires the initializers to be \"address constants\".  Function designators "
"like :c:func:`PyType_GenericNew`, with implicit conversion to a pointer, are "
"valid C99 address constants."
msgstr ""
"A inicialização de slots está sujeita às regras de inicialização de globais. "
"O C99 requer que os inicializadores sejam \"constantes de endereço\". "
"Designadores de função como :c:func:`PyType_GenericNew`, com conversão "
"implícita para um ponteiro, são constantes de endereço C99 válidas."

#: ../../c-api/typeobj.rst:1914
msgid ""
"However, the unary '&' operator applied to a non-static variable like :c:"
"data:`PyBaseObject_Type` is not required to produce an address constant.  "
"Compilers may support this (gcc does), MSVC does not. Both compilers are "
"strictly standard conforming in this particular behavior."
msgstr ""
"No entanto, o operador unário '&' aplicado a uma variável não estática como :"
"c:data:`PyBaseObject_Type` não é obrigado a produzir uma constante de "
"endereço. Os compiladores podem suportar isto (gcc suporta), MSVC não. Ambos "
"os compiladores estão estritamente conformes ao padrão neste comportamento "
"particular."

#: ../../c-api/typeobj.rst:1920
msgid ""
"Consequently, :c:member:`~PyTypeObject.tp_base` should be set in the "
"extension module's init function."
msgstr ""
"Consequentemente, :c:member:`~PyTypeObject.tp_base` deve ser definido na "
"função de inicialização do módulo de extensão."

#: ../../c-api/typeobj.rst:1925
msgid "This field is not inherited by subtypes (obviously)."
msgstr "Este campo não é herdado por subtipos (obviamente)."

#: ../../c-api/typeobj.rst:1929
msgid ""
"This field defaults to ``&PyBaseObject_Type`` (which to Python programmers "
"is known as the type :class:`object`)."
msgstr ""
"Este campo tem como predefinição ``&PyBaseObject_Type`` (que para "
"programadores Python é conhecido como o tipo :class:`object`)."

#: ../../c-api/typeobj.rst:1935
msgid "The type's dictionary is stored here by :c:func:`PyType_Ready`."
msgstr "O dicionário do tipo é armazenado aqui por :c:func:`PyType_Ready`."

#: ../../c-api/typeobj.rst:1937
msgid ""
"This field should normally be initialized to ``NULL`` before PyType_Ready is "
"called; it may also be initialized to a dictionary containing initial "
"attributes for the type.  Once :c:func:`PyType_Ready` has initialized the "
"type, extra attributes for the type may be added to this dictionary only if "
"they don't correspond to overloaded operations (like :meth:`~object."
"__add__`).  Once initialization for the type has finished, this field should "
"be treated as read-only."
msgstr ""
"Este campo deve normalmente ser inicializado para ``NULL`` antes de "
"PyType_Ready ser chamado; também pode ser inicializado para um dicionário "
"contendo atributos iniciais para o tipo. Uma vez que :c:func:`PyType_Ready` "
"tenha inicializado o tipo, atributos extra para o tipo podem ser adicionados "
"a este dicionário apenas se não corresponderem a operações sobrecarregadas "
"(como :meth:`~object.__add__`). Uma vez terminada a inicialização do tipo, "
"este campo deve ser tratado como apenas de leitura."

#: ../../c-api/typeobj.rst:1945
msgid ""
"Some types may not store their dictionary in this slot. Use :c:func:"
"`PyType_GetDict` to retrieve the dictionary for an arbitrary type."
msgstr ""
"Alguns tipos podem não armazenar o seu dicionário neste slot. Use :c:func:"
"`PyType_GetDict` para recuperar o dicionário para um tipo arbitrário."

#: ../../c-api/typeobj.rst:1951
msgid ""
"Internals detail: For static builtin types, this is always ``NULL``. "
"Instead, the dict for such types is stored on ``PyInterpreterState``. Use :c:"
"func:`PyType_GetDict` to get the dict for an arbitrary type."
msgstr ""
"Detalhe interno: Para tipos incorporados estáticos, isto é sempre ``NULL``. "
"Em vez disso, o dicionário para esses tipos é armazenado em "
"``PyInterpreterState``. Use :c:func:`PyType_GetDict` para obter o dicionário "
"para um tipo arbitrário."

#: ../../c-api/typeobj.rst:1957
msgid ""
"This field is not inherited by subtypes (though the attributes defined in "
"here are inherited through a different mechanism)."
msgstr ""
"Este campo não é herdado por subtipos (embora os atributos definidos aqui "
"sejam herdados através de um mecanismo diferente)."

#: ../../c-api/typeobj.rst:1962
msgid ""
"If this field is ``NULL``, :c:func:`PyType_Ready` will assign a new "
"dictionary to it."
msgstr ""
"Se este campo for ``NULL``, :c:func:`PyType_Ready` atribuirá um novo "
"dicionário a ele."

#: ../../c-api/typeobj.rst:1967
msgid ""
"It is not safe to use :c:func:`PyDict_SetItem` on or otherwise modify :c:"
"member:`~PyTypeObject.tp_dict` with the dictionary C-API."
msgstr ""
"Não é seguro usar :c:func:`PyDict_SetItem` ou modificar de outra forma :c:"
"member:`~PyTypeObject.tp_dict` com a API C de dicionário."

#: ../../c-api/typeobj.rst:1973
msgid "An optional pointer to a \"descriptor get\" function."
msgstr "Um ponteiro opcional para uma função \"descritor get\"."

#: ../../c-api/typeobj.rst:1975 ../../c-api/typeobj.rst:1991
#: ../../c-api/typeobj.rst:2055 ../../c-api/typeobj.rst:2085
#: ../../c-api/typeobj.rst:2108
msgid "The function signature is::"
msgstr "A assinatura da função é::"

#: ../../c-api/typeobj.rst:1977
msgid "PyObject * tp_descr_get(PyObject *self, PyObject *obj, PyObject *type);"
msgstr ""
"PyObject * tp_descr_get(PyObject *self, PyObject *obj, PyObject *type);"

#: ../../c-api/typeobj.rst:1988
msgid ""
"An optional pointer to a function for setting and deleting a descriptor's "
"value."
msgstr ""
"Um ponteiro opcional para uma função de definição e eliminação do valor de "
"um descritor."

#: ../../c-api/typeobj.rst:1993
msgid "int tp_descr_set(PyObject *self, PyObject *obj, PyObject *value);"
msgstr "int tp_descr_set(PyObject *self, PyObject *obj, PyObject *value);"

#: ../../c-api/typeobj.rst:1995
msgid "The *value* argument is set to ``NULL`` to delete the value."
msgstr "O argumento *value* é definido para ``NULL`` para eliminar o valor."

#: ../../c-api/typeobj.rst:2006
msgid ""
"While this field is still supported, :c:macro:`Py_TPFLAGS_MANAGED_DICT` "
"should be used instead, if at all possible."
msgstr ""
"Embora este campo ainda seja suportado, :c:macro:`Py_TPFLAGS_MANAGED_DICT` "
"deve ser usado em vez disso, se possível."

#: ../../c-api/typeobj.rst:2009
msgid ""
"If the instances of this type have a dictionary containing instance "
"variables, this field is non-zero and contains the offset in the instances "
"of the type of the instance variable dictionary; this offset is used by :c:"
"func:`PyObject_GenericGetAttr`."
msgstr ""
"Se as instâncias deste tipo tiverem um dicionário contendo variáveis de "
"instância, este campo é não-zero e contém o deslocamento nas instâncias do "
"tipo do dicionário de variáveis de instância; este deslocamento é usado por :"
"c:func:`PyObject_GenericGetAttr`."

#: ../../c-api/typeobj.rst:2014
msgid ""
"Do not confuse this field with :c:member:`~PyTypeObject.tp_dict`; that is "
"the dictionary for attributes of the type object itself."
msgstr ""
"Não confunda este campo com :c:member:`~PyTypeObject.tp_dict`; esse é o "
"dicionário para atributos do próprio objeto de tipo."

#: ../../c-api/typeobj.rst:2017
msgid ""
"The value specifies the offset of the dictionary from the start of the "
"instance structure."
msgstr ""
"O valor especifica o deslocamento do dicionário a partir do início da "
"estrutura da instância."

#: ../../c-api/typeobj.rst:2019
msgid ""
"The :c:member:`~PyTypeObject.tp_dictoffset` should be regarded as write-"
"only. To get the pointer to the dictionary call :c:func:"
"`PyObject_GenericGetDict`. Calling :c:func:`PyObject_GenericGetDict` may "
"need to allocate memory for the dictionary, so it is may be more efficient "
"to call :c:func:`PyObject_GetAttr` when accessing an attribute on the object."
msgstr ""
"O :c:member:`~PyTypeObject.tp_dictoffset` deve ser considerado apenas de "
"escrita. Para obter o ponteiro para o dicionário, chame :c:func:"
"`PyObject_GenericGetDict`. Chamar :c:func:`PyObject_GenericGetDict` pode "
"precisar de alocar memória para o dicionário, por isso pode ser mais "
"eficiente chamar :c:func:`PyObject_GetAttr` ao aceder a um atributo no "
"objeto."

#: ../../c-api/typeobj.rst:2025
msgid ""
"It is an error to set both the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit and :c:"
"member:`~PyTypeObject.tp_dictoffset`."
msgstr ""
"É um erro definir tanto o bit :c:macro:`Py_TPFLAGS_MANAGED_DICT` como :c:"
"member:`~PyTypeObject.tp_dictoffset`."

#: ../../c-api/typeobj.rst:2030
msgid ""
"This field is inherited by subtypes. A subtype should not override this "
"offset; doing so could be unsafe, if C code tries to access the dictionary "
"at the previous offset. To properly support inheritance, use :c:macro:"
"`Py_TPFLAGS_MANAGED_DICT`."
msgstr ""
"Este campo é herdado por subtipos. Um subtipo não deve substituir este "
"deslocamento; fazê-lo pode ser inseguro, se o código C tentar aceder ao "
"dicionário no deslocamento anterior. Para suportar corretamente a herança, "
"use :c:macro:`Py_TPFLAGS_MANAGED_DICT`."

#: ../../c-api/typeobj.rst:2037
msgid ""
"This slot has no default.  For :ref:`static types <static-types>`, if the "
"field is ``NULL`` then no :attr:`~object.__dict__` gets created for "
"instances."
msgstr ""
"Este slot não tem predefinição. Para :ref:`tipos estáticos <static-types>`, "
"se o campo for ``NULL``, então nenhum :attr:`~object.__dict__` é criado para "
"instâncias."

#: ../../c-api/typeobj.rst:2040
msgid ""
"If the :c:macro:`Py_TPFLAGS_MANAGED_DICT` bit is set in the :c:member:"
"`~PyTypeObject.tp_flags` field, then :c:member:`~PyTypeObject.tp_dictoffset` "
"will be set to ``-1``, to indicate that it is unsafe to use this field."
msgstr ""
"Se o bit :c:macro:`Py_TPFLAGS_MANAGED_DICT` estiver definido no campo :c:"
"member:`~PyTypeObject.tp_flags`, então :c:member:`~PyTypeObject."
"tp_dictoffset` será definido para ``-1``, para indicar que não é seguro usar "
"este campo."

#: ../../c-api/typeobj.rst:2048
msgid "An optional pointer to an instance initialization function."
msgstr "Um ponteiro opcional para uma função de inicialização de instância."

#: ../../c-api/typeobj.rst:2050
msgid ""
"This function corresponds to the :meth:`~object.__init__` method of "
"classes.  Like :meth:`!__init__`, it is possible to create an instance "
"without calling :meth:`!__init__`, and it is possible to reinitialize an "
"instance by calling its :meth:`!__init__` method again."
msgstr ""
"Esta função corresponde ao método :meth:`~object.__init__` das classes. Tal "
"como :meth:`!__init__`, é possível criar uma instância sem chamar :meth:`!"
"__init__`, e é possível reinicializar uma instância chamando novamente o seu "
"método :meth:`!__init__`."

#: ../../c-api/typeobj.rst:2057
msgid "int tp_init(PyObject *self, PyObject *args, PyObject *kwds);"
msgstr "int tp_init(PyObject *self, PyObject *args, PyObject *kwds);"

#: ../../c-api/typeobj.rst:2059
msgid ""
"The self argument is the instance to be initialized; the *args* and *kwds* "
"arguments represent positional and keyword arguments of the call to :meth:"
"`~object.__init__`."
msgstr ""
"O argumento self é a instância a ser inicializada; os argumentos *args* e "
"*kwds* representam argumentos posicionais e de argumentos nomeados da "
"chamada a :meth:`~object.__init__`."

#: ../../c-api/typeobj.rst:2063
msgid ""
"The :c:member:`~PyTypeObject.tp_init` function, if not ``NULL``, is called "
"when an instance is created normally by calling its type, after the type's :"
"c:member:`~PyTypeObject.tp_new` function has returned an instance of the "
"type.  If the :c:member:`~PyTypeObject.tp_new` function returns an instance "
"of some other type that is not a subtype of the original type, no :c:member:"
"`~PyTypeObject.tp_init` function is called; if :c:member:`~PyTypeObject."
"tp_new` returns an instance of a subtype of the original type, the "
"subtype's :c:member:`~PyTypeObject.tp_init` is called."
msgstr ""
"A função :c:member:`~PyTypeObject.tp_init`, se não for ``NULL``, é chamada "
"quando uma instância é criada normalmente chamando o seu tipo, depois de a "
"função :c:member:`~PyTypeObject.tp_new` do tipo ter retornado uma instância "
"do tipo. Se a função :c:member:`~PyTypeObject.tp_new` retornar uma instância "
"de algum outro tipo que não seja um subtipo do tipo original, nenhuma "
"função :c:member:`~PyTypeObject.tp_init` é chamada; se :c:member:"
"`~PyTypeObject.tp_new` retornar uma instância de um subtipo do tipo "
"original, a função :c:member:`~PyTypeObject.tp_init` do subtipo é chamada."

#: ../../c-api/typeobj.rst:2070
msgid "Returns ``0`` on success, ``-1`` and sets an exception on error."
msgstr ""
"Retorna ``0`` em caso de sucesso, ``-1`` e define uma exceção em caso de "
"erro."

#: ../../c-api/typeobj.rst:2078
msgid ""
"For :ref:`static types <static-types>` this field does not have a default."
msgstr ""
"Para :ref:`tipos estáticos <static-types>` este campo não tem uma "
"predefinição."

#: ../../c-api/typeobj.rst:2083
msgid "An optional pointer to an instance allocation function."
msgstr "Um ponteiro opcional para uma função de alocação de instância."

#: ../../c-api/typeobj.rst:2087
msgid "PyObject *tp_alloc(PyTypeObject *self, Py_ssize_t nitems);"
msgstr "PyObject *tp_alloc(PyTypeObject *self, Py_ssize_t nitems);"

#: ../../c-api/typeobj.rst:2091
msgid ""
"Static subtypes inherit this slot, which will be :c:func:"
"`PyType_GenericAlloc` if inherited from :class:`object`."
msgstr ""
"Subtipos estáticos herdam este slot, que será :c:func:`PyType_GenericAlloc` "
"se herdado de :class:`object`."

#: ../../c-api/typeobj.rst:2094 ../../c-api/typeobj.rst:2161
msgid ":ref:`Heap subtypes <heap-types>` do not inherit this slot."
msgstr ":ref:`Subtipos de heap <heap-types>` não herdam este slot."

#: ../../c-api/typeobj.rst:2098
msgid ""
"For heap subtypes, this field is always set to :c:func:`PyType_GenericAlloc`."
msgstr ""
"Para subtipos de heap, este campo é sempre definido para :c:func:"
"`PyType_GenericAlloc`."

#: ../../c-api/typeobj.rst:2101 ../../c-api/typeobj.rst:2169
msgid "For static subtypes, this slot is inherited (see above)."
msgstr "Para subtipos estáticos, este slot é herdado (ver acima)."

#: ../../c-api/typeobj.rst:2106
msgid "An optional pointer to an instance creation function."
msgstr "Um ponteiro opcional para uma função de criação de instância."

#: ../../c-api/typeobj.rst:2110
msgid ""
"PyObject *tp_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds);"
msgstr ""
"PyObject *tp_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds);"

#: ../../c-api/typeobj.rst:2112
msgid ""
"The *subtype* argument is the type of the object being created; the *args* "
"and *kwds* arguments represent positional and keyword arguments of the call "
"to the type.  Note that *subtype* doesn't have to equal the type whose :c:"
"member:`~PyTypeObject.tp_new` function is called; it may be a subtype of "
"that type (but not an unrelated type)."
msgstr ""
"O argumento *subtype* é o tipo do objeto a ser criado; os argumentos *args* "
"e *kwds* representam argumentos posicionais e argumentos nomeados da chamada "
"ao tipo. Note que *subtype* não tem de ser igual ao tipo cuja função :c:"
"member:`~PyTypeObject.tp_new` é chamada; pode ser um subtipo desse tipo (mas "
"não um tipo não relacionado)."

#: ../../c-api/typeobj.rst:2118
msgid ""
"The :c:member:`~PyTypeObject.tp_new` function should call ``subtype-"
">tp_alloc(subtype, nitems)`` to allocate space for the object, and then do "
"only as much further initialization as is absolutely necessary.  "
"Initialization that can safely be ignored or repeated should be placed in "
"the :c:member:`~PyTypeObject.tp_init` handler.  A good rule of thumb is that "
"for immutable types, all initialization should take place in :c:member:"
"`~PyTypeObject.tp_new`, while for mutable types, most initialization should "
"be deferred to :c:member:`~PyTypeObject.tp_init`."
msgstr ""
"A função :c:member:`~PyTypeObject.tp_new` deve chamar ``subtype-"
">tp_alloc(subtype, nitems)`` para alocar espaço para o objeto, e depois "
"fazer apenas a inicialização adicional que seja absolutamente necessária. A "
"inicialização que pode ser ignorada ou repetida em segurança deve ser "
"colocada no manipulador :c:member:`~PyTypeObject.tp_init`. Uma boa regra "
"geral é que para tipos imutáveis, toda a inicialização deve ter lugar em :c:"
"member:`~PyTypeObject.tp_new`, enquanto para tipos mutáveis, a maioria da "
"inicialização deve ser adiada para :c:member:`~PyTypeObject.tp_init`."

#: ../../c-api/typeobj.rst:2126
msgid ""
"Set the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag to disallow "
"creating instances of the type in Python."
msgstr ""
"Defina a flag :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` para proibir a "
"criação de instâncias do tipo em Python."

#: ../../c-api/typeobj.rst:2131
msgid ""
"This field is inherited by subtypes, except it is not inherited by :ref:"
"`static types <static-types>` whose :c:member:`~PyTypeObject.tp_base` is "
"``NULL`` or ``&PyBaseObject_Type``."
msgstr ""
"Este campo é herdado por subtipos, exceto que não é herdado por :ref:`tipos "
"estáticos <static-types>` cujo :c:member:`~PyTypeObject.tp_base` é ``NULL`` "
"ou ``&PyBaseObject_Type``."

#: ../../c-api/typeobj.rst:2137
msgid ""
"For :ref:`static types <static-types>` this field has no default. This means "
"if the slot is defined as ``NULL``, the type cannot be called to create new "
"instances; presumably there is some other way to create instances, like a "
"factory function."
msgstr ""
"Para :ref:`tipos estáticos <static-types>` este campo não tem predefinição. "
"Isto significa que se o slot for definido como ``NULL``, o tipo não pode ser "
"chamado para criar novas instâncias; presumivelmente há outra forma de criar "
"instâncias, como uma função fábrica."

#: ../../c-api/typeobj.rst:2145
msgid ""
"An optional pointer to an instance deallocation function.  Its signature is::"
msgstr ""
"Um ponteiro opcional para uma função de desalocação de instância. A sua "
"assinatura é::"

#: ../../c-api/typeobj.rst:2147
msgid "void tp_free(void *self);"
msgstr "void tp_free(void *self);"

#: ../../c-api/typeobj.rst:2149
msgid ""
"This function must free the memory allocated by :c:member:`~PyTypeObject."
"tp_alloc`."
msgstr ""
"Esta função deve libertar a memória alocada por :c:member:`~PyTypeObject."
"tp_alloc`."

#: ../../c-api/typeobj.rst:2154
msgid ""
"Static subtypes inherit this slot, which will be :c:func:`PyObject_Free` if "
"inherited from :class:`object`.  Exception: If the type supports garbage "
"collection (i.e., the :c:macro:`Py_TPFLAGS_HAVE_GC` flag is set in :c:member:"
"`~PyTypeObject.tp_flags`) and it would inherit :c:func:`PyObject_Free`, then "
"this slot is not inherited but instead defaults to :c:func:`PyObject_GC_Del`."
msgstr ""
"Subtipos estáticos herdam este slot, que será :c:func:`PyObject_Free` se "
"herdado de :class:`object`. Exceção: Se o tipo suportar recolha de lixo (ou "
"seja, a flag :c:macro:`Py_TPFLAGS_HAVE_GC` estiver definida em :c:member:"
"`~PyTypeObject.tp_flags`) e herdaria :c:func:`PyObject_Free`, então este "
"slot não é herdado, mas em vez disso tem como predefinição :c:func:"
"`PyObject_GC_Del`."

#: ../../c-api/typeobj.rst:2165
msgid ""
"For :ref:`heap subtypes <heap-types>`, this slot defaults to a deallocator "
"suitable to match :c:func:`PyType_GenericAlloc` and the value of the :c:"
"macro:`Py_TPFLAGS_HAVE_GC` flag."
msgstr ""
"Para :ref:`subtipos de heap <heap-types>`, este slot tem como predefinição "
"um desalocador adequado para corresponder a :c:func:`PyType_GenericAlloc` e "
"ao valor da flag :c:macro:`Py_TPFLAGS_HAVE_GC`."

#: ../../c-api/typeobj.rst:2174
msgid "An optional pointer to a function called by the garbage collector."
msgstr "Um ponteiro opcional para uma função chamada pelo recolhedor de lixo."

#: ../../c-api/typeobj.rst:2176
msgid ""
"The garbage collector needs to know whether a particular object is "
"collectible or not.  Normally, it is sufficient to look at the object's "
"type's :c:member:`~PyTypeObject.tp_flags` field, and check the :c:macro:"
"`Py_TPFLAGS_HAVE_GC` flag bit.  But some types have a mixture of statically "
"and dynamically allocated instances, and the statically allocated instances "
"are not collectible.  Such types should define this function; it should "
"return ``1`` for a collectible instance, and ``0`` for a non-collectible "
"instance. The signature is::"
msgstr ""
"O recolhedor de lixo precisa de saber se um objeto específico é recolhível "
"ou não. Normalmente, é suficiente olhar para o campo :c:member:"
"`~PyTypeObject.tp_flags` do tipo do objeto e verificar o bit de flag :c:"
"macro:`Py_TPFLAGS_HAVE_GC`. Mas alguns tipos têm uma mistura de instâncias "
"alocadas estática e dinamicamente, e as instâncias alocadas estaticamente "
"não são recolhíveis. Tais tipos devem definir esta função; deve retornar "
"``1`` para uma instância recolhível e ``0`` para uma instância não "
"recolhível. A assinatura é::"

#: ../../c-api/typeobj.rst:2184
msgid "int tp_is_gc(PyObject *self);"
msgstr "int tp_is_gc(PyObject *self);"

#: ../../c-api/typeobj.rst:2186
msgid ""
"(The only example of this are types themselves.  The metatype, :c:data:"
"`PyType_Type`, defines this function to distinguish between statically and :"
"ref:`dynamically allocated types <heap-types>`.)"
msgstr ""
"(O único exemplo disto são os próprios tipos. O metatipo, :c:data:"
"`PyType_Type`, define esta função para distinguir entre tipos alocados "
"estática e :ref:`dinamicamente <heap-types>`.)"

#: ../../c-api/typeobj.rst:2196
msgid ""
"This slot has no default.  If this field is ``NULL``, :c:macro:"
"`Py_TPFLAGS_HAVE_GC` is used as the functional equivalent."
msgstr ""
"Este slot não tem predefinição. Se este campo for ``NULL``, :c:macro:"
"`Py_TPFLAGS_HAVE_GC` é usado como equivalente funcional."

#: ../../c-api/typeobj.rst:2202
msgid "Tuple of base types."
msgstr "Tuplo de tipos base."

#: ../../c-api/typeobj.rst:2204 ../../c-api/typeobj.rst:2228
msgid ""
"This field should be set to ``NULL`` and treated as read-only. Python will "
"fill it in when the type is :c:func:`initialized <PyType_Ready>`."
msgstr ""
"Este campo deve ser definido como ``NULL`` e tratado como apenas de leitura. "
"O Python preencherá este campo quando o tipo for :c:func:`inicializado "
"<PyType_Ready>`."

#: ../../c-api/typeobj.rst:2207
msgid ""
"For dynamically created classes, the ``Py_tp_bases`` :c:type:`slot "
"<PyType_Slot>` can be used instead of the *bases* argument of :c:func:"
"`PyType_FromSpecWithBases`. The argument form is preferred."
msgstr ""
"Para classes criadas dinamicamente, o ``Py_tp_bases`` :c:type:`slot "
"<PyType_Slot>` pode ser usado em vez do argumento *bases* de :c:func:"
"`PyType_FromSpecWithBases`. A forma de argumento é preferida."

#: ../../c-api/typeobj.rst:2214
msgid ""
"Multiple inheritance does not work well for statically defined types. If you "
"set ``tp_bases`` to a tuple, Python will not raise an error, but some slots "
"will only be inherited from the first base."
msgstr ""
"A herança múltipla não funciona bem para tipos definidos estaticamente. Se "
"definir ``tp_bases`` para um tuplo, o Python não levantará um erro, mas "
"alguns slots só serão herdados da primeira base."

#: ../../c-api/typeobj.rst:2220 ../../c-api/typeobj.rst:2243
#: ../../c-api/typeobj.rst:2260 ../../c-api/typeobj.rst:2277
#: ../../c-api/typeobj.rst:2291
msgid "This field is not inherited."
msgstr "Este campo não é herdado."

#: ../../c-api/typeobj.rst:2225
msgid ""
"Tuple containing the expanded set of base types, starting with the type "
"itself and ending with :class:`object`, in Method Resolution Order."
msgstr ""
"Tuplo contendo o conjunto expandido de tipos base, começando com o próprio "
"tipo e terminando com :class:`object`, na Ordem de Resolução de Métodos."

#: ../../c-api/typeobj.rst:2233
msgid ""
"This field is not inherited; it is calculated fresh by :c:func:"
"`PyType_Ready`."
msgstr ""
"Este campo não é herdado; é calculado de novo por :c:func:`PyType_Ready`."

#: ../../c-api/typeobj.rst:2239
msgid "Unused.  Internal use only."
msgstr "Não usado. Apenas para uso interno."

#: ../../c-api/typeobj.rst:2248
msgid ""
"A collection of subclasses.  Internal use only.  May be an invalid pointer."
msgstr ""
"Uma coleção de subclasses. Apenas para uso interno. Pode ser um ponteiro "
"inválido."

#: ../../c-api/typeobj.rst:2250
msgid ""
"To get a list of subclasses, call the Python method :py:meth:`~type."
"__subclasses__`."
msgstr ""
"Para obter uma lista de subclasses, chame o método Python :py:meth:`~type."
"__subclasses__`."

#: ../../c-api/typeobj.rst:2255
msgid ""
"For some types, this field does not hold a valid :c:expr:`PyObject*`. The "
"type was changed to :c:expr:`void*` to indicate this."
msgstr ""
"Para alguns tipos, este campo não contém um :c:expr:`PyObject*` válido. O "
"tipo foi alterado para :c:expr:`void*` para indicar isto."

#: ../../c-api/typeobj.rst:2265
msgid ""
"Weak reference list head, for weak references to this type object.  Not "
"inherited.  Internal use only."
msgstr ""
"Cabeçalho da lista de referências fracas, para referências fracas a este "
"objeto de tipo. Não herdado. Apenas para uso interno."

#: ../../c-api/typeobj.rst:2270
msgid ""
"Internals detail: For the static builtin types this is always ``NULL``, even "
"if weakrefs are added.  Instead, the weakrefs for each are stored on "
"``PyInterpreterState``.  Use the public C-API or the internal "
"``_PyObject_GET_WEAKREFS_LISTPTR()`` macro to avoid the distinction."
msgstr ""
"Detalhe interno: Para os tipos incorporados estáticos, isto é sempre "
"``NULL``, mesmo que sejam adicionadas weakrefs. Em vez disso, as weakrefs "
"para cada um são armazenadas em ``PyInterpreterState``. Use a API C pública "
"ou a macro interna ``_PyObject_GET_WEAKREFS_LISTPTR()`` para evitar a "
"distinção."

#: ../../c-api/typeobj.rst:2282
msgid ""
"This field is deprecated.  Use :c:member:`~PyTypeObject.tp_finalize` instead."
msgstr ""
"Este campo está obsoleto. Use :c:member:`~PyTypeObject.tp_finalize` em vez "
"disso."

#: ../../c-api/typeobj.rst:2287
msgid "Used to index into the method cache.  Internal use only."
msgstr "Usado para indexar a cache de métodos. Apenas para uso interno."

#: ../../c-api/typeobj.rst:2296
msgid ""
"An optional pointer to an instance finalization function.  This is the C "
"implementation of the :meth:`~object.__del__` special method.  Its signature "
"is::"
msgstr ""
"Um ponteiro opcional para uma função de finalização de instância. Esta é a "
"implementação em C do método especial :meth:`~object.__del__`. A sua "
"assinatura é::"

#: ../../c-api/typeobj.rst:2300
msgid "void tp_finalize(PyObject *self);"
msgstr "void tp_finalize(PyObject *self);"

#: ../../c-api/typeobj.rst:2302
msgid ""
"The primary purpose of finalization is to perform any non-trivial cleanup "
"that must be performed before the object is destroyed, while the object and "
"any other objects it directly or indirectly references are still in a "
"consistent state.  The finalizer is allowed to execute arbitrary Python code."
msgstr ""
"O objetivo principal da finalização é realizar qualquer limpeza não trivial "
"que deva ser efetuada antes de o objeto ser destruído, enquanto o objeto e "
"quaisquer outros objetos que referencia direta ou indiretamente ainda estão "
"num estado consistente. O finalizador pode executar código Python arbitrário."

#: ../../c-api/typeobj.rst:2308
msgid ""
"Before Python automatically finalizes an object, some of the object's direct "
"or indirect referents might have themselves been automatically finalized. "
"However, none of the referents will have been automatically cleared (:c:"
"member:`~PyTypeObject.tp_clear`) yet."
msgstr ""
"Antes de o Python finalizar automaticamente um objeto, alguns dos referentes "
"diretos ou indiretos do objeto podem já ter sido finalizados "
"automaticamente. No entanto, nenhum dos referentes terá sido limpo "
"automaticamente (:c:member:`~PyTypeObject.tp_clear`)."

#: ../../c-api/typeobj.rst:2313
msgid ""
"Other non-finalized objects might still be using a finalized object, so the "
"finalizer must leave the object in a sane state (e.g., invariants are still "
"met)."
msgstr ""
"Outros objetos não finalizados podem ainda estar a usar um objeto "
"finalizado, por isso o finalizador deve deixar o objeto num estado são (por "
"exemplo, os invariantes ainda são cumpridos)."

#: ../../c-api/typeobj.rst:2319
msgid ""
"After Python automatically finalizes an object, Python might start "
"automatically clearing (:c:member:`~PyTypeObject.tp_clear`) the object and "
"its referents (direct and indirect).  Cleared objects are not guaranteed to "
"be in a consistent state; a finalized object must be able to tolerate "
"cleared referents."
msgstr ""
"Depois de o Python finalizar automaticamente um objeto, o Python pode "
"começar a limpar automaticamente (:c:member:`~PyTypeObject.tp_clear`) o "
"objeto e os seus referentes (diretos e indiretos). Objetos limpos não têm "
"garantia de estar num estado consistente; um objeto finalizado deve ser "
"capaz de tolerar referentes limpos."

#: ../../c-api/typeobj.rst:2327
msgid ""
"An object is not guaranteed to be automatically finalized before its "
"destructor (:c:member:`~PyTypeObject.tp_dealloc`) is called.  It is "
"recommended to call :c:func:`PyObject_CallFinalizerFromDealloc` at the "
"beginning of :c:member:`!tp_dealloc` to guarantee that the object is always "
"finalized before destruction."
msgstr ""
"Não é garantido que um objeto seja finalizado automaticamente antes de o seu "
"destrutor (:c:member:`~PyTypeObject.tp_dealloc`) ser chamado. É recomendado "
"chamar :c:func:`PyObject_CallFinalizerFromDealloc` no início de :c:member:`!"
"tp_dealloc` para garantir que o objeto é sempre finalizado antes da "
"destruição."

#: ../../c-api/typeobj.rst:2335
msgid ""
"The :c:member:`~PyTypeObject.tp_finalize` function can be called from any "
"thread, although the :term:`GIL` will be held."
msgstr ""
"A função :c:member:`~PyTypeObject.tp_finalize` pode ser chamada a partir de "
"qualquer thread, embora o :term:`GIL` seja mantido."

#: ../../c-api/typeobj.rst:2340
msgid ""
"The :c:member:`!tp_finalize` function can be called during shutdown, after "
"some global variables have been deleted.  See the documentation of the :meth:"
"`~object.__del__` method for details."
msgstr ""
"A função :c:member:`!tp_finalize` pode ser chamada durante o encerramento, "
"depois de algumas variáveis globais terem sido eliminadas. Ver a "
"documentação do método :meth:`~object.__del__` para detalhes."

#: ../../c-api/typeobj.rst:2344
msgid ""
"When Python finalizes an object, it behaves like the following algorithm:"
msgstr ""
"Quando o Python finaliza um objeto, comporta-se como o seguinte algoritmo:"

#: ../../c-api/typeobj.rst:2346
msgid ""
"Python might mark the object as *finalized*.  Currently, Python always marks "
"objects whose type supports garbage collection (i.e., the :c:macro:"
"`Py_TPFLAGS_HAVE_GC` flag is set in :c:member:`~PyTypeObject.tp_flags`) and "
"never marks other types of objects; this might change in a future version."
msgstr ""
"O Python pode marcar o objeto como *finalizado*. Atualmente, o Python marca "
"sempre objetos cujo tipo suporta recolha de lixo (ou seja, a flag :c:macro:"
"`Py_TPFLAGS_HAVE_GC` está definida em :c:member:`~PyTypeObject.tp_flags`) e "
"nunca marca outros tipos de objetos; isto pode mudar numa versão futura."

#: ../../c-api/typeobj.rst:2351
msgid ""
"If the object is not marked as *finalized* and its :c:member:`!tp_finalize` "
"finalizer function is non-``NULL``, the finalizer function is called."
msgstr ""
"Se o objeto não estiver marcado como *finalizado* e a sua função "
"finalizadora :c:member:`!tp_finalize` não for ``NULL``, a função "
"finalizadora é chamada."

#: ../../c-api/typeobj.rst:2354
msgid ""
"If the finalizer function was called and the finalizer made the object "
"reachable (i.e., there is a reference to the object and it is not a member "
"of a :term:`cyclic isolate`), then the finalizer is said to have "
"*resurrected* the object.  It is unspecified whether the finalizer can also "
"resurrect the object by adding a new reference to the object that does not "
"make it reachable, i.e., the object is (still) a member of a cyclic isolate."
msgstr ""
"Se a função finalizadora foi chamada e o finalizador tornou o objeto "
"acessível (ou seja, há uma referência ao objeto e ele não é membro de um :"
"term:`isolado cíclico`), então diz-se que o finalizador *ressuscitou* o "
"objeto. Não está especificado se o finalizador também pode ressuscitar o "
"objeto adicionando uma nova referência ao objeto que não o torna acessível, "
"ou seja, o objeto é (ainda) um membro de um isolado cíclico."

#: ../../c-api/typeobj.rst:2361
msgid ""
"If the finalizer resurrected the object, the object's pending destruction is "
"canceled and the object's *finalized* mark might be removed if present.  "
"Currently, Python never removes the *finalized* mark; this might change in a "
"future version."
msgstr ""
"Se o finalizador ressuscitou o objeto, a destruição pendente do objeto é "
"cancelada e a marca *finalizado* do objeto pode ser removida, se presente. "
"Atualmente, o Python nunca remove a marca *finalizado*; isto pode mudar numa "
"versão futura."

#: ../../c-api/typeobj.rst:2366
msgid ""
"*Automatic finalization* refers to any finalization performed by Python "
"except via calls to :c:func:`PyObject_CallFinalizer` or :c:func:"
"`PyObject_CallFinalizerFromDealloc`.  No guarantees are made about when, if, "
"or how often an object is automatically finalized, except:"
msgstr ""
"*Finalização automática* refere-se a qualquer finalização realizada pelo "
"Python, exceto através de chamadas a :c:func:`PyObject_CallFinalizer` ou :c:"
"func:`PyObject_CallFinalizerFromDealloc`. Não são feitas garantias sobre "
"quando, se, ou com que frequência um objeto é finalizado automaticamente, "
"exceto:"

#: ../../c-api/typeobj.rst:2371
msgid ""
"Python will not automatically finalize an object if it is reachable, i.e., "
"there is a reference to it and it is not a member of a :term:`cyclic "
"isolate`."
msgstr ""
"O Python não finalizará automaticamente um objeto se este for acessível, ou "
"seja, se houver uma referência a ele e não for membro de um :term:`isolado "
"cíclico`."

#: ../../c-api/typeobj.rst:2374
msgid ""
"Python will not automatically finalize an object if finalizing it would not "
"mark the object as *finalized*.  Currently, this applies to objects whose "
"type does not support garbage collection, i.e., the :c:macro:"
"`Py_TPFLAGS_HAVE_GC` flag is not set.  Such objects can still be manually "
"finalized by calling :c:func:`PyObject_CallFinalizer` or :c:func:"
"`PyObject_CallFinalizerFromDealloc`."
msgstr ""
"O Python não finalizará automaticamente um objeto se a sua finalização não o "
"marcasse como *finalizado*. Atualmente, isto aplica-se a objetos cujo tipo "
"não suporta recolha de lixo, ou seja, a flag :c:macro:`Py_TPFLAGS_HAVE_GC` "
"não está definida. Tais objetos ainda podem ser finalizados manualmente "
"chamando :c:func:`PyObject_CallFinalizer` ou :c:func:"
"`PyObject_CallFinalizerFromDealloc`."

#: ../../c-api/typeobj.rst:2380
msgid ""
"Python will not automatically finalize any two members of a :term:`cyclic "
"isolate` concurrently."
msgstr ""
"O Python não finalizará automaticamente quaisquer dois membros de um :term:"
"`isolado cíclico` em simultâneo."

#: ../../c-api/typeobj.rst:2382
msgid ""
"Python will not automatically finalize an object after it has automatically "
"cleared (:c:member:`~PyTypeObject.tp_clear`) the object."
msgstr ""
"O Python não finalizará automaticamente um objeto depois de ter limpo "
"automaticamente (:c:member:`~PyTypeObject.tp_clear`) o objeto."

#: ../../c-api/typeobj.rst:2384
msgid ""
"If an object is a member of a :term:`cyclic isolate`, Python will not "
"automatically finalize it after automatically clearing (see :c:member:"
"`~PyTypeObject.tp_clear`) any other member."
msgstr ""
"Se um objeto for membro de um :term:`isolado cíclico`, o Python não o "
"finalizará automaticamente depois de limpar automaticamente (ver :c:member:"
"`~PyTypeObject.tp_clear`) qualquer outro membro."

#: ../../c-api/typeobj.rst:2387
msgid ""
"Python will automatically finalize every member of a :term:`cyclic isolate` "
"before it automatically clears (see :c:member:`~PyTypeObject.tp_clear`) any "
"of them."
msgstr ""
"O Python finalizará automaticamente todos os membros de um :term:`isolado "
"cíclico` antes de os limpar automaticamente (ver :c:member:`~PyTypeObject."
"tp_clear`)."

#: ../../c-api/typeobj.rst:2390
msgid ""
"If Python is going to automatically clear an object (:c:member:"
"`~PyTypeObject.tp_clear`), it will automatically finalize the object first."
msgstr ""
"Se o Python for limpar automaticamente um objeto (:c:member:`~PyTypeObject."
"tp_clear`), finalizará automaticamente o objeto primeiro."

#: ../../c-api/typeobj.rst:2394
msgid ""
"Python currently only automatically finalizes objects that are members of a :"
"term:`cyclic isolate`, but future versions might finalize objects regularly "
"before their destruction."
msgstr ""
"Atualmente, o Python finaliza automaticamente apenas objetos que são membros "
"de um :term:`isolado cíclico`, mas versões futuras podem finalizar objetos "
"regularmente antes da sua destruição."

#: ../../c-api/typeobj.rst:2398
msgid ""
"To manually finalize an object, do not call this function directly; call :c:"
"func:`PyObject_CallFinalizer` or :c:func:`PyObject_CallFinalizerFromDealloc` "
"instead."
msgstr ""
"Para finalizar manualmente um objeto, não chame esta função diretamente; "
"chame :c:func:`PyObject_CallFinalizer` ou :c:func:"
"`PyObject_CallFinalizerFromDealloc` em vez disso."

#: ../../c-api/typeobj.rst:2402
msgid ""
":c:member:`~PyTypeObject.tp_finalize` should leave the current exception "
"status unchanged.  The recommended way to write a non-trivial finalizer is "
"to back up the exception at the beginning by calling :c:func:"
"`PyErr_GetRaisedException` and restore the exception at the end by calling :"
"c:func:`PyErr_SetRaisedException`.  If an exception is encountered in the "
"middle of the finalizer, log and clear it with :c:func:"
"`PyErr_WriteUnraisable` or :c:func:`PyErr_FormatUnraisable`.  For example::"
msgstr ""
":c:member:`~PyTypeObject.tp_finalize` deve deixar o estado atual da exceção "
"inalterado. A forma recomendada de escrever um finalizador não trivial é "
"guardar a exceção no início chamando :c:func:`PyErr_GetRaisedException` e "
"restaurar a exceção no final chamando :c:func:`PyErr_SetRaisedException`. Se "
"uma exceção for encontrada no meio do finalizador, registe-a e limpe-a com :"
"c:func:`PyErr_WriteUnraisable` ou :c:func:`PyErr_FormatUnraisable`. Por "
"exemplo::"

#: ../../c-api/typeobj.rst:2411
msgid ""
"static void\n"
"foo_finalize(PyObject *self)\n"
"{\n"
"    // Save the current exception, if any.\n"
"    PyObject *exc = PyErr_GetRaisedException();\n"
"\n"
"    // ...\n"
"\n"
"    if (do_something_that_might_raise() != success_indicator) {\n"
"        PyErr_WriteUnraisable(self);\n"
"        goto done;\n"
"    }\n"
"\n"
"done:\n"
"    // Restore the saved exception.  This silently discards any exception\n"
"    // raised above, so be sure to call PyErr_WriteUnraisable first if\n"
"    // necessary.\n"
"    PyErr_SetRaisedException(exc);\n"
"}"
msgstr ""
"static void\n"
"foo_finalize(PyObject *self)\n"
"{\n"
"    // Guarda a exceção atual, se houver.\n"
"    PyObject *exc = PyErr_GetRaisedException();\n"
"\n"
"    // ...\n"
"\n"
"    if (do_something_that_might_raise() != success_indicator) {\n"
"        PyErr_WriteUnraisable(self);\n"
"        goto done;\n"
"    }\n"
"\n"
"done:\n"
"    // Restaura a exceção guardada. Isto descarta silenciosamente qualquer "
"exceção\n"
"    // levantada acima, por isso certifique-se de chamar "
"PyErr_WriteUnraisable primeiro se\n"
"    // necessário.\n"
"    PyErr_SetRaisedException(exc);\n"
"}"

#: ../../c-api/typeobj.rst:2439
msgid ""
"Before version 3.8 it was necessary to set the :c:macro:"
"`Py_TPFLAGS_HAVE_FINALIZE` flags bit in order for this field to be used.  "
"This is no longer required."
msgstr ""
"Antes da versão 3.8, era necessário definir o bit de flag :c:macro:"
"`Py_TPFLAGS_HAVE_FINALIZE` para que este campo fosse usado. Isto já não é "
"necessário."

#: ../../c-api/typeobj.rst:2445
msgid ":pep:`442`: \"Safe object finalization\""
msgstr ":pep:`442`: \"Finalização segura de objetos\""

#: ../../c-api/typeobj.rst:2448
msgid ":c:func:`PyObject_CallFinalizer`"
msgstr ":c:func:`PyObject_CallFinalizer`"

#: ../../c-api/typeobj.rst:2449
msgid ":c:func:`PyObject_CallFinalizerFromDealloc`"
msgstr ":c:func:`PyObject_CallFinalizerFromDealloc`"

#: ../../c-api/typeobj.rst:2454
msgid ""
"A :ref:`vectorcall function <vectorcall>` to use for calls of this type "
"object (rather than instances). In other words, ``tp_vectorcall`` can be "
"used to optimize ``type.__call__``, which typically returns a new instance "
"of *type*."
msgstr ""
"Uma :ref:`função vectorcall <vectorcall>` a usar para chamadas deste objeto "
"de tipo (em vez de instâncias). Em outras palavras, ``tp_vectorcall`` pode "
"ser usado para otimizar ``type.__call__``, que tipicamente retorna uma nova "
"instância de *type*."

#: ../../c-api/typeobj.rst:2459
msgid ""
"As with any vectorcall function, if ``tp_vectorcall`` is ``NULL``, the "
"*tp_call* protocol (``Py_TYPE(type)->tp_call``) is used instead."
msgstr ""
"Como com qualquer função vectorcall, se ``tp_vectorcall`` for ``NULL``, o "
"protocolo *tp_call* (``Py_TYPE(type)->tp_call``) é usado em vez disso."

#: ../../c-api/typeobj.rst:2464
msgid ""
"The :ref:`vectorcall protocol <vectorcall>` requires that the vectorcall "
"function has the same behavior as the corresponding ``tp_call``. This means "
"that ``type->tp_vectorcall`` must match the behavior of ``Py_TYPE(type)-"
">tp_call``."
msgstr ""
"O :ref:`protocolo vectorcall <vectorcall>` requer que a função vectorcall "
"tenha o mesmo comportamento que o ``tp_call`` correspondente. Isto significa "
"que ``type->tp_vectorcall`` deve corresponder ao comportamento de "
"``Py_TYPE(type)->tp_call``."

#: ../../c-api/typeobj.rst:2469
msgid ""
"Specifically, if *type* uses the default metaclass, ``type->tp_vectorcall`` "
"must behave the same as :c:expr:`PyType_Type->tp_call`, which:"
msgstr ""
"Especificamente, se *type* usar a metaclasse predefinida, ``type-"
">tp_vectorcall`` deve comportar-se da mesma forma que :c:expr:`PyType_Type-"
">tp_call`, que:"

#: ../../c-api/typeobj.rst:2473
msgid "calls ``type->tp_new``,"
msgstr "chama ``type->tp_new``,"

#: ../../c-api/typeobj.rst:2475
msgid ""
"if the result is a subclass of *type*, calls ``type->tp_init`` on the result "
"of ``tp_new``, and"
msgstr ""
"se o resultado for uma subclasse de *type*, chama ``type->tp_init`` no "
"resultado de ``tp_new``, e"

#: ../../c-api/typeobj.rst:2478
msgid "returns the result of ``tp_new``."
msgstr "retorna o resultado de ``tp_new``."

#: ../../c-api/typeobj.rst:2480
msgid ""
"Typically, ``tp_vectorcall`` is overridden to optimize this process for "
"specific :c:member:`~PyTypeObject.tp_new` and :c:member:`~PyTypeObject."
"tp_init`. When doing this for user-subclassable types, note that both can be "
"overridden (using :py:func:`~object.__new__` and :py:func:`~object."
"__init__`, respectively)."
msgstr ""
"Tipicamente, ``tp_vectorcall`` é substituído para otimizar este processo "
"para :c:member:`~PyTypeObject.tp_new` e :c:member:`~PyTypeObject.tp_init` "
"específicos. Ao fazer isto para tipos que podem ser subtipados pelo "
"utilizador, note que ambos podem ser substituídos (usando :py:func:`~object."
"__new__` e :py:func:`~object.__init__`, respetivamente)."

#: ../../c-api/typeobj.rst:2491
msgid "This field is never inherited."
msgstr "Este campo nunca é herdado."

#: ../../c-api/typeobj.rst:2493
msgid "(the field exists since 3.8 but it's only used since 3.9)"
msgstr "(o campo existe desde a versão 3.8, mas só é usado desde a 3.9)"

#: ../../c-api/typeobj.rst:2498
msgid "Internal. Do not use."
msgstr "Interno. Não usar."

#: ../../c-api/typeobj.rst:2506
msgid "Static Types"
msgstr "Tipos Estáticos"

#: ../../c-api/typeobj.rst:2508
msgid ""
"Traditionally, types defined in C code are *static*, that is, a static :c:"
"type:`PyTypeObject` structure is defined directly in code and initialized "
"using :c:func:`PyType_Ready`."
msgstr ""
"Tradicionalmente, os tipos definidos em código C são *estáticos*, ou seja, "
"uma estrutura :c:type:`PyTypeObject` estática é definida diretamente no "
"código e inicializada usando :c:func:`PyType_Ready`."

#: ../../c-api/typeobj.rst:2512
msgid ""
"This results in types that are limited relative to types defined in Python:"
msgstr ""
"Isto resulta em tipos que são limitados em relação aos tipos definidos em "
"Python:"

#: ../../c-api/typeobj.rst:2514
msgid ""
"Static types are limited to one base, i.e. they cannot use multiple "
"inheritance."
msgstr ""
"Os tipos estáticos estão limitados a uma base, ou seja, não podem usar "
"herança múltipla."

#: ../../c-api/typeobj.rst:2516
msgid ""
"Static type objects (but not necessarily their instances) are immutable. It "
"is not possible to add or modify the type object's attributes from Python."
msgstr ""
"Os objetos de tipo estático (mas não necessariamente as suas instâncias) são "
"imutáveis. Não é possível adicionar ou modificar os atributos do objeto de "
"tipo a partir do Python."

#: ../../c-api/typeobj.rst:2518
msgid ""
"Static type objects are shared across :ref:`sub-interpreters <sub-"
"interpreter-support>`, so they should not include any subinterpreter-"
"specific state."
msgstr ""
"Os objetos de tipo estático são partilhados entre :ref:`sub-interpretadores "
"<sub-interpreter-support>`, pelo que não devem incluir qualquer estado "
"específico de sub-interpretador."

#: ../../c-api/typeobj.rst:2522
msgid ""
"Also, since :c:type:`PyTypeObject` is only part of the :ref:`Limited API "
"<limited-c-api>` as an opaque struct, any extension modules using static "
"types must be compiled for a specific Python minor version."
msgstr ""
"Além disso, uma vez que :c:type:`PyTypeObject` faz parte apenas da :ref:`API "
"Limitada <limited-c-api>` como uma struct opaca, quaisquer módulos de "
"extensão que usem tipos estáticos devem ser compilados para uma versão menor "
"específica do Python."

#: ../../c-api/typeobj.rst:2530
msgid "Heap Types"
msgstr "Tipos de Heap"

#: ../../c-api/typeobj.rst:2532
msgid ""
"An alternative to :ref:`static types <static-types>` is *heap-allocated "
"types*, or *heap types* for short, which correspond closely to classes "
"created by Python's ``class`` statement. Heap types have the :c:macro:"
"`Py_TPFLAGS_HEAPTYPE` flag set."
msgstr ""
"Uma alternativa aos :ref:`tipos estáticos <static-types>` são os *tipos "
"alocados em heap*, ou *tipos de heap* para abreviar, que correspondem de "
"perto às classes criadas pela instrução ``class`` do Python. Os tipos de "
"heap têm a flag :c:macro:`Py_TPFLAGS_HEAPTYPE` definida."

#: ../../c-api/typeobj.rst:2537
msgid ""
"This is done by filling a :c:type:`PyType_Spec` structure and calling :c:"
"func:`PyType_FromSpec`, :c:func:`PyType_FromSpecWithBases`, :c:func:"
"`PyType_FromModuleAndSpec`, or :c:func:`PyType_FromMetaclass`."
msgstr ""
"Isto é feito preenchendo uma estrutura :c:type:`PyType_Spec` e chamando :c:"
"func:`PyType_FromSpec`, :c:func:`PyType_FromSpecWithBases`, :c:func:"
"`PyType_FromModuleAndSpec`, ou :c:func:`PyType_FromMetaclass`."

#: ../../c-api/typeobj.rst:2545
msgid "Number Object Structures"
msgstr "Estruturas de Objetos Numéricos"

#: ../../c-api/typeobj.rst:2552
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the number protocol.  Each function is used by the function of "
"similar name documented in the :ref:`number` section."
msgstr ""
"Esta estrutura contém ponteiros para as funções que um objeto usa para "
"implementar o protocolo numérico. Cada função é usada pela função de nome "
"semelhante documentada na secção :ref:`number`."

#: ../../c-api/typeobj.rst:2558 ../../c-api/typeobj.rst:2882
msgid "Here is the structure definition::"
msgstr "Aqui está a definição da estrutura::"

#: ../../c-api/typeobj.rst:2560
msgid ""
"typedef struct {\n"
"     binaryfunc nb_add;\n"
"     binaryfunc nb_subtract;\n"
"     binaryfunc nb_multiply;\n"
"     binaryfunc nb_remainder;\n"
"     binaryfunc nb_divmod;\n"
"     ternaryfunc nb_power;\n"
"     unaryfunc nb_negative;\n"
"     unaryfunc nb_positive;\n"
"     unaryfunc nb_absolute;\n"
"     inquiry nb_bool;\n"
"     unaryfunc nb_invert;\n"
"     binaryfunc nb_lshift;\n"
"     binaryfunc nb_rshift;\n"
"     binaryfunc nb_and;\n"
"     binaryfunc nb_xor;\n"
"     binaryfunc nb_or;\n"
"     unaryfunc nb_int;\n"
"     void *nb_reserved;\n"
"     unaryfunc nb_float;\n"
"\n"
"     binaryfunc nb_inplace_add;\n"
"     binaryfunc nb_inplace_subtract;\n"
"     binaryfunc nb_inplace_multiply;\n"
"     binaryfunc nb_inplace_remainder;\n"
"     ternaryfunc nb_inplace_power;\n"
"     binaryfunc nb_inplace_lshift;\n"
"     binaryfunc nb_inplace_rshift;\n"
"     binaryfunc nb_inplace_and;\n"
"     binaryfunc nb_inplace_xor;\n"
"     binaryfunc nb_inplace_or;\n"
"\n"
"     binaryfunc nb_floor_divide;\n"
"     binaryfunc nb_true_divide;\n"
"     binaryfunc nb_inplace_floor_divide;\n"
"     binaryfunc nb_inplace_true_divide;\n"
"\n"
"     unaryfunc nb_index;\n"
"\n"
"     binaryfunc nb_matrix_multiply;\n"
"     binaryfunc nb_inplace_matrix_multiply;\n"
"} PyNumberMethods;"
msgstr ""
"typedef struct {\n"
"     binaryfunc nb_add;\n"
"     binaryfunc nb_subtract;\n"
"     binaryfunc nb_multiply;\n"
"     binaryfunc nb_remainder;\n"
"     binaryfunc nb_divmod;\n"
"     ternaryfunc nb_power;\n"
"     unaryfunc nb_negative;\n"
"     unaryfunc nb_positive;\n"
"     unaryfunc nb_absolute;\n"
"     inquiry nb_bool;\n"
"     unaryfunc nb_invert;\n"
"     binaryfunc nb_lshift;\n"
"     binaryfunc nb_rshift;\n"
"     binaryfunc nb_and;\n"
"     binaryfunc nb_xor;\n"
"     binaryfunc nb_or;\n"
"     unaryfunc nb_int;\n"
"     void *nb_reserved;\n"
"     unaryfunc nb_float;\n"
"\n"
"     binaryfunc nb_inplace_add;\n"
"     binaryfunc nb_inplace_subtract;\n"
"     binaryfunc nb_inplace_multiply;\n"
"     binaryfunc nb_inplace_remainder;\n"
"     ternaryfunc nb_inplace_power;\n"
"     binaryfunc nb_inplace_lshift;\n"
"     binaryfunc nb_inplace_rshift;\n"
"     binaryfunc nb_inplace_and;\n"
"     binaryfunc nb_inplace_xor;\n"
"     binaryfunc nb_inplace_or;\n"
"\n"
"     binaryfunc nb_floor_divide;\n"
"     binaryfunc nb_true_divide;\n"
"     binaryfunc nb_inplace_floor_divide;\n"
"     binaryfunc nb_inplace_true_divide;\n"
"\n"
"     unaryfunc nb_index;\n"
"\n"
"     binaryfunc nb_matrix_multiply;\n"
"     binaryfunc nb_inplace_matrix_multiply;\n"
"} PyNumberMethods;"

#: ../../c-api/typeobj.rst:2605
msgid ""
"Binary and ternary functions must check the type of all their operands, and "
"implement the necessary conversions (at least one of the operands is an "
"instance of the defined type).  If the operation is not defined for the "
"given operands, binary and ternary functions must return "
"``Py_NotImplemented``, if another error occurred they must return ``NULL`` "
"and set an exception."
msgstr ""
"As funções binárias e ternárias devem verificar o tipo de todos os seus "
"operandos e implementar as conversões necessárias (pelo menos um dos "
"operandos é uma instância do tipo definido). Se a operação não estiver "
"definida para os operandos dados, as funções binárias e ternárias devem "
"retornar ``Py_NotImplemented``; se ocorrer outro erro, devem retornar "
"``NULL`` e definir uma exceção."

#: ../../c-api/typeobj.rst:2614
msgid ""
"The :c:member:`~PyNumberMethods.nb_reserved` field should always be "
"``NULL``.  It was previously called :c:member:`!nb_long`, and was renamed in "
"Python 3.0.1."
msgstr ""
"O campo :c:member:`~PyNumberMethods.nb_reserved` deve ser sempre ``NULL``. "
"Anteriormente chamava-se :c:member:`!nb_long`, e foi renomeado na versão "
"3.0.1 do Python."

#: ../../c-api/typeobj.rst:2659
msgid "Mapping Object Structures"
msgstr "Estruturas de Objetos de Mapeamento"

#: ../../c-api/typeobj.rst:2666
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the mapping protocol.  It has three members:"
msgstr ""
"Esta estrutura contém ponteiros para as funções que um objeto usa para "
"implementar o protocolo de mapeamento. Tem três membros:"

#: ../../c-api/typeobj.rst:2671
msgid ""
"This function is used by :c:func:`PyMapping_Size` and :c:func:"
"`PyObject_Size`, and has the same signature.  This slot may be set to "
"``NULL`` if the object has no defined length."
msgstr ""
"Esta função é usada por :c:func:`PyMapping_Size` e :c:func:`PyObject_Size`, "
"e tem a mesma assinatura. Este slot pode ser definido como ``NULL`` se o "
"objeto não tiver um comprimento definido."

#: ../../c-api/typeobj.rst:2677
msgid ""
"This function is used by :c:func:`PyObject_GetItem` and :c:func:"
"`PySequence_GetSlice`, and has the same signature as :c:func:`!"
"PyObject_GetItem`.  This slot must be filled for the :c:func:"
"`PyMapping_Check` function to return ``1``, it can be ``NULL`` otherwise."
msgstr ""
"Esta função é usada por :c:func:`PyObject_GetItem` e :c:func:"
"`PySequence_GetSlice`, e tem a mesma assinatura que :c:func:`!"
"PyObject_GetItem`. Este slot deve ser preenchido para que a função :c:func:"
"`PyMapping_Check` retorne ``1``; caso contrário, pode ser ``NULL``."

#: ../../c-api/typeobj.rst:2685
msgid ""
"This function is used by :c:func:`PyObject_SetItem`, :c:func:"
"`PyObject_DelItem`, :c:func:`PySequence_SetSlice` and :c:func:"
"`PySequence_DelSlice`.  It has the same signature as :c:func:`!"
"PyObject_SetItem`, but *v* can also be set to ``NULL`` to delete an item.  "
"If this slot is ``NULL``, the object does not support item assignment and "
"deletion."
msgstr ""
"Esta função é usada por :c:func:`PyObject_SetItem`, :c:func:"
"`PyObject_DelItem`, :c:func:`PySequence_SetSlice` e :c:func:"
"`PySequence_DelSlice`. Tem a mesma assinatura que :c:func:`!"
"PyObject_SetItem`, mas *v* também pode ser definido como ``NULL`` para "
"eliminar um item. Se este slot for ``NULL``, o objeto não suporta atribuição "
"e eliminação de itens."

#: ../../c-api/typeobj.rst:2696
msgid "Sequence Object Structures"
msgstr "Estruturas de Objetos de Sequência"

#: ../../c-api/typeobj.rst:2703
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the sequence protocol."
msgstr ""
"Esta estrutura contém ponteiros para as funções que um objeto usa para "
"implementar o protocolo de sequência."

#: ../../c-api/typeobj.rst:2708
msgid ""
"This function is used by :c:func:`PySequence_Size` and :c:func:"
"`PyObject_Size`, and has the same signature.  It is also used for handling "
"negative indices via the :c:member:`~PySequenceMethods.sq_item` and the :c:"
"member:`~PySequenceMethods.sq_ass_item` slots."
msgstr ""
"Esta função é usada por :c:func:`PySequence_Size` e :c:func:`PyObject_Size`, "
"e tem a mesma assinatura. Também é usada para lidar com índices negativos "
"através dos slots :c:member:`~PySequenceMethods.sq_item` e :c:member:"
"`~PySequenceMethods.sq_ass_item`."

#: ../../c-api/typeobj.rst:2715
msgid ""
"This function is used by :c:func:`PySequence_Concat` and has the same "
"signature.  It is also used by the ``+`` operator, after trying the numeric "
"addition via the :c:member:`~PyNumberMethods.nb_add` slot."
msgstr ""
"Esta função é usada por :c:func:`PySequence_Concat` e tem a mesma "
"assinatura. Também é usada pelo operador ``+``, depois de tentar a adição "
"numérica através do slot :c:member:`~PyNumberMethods.nb_add`."

#: ../../c-api/typeobj.rst:2721
msgid ""
"This function is used by :c:func:`PySequence_Repeat` and has the same "
"signature.  It is also used by the ``*`` operator, after trying numeric "
"multiplication via the :c:member:`~PyNumberMethods.nb_multiply` slot."
msgstr ""
"Esta função é usada por :c:func:`PySequence_Repeat` e tem a mesma "
"assinatura. Também é usada pelo operador ``*``, depois de tentar a "
"multiplicação numérica através do slot :c:member:`~PyNumberMethods."
"nb_multiply`."

#: ../../c-api/typeobj.rst:2727
msgid ""
"This function is used by :c:func:`PySequence_GetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_GetItem`, after trying the "
"subscription via the :c:member:`~PyMappingMethods.mp_subscript` slot. This "
"slot must be filled for the :c:func:`PySequence_Check` function to return "
"``1``, it can be ``NULL`` otherwise."
msgstr ""
"Esta função é usada por :c:func:`PySequence_GetItem` e tem a mesma "
"assinatura. Também é usada por :c:func:`PyObject_GetItem`, depois de tentar "
"a subscrição através do slot :c:member:`~PyMappingMethods.mp_subscript`. "
"Este slot deve ser preenchido para que a função :c:func:`PySequence_Check` "
"retorne ``1``; caso contrário, pode ser ``NULL``."

#: ../../c-api/typeobj.rst:2733
msgid ""
"Negative indexes are handled as follows: if the :c:member:"
"`~PySequenceMethods.sq_length` slot is filled, it is called and the sequence "
"length is used to compute a positive index which is passed to  :c:member:"
"`~PySequenceMethods.sq_item`.  If :c:member:`!sq_length` is ``NULL``, the "
"index is passed as is to the function."
msgstr ""
"Os índices negativos são tratados da seguinte forma: se o slot :c:member:"
"`~PySequenceMethods.sq_length` estiver preenchido, é chamado e o comprimento "
"da sequência é usado para calcular um índice positivo que é passado para :c:"
"member:`~PySequenceMethods.sq_item`. Se :c:member:`!sq_length` for ``NULL``, "
"o índice é passado como está para a função."

#: ../../c-api/typeobj.rst:2740
msgid ""
"This function is used by :c:func:`PySequence_SetItem` and has the same "
"signature.  It is also used by :c:func:`PyObject_SetItem` and :c:func:"
"`PyObject_DelItem`, after trying the item assignment and deletion via the :c:"
"member:`~PyMappingMethods.mp_ass_subscript` slot. This slot may be left to "
"``NULL`` if the object does not support item assignment and deletion."
msgstr ""
"Esta função é usada por :c:func:`PySequence_SetItem` e tem a mesma "
"assinatura. Também é usada por :c:func:`PyObject_SetItem` e :c:func:"
"`PyObject_DelItem`, depois de tentar a atribuição e eliminação de itens "
"através do slot :c:member:`~PyMappingMethods.mp_ass_subscript`. Este slot "
"pode ser deixado como ``NULL`` se o objeto não suportar atribuição e "
"eliminação de itens."

#: ../../c-api/typeobj.rst:2749
msgid ""
"This function may be used by :c:func:`PySequence_Contains` and has the same "
"signature.  This slot may be left to ``NULL``, in this case :c:func:`!"
"PySequence_Contains` simply traverses the sequence until it finds a match."
msgstr ""
"Esta função pode ser usada por :c:func:`PySequence_Contains` e tem a mesma "
"assinatura. Este slot pode ser deixado como ``NULL``; neste caso, :c:func:`!"
"PySequence_Contains` percorre simplesmente a sequência até encontrar uma "
"correspondência."

#: ../../c-api/typeobj.rst:2756
msgid ""
"This function is used by :c:func:`PySequence_InPlaceConcat` and has the same "
"signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceConcat` "
"will fall back to :c:func:`PySequence_Concat`.  It is also used by the "
"augmented assignment ``+=``, after trying numeric in-place addition via the :"
"c:member:`~PyNumberMethods.nb_inplace_add` slot."
msgstr ""
"Esta função é usada por :c:func:`PySequence_InPlaceConcat` e tem a mesma "
"assinatura. Deve modificar o seu primeiro operando e retorná-lo. Este slot "
"pode ser deixado como ``NULL``; neste caso, :c:func:`!"
"PySequence_InPlaceConcat` recuará para :c:func:`PySequence_Concat`. Também é "
"usada pela atribuição aumentada ``+=``, depois de tentar a adição numérica "
"no local através do slot :c:member:`~PyNumberMethods.nb_inplace_add`."

#: ../../c-api/typeobj.rst:2765
msgid ""
"This function is used by :c:func:`PySequence_InPlaceRepeat` and has the same "
"signature.  It should modify its first operand, and return it.  This slot "
"may be left to ``NULL``, in this case :c:func:`!PySequence_InPlaceRepeat` "
"will fall back to :c:func:`PySequence_Repeat`.  It is also used by the "
"augmented assignment ``*=``, after trying numeric in-place multiplication "
"via the :c:member:`~PyNumberMethods.nb_inplace_multiply` slot."
msgstr ""
"Esta função é usada por :c:func:`PySequence_InPlaceRepeat` e tem a mesma "
"assinatura. Deve modificar o seu primeiro operando e retorná-lo. Este slot "
"pode ser deixado como ``NULL``; neste caso, :c:func:`!"
"PySequence_InPlaceRepeat` recuará para :c:func:`PySequence_Repeat`. Também é "
"usada pela atribuição aumentada ``*=``, depois de tentar a multiplicação "
"numérica no local através do slot :c:member:`~PyNumberMethods."
"nb_inplace_multiply`."

#: ../../c-api/typeobj.rst:2776
msgid "Buffer Object Structures"
msgstr "Estruturas de Objetos de Buffer"

#: ../../c-api/typeobj.rst:2784
msgid ""
"This structure holds pointers to the functions required by the :ref:`Buffer "
"protocol <bufferobjects>`. The protocol defines how an exporter object can "
"expose its internal data to consumer objects."
msgstr ""
"Esta estrutura contém ponteiros para as funções necessárias pelo :ref:"
"`protocolo Buffer <bufferobjects>`. O protocolo define como um objeto "
"exportador pode expor os seus dados internos a objetos consumidores."

#: ../../c-api/typeobj.rst:2790 ../../c-api/typeobj.rst:2839
#: ../../c-api/typeobj.rst:2893 ../../c-api/typeobj.rst:2904
#: ../../c-api/typeobj.rst:2916 ../../c-api/typeobj.rst:2926
msgid "The signature of this function is::"
msgstr "A assinatura desta função é::"

#: ../../c-api/typeobj.rst:2792
msgid "int (PyObject *exporter, Py_buffer *view, int flags);"
msgstr "int (PyObject *exporter, Py_buffer *view, int flags);"

#: ../../c-api/typeobj.rst:2794
msgid ""
"Handle a request to *exporter* to fill in *view* as specified by *flags*. "
"Except for point (3), an implementation of this function MUST take these "
"steps:"
msgstr ""
"Tratar um pedido ao *exporter* para preencher *view* como especificado por "
"*flags*. Exceto pelo ponto (3), uma implementação desta função DEVE seguir "
"estes passos:"

#: ../../c-api/typeobj.rst:2798
msgid ""
"Check if the request can be met. If not, raise :exc:`BufferError`, set :c:"
"expr:`view->obj` to ``NULL`` and return ``-1``."
msgstr ""
"Verificar se o pedido pode ser satisfeito. Se não, levantar :exc:"
"`BufferError`, definir :c:expr:`view->obj` para ``NULL`` e retornar ``-1``."

#: ../../c-api/typeobj.rst:2801
msgid "Fill in the requested fields."
msgstr "Preencher os campos solicitados."

#: ../../c-api/typeobj.rst:2803
msgid "Increment an internal counter for the number of exports."
msgstr "Incrementar um contador interno para o número de exportações."

#: ../../c-api/typeobj.rst:2805
msgid ""
"Set :c:expr:`view->obj` to *exporter* and increment :c:expr:`view->obj`."
msgstr ""
"Definir :c:expr:`view->obj` para *exporter* e incrementar :c:expr:`view-"
">obj`."

#: ../../c-api/typeobj.rst:2807
msgid "Return ``0``."
msgstr "Retornar ``0``."

#: ../../c-api/typeobj.rst:2809
msgid ""
"If *exporter* is part of a chain or tree of buffer providers, two main "
"schemes can be used:"
msgstr ""
"Se *exporter* fizer parte de uma cadeia ou árvore de fornecedores de buffer, "
"dois esquemas principais podem ser usados:"

#: ../../c-api/typeobj.rst:2812
msgid ""
"Re-export: Each member of the tree acts as the exporting object and sets :c:"
"expr:`view->obj` to a new reference to itself."
msgstr ""
"Re-exportar: Cada membro da árvore age como o objeto exportador e define :c:"
"expr:`view->obj` para uma nova referência a si mesmo."

#: ../../c-api/typeobj.rst:2815
msgid ""
"Redirect: The buffer request is redirected to the root object of the tree. "
"Here, :c:expr:`view->obj` will be a new reference to the root object."
msgstr ""
"Redirecionar: O pedido de buffer é redirecionado para o objeto raiz da "
"árvore. Aqui, :c:expr:`view->obj` será uma nova referência ao objeto raiz."

#: ../../c-api/typeobj.rst:2819
msgid ""
"The individual fields of *view* are described in section :ref:`Buffer "
"structure <buffer-structure>`, the rules how an exporter must react to "
"specific requests are in section :ref:`Buffer request types <buffer-request-"
"types>`."
msgstr ""
"Os campos individuais de *view* são descritos na secção :ref:`Buffer "
"structure <buffer-structure>`, as regras de como um exportador deve reagir a "
"pedidos específicos estão na secção :ref:`Buffer request types <buffer-"
"request-types>`."

#: ../../c-api/typeobj.rst:2824
msgid ""
"All memory pointed to in the :c:type:`Py_buffer` structure belongs to the "
"exporter and must remain valid until there are no consumers left. :c:member:"
"`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, :c:member:`~Py_buffer."
"strides`, :c:member:`~Py_buffer.suboffsets` and :c:member:`~Py_buffer."
"internal` are read-only for the consumer."
msgstr ""
"Toda a memória apontada na estrutura :c:type:`Py_buffer` pertence ao "
"exportador e deve permanecer válida até não restarem consumidores. :c:member:"
"`~Py_buffer.format`, :c:member:`~Py_buffer.shape`, :c:member:`~Py_buffer."
"strides`, :c:member:`~Py_buffer.suboffsets` e :c:member:`~Py_buffer."
"internal` são apenas de leitura para o consumidor."

#: ../../c-api/typeobj.rst:2831
msgid ""
":c:func:`PyBuffer_FillInfo` provides an easy way of exposing a simple bytes "
"buffer while dealing correctly with all request types."
msgstr ""
":c:func:`PyBuffer_FillInfo` fornece uma forma fácil de expor um buffer de "
"bytes simples, lidando corretamente com todos os tipos de pedido."

#: ../../c-api/typeobj.rst:2834
msgid ""
":c:func:`PyObject_GetBuffer` is the interface for the consumer that wraps "
"this function."
msgstr ""
":c:func:`PyObject_GetBuffer` é a interface para o consumidor que envolve "
"esta função."

#: ../../c-api/typeobj.rst:2841
msgid "void (PyObject *exporter, Py_buffer *view);"
msgstr "void (PyObject *exporter, Py_buffer *view);"

#: ../../c-api/typeobj.rst:2843
msgid ""
"Handle a request to release the resources of the buffer. If no resources "
"need to be released, :c:member:`PyBufferProcs.bf_releasebuffer` may be "
"``NULL``. Otherwise, a standard implementation of this function will take "
"these optional steps:"
msgstr ""
"Tratar um pedido para libertar os recursos do buffer. Se não for necessário "
"libertar recursos, :c:member:`PyBufferProcs.bf_releasebuffer` pode ser "
"``NULL``. Caso contrário, uma implementação padrão desta função seguirá "
"estes passos opcionais:"

#: ../../c-api/typeobj.rst:2848
msgid "Decrement an internal counter for the number of exports."
msgstr "Decrementar um contador interno para o número de exportações."

#: ../../c-api/typeobj.rst:2850
msgid "If the counter is ``0``, free all memory associated with *view*."
msgstr "Se o contador for ``0``, libertar toda a memória associada a *view*."

#: ../../c-api/typeobj.rst:2852
msgid ""
"The exporter MUST use the :c:member:`~Py_buffer.internal` field to keep "
"track of buffer-specific resources. This field is guaranteed to remain "
"constant, while a consumer MAY pass a copy of the original buffer as the "
"*view* argument."
msgstr ""
"O exportador DEVE usar o campo :c:member:`~Py_buffer.internal` para "
"acompanhar os recursos específicos do buffer. Este campo é garantido como "
"constante, enquanto um consumidor PODE passar uma cópia do buffer original "
"como argumento *view*."

#: ../../c-api/typeobj.rst:2858
msgid ""
"This function MUST NOT decrement :c:expr:`view->obj`, since that is done "
"automatically in :c:func:`PyBuffer_Release` (this scheme is useful for "
"breaking reference cycles)."
msgstr ""
"Esta função NÃO DEVE decrementar :c:expr:`view->obj`, uma vez que isso é "
"feito automaticamente em :c:func:`PyBuffer_Release` (este esquema é útil "
"para quebrar ciclos de referência)."

#: ../../c-api/typeobj.rst:2863
msgid ""
":c:func:`PyBuffer_Release` is the interface for the consumer that wraps this "
"function."
msgstr ""
":c:func:`PyBuffer_Release` é a interface para o consumidor que envolve esta "
"função."

#: ../../c-api/typeobj.rst:2871
msgid "Async Object Structures"
msgstr "Estruturas de Objetos Assíncronos"

#: ../../c-api/typeobj.rst:2879
msgid ""
"This structure holds pointers to the functions required to implement :term:"
"`awaitable` and :term:`asynchronous iterator` objects."
msgstr ""
"Esta estrutura contém ponteiros para as funções necessárias para implementar "
"objetos :term:`awaitable` e :term:`iterador assíncrono`."

#: ../../c-api/typeobj.rst:2884
msgid ""
"typedef struct {\n"
"    unaryfunc am_await;\n"
"    unaryfunc am_aiter;\n"
"    unaryfunc am_anext;\n"
"    sendfunc am_send;\n"
"} PyAsyncMethods;"
msgstr ""
"typedef struct {\n"
"    unaryfunc am_await;\n"
"    unaryfunc am_aiter;\n"
"    unaryfunc am_anext;\n"
"    sendfunc am_send;\n"
"} PyAsyncMethods;"

#: ../../c-api/typeobj.rst:2895
msgid "PyObject *am_await(PyObject *self);"
msgstr "PyObject *am_await(PyObject *self);"

#: ../../c-api/typeobj.rst:2897
msgid ""
"The returned object must be an :term:`iterator`, i.e. :c:func:`PyIter_Check` "
"must return ``1`` for it."
msgstr ""
"O objeto retornado deve ser um :term:`iterator`, ou seja, :c:func:"
"`PyIter_Check` deve retornar ``1`` para ele."

#: ../../c-api/typeobj.rst:2900
msgid ""
"This slot may be set to ``NULL`` if an object is not an :term:`awaitable`."
msgstr ""
"Este slot pode ser definido como ``NULL`` se um objeto não for um :term:"
"`awaitable`."

#: ../../c-api/typeobj.rst:2906
msgid "PyObject *am_aiter(PyObject *self);"
msgstr "PyObject *am_aiter(PyObject *self);"

#: ../../c-api/typeobj.rst:2908
msgid ""
"Must return an :term:`asynchronous iterator` object. See :meth:`~object."
"__anext__` for details."
msgstr ""
"Deve retornar um objeto :term:`iterador assíncrono`. Consulte :meth:`~object."
"__anext__` para obter detalhes."

#: ../../c-api/typeobj.rst:2911
msgid ""
"This slot may be set to ``NULL`` if an object does not implement "
"asynchronous iteration protocol."
msgstr ""
"Este slot pode ser definido como ``NULL`` se um objeto não implementar o "
"protocolo de iteração assíncrona."

#: ../../c-api/typeobj.rst:2918
msgid "PyObject *am_anext(PyObject *self);"
msgstr "PyObject *am_anext(PyObject *self);"

#: ../../c-api/typeobj.rst:2920
msgid ""
"Must return an :term:`awaitable` object. See :meth:`~object.__anext__` for "
"details. This slot may be set to ``NULL``."
msgstr ""
"Deve retornar um objeto :term:`awaitable`. Consulte :meth:`~object."
"__anext__` para obter detalhes. Este slot pode ser definido como ``NULL``."

#: ../../c-api/typeobj.rst:2928
msgid "PySendResult am_send(PyObject *self, PyObject *arg, PyObject **result);"
msgstr ""
"PySendResult am_send(PyObject *self, PyObject *arg, PyObject **result);"

#: ../../c-api/typeobj.rst:2930
msgid ""
"See :c:func:`PyIter_Send` for details. This slot may be set to ``NULL``."
msgstr ""
"Consulte :c:func:`PyIter_Send` para obter detalhes. Este slot pode ser "
"definido como ``NULL``."

#: ../../c-api/typeobj.rst:2939
msgid "Slot Type typedefs"
msgstr "Tipo de molde typedefs"

#: ../../c-api/typeobj.rst:2943
msgid ""
"The purpose of this function is to separate memory allocation from memory "
"initialization.  It should return a pointer to a block of memory of adequate "
"length for the instance, suitably aligned, and initialized to zeros, but "
"with :c:member:`~PyObject.ob_refcnt` set to ``1`` and :c:member:`~PyObject."
"ob_type` set to the type argument.  If the type's :c:member:`~PyTypeObject."
"tp_itemsize` is non-zero, the object's :c:member:`~PyVarObject.ob_size` "
"field should be initialized to *nitems* and the length of the allocated "
"memory block should be ``tp_basicsize + nitems*tp_itemsize``, rounded up to "
"a multiple of ``sizeof(void*)``; otherwise, *nitems* is not used and the "
"length of the block should be :c:member:`~PyTypeObject.tp_basicsize`."
msgstr ""
"O objetivo desta função é separar a alocação de memória da inicialização da "
"memória. Ela deve retornar um ponteiro para um bloco de memória de "
"comprimento adequado para a instância, devidamente alinhado e inicializado "
"com zeros, mas com :c:member:`~PyObject.ob_refcnt` definido como ``1`` e :c:"
"member:`~PyObject.ob_type` definido como o argumento de tipo. Se o :c:member:"
"`~PyTypeObject.tp_itemsize` do tipo for diferente de zero, o campo :c:member:"
"`~PyVarObject.ob_size` do objeto deve ser inicializado para *nitems* e o "
"comprimento do bloco de memória alocado deve ser ``tp_basicsize + "
"nitems*tp_itemsize``, arredondado para um múltiplo de ``sizeof(void*)``; "
"caso contrário, *nitems* não é usado e o comprimento do bloco deve ser :c:"
"member:`~PyTypeObject.tp_basicsize`."

#: ../../c-api/typeobj.rst:2953
msgid ""
"This function should not do any other instance initialization, not even to "
"allocate additional memory; that should be done by :c:member:`~PyTypeObject."
"tp_new`."
msgstr ""
"Esta função não deve realizar nenhuma outra inicialização de instância, nem "
"mesmo para alocar memória adicional; isso deve ser feito por :c:member:"
"`~PyTypeObject.tp_new`."

#: ../../c-api/typeobj.rst:2960
msgid "See :c:member:`~PyTypeObject.tp_free`."
msgstr "Ver :c:member:`~PyTypeObject.tp_free`."

#: ../../c-api/typeobj.rst:2964
msgid "See :c:member:`~PyTypeObject.tp_new`."
msgstr "Ver :c:member:`~PyTypeObject.tp_new`."

#: ../../c-api/typeobj.rst:2968
msgid "See :c:member:`~PyTypeObject.tp_init`."
msgstr "Ver :c:member:`~PyTypeObject.tp_init`."

#: ../../c-api/typeobj.rst:2972
msgid "See :c:member:`~PyTypeObject.tp_repr`."
msgstr "Ver :c:member:`~PyTypeObject.tp_repr`."

#: ../../c-api/typeobj.rst:2976 ../../c-api/typeobj.rst:2985
msgid "Return the value of the named attribute for the object."
msgstr "Retorna o valor do atributo nomeado para o objeto."

#: ../../c-api/typeobj.rst:2980 ../../c-api/typeobj.rst:2991
msgid ""
"Set the value of the named attribute for the object. The value argument is "
"set to ``NULL`` to delete the attribute."
msgstr ""
"Defina o valor do atributo nomeado para o objeto. O argumento de valor é "
"definido como ``NULL`` para excluir o atributo."

#: ../../c-api/typeobj.rst:2987
msgid "See :c:member:`~PyTypeObject.tp_getattro`."
msgstr "Ver :c:member:`~PyTypeObject.tp_getattro`."

#: ../../c-api/typeobj.rst:2994
msgid "See :c:member:`~PyTypeObject.tp_setattro`."
msgstr "Ver :c:member:`~PyTypeObject.tp_setattro`."

#: ../../c-api/typeobj.rst:2998
msgid "See :c:member:`~PyTypeObject.tp_descr_get`."
msgstr "Ver :c:member:`~PyTypeObject.tp_descr_get`."

#: ../../c-api/typeobj.rst:3002
msgid "See :c:member:`~PyTypeObject.tp_descr_set`."
msgstr "Ver :c:member:`~PyTypeObject.tp_descr_set`."

#: ../../c-api/typeobj.rst:3006
msgid "See :c:member:`~PyTypeObject.tp_hash`."
msgstr "Ver :c:member:`~PyTypeObject.tp_hash`."

#: ../../c-api/typeobj.rst:3010
msgid "See :c:member:`~PyTypeObject.tp_richcompare`."
msgstr "Ver :c:member:`~PyTypeObject.tp_richcompare`."

#: ../../c-api/typeobj.rst:3014
msgid "See :c:member:`~PyTypeObject.tp_iter`."
msgstr "Ver :c:member:`~PyTypeObject.tp_iter`."

#: ../../c-api/typeobj.rst:3018
msgid "See :c:member:`~PyTypeObject.tp_iternext`."
msgstr "Ver :c:member:`~PyTypeObject.tp_iternext`."

#: ../../c-api/typeobj.rst:3032
msgid "See :c:member:`~PyAsyncMethods.am_send`."
msgstr "Ver :c:member:`~PyAsyncMethods.am_send`."

#: ../../c-api/typeobj.rst:3048
msgid "Examples"
msgstr "Exemplos"

#: ../../c-api/typeobj.rst:3050
msgid ""
"The following are simple examples of Python type definitions.  They include "
"common usage you may encounter.  Some demonstrate tricky corner cases.  For "
"more examples, practical info, and a tutorial, see :ref:`defining-new-types` "
"and :ref:`new-types-topics`."
msgstr ""
"A seguir estão exemplos simples de definições de tipos em Python. Eles "
"incluem usos comuns que você pode encontrar. Alguns demonstram casos "
"extremos complicados. Para mais exemplos, informações práticas e um "
"tutorial, consulte :ref:`defining-new-types` e :ref:`new-types-topics`."

#: ../../c-api/typeobj.rst:3055
msgid "A basic :ref:`static type <static-types>`::"
msgstr "Um tipo estático básico :ref:`tipo estático <static-types>`::"

#: ../../c-api/typeobj.rst:3057
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"My objects\"),\n"
"    .tp_new = myobj_new,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"My objects\"),\n"
"    .tp_new = myobj_new,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"

#: ../../c-api/typeobj.rst:3072
msgid ""
"You may also find older code (especially in the CPython code base) with a "
"more verbose initializer::"
msgstr ""
"Você também pode encontrar códigos mais antigos (especialmente na base de "
"código CPython) com um inicializador mais detalhado:"

#: ../../c-api/typeobj.rst:3075
msgid ""
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    \"mymod.MyObject\",               /* tp_name */\n"
"    sizeof(MyObject),               /* tp_basicsize */\n"
"    0,                              /* tp_itemsize */\n"
"    (destructor)myobj_dealloc,      /* tp_dealloc */\n"
"    0,                              /* tp_vectorcall_offset */\n"
"    0,                              /* tp_getattr */\n"
"    0,                              /* tp_setattr */\n"
"    0,                              /* tp_as_async */\n"
"    (reprfunc)myobj_repr,           /* tp_repr */\n"
"    0,                              /* tp_as_number */\n"
"    0,                              /* tp_as_sequence */\n"
"    0,                              /* tp_as_mapping */\n"
"    0,                              /* tp_hash */\n"
"    0,                              /* tp_call */\n"
"    0,                              /* tp_str */\n"
"    0,                              /* tp_getattro */\n"
"    0,                              /* tp_setattro */\n"
"    0,                              /* tp_as_buffer */\n"
"    0,                              /* tp_flags */\n"
"    PyDoc_STR(\"My objects\"),        /* tp_doc */\n"
"    0,                              /* tp_traverse */\n"
"    0,                              /* tp_clear */\n"
"    0,                              /* tp_richcompare */\n"
"    0,                              /* tp_weaklistoffset */\n"
"    0,                              /* tp_iter */\n"
"    0,                              /* tp_iternext */\n"
"    0,                              /* tp_methods */\n"
"    0,                              /* tp_members */\n"
"    0,                              /* tp_getset */\n"
"    0,                              /* tp_base */\n"
"    0,                              /* tp_dict */\n"
"    0,                              /* tp_descr_get */\n"
"    0,                              /* tp_descr_set */\n"
"    0,                              /* tp_dictoffset */\n"
"    0,                              /* tp_init */\n"
"    0,                              /* tp_alloc */\n"
"    myobj_new,                      /* tp_new */\n"
"};"
msgstr ""
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    \"mymod.MyObject\",               /* tp_name */\n"
"    sizeof(MyObject),               /* tp_basicsize */\n"
"    0,                              /* tp_itemsize */\n"
"    (destructor)myobj_dealloc,      /* tp_dealloc */\n"
"    0,                              /* tp_vectorcall_offset */\n"
"    0,                              /* tp_getattr */\n"
"    0,                              /* tp_setattr */\n"
"    0,                              /* tp_as_async */\n"
"    (reprfunc)myobj_repr,           /* tp_repr */\n"
"    0,                              /* tp_as_number */\n"
"    0,                              /* tp_as_sequence */\n"
"    0,                              /* tp_as_mapping */\n"
"    0,                              /* tp_hash */\n"
"    0,                              /* tp_call */\n"
"    0,                              /* tp_str */\n"
"    0,                              /* tp_getattro */\n"
"    0,                              /* tp_setattro */\n"
"    0,                              /* tp_as_buffer */\n"
"    0,                              /* tp_flags */\n"
"    PyDoc_STR(\"My objects\"),        /* tp_doc */\n"
"    0,                              /* tp_traverse */\n"
"    0,                              /* tp_clear */\n"
"    0,                              /* tp_richcompare */\n"
"    0,                              /* tp_weaklistoffset */\n"
"    0,                              /* tp_iter */\n"
"    0,                              /* tp_iternext */\n"
"    0,                              /* tp_methods */\n"
"    0,                              /* tp_members */\n"
"    0,                              /* tp_getset */\n"
"    0,                              /* tp_base */\n"
"    0,                              /* tp_dict */\n"
"    0,                              /* tp_descr_get */\n"
"    0,                              /* tp_descr_set */\n"
"    0,                              /* tp_dictoffset */\n"
"    0,                              /* tp_init */\n"
"    0,                              /* tp_alloc */\n"
"    myobj_new,                      /* tp_new */\n"
"};"

#: ../../c-api/typeobj.rst:3116
msgid "A type that supports weakrefs, instance dicts, and hashing::"
msgstr "Um tipo que suporta weakrefs, dicionários de instância e hashing::"

#: ../../c-api/typeobj.rst:3118
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"My objects\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |\n"
"         Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_MANAGED_DICT |\n"
"         Py_TPFLAGS_MANAGED_WEAKREF,\n"
"    .tp_new = myobj_new,\n"
"    .tp_traverse = (traverseproc)myobj_traverse,\n"
"    .tp_clear = (inquiry)myobj_clear,\n"
"    .tp_alloc = PyType_GenericNew,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"    .tp_hash = (hashfunc)myobj_hash,\n"
"    .tp_richcompare = PyBaseObject_Type.tp_richcompare,\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"    const char *data;\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject),\n"
"    .tp_doc = PyDoc_STR(\"My objects\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |\n"
"         Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_MANAGED_DICT |\n"
"         Py_TPFLAGS_MANAGED_WEAKREF,\n"
"    .tp_new = myobj_new,\n"
"    .tp_traverse = (traverseproc)myobj_traverse,\n"
"    .tp_clear = (inquiry)myobj_clear,\n"
"    .tp_alloc = PyType_GenericNew,\n"
"    .tp_dealloc = (destructor)myobj_dealloc,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"    .tp_hash = (hashfunc)myobj_hash,\n"
"    .tp_richcompare = PyBaseObject_Type.tp_richcompare,\n"
"};"

#: ../../c-api/typeobj.rst:3141
msgid ""
"A str subclass that cannot be subclassed and cannot be called to create "
"instances (e.g. uses a separate factory func) using :c:macro:"
"`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag::"
msgstr ""
"Uma subclasse str que não pode ser subclassificada e não pode ser chamada "
"para criar instâncias (por exemplo, usa uma função de fábrica separada) "
"usando o sinalizador :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`::"

#: ../../c-api/typeobj.rst:3145
msgid ""
"typedef struct {\n"
"    PyUnicodeObject raw;\n"
"    char *extra;\n"
"} MyStr;\n"
"\n"
"static PyTypeObject MyStr_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyStr\",\n"
"    .tp_basicsize = sizeof(MyStr),\n"
"    .tp_base = NULL,  // set to &PyUnicode_Type in module init\n"
"    .tp_doc = PyDoc_STR(\"my custom str\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_DISALLOW_INSTANTIATION,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyUnicodeObject raw;\n"
"    char *extra;\n"
"} MyStr;\n"
"\n"
"static PyTypeObject MyStr_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyStr\",\n"
"    .tp_basicsize = sizeof(MyStr),\n"
"    .tp_base = NULL,  // set to &PyUnicode_Type in module init\n"
"    .tp_doc = PyDoc_STR(\"my custom str\"),\n"
"    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_DISALLOW_INSTANTIATION,\n"
"    .tp_repr = (reprfunc)myobj_repr,\n"
"};"

#: ../../c-api/typeobj.rst:3160
msgid ""
"The simplest :ref:`static type <static-types>` with fixed-length instances::"
msgstr ""
"O mais simples :ref:`tipo estático <static-types>` com instâncias de "
"comprimento fixo::"

#: ../../c-api/typeobj.rst:3162
msgid ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyObject_HEAD\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"};"

#: ../../c-api/typeobj.rst:3171
msgid ""
"The simplest :ref:`static type <static-types>` with variable-length "
"instances::"
msgstr ""
"O mais simples :ref:`tipo estático <static-types>` com instâncias de "
"comprimento variável::"

#: ../../c-api/typeobj.rst:3173
msgid ""
"typedef struct {\n"
"    PyObject_VAR_HEAD\n"
"    const char *data[1];\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject) - sizeof(char *),\n"
"    .tp_itemsize = sizeof(char *),\n"
"};"
msgstr ""
"typedef struct {\n"
"    PyObject_VAR_HEAD\n"
"    const char *data[1];\n"
"} MyObject;\n"
"\n"
"static PyTypeObject MyObject_Type = {\n"
"    PyVarObject_HEAD_INIT(NULL, 0)\n"
"    .tp_name = \"mymod.MyObject\",\n"
"    .tp_basicsize = sizeof(MyObject) - sizeof(char *),\n"
"    .tp_itemsize = sizeof(char *),\n"
"};"

#: ../../c-api/typeobj.rst:912 ../../c-api/typeobj.rst:977
msgid "built-in function"
msgstr "função incorporada"

#: ../../c-api/typeobj.rst:912
msgid "repr"
msgstr "repr"

#: ../../c-api/typeobj.rst:977
msgid "hash"
msgstr "hash"
