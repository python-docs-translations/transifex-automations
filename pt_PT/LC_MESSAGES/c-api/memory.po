# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2026, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2026
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-23 15:04+0000\n"
"PO-Revision-Date: 2025-09-15 01:03+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2026\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../c-api/memory.rst:8
msgid "Memory Management"
msgstr "Gestão de Memória"

#: ../../c-api/memory.rst:17
msgid "Overview"
msgstr "Visão Geral"

#: ../../c-api/memory.rst:19
msgid ""
"Memory management in Python involves a private heap containing all Python "
"objects and data structures. The management of this private heap is ensured "
"internally by the *Python memory manager*.  The Python memory manager has "
"different components which deal with various dynamic storage management "
"aspects, like sharing, segmentation, preallocation or caching."
msgstr ""
"A gestão de memória em Python envolve um *heap* privado que contém todos os "
"objetos e estruturas de dados Python. A gestão deste *heap* privado é "
"garantida internamente pelo *gestor de memória do Python*. O gestor de "
"memória do Python tem diferentes componentes que lidam com vários aspetos da "
"gestão dinâmica de armazenamento, como partilha, segmentação, pré-alocação "
"ou cache."

#: ../../c-api/memory.rst:25
msgid ""
"At the lowest level, a raw memory allocator ensures that there is enough "
"room in the private heap for storing all Python-related data by interacting "
"with the memory manager of the operating system. On top of the raw memory "
"allocator, several object-specific allocators operate on the same heap and "
"implement distinct memory management policies adapted to the peculiarities "
"of every object type. For example, integer objects are managed differently "
"within the heap than strings, tuples or dictionaries because integers imply "
"different storage requirements and speed/space tradeoffs. The Python memory "
"manager thus delegates some of the work to the object-specific allocators, "
"but ensures that the latter operate within the bounds of the private heap."
msgstr ""
"Ao nível mais baixo, um alocador de memória bruta garante que existe espaço "
"suficiente no *heap* privado para armazenar todos os dados relacionados com "
"Python, interagindo com o gestor de memória do sistema operativo. Por cima "
"do alocador de memória bruta, vários alocadores específicos de objetos "
"operam no mesmo *heap* e implementam políticas distintas de gestão de "
"memória, adaptadas às particularidades de cada tipo de objeto. Por exemplo, "
"os objetos inteiros são geridos de forma diferente no *heap* em relação a "
"cadeias de caracteres, tuplos ou dicionários, porque os inteiros implicam "
"requisitos de armazenamento e compromissos de velocidade/espaço distintos. O "
"gestor de memória do Python delega, assim, parte do trabalho aos alocadores "
"específicos de objetos, mas garante que estes operam dentro dos limites do "
"*heap* privado."

#: ../../c-api/memory.rst:36
msgid ""
"It is important to understand that the management of the Python heap is "
"performed by the interpreter itself and that the user has no control over "
"it, even if they regularly manipulate object pointers to memory blocks "
"inside that heap.  The allocation of heap space for Python objects and other "
"internal buffers is performed on demand by the Python memory manager through "
"the Python/C API functions listed in this document."
msgstr ""
"É importante compreender que a gestão do *heap* do Python é realizada pelo "
"próprio intérprete e que o utilizador não tem controlo sobre ela, mesmo que "
"manipule regularmente ponteiros de objetos para blocos de memória dentro "
"desse *heap*. A alocação de espaço no *heap* para objetos Python e outros "
"buffers internos é realizada sob pedido pelo gestor de memória do Python, "
"através das funções da API C/Python listadas neste documento."

#: ../../c-api/memory.rst:49
msgid ""
"To avoid memory corruption, extension writers should never try to operate on "
"Python objects with the functions exported by the C library: :c:func:"
"`malloc`, :c:func:`calloc`, :c:func:`realloc` and :c:func:`free`.  This will "
"result in  mixed calls between the C allocator and the Python memory manager "
"with fatal consequences, because they implement different algorithms and "
"operate on different heaps.  However, one may safely allocate and release "
"memory blocks with the C library allocator for individual purposes, as shown "
"in the following example::"
msgstr ""
"Para evitar corrupção de memória, os programadores de extensões nunca devem "
"tentar operar em objetos Python com as funções exportadas pela biblioteca "
"C: :c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` e :c:func:`free`. "
"Isto resultará em chamadas misturadas entre o alocador C e o gestor de "
"memória do Python, com consequências fatais, porque implementam algoritmos "
"diferentes e operam em *heaps* distintos. No entanto, pode-se alocar e "
"libertar blocos de memória com o alocador da biblioteca C para fins "
"individuais, como mostrado no exemplo seguinte::"

#: ../../c-api/memory.rst:58
msgid ""
"PyObject *res;\n"
"char *buf = (char *) malloc(BUFSIZ); /* for I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"...Do some I/O operation involving buf...\n"
"res = PyBytes_FromString(buf);\n"
"free(buf); /* malloc'ed */\n"
"return res;"
msgstr ""
"PyObject *res;\n"
"char *buf = (char *) malloc(BUFSIZ); /* para I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"...Efetuar alguma operação de I/O envolvendo buf...\n"
"res = PyBytes_FromString(buf);\n"
"free(buf); /* alocado com malloc */\n"
"return res;"

#: ../../c-api/memory.rst:68
msgid ""
"In this example, the memory request for the I/O buffer is handled by the C "
"library allocator. The Python memory manager is involved only in the "
"allocation of the bytes object returned as a result."
msgstr ""
"Neste exemplo, o pedido de memória para o buffer de I/O é tratado pelo "
"alocador da biblioteca C. O gestor de memória do Python está envolvido "
"apenas na alocação do objeto bytes retornado como resultado."

#: ../../c-api/memory.rst:72
msgid ""
"In most situations, however, it is recommended to allocate memory from the "
"Python heap specifically because the latter is under control of the Python "
"memory manager. For example, this is required when the interpreter is "
"extended with new object types written in C. Another reason for using the "
"Python heap is the desire to *inform* the Python memory manager about the "
"memory needs of the extension module. Even when the requested memory is used "
"exclusively for internal, highly specific purposes, delegating all memory "
"requests to the Python memory manager causes the interpreter to have a more "
"accurate image of its memory footprint as a whole. Consequently, under "
"certain circumstances, the Python memory manager may or may not trigger "
"appropriate actions, like garbage collection, memory compaction or other "
"preventive procedures. Note that by using the C library allocator as shown "
"in the previous example, the allocated memory for the I/O buffer escapes "
"completely the Python memory manager."
msgstr ""
"Na maioria das situações, no entanto, é recomendado alocar memória a partir "
"do *heap* do Python, especificamente porque este está sob controlo do gestor "
"de memória do Python. Por exemplo, isto é necessário quando o intérprete é "
"estendido com novos tipos de objetos escritos em C. Outra razão para usar o "
"*heap* do Python é o desejo de *informar* o gestor de memória do Python "
"sobre as necessidades de memória do módulo de extensão. Mesmo quando a "
"memória solicitada é usada exclusivamente para fins internos e altamente "
"específicos, delegar todos os pedidos de memória ao gestor de memória do "
"Python faz com que o intérprete tenha uma imagem mais precisa da sua pegada "
"de memória como um todo. Consequentemente, em certas circunstâncias, o "
"gestor de memória do Python pode ou não desencadear ações apropriadas, como "
"recolha de lixo, compactação de memória ou outros procedimentos preventivos. "
"Note que, ao usar o alocador da biblioteca C, como mostrado no exemplo "
"anterior, a memória alocada para o buffer de I/O escapa completamente ao "
"gestor de memória do Python."

#: ../../c-api/memory.rst:88
msgid ""
"The :envvar:`PYTHONMALLOC` environment variable can be used to configure the "
"memory allocators used by Python."
msgstr ""
"A variável de ambiente :envvar:`PYTHONMALLOC` pode ser usada para configurar "
"os alocadores de memória usados pelo Python."

#: ../../c-api/memory.rst:91
msgid ""
"The :envvar:`PYTHONMALLOCSTATS` environment variable can be used to print "
"statistics of the :ref:`pymalloc memory allocator <pymalloc>` every time a "
"new pymalloc object arena is created, and on shutdown."
msgstr ""
"A variável de ambiente :envvar:`PYTHONMALLOCSTATS` pode ser usada para "
"imprimir estatísticas do alocador de memória :ref:`pymalloc <pymalloc>` "
"sempre que uma nova arena de objetos pymalloc é criada e no encerramento."

#: ../../c-api/memory.rst:96
msgid "Allocator Domains"
msgstr "Domínios de Alocação"

#: ../../c-api/memory.rst:100
msgid ""
"All allocating functions belong to one of three different \"domains\" (see "
"also :c:type:`PyMemAllocatorDomain`). These domains represent different "
"allocation strategies and are optimized for different purposes. The specific "
"details on how every domain allocates memory or what internal functions each "
"domain calls is considered an implementation detail, but for debugging "
"purposes a simplified table can be found at :ref:`default-memory-"
"allocators`. The APIs used to allocate and free a block of memory must be "
"from the same domain. For example, :c:func:`PyMem_Free` must be used to free "
"memory allocated using :c:func:`PyMem_Malloc`."
msgstr ""
"Todas as funções de alocação pertencem a um dos três diferentes "
"\"domínios\" (consulte também :c:type:`PyMemAllocatorDomain`). Estes "
"domínios representam diferentes estratégias de alocação e são otimizados "
"para diferentes finalidades. Os detalhes específicos sobre como cada domínio "
"aloca memória ou quais funções internas cada domínio chama são considerados "
"detalhes de implementação, mas para fins de depuração, uma tabela "
"simplificada pode ser encontrada em :ref:`default-memory-allocators`. As "
"APIs utilizadas para alocar e liberar um bloco de memória devem ser do mesmo "
"domínio. Por exemplo, :c:func:`PyMem_Free` deve ser utilizado para liberar a "
"memória alocada utilizando :c:func:`PyMem_Malloc`."

#: ../../c-api/memory.rst:109
msgid "The three allocation domains are:"
msgstr "Os três domínios de alocação são:"

#: ../../c-api/memory.rst:111
msgid ""
"Raw domain: intended for allocating memory for general-purpose memory "
"buffers where the allocation *must* go to the system allocator or where the "
"allocator can operate without the :term:`GIL`. The memory is requested "
"directly from the system. See :ref:`Raw Memory Interface <raw-"
"memoryinterface>`."
msgstr ""

#: ../../c-api/memory.rst:116
msgid ""
"\"Mem\" domain: intended for allocating memory for Python buffers and "
"general-purpose memory buffers where the allocation must be performed with "
"the :term:`GIL` held. The memory is taken from the Python private heap. See :"
"ref:`Memory Interface <memoryinterface>`."
msgstr ""

#: ../../c-api/memory.rst:121
msgid ""
"Object domain: intended for allocating memory for Python objects. The memory "
"is taken from the Python private heap. See :ref:`Object allocators "
"<objectinterface>`."
msgstr ""
"Domínio de Objetos: destinado à alocação de memória para objetos Python. A "
"memória é obtida do *heap* privado do Python. Veja :ref:`Alocadores de "
"Objetos <objectinterface>`."

#: ../../c-api/memory.rst:126
msgid ""
"The :term:`free-threaded <free threading>` build requires that only Python "
"objects are allocated using the \"object\" domain and that all Python "
"objects are allocated using that domain. This differs from the prior Python "
"versions, where this was only a best practice and not a hard requirement."
msgstr ""
"A compilação :term:`free-threaded <free threading>` exige que apenas objetos "
"Python sejam alocados usando o domínio \"objeto\" e que todos os objetos "
"Python sejam alocados usando esse domínio. Isto difere das versões "
"anteriores do Python, onde isto era apenas uma boa prática e não um "
"requisito obrigatório."

#: ../../c-api/memory.rst:130
msgid ""
"For example, buffers (non-Python objects) should be allocated using :c:func:"
"`PyMem_Malloc`, :c:func:`PyMem_RawMalloc`, or :c:func:`malloc`, but not :c:"
"func:`PyObject_Malloc`."
msgstr ""
"Por exemplo, buffers (objetos não-Python) devem ser alocados usando :c:func:"
"`PyMem_Malloc`, :c:func:`PyMem_RawMalloc`, ou :c:func:`malloc`, mas não :c:"
"func:`PyObject_Malloc`."

#: ../../c-api/memory.rst:133
msgid "See :ref:`Memory Allocation APIs <free-threaded-memory-allocation>`."
msgstr ""
"Veja :ref:`APIs de Alocação de Memória <free-threaded-memory-allocation>`...."

#: ../../c-api/memory.rst:139
msgid "Raw Memory Interface"
msgstr "Interface de Memória Raw"

#: ../../c-api/memory.rst:141
msgid ""
"The following function sets are wrappers to the system allocator. These "
"functions are thread-safe, the :term:`GIL <global interpreter lock>` does "
"not need to be held."
msgstr ""

#: ../../c-api/memory.rst:145
msgid ""
"The :ref:`default raw memory allocator <default-memory-allocators>` uses the "
"following functions: :c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` "
"and :c:func:`!free`; call ``malloc(1)`` (or ``calloc(1, 1)``) when "
"requesting zero bytes."
msgstr ""
"O :ref:`alocador de memória raw predefinido <default-memory-allocators>` usa "
"as seguintes funções: :c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` "
"e :c:func:`!free`; chamar ``malloc(1)`` (ou ``calloc(1, 1)``) ao solicitar "
"zero bytes."

#: ../../c-api/memory.rst:154 ../../c-api/memory.rst:225
#: ../../c-api/memory.rst:357
msgid ""
"Allocates *n* bytes and returns a pointer of type :c:expr:`void*` to the "
"allocated memory, or ``NULL`` if the request fails."
msgstr ""
"Aloca *n* bytes e retorna um ponteiro do tipo :c:expr:`void*` para a memória "
"alocada, ou ``NULL`` se o pedido falhar."

#: ../../c-api/memory.rst:157
msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyMem_RawMalloc(1)`` had been called instead. The memory will not "
"have been initialized in any way."
msgstr ""
"Solicitar zero bytes retorna um ponteiro não-``NULL`` distinto, se possível, "
"como se ``PyMem_RawMalloc(1)`` tivesse sido chamado. A memória não será "
"inicializada de nenhuma forma."

#: ../../c-api/memory.rst:164 ../../c-api/memory.rst:235
#: ../../c-api/memory.rst:367
msgid ""
"Allocates *nelem* elements each whose size in bytes is *elsize* and returns "
"a pointer of type :c:expr:`void*` to the allocated memory, or ``NULL`` if "
"the request fails. The memory is initialized to zeros."
msgstr ""
"Aloca *nelem* elementos, cada um com tamanho em bytes de *elsize*, e retorna "
"um ponteiro do tipo :c:expr:`void*` para a memória alocada, ou ``NULL`` se o "
"pedido falhar. A memória é inicializada a zeros."

#: ../../c-api/memory.rst:168
msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyMem_RawCalloc(1, 1)`` had been "
"called instead."
msgstr ""
"Solicitar zero elementos ou elementos com tamanho de zero bytes retorna um "
"ponteiro não-``NULL`` distinto, se possível, como se ``PyMem_RawCalloc(1, "
"1)`` tivesse sido chamado."

#: ../../c-api/memory.rst:177 ../../c-api/memory.rst:248
#: ../../c-api/memory.rst:380
msgid ""
"Resizes the memory block pointed to by *p* to *n* bytes. The contents will "
"be unchanged to the minimum of the old and the new sizes."
msgstr ""
"Redimensiona o bloco de memória apontado por *p* para *n* bytes. O conteúdo "
"será inalterado até ao mínimo dos tamanhos antigo e novo."

#: ../../c-api/memory.rst:180
msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyMem_RawMalloc(n)``; else "
"if *n* is equal to zero, the memory block is resized but is not freed, and "
"the returned pointer is non-``NULL``."
msgstr ""
"Se *p* for ``NULL``, a chamada é equivalente a ``PyMem_RawMalloc(n)``; caso "
"contrário, se *n* for igual a zero, o bloco de memória é redimensionado, mas "
"não libertado, e o ponteiro retornado é não-``NULL``."

#: ../../c-api/memory.rst:184
msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to :c:"
"func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` or :c:func:"
"`PyMem_RawCalloc`."
msgstr ""
"A menos que *p* seja ``NULL``, deve ter sido retornado por uma chamada "
"anterior a :c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` ou :c:func:"
"`PyMem_RawCalloc`."

#: ../../c-api/memory.rst:188
msgid ""
"If the request fails, :c:func:`PyMem_RawRealloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Se o pedido falhar, :c:func:`PyMem_RawRealloc` retorna ``NULL`` e *p* "
"permanece um ponteiro válido para a área de memória anterior."

#: ../../c-api/memory.rst:194
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a "
"previous call to :c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` or :c:"
"func:`PyMem_RawCalloc`.  Otherwise, or if ``PyMem_RawFree(p)`` has been "
"called before, undefined behavior occurs."
msgstr ""
"Liberta o bloco de memória apontado por *p*, que deve ter sido retornado por "
"uma chamada anterior a :c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` "
"ou :c:func:`PyMem_RawCalloc`. Caso contrário, ou se ``PyMem_RawFree(p)`` "
"tiver sido chamado anteriormente, ocorre comportamento indefinido."

#: ../../c-api/memory.rst:199 ../../c-api/memory.rst:269
#: ../../c-api/memory.rst:401
msgid "If *p* is ``NULL``, no operation is performed."
msgstr "Se *p* for ``NULL``, nenhuma operação é realizada."

#: ../../c-api/memory.rst:205
msgid "Memory Interface"
msgstr "Interface de Memória"

#: ../../c-api/memory.rst:207 ../../c-api/memory.rst:337
msgid ""
"The following function sets, modeled after the ANSI C standard, but "
"specifying behavior when requesting zero bytes, are available for allocating "
"and releasing memory from the Python heap."
msgstr ""
"Os seguintes conjuntos de funções, modelados segundo o padrão ANSI C, mas "
"especificando o comportamento ao solicitar zero bytes, estão disponíveis "
"para alocar e libertar memória do *heap* do Python."

#: ../../c-api/memory.rst:211
msgid ""
"The :ref:`default memory allocator <default-memory-allocators>` uses the :"
"ref:`pymalloc memory allocator <pymalloc>`."
msgstr ""
"O :ref:`alocador de memória predefinido <default-memory-allocators>` usa o :"
"ref:`alocador de memória pymalloc <pymalloc>`."

#: ../../c-api/memory.rst:216 ../../c-api/memory.rst:352
msgid ""
"The :term:`GIL <global interpreter lock>` must be held when using these "
"functions."
msgstr ""

#: ../../c-api/memory.rst:221
msgid ""
"The default allocator is now pymalloc instead of system :c:func:`malloc`."
msgstr ""
"O alocador predefinido é agora o pymalloc em vez do :c:func:`malloc` do "
"sistema."

#: ../../c-api/memory.rst:228
msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyMem_Malloc(1)`` had been called instead. The memory will not have "
"been initialized in any way."
msgstr ""
"Solicitar zero bytes retorna um ponteiro não-``NULL`` distinto, se possível, "
"como se ``PyMem_Malloc(1)`` tivesse sido chamado. A memória não será "
"inicializada de nenhuma forma."

#: ../../c-api/memory.rst:239
msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyMem_Calloc(1, 1)`` had been "
"called instead."
msgstr ""
"Solicitar zero elementos ou elementos com tamanho de zero bytes retorna um "
"ponteiro não-``NULL`` distinto, se possível, como se ``PyMem_Calloc(1, 1)`` "
"tivesse sido chamado."

#: ../../c-api/memory.rst:251
msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyMem_Malloc(n)``; else if "
"*n* is equal to zero, the memory block is resized but is not freed, and the "
"returned pointer is non-``NULL``."
msgstr ""
"Se *p* for ``NULL``, a chamada é equivalente a ``PyMem_Malloc(n)``; caso "
"contrário, se *n* for igual a zero, o bloco de memória é redimensionado, mas "
"não libertado, e o ponteiro retornado é não-``NULL``."

#: ../../c-api/memory.rst:255
msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to :c:"
"func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` or :c:func:`PyMem_Calloc`."
msgstr ""
"A menos que *p* seja ``NULL``, deve ter sido retornado por uma chamada "
"anterior a :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` ou :c:func:"
"`PyMem_Calloc`."

#: ../../c-api/memory.rst:258
msgid ""
"If the request fails, :c:func:`PyMem_Realloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Se o pedido falhar, :c:func:`PyMem_Realloc` retorna ``NULL`` e *p* permanece "
"um ponteiro válido para a área de memória anterior."

#: ../../c-api/memory.rst:264
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a "
"previous call to :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` or :c:func:"
"`PyMem_Calloc`.  Otherwise, or if ``PyMem_Free(p)`` has been called before, "
"undefined behavior occurs."
msgstr ""
"Liberta o bloco de memória apontado por *p*, que deve ter sido retornado por "
"uma chamada anterior a :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` ou :c:"
"func:`PyMem_Calloc`. Caso contrário, ou se ``PyMem_Free(p)`` tiver sido "
"chamado anteriormente, ocorre comportamento indefinido."

#: ../../c-api/memory.rst:271
msgid ""
"The following type-oriented macros are provided for convenience.  Note  that "
"*TYPE* refers to any C type."
msgstr ""
"As seguintes macros orientadas a tipos são fornecidas por conveniência. Note "
"que *TYPE* refere-se a qualquer tipo C."

#: ../../c-api/memory.rst:277
msgid ""
"Same as :c:func:`PyMem_Malloc`, but allocates ``(n * sizeof(TYPE))`` bytes "
"of memory.  Returns a pointer cast to ``TYPE*``.  The memory will not have "
"been initialized in any way."
msgstr ""
"Semelhante a :c:func:`PyMem_Malloc`, mas aloca ``(n * sizeof(TYPE))`` bytes "
"de memória. Retorna um ponteiro convertido para ``TYPE*``. A memória não "
"será inicializada de nenhuma forma."

#: ../../c-api/memory.rst:284
msgid ""
"Same as :c:func:`PyMem_Realloc`, but the memory block is resized to ``(n * "
"sizeof(TYPE))`` bytes.  Returns a pointer cast to ``TYPE*``. On return, *p* "
"will be a pointer to the new memory area, or ``NULL`` in the event of "
"failure."
msgstr ""
"Semelhante a :c:func:`PyMem_Realloc`, mas o bloco de memória é "
"redimensionado para ``(n * sizeof(TYPE))`` bytes. Retorna um ponteiro "
"convertido para ``TYPE*``. Ao retornar, *p* será um ponteiro para a nova "
"área de memória, ou ``NULL`` em caso de falha."

#: ../../c-api/memory.rst:289
msgid ""
"This is a C preprocessor macro; *p* is always reassigned.  Save the original "
"value of *p* to avoid losing memory when handling errors."
msgstr ""
"Esta é uma macro do pré-processador C; *p* é sempre reatribuído. Guarde o "
"valor original de *p* para evitar perder memória ao tratar erros."

#: ../../c-api/memory.rst:295
msgid "Same as :c:func:`PyMem_Free`."
msgstr "Semelhante a :c:func:`PyMem_Free`."

#: ../../c-api/memory.rst:299
msgid "Deprecated aliases"
msgstr "Alias obsoleto"

#: ../../c-api/memory.rst:301
msgid ""
"These are :term:`soft deprecated` aliases to existing functions and macros. "
"They exist solely for backwards compatibility."
msgstr ""
"Estes são aliases em :term:`descontinuação latente` para funções e macros "
"existentes. Eles existem apenas para compatibilidade com versões anteriores."

#: ../../c-api/memory.rst:308
msgid "Deprecated alias"
msgstr "Alias obsoleto"

#: ../../c-api/memory.rst:309
msgid "Corresponding function or macro"
msgstr ""

#: ../../c-api/memory.rst:311
msgid ":c:func:`PyMem_Malloc`"
msgstr ""

#: ../../c-api/memory.rst:313
msgid ":c:macro:`PyMem_New`"
msgstr ""

#: ../../c-api/memory.rst:315 ../../c-api/memory.rst:484
msgid ":c:func:`PyMem_Realloc`"
msgstr ":c:func:`PyMem_Realloc`"

#: ../../c-api/memory.rst:317
msgid ":c:macro:`PyMem_Resize`"
msgstr ""

#: ../../c-api/memory.rst:319 ../../c-api/memory.rst:321
#: ../../c-api/memory.rst:486
msgid ":c:func:`PyMem_Free`"
msgstr ":c:func:`PyMem_Free`"

#: ../../c-api/memory.rst:325
msgid ""
"The macros are now aliases of the corresponding functions and macros. "
"Previously, their behavior was the same, but their use did not necessarily "
"preserve binary compatibility across Python versions."
msgstr ""

#: ../../c-api/memory.rst:335
msgid "Object allocators"
msgstr "Alocadores de Objetos"

#: ../../c-api/memory.rst:342
msgid ""
"There is no guarantee that the memory returned by these allocators can be "
"successfully cast to a Python object when intercepting the allocating "
"functions in this domain by the methods described in the :ref:`Customize "
"Memory Allocators <customize-memory-allocators>` section."
msgstr ""
"Não há garantia de que a memória retornada por estes alocadores possa ser "
"convertida com sucesso para um objeto Python ao interceptar as funções de "
"alocação neste domínio pelos métodos descritos na secção :ref:`Personalizar "
"Alocadores de Memória <customize-memory-allocators>`."

#: ../../c-api/memory.rst:347
msgid ""
"The :ref:`default object allocator <default-memory-allocators>` uses the :"
"ref:`pymalloc memory allocator <pymalloc>`."
msgstr ""
"O :ref:`alocador de objetos predefinido <default-memory-allocators>` usa o :"
"ref:`alocador de memória pymalloc <pymalloc>`."

#: ../../c-api/memory.rst:360
msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyObject_Malloc(1)`` had been called instead. The memory will not "
"have been initialized in any way."
msgstr ""
"Solicitar zero bytes retorna um ponteiro não-``NULL`` distinto, se possível, "
"como se ``PyObject_Malloc(1)`` tivesse sido chamado. A memória não será "
"inicializada de nenhuma forma."

#: ../../c-api/memory.rst:371
msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyObject_Calloc(1, 1)`` had been "
"called instead."
msgstr ""
"Solicitar zero elementos ou elementos com tamanho de zero bytes retorna um "
"ponteiro não-``NULL`` distinto, se possível, como se ``PyObject_Calloc(1, "
"1)`` tivesse sido chamado."

#: ../../c-api/memory.rst:383
msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyObject_Malloc(n)``; else "
"if *n* is equal to zero, the memory block is resized but is not freed, and "
"the returned pointer is non-``NULL``."
msgstr ""
"Se *p* for ``NULL``, a chamada é equivalente a ``PyObject_Malloc(n)``; caso "
"contrário, se *n* for igual a zero, o bloco de memória é redimensionado, mas "
"não libertado, e o ponteiro retornado é não-``NULL``."

#: ../../c-api/memory.rst:387
msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to :c:"
"func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` or :c:func:"
"`PyObject_Calloc`."
msgstr ""
"A menos que *p* seja ``NULL``, deve ter sido retornado por uma chamada "
"anterior a :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` ou :c:func:"
"`PyObject_Calloc`."

#: ../../c-api/memory.rst:390
msgid ""
"If the request fails, :c:func:`PyObject_Realloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Se o pedido falhar, :c:func:`PyObject_Realloc` retorna ``NULL`` e *p* "
"permanece um ponteiro válido para a área de memória anterior."

#: ../../c-api/memory.rst:396
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a "
"previous call to :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` or :c:"
"func:`PyObject_Calloc`.  Otherwise, or if ``PyObject_Free(p)`` has been "
"called before, undefined behavior occurs."
msgstr ""
"Liberta o bloco de memória apontado por *p*, que deve ter sido retornado por "
"uma chamada anterior a :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` "
"ou :c:func:`PyObject_Calloc`. Caso contrário, ou se ``PyObject_Free(p)`` "
"tiver sido chamado anteriormente, ocorre comportamento indefinido."

#: ../../c-api/memory.rst:407
msgid "Default Memory Allocators"
msgstr "Alocadores de Memória Predefinidos"

#: ../../c-api/memory.rst:409
msgid "Default memory allocators:"
msgstr "Alocadores de memória predefinidos:"

#: ../../c-api/memory.rst:412
msgid "Configuration"
msgstr "Configuração"

#: ../../c-api/memory.rst:412
msgid "Name"
msgstr "Nome"

#: ../../c-api/memory.rst:412
msgid "PyMem_RawMalloc"
msgstr "PyMem_RawMalloc"

#: ../../c-api/memory.rst:412
msgid "PyMem_Malloc"
msgstr "PyMem_Malloc"

#: ../../c-api/memory.rst:412
msgid "PyObject_Malloc"
msgstr "PyObject_Malloc"

#: ../../c-api/memory.rst:414
msgid "Release build"
msgstr "Compilação de lançamento"

#: ../../c-api/memory.rst:414
msgid "``\"pymalloc\"``"
msgstr "``\"pymalloc\"``"

#: ../../c-api/memory.rst:414 ../../c-api/memory.rst:416
msgid "``malloc``"
msgstr "``malloc``"

#: ../../c-api/memory.rst:414
msgid "``pymalloc``"
msgstr "``pymalloc``"

#: ../../c-api/memory.rst:415
msgid "Debug build"
msgstr "Compilação de depuração"

#: ../../c-api/memory.rst:415
msgid "``\"pymalloc_debug\"``"
msgstr "``\"pymalloc_debug\"``"

#: ../../c-api/memory.rst:415 ../../c-api/memory.rst:417
msgid "``malloc`` + debug"
msgstr "``malloc`` + depuração"

#: ../../c-api/memory.rst:415
msgid "``pymalloc`` + debug"
msgstr "``pymalloc`` + depuração"

#: ../../c-api/memory.rst:416
msgid "Release build, without pymalloc"
msgstr "Compilação de lançamento, sem pymalloc"

#: ../../c-api/memory.rst:416
msgid "``\"malloc\"``"
msgstr "``\"malloc\"``"

#: ../../c-api/memory.rst:417
msgid "Debug build, without pymalloc"
msgstr "Compilação de depuração, sem pymalloc"

#: ../../c-api/memory.rst:417
msgid "``\"malloc_debug\"``"
msgstr "``\"malloc_debug\"``"

#: ../../c-api/memory.rst:420
msgid "Legend:"
msgstr "Legenda:"

#: ../../c-api/memory.rst:422
msgid "Name: value for :envvar:`PYTHONMALLOC` environment variable."
msgstr "Nome: valor para a variável de ambiente :envvar:`PYTHONMALLOC`."

#: ../../c-api/memory.rst:423
msgid ""
"``malloc``: system allocators from the standard C library, C functions: :c:"
"func:`malloc`, :c:func:`calloc`, :c:func:`realloc` and :c:func:`free`."
msgstr ""
"``malloc``: alocadores do sistema da biblioteca C padrão, funções C: :c:func:"
"`malloc`, :c:func:`calloc`, :c:func:`realloc` e :c:func:`free`."

#: ../../c-api/memory.rst:425
msgid "``pymalloc``: :ref:`pymalloc memory allocator <pymalloc>`."
msgstr "``pymalloc``: :ref:`alocador de memória pymalloc <pymalloc>`."

#: ../../c-api/memory.rst:426
msgid ""
"``mimalloc``: :ref:`mimalloc memory allocator <mimalloc>`.  The pymalloc "
"allocator will be used if mimalloc support isn't available."
msgstr ""
"``mimalloc``: :ref:`alocador de memória mimalloc <mimalloc>`. O alocador "
"pymalloc será usado se o suporte para mimalloc não estiver disponível."

#: ../../c-api/memory.rst:428
msgid ""
"\"+ debug\": with :ref:`debug hooks on the Python memory allocators <pymem-"
"debug-hooks>`."
msgstr ""
"\"+ depuração\": com :ref:`ganchos de depuração nos alocadores de memória do "
"Python <pymem-debug-hooks>`."

#: ../../c-api/memory.rst:430
msgid "\"Debug build\": :ref:`Python build in debug mode <debug-build>`."
msgstr ""
"\"Compilação de depuração\": :ref:`compilação do Python em modo de depuração "
"<debug-build>`. "

#: ../../c-api/memory.rst:435
msgid "Customize Memory Allocators"
msgstr "Personalizar Alocadores de Memória"

#: ../../c-api/memory.rst:441
msgid ""
"Structure used to describe a memory block allocator. The structure has the "
"following fields:"
msgstr ""
"Estrutura usada para descrever um alocador de blocos de memória. A estrutura "
"tem os seguintes campos:"

#: ../../c-api/memory.rst:445 ../../c-api/memory.rst:696
msgid "Field"
msgstr "Campo"

#: ../../c-api/memory.rst:445 ../../c-api/memory.rst:696
msgid "Meaning"
msgstr "Significado"

#: ../../c-api/memory.rst:447 ../../c-api/memory.rst:698
msgid "``void *ctx``"
msgstr "``void *ctx``"

#: ../../c-api/memory.rst:447 ../../c-api/memory.rst:698
msgid "user context passed as first argument"
msgstr "contexto do utilizador passado como primeiro argumento"

#: ../../c-api/memory.rst:449
msgid "``void* malloc(void *ctx, size_t size)``"
msgstr "``void* malloc(void *ctx, size_t size)``"

#: ../../c-api/memory.rst:449
msgid "allocate a memory block"
msgstr "alocar um bloco de memória"

#: ../../c-api/memory.rst:451
msgid "``void* calloc(void *ctx, size_t nelem, size_t elsize)``"
msgstr "``void* calloc(void *ctx, size_t nelem, size_t elsize)``"

#: ../../c-api/memory.rst:451
msgid "allocate a memory block initialized with zeros"
msgstr "alocar um bloco de memória inicializado com zeros"

#: ../../c-api/memory.rst:454
msgid "``void* realloc(void *ctx, void *ptr, size_t new_size)``"
msgstr "``void* realloc(void *ctx, void *ptr, size_t new_size)``"

#: ../../c-api/memory.rst:454
msgid "allocate or resize a memory block"
msgstr "alocar ou redimensionar um bloco de memória"

#: ../../c-api/memory.rst:456
msgid "``void free(void *ctx, void *ptr)``"
msgstr "``void free(void *ctx, void *ptr)``"

#: ../../c-api/memory.rst:456
msgid "free a memory block"
msgstr "libertar um bloco de memória"

#: ../../c-api/memory.rst:459
msgid ""
"The :c:type:`!PyMemAllocator` structure was renamed to :c:type:"
"`PyMemAllocatorEx` and a new ``calloc`` field was added."
msgstr ""
"A estrutura :c:type:`!PyMemAllocator` foi renomeada para :c:type:"
"`PyMemAllocatorEx` e foi adicionado um novo campo ``calloc``."

#: ../../c-api/memory.rst:466
msgid "Enum used to identify an allocator domain. Domains:"
msgstr "Enum usado para identificar um domínio de alocação. Domínios:"

#: ../../c-api/memory.rst:472 ../../c-api/memory.rst:481
#: ../../c-api/memory.rst:490
msgid "Functions:"
msgstr "Funções:"

#: ../../c-api/memory.rst:474
msgid ":c:func:`PyMem_RawMalloc`"
msgstr ":c:func:`PyMem_RawMalloc`"

#: ../../c-api/memory.rst:475
msgid ":c:func:`PyMem_RawRealloc`"
msgstr ":c:func:`PyMem_RawRealloc`"

#: ../../c-api/memory.rst:476
msgid ":c:func:`PyMem_RawCalloc`"
msgstr ":c:func:`PyMem_RawCalloc`"

#: ../../c-api/memory.rst:477
msgid ":c:func:`PyMem_RawFree`"
msgstr ":c:func:`PyMem_RawFree`"

#: ../../c-api/memory.rst:483
msgid ":c:func:`PyMem_Malloc`,"
msgstr ":c:func:`PyMem_Malloc`,"

#: ../../c-api/memory.rst:485
msgid ":c:func:`PyMem_Calloc`"
msgstr ":c:func:`PyMem_Calloc`"

#: ../../c-api/memory.rst:492
msgid ":c:func:`PyObject_Malloc`"
msgstr ":c:func:`PyObject_Malloc`"

#: ../../c-api/memory.rst:493
msgid ":c:func:`PyObject_Realloc`"
msgstr ":c:func:`PyObject_Realloc`"

#: ../../c-api/memory.rst:494
msgid ":c:func:`PyObject_Calloc`"
msgstr ":c:func:`PyObject_Calloc`"

#: ../../c-api/memory.rst:495
msgid ":c:func:`PyObject_Free`"
msgstr ":c:func:`PyObject_Free`"

#: ../../c-api/memory.rst:499
msgid "Get the memory block allocator of the specified domain."
msgstr "Obter o alocador de blocos de memória do domínio especificado."

#: ../../c-api/memory.rst:504
msgid "Set the memory block allocator of the specified domain."
msgstr "Definir o alocador de blocos de memória do domínio especificado."

#: ../../c-api/memory.rst:506
msgid ""
"The new allocator must return a distinct non-``NULL`` pointer when "
"requesting zero bytes."
msgstr ""
"O novo alocador deve retornar um ponteiro não-``NULL`` distinto ao solicitar "
"zero bytes."

#: ../../c-api/memory.rst:509
msgid ""
"For the :c:macro:`PYMEM_DOMAIN_RAW` domain, the allocator must be thread-"
"safe: the :term:`GIL <global interpreter lock>` is not held when the "
"allocator is called."
msgstr ""

#: ../../c-api/memory.rst:513
msgid ""
"For the remaining domains, the allocator must also be thread-safe: the "
"allocator may be called in different interpreters that do not share a "
"``GIL``."
msgstr ""

#: ../../c-api/memory.rst:517
msgid ""
"If the new allocator is not a hook (does not call the previous allocator), "
"the :c:func:`PyMem_SetupDebugHooks` function must be called to reinstall the "
"debug hooks on top on the new allocator."
msgstr ""
"Se o novo alocador não for um *hook* (não chama o alocador anterior), a "
"função :c:func:`PyMem_SetupDebugHooks` deve ser chamada para reinstalar os "
"*hooks* de depuração no novo alocador."

#: ../../c-api/memory.rst:521
msgid ""
"See also :c:member:`PyPreConfig.allocator` and :ref:`Preinitialize Python "
"with PyPreConfig <c-preinit>`."
msgstr ""
"Veja também :c:member:`PyPreConfig.allocator` e :ref:`Pré-inicializar o "
"Python com PyPreConfig <c-preinit>`."

#: ../../c-api/memory.rst:526
msgid ":c:func:`PyMem_SetAllocator` does have the following contract:"
msgstr ":c:func:`PyMem_SetAllocator` tem o seguinte contrato:"

#: ../../c-api/memory.rst:528
msgid ""
"It can be called after :c:func:`Py_PreInitialize` and before :c:func:"
"`Py_InitializeFromConfig` to install a custom memory allocator. There are no "
"restrictions over the installed allocator other than the ones imposed by the "
"domain (for instance, the Raw Domain allows the allocator to be called "
"without the GIL held). See :ref:`the section on allocator domains <allocator-"
"domains>` for more information."
msgstr ""

#: ../../c-api/memory.rst:536
msgid ""
"If called after Python has finish initializing (after :c:func:"
"`Py_InitializeFromConfig` has been called) the allocator **must** wrap the "
"existing allocator. Substituting the current allocator for some other "
"arbitrary one is **not supported**."
msgstr ""
"Se chamada após o Python ter terminado a inicialização (após :c:func:"
"`Py_InitializeFromConfig` ter sido chamada), o alocador **deve** encapsular "
"o alocador existente. Substituir o alocador atual por outro arbitrário **não "
"é suportado**."

#: ../../c-api/memory.rst:541
msgid "All allocators must be thread-safe."
msgstr "Todos os alocadores devem ser *thread-safe*."

#: ../../c-api/memory.rst:547
msgid ""
"Setup :ref:`debug hooks in the Python memory allocators <pymem-debug-hooks>` "
"to detect memory errors."
msgstr ""
"Configurar :ref:`*hooks* de depuração nos alocadores de memória do Python "
"<pymem-debug-hooks>` para detetar erros de memória."

#: ../../c-api/memory.rst:554
msgid "Debug hooks on the Python memory allocators"
msgstr "*Hooks* de depuração nos alocadores de memória do Python"

#: ../../c-api/memory.rst:556
msgid ""
"When :ref:`Python is built in debug mode <debug-build>`, the :c:func:"
"`PyMem_SetupDebugHooks` function is called at the :ref:`Python "
"preinitialization <c-preinit>` to setup debug hooks on Python memory "
"allocators to detect memory errors."
msgstr ""
"Quando o :ref:`Python é compilado em modo de depuração <debug-build>`, a "
"função :c:func:`PyMem_SetupDebugHooks` é chamada durante a :ref:`pré-"
"inicialização do Python <c-preinit>` para configurar *hooks* de depuração "
"nos alocadores de memória do Python e detetar erros de memória."

#: ../../c-api/memory.rst:561
msgid ""
"The :envvar:`PYTHONMALLOC` environment variable can be used to install debug "
"hooks on a Python compiled in release mode (ex: ``PYTHONMALLOC=debug``)."
msgstr ""
"A variável de ambiente :envvar:`PYTHONMALLOC` pode ser usada para instalar "
"*hooks* de depuração num Python compilado em modo de lançamento (ex: "
"``PYTHONMALLOC=debug``)."

#: ../../c-api/memory.rst:564
msgid ""
"The :c:func:`PyMem_SetupDebugHooks` function can be used to set debug hooks "
"after calling :c:func:`PyMem_SetAllocator`."
msgstr ""
"A função :c:func:`PyMem_SetupDebugHooks` pode ser usada para definir *hooks* "
"de depuração após chamar :c:func:`PyMem_SetAllocator`."

#: ../../c-api/memory.rst:567
msgid ""
"These debug hooks fill dynamically allocated memory blocks with special, "
"recognizable bit patterns. Newly allocated memory is filled with the byte "
"``0xCD`` (``PYMEM_CLEANBYTE``), freed memory is filled with the byte "
"``0xDD`` (``PYMEM_DEADBYTE``). Memory blocks are surrounded by \"forbidden "
"bytes\" filled with the byte ``0xFD`` (``PYMEM_FORBIDDENBYTE``). Strings of "
"these bytes are unlikely to be valid addresses, floats, or ASCII strings."
msgstr ""
"Estes *hooks* de depuração preenchem blocos de memória alocados "
"dinamicamente com padrões de bits especiais e reconhecíveis. A memória recém-"
"alocada é preenchida com o byte ``0xCD`` (``PYMEM_CLEANBYTE``), a memória "
"libertada é preenchida com o byte ``0xDD`` (``PYMEM_DEADBYTE``). Os blocos "
"de memória são rodeados por \"bytes proibidos\" preenchidos com o byte "
"``0xFD`` (``PYMEM_FORBIDDENBYTE``). Cadeias destes bytes são improváveis de "
"serem endereços, floats ou cadeias ASCII válidos."

#: ../../c-api/memory.rst:574
msgid "Runtime checks:"
msgstr "Verificações em tempo de execução:"

#: ../../c-api/memory.rst:576
msgid ""
"Detect API violations. For example, detect if :c:func:`PyObject_Free` is "
"called on a memory block allocated by :c:func:`PyMem_Malloc`."
msgstr ""
"Detetar violações da API. Por exemplo, detetar se :c:func:`PyObject_Free` é "
"chamada num bloco de memória alocado por :c:func:`PyMem_Malloc`."

#: ../../c-api/memory.rst:578
msgid "Detect write before the start of the buffer (buffer underflow)."
msgstr "Detetar escrita antes do início do buffer (*buffer underflow*)."

#: ../../c-api/memory.rst:579
msgid "Detect write after the end of the buffer (buffer overflow)."
msgstr "Detetar escrita após o fim do buffer (*buffer overflow*)."

#: ../../c-api/memory.rst:580
msgid ""
"Check that the :term:`GIL <global interpreter lock>` is held when allocator "
"functions of :c:macro:`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`) "
"and :c:macro:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) domains are "
"called."
msgstr ""
"Verificar se o :term:`GIL <global interpreter lock>` está retido quando as "
"funções de alocação dos domínios :c:macro:`PYMEM_DOMAIN_OBJ` (ex: :c:func:"
"`PyObject_Malloc`) e :c:macro:`PYMEM_DOMAIN_MEM` (ex: :c:func:"
"`PyMem_Malloc`) são chamadas."

#: ../../c-api/memory.rst:585
msgid ""
"On error, the debug hooks use the :mod:`tracemalloc` module to get the "
"traceback where a memory block was allocated. The traceback is only "
"displayed if :mod:`tracemalloc` is tracing Python memory allocations and the "
"memory block was traced."
msgstr ""
"Em caso de erro, os *hooks* de depuração usam o módulo :mod:`tracemalloc` "
"para obter o *traceback* de onde um bloco de memória foi alocado. O "
"*traceback* só é apresentado se o :mod:`tracemalloc` estiver a traçar "
"alocações de memória do Python e o bloco de memória tiver sido traçado."

#: ../../c-api/memory.rst:590
msgid ""
"Let *S* = ``sizeof(size_t)``. ``2*S`` bytes are added at each end of each "
"block of *N* bytes requested.  The memory layout is like so, where p "
"represents the address returned by a malloc-like or realloc-like function "
"(``p[i:j]`` means the slice of bytes from ``*(p+i)`` inclusive up to "
"``*(p+j)`` exclusive; note that the treatment of negative indices differs "
"from a Python slice):"
msgstr ""
"Seja *S* = ``sizeof(size_t)``. ``2*S`` bytes são adicionados em cada "
"extremidade de cada bloco de *N* bytes solicitados. O *layout* da memória é "
"como segue, onde p representa o endereço retornado por uma função do tipo "
"malloc ou realloc (``p[i:j]`` significa a fatia de bytes de ``*(p+i)`` "
"inclusive até ``*(p+j)`` exclusivo; note que o tratamento de índices "
"negativos difere de uma fatia Python):"

#: ../../c-api/memory.rst:596
msgid "``p[-2*S:-S]``"
msgstr "``p[-2*S:-S]``"

#: ../../c-api/memory.rst:597
msgid ""
"Number of bytes originally asked for.  This is a size_t, big-endian (easier "
"to read in a memory dump)."
msgstr ""
"Número de bytes originalmente solicitados. Isto é um size_t, em *big-endian* "
"(mais fácil de ler num *dump* de memória)."

#: ../../c-api/memory.rst:599
msgid "``p[-S]``"
msgstr "``p[-S]``"

#: ../../c-api/memory.rst:600
msgid "API identifier (ASCII character):"
msgstr "Identificador da API (caractere ASCII):"

#: ../../c-api/memory.rst:602
msgid "``'r'`` for :c:macro:`PYMEM_DOMAIN_RAW`."
msgstr "``'r'`` para :c:macro:`PYMEM_DOMAIN_RAW`."

#: ../../c-api/memory.rst:603
msgid "``'m'`` for :c:macro:`PYMEM_DOMAIN_MEM`."
msgstr "``'m'`` para :c:macro:`PYMEM_DOMAIN_MEM`."

#: ../../c-api/memory.rst:604
msgid "``'o'`` for :c:macro:`PYMEM_DOMAIN_OBJ`."
msgstr "``'o'`` para :c:macro:`PYMEM_DOMAIN_OBJ`."

#: ../../c-api/memory.rst:606
msgid "``p[-S+1:0]``"
msgstr "``p[-S+1:0]``"

#: ../../c-api/memory.rst:607
msgid "Copies of PYMEM_FORBIDDENBYTE.  Used to catch under- writes and reads."
msgstr ""
"Cópias de PYMEM_FORBIDDENBYTE. Usado para detetar escritas e leituras abaixo "
"do limite."

#: ../../c-api/memory.rst:609
msgid "``p[0:N]``"
msgstr "``p[0:N]``"

#: ../../c-api/memory.rst:610
msgid ""
"The requested memory, filled with copies of PYMEM_CLEANBYTE, used to catch "
"reference to uninitialized memory.  When a realloc-like function is called "
"requesting a larger memory block, the new excess bytes are also filled with "
"PYMEM_CLEANBYTE.  When a free-like function is called, these are overwritten "
"with PYMEM_DEADBYTE, to catch reference to freed memory.  When a realloc- "
"like function is called requesting a smaller memory block, the excess old "
"bytes are also filled with PYMEM_DEADBYTE."
msgstr ""
"A memória solicitada, preenchida com cópias de PYMEM_CLEANBYTE, usada para "
"detetar referências a memória não inicializada. Quando uma função do tipo "
"realloc é chamada solicitando um bloco de memória maior, os novos bytes em "
"excesso também são preenchidos com PYMEM_CLEANBYTE. Quando uma função do "
"tipo free é chamada, estes são sobrescritos com PYMEM_DEADBYTE, para detetar "
"referências a memória libertada. Quando uma função do tipo realloc é chamada "
"solicitando um bloco de memória menor, os bytes antigos em excesso também "
"são preenchidos com PYMEM_DEADBYTE."

#: ../../c-api/memory.rst:618
msgid "``p[N:N+S]``"
msgstr "``p[N:N+S]``"

#: ../../c-api/memory.rst:619
msgid "Copies of PYMEM_FORBIDDENBYTE.  Used to catch over- writes and reads."
msgstr ""
"Cópias de PYMEM_FORBIDDENBYTE. Usado para detetar escritas e leituras acima "
"do limite."

#: ../../c-api/memory.rst:621
msgid "``p[N+S:N+2*S]``"
msgstr "``p[N+S:N+2*S]``"

#: ../../c-api/memory.rst:622
msgid ""
"Only used if the ``PYMEM_DEBUG_SERIALNO`` macro is defined (not defined by "
"default)."
msgstr ""
"Apenas usado se a macro ``PYMEM_DEBUG_SERIALNO`` estiver definida (não "
"definida por predefinição)."

#: ../../c-api/memory.rst:625
msgid ""
"A serial number, incremented by 1 on each call to a malloc-like or realloc-"
"like function.  Big-endian :c:type:`size_t`.  If \"bad memory\" is detected "
"later, the serial number gives an excellent way to set a breakpoint on the "
"next run, to capture the instant at which this block was passed out.  The "
"static function bumpserialno() in obmalloc.c is the only place the serial "
"number is incremented, and exists so you can set such a breakpoint easily."
msgstr ""
"Um número de série, incrementado em 1 em cada chamada a uma função do tipo "
"malloc ou realloc. :c:type:`size_t` em *big-endian*. Se for detetada "
"\"memória corrompida\" mais tarde, o número de série fornece uma excelente "
"forma de definir um *breakpoint* na próxima execução, para capturar o "
"instante em que este bloco foi passado. A função estática bumpserialno() em "
"obmalloc.c é o único local onde o número de série é incrementado, e existe "
"para que possa definir facilmente tal *breakpoint*."

#: ../../c-api/memory.rst:632
msgid ""
"A realloc-like or free-like function first checks that the "
"PYMEM_FORBIDDENBYTE bytes at each end are intact.  If they've been altered, "
"diagnostic output is written to stderr, and the program is aborted via "
"Py_FatalError().  The other main failure mode is provoking a memory error "
"when a program reads up one of the special bit patterns and tries to use it "
"as an address.  If you get in a debugger then and look at the object, you're "
"likely to see that it's entirely filled with PYMEM_DEADBYTE (meaning freed "
"memory is getting used) or PYMEM_CLEANBYTE (meaning uninitialized memory is "
"getting used)."
msgstr ""
"Uma função do tipo realloc ou free verifica primeiro se os bytes "
"PYMEM_FORBIDDENBYTE em cada extremidade estão intactos. Se tiverem sido "
"alterados, é escrita saída de diagnóstico para stderr, e o programa é "
"abortado via Py_FatalError(). O outro modo principal de falha é provocar um "
"erro de memória quando um programa lê um dos padrões de bits especiais e "
"tenta usá-lo como um endereço. Se entrar num depurador nesse momento e "
"observar o objeto, é provável que veja que está completamente preenchido com "
"PYMEM_DEADBYTE (significando que memória libertada está a ser usada) ou "
"PYMEM_CLEANBYTE (significando que memória não inicializada está a ser usada)."

#: ../../c-api/memory.rst:641
msgid ""
"The :c:func:`PyMem_SetupDebugHooks` function now also works on Python "
"compiled in release mode.  On error, the debug hooks now use :mod:"
"`tracemalloc` to get the traceback where a memory block was allocated. The "
"debug hooks now also check if the GIL is held when functions of :c:macro:"
"`PYMEM_DOMAIN_OBJ` and :c:macro:`PYMEM_DOMAIN_MEM` domains are called."
msgstr ""

#: ../../c-api/memory.rst:649
msgid ""
"Byte patterns ``0xCB`` (``PYMEM_CLEANBYTE``), ``0xDB`` (``PYMEM_DEADBYTE``) "
"and ``0xFB`` (``PYMEM_FORBIDDENBYTE``) have been replaced with ``0xCD``, "
"``0xDD`` and ``0xFD`` to use the same values than Windows CRT debug "
"``malloc()`` and ``free()``."
msgstr ""
"Os padrões de bytes ``0xCB`` (``PYMEM_CLEANBYTE``), ``0xDB`` "
"(``PYMEM_DEADBYTE``) e ``0xFB`` (``PYMEM_FORBIDDENBYTE``) foram substituídos "
"por ``0xCD``, ``0xDD`` e ``0xFD`` para usar os mesmos valores que o "
"``malloc()`` e ``free()`` de depuração da CRT do Windows."

#: ../../c-api/memory.rst:659
msgid "The pymalloc allocator"
msgstr "O alocador pymalloc"

#: ../../c-api/memory.rst:661
msgid ""
"Python has a *pymalloc* allocator optimized for small objects (smaller or "
"equal to 512 bytes) with a short lifetime. It uses memory mappings called "
"\"arenas\" with a fixed size of either 256 KiB on 32-bit platforms or 1 MiB "
"on 64-bit platforms. It falls back to :c:func:`PyMem_RawMalloc` and :c:func:"
"`PyMem_RawRealloc` for allocations larger than 512 bytes."
msgstr ""
"O Python tem um alocador *pymalloc* otimizado para objetos pequenos (menores "
"ou iguais a 512 bytes) com um tempo de vida curto. Utiliza mapeamentos de "
"memória chamados \"arenas\" com um tamanho fixo de 256 KiB em plataformas de "
"32 bits ou 1 MiB em plataformas de 64 bits. Recorre a :c:func:"
"`PyMem_RawMalloc` e :c:func:`PyMem_RawRealloc` para alocações maiores que "
"512 bytes."

#: ../../c-api/memory.rst:667
msgid ""
"*pymalloc* is the :ref:`default allocator <default-memory-allocators>` of "
"the :c:macro:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) and :c:macro:"
"`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`) domains."
msgstr ""
"O *pymalloc* é o :ref:`alocador predefinido <default-memory-allocators>` dos "
"domínios :c:macro:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) e :c:macro:"
"`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`)."

#: ../../c-api/memory.rst:671
msgid "The arena allocator uses the following functions:"
msgstr "O alocador de arenas usa as seguintes funções:"

#: ../../c-api/memory.rst:673
msgid ":c:func:`!VirtualAlloc` and :c:func:`!VirtualFree` on Windows,"
msgstr ":c:func:`!VirtualAlloc` e :c:func:`!VirtualFree` no Windows,"

#: ../../c-api/memory.rst:674
msgid ":c:func:`!mmap` and :c:func:`!munmap` if available,"
msgstr ":c:func:`!mmap` e :c:func:`!munmap` se disponíveis,"

#: ../../c-api/memory.rst:675
msgid ":c:func:`malloc` and :c:func:`free` otherwise."
msgstr ":c:func:`malloc` e :c:func:`free` caso contrário."

#: ../../c-api/memory.rst:677
msgid ""
"This allocator is disabled if Python is configured with the :option:`--"
"without-pymalloc` option. It can also be disabled at runtime using the :"
"envvar:`PYTHONMALLOC` environment variable (ex: ``PYTHONMALLOC=malloc``)."
msgstr ""
"Este alocador está desativado se o Python for configurado com a opção :"
"option:`--without-pymalloc`. Também pode ser desativado em tempo de execução "
"usando a variável de ambiente :envvar:`PYTHONMALLOC` (ex: "
"``PYTHONMALLOC=malloc``)."

#: ../../c-api/memory.rst:681
msgid ""
"Typically, it makes sense to disable the pymalloc allocator when building "
"Python with AddressSanitizer (:option:`--with-address-sanitizer`) which "
"helps uncover low level bugs within the C code."
msgstr ""
"Normalmente, faz sentido desativar o alocador pymalloc ao compilar o Python "
"com AddressSanitizer (:option:`--with-address-sanitizer`), que ajuda a "
"descobrir erros de baixo nível no código C."

#: ../../c-api/memory.rst:686
msgid "Customize pymalloc Arena Allocator"
msgstr "Personalizar o Alocador de Arenas do pymalloc"

#: ../../c-api/memory.rst:692
msgid ""
"Structure used to describe an arena allocator. The structure has three "
"fields:"
msgstr ""
"Estrutura usada para descrever um alocador de arenas. A estrutura tem três "
"campos:"

#: ../../c-api/memory.rst:700
msgid "``void* alloc(void *ctx, size_t size)``"
msgstr "``void* alloc(void *ctx, size_t size)``"

#: ../../c-api/memory.rst:700
msgid "allocate an arena of size bytes"
msgstr "alocar uma arena de tamanho *bytes*"

#: ../../c-api/memory.rst:702
msgid "``void free(void *ctx, void *ptr, size_t size)``"
msgstr "``void free(void *ctx, void *ptr, size_t size)``"

#: ../../c-api/memory.rst:702
msgid "free an arena"
msgstr "libertar uma arena"

#: ../../c-api/memory.rst:707
msgid "Get the arena allocator."
msgstr "Obter o alocador de arenas."

#: ../../c-api/memory.rst:711
msgid "Set the arena allocator."
msgstr "Definir o alocador de arenas."

#: ../../c-api/memory.rst:716
msgid "The mimalloc allocator"
msgstr "O alocador mimalloc"

#: ../../c-api/memory.rst:720
msgid ""
"Python supports the mimalloc allocator when the underlying platform support "
"is available. mimalloc \"is a general purpose allocator with excellent "
"performance characteristics. Initially developed by Daan Leijen for the "
"runtime systems of the Koka and Lean languages.\""
msgstr ""
"O Python suporta o alocador mimalloc quando o suporte da plataforma "
"subjacente estiver disponível. O mimalloc \"é um alocador de uso geral com "
"excelentes características de desempenho. Desenvolvido inicialmente por Daan "
"Leijen para os sistemas de execução das linguagens Koka e Lean.\""

#: ../../c-api/memory.rst:725
msgid "tracemalloc C API"
msgstr "API C do tracemalloc"

#: ../../c-api/memory.rst:731
msgid "Track an allocated memory block in the :mod:`tracemalloc` module."
msgstr "Rastrear um bloco de memória alocado no módulo :mod:`tracemalloc`."

#: ../../c-api/memory.rst:733
msgid ""
"Return ``0`` on success, return ``-1`` on error (failed to allocate memory "
"to store the trace). Return ``-2`` if tracemalloc is disabled."
msgstr ""
"Retorna ``0`` em caso de sucesso, ``-1`` em caso de erro (falha ao alocar "
"memória para armazenar o rastreio). Retorna ``-2`` se o tracemalloc estiver "
"desativado."

#: ../../c-api/memory.rst:736
msgid "If memory block is already tracked, update the existing trace."
msgstr ""
"Se o bloco de memória já estiver a ser rastreado, atualizar o rastreio "
"existente."

#: ../../c-api/memory.rst:740
msgid ""
"Untrack an allocated memory block in the :mod:`tracemalloc` module. Do "
"nothing if the block was not tracked."
msgstr ""
"Deixar de rastrear um bloco de memória alocado no módulo :mod:`tracemalloc`. "
"Não fazer nada se o bloco não estiver a ser rastreado."

#: ../../c-api/memory.rst:743
msgid "Return ``-2`` if tracemalloc is disabled, otherwise return ``0``."
msgstr ""
"Retorna ``-2`` se o tracemalloc estiver desativado, caso contrário retorna "
"``0``."

#: ../../c-api/memory.rst:749
msgid "Examples"
msgstr "Exemplos"

#: ../../c-api/memory.rst:751
msgid ""
"Here is the example from section :ref:`memoryoverview`, rewritten so that "
"the I/O buffer is allocated from the Python heap by using the first function "
"set::"
msgstr ""
"Aqui está o exemplo da secção :ref:`memoryoverview`, reescrito de forma a "
"que o buffer de I/O seja alocado a partir do *heap* do Python usando o "
"primeiro conjunto de funções::"

#: ../../c-api/memory.rst:754
msgid ""
"PyObject *res;\n"
"char *buf = (char *) PyMem_Malloc(BUFSIZ); /* for I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"/* ...Do some I/O operation involving buf... */\n"
"res = PyBytes_FromString(buf);\n"
"PyMem_Free(buf); /* allocated with PyMem_Malloc */\n"
"return res;"
msgstr ""
"PyObject *res;\n"
"char *buf = (char *) PyMem_Malloc(BUFSIZ); /* para I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"/* ...Efetuar alguma operação de I/O envolvendo buf... */\n"
"res = PyBytes_FromString(buf);\n"
"PyMem_Free(buf); /* alocado com PyMem_Malloc */\n"
"return res;"

#: ../../c-api/memory.rst:764
msgid "The same code using the type-oriented function set::"
msgstr "O mesmo código usando o conjunto de funções orientadas a tipos::"

#: ../../c-api/memory.rst:766
msgid ""
"PyObject *res;\n"
"char *buf = PyMem_New(char, BUFSIZ); /* for I/O */\n"
"\n"
"if (buf == NULL)\n"
"    return PyErr_NoMemory();\n"
"/* ...Do some I/O operation involving buf... */\n"
"res = PyBytes_FromString(buf);\n"
"PyMem_Del(buf); /* allocated with PyMem_New */\n"
"return res;"
msgstr ""

#: ../../c-api/memory.rst:776
msgid ""
"Note that in the two examples above, the buffer is always manipulated via "
"functions belonging to the same set. Indeed, it is required to use the same "
"memory API family for a given memory block, so that the risk of mixing "
"different allocators is reduced to a minimum. The following code sequence "
"contains two errors, one of which is labeled as *fatal* because it mixes two "
"different allocators operating on different heaps. ::"
msgstr ""
"Note que nos dois exemplos acima, o buffer é sempre manipulado através de "
"funções pertencentes ao mesmo conjunto. De facto, é necessário usar a mesma "
"família de API de memória para um determinado bloco de memória, de forma a "
"reduzir ao mínimo o risco de misturar alocadores diferentes. A seguinte "
"sequência de código contém dois erros, um dos quais é rotulado como *fatal* "
"porque mistura dois alocadores que operam em *heaps* diferentes.::"

#: ../../c-api/memory.rst:783
msgid ""
"char *buf1 = PyMem_New(char, BUFSIZ);\n"
"char *buf2 = (char *) malloc(BUFSIZ);\n"
"char *buf3 = (char *) PyMem_Malloc(BUFSIZ);\n"
"...\n"
"PyMem_Del(buf3);  /* Wrong -- should be PyMem_Free() */\n"
"free(buf2);       /* Right -- allocated via malloc() */\n"
"free(buf1);       /* Fatal -- should be PyMem_Del()  */"
msgstr ""

#: ../../c-api/memory.rst:791
msgid ""
"In addition to the functions aimed at handling raw memory blocks from the "
"Python heap, objects in Python are allocated and released with :c:macro:"
"`PyObject_New`, :c:macro:`PyObject_NewVar` and :c:func:`PyObject_Del`."
msgstr ""

#: ../../c-api/memory.rst:795
msgid ""
"These will be explained in the next chapter on defining and implementing new "
"object types in C."
msgstr ""
"Estas serão explicadas no próximo capítulo sobre a definição e implementação "
"de novos tipos de objetos em C."

#: ../../c-api/memory.rst:43
msgid "malloc (C function)"
msgstr "malloc (função C)"

#: ../../c-api/memory.rst:43
msgid "calloc (C function)"
msgstr "calloc (função C)"

#: ../../c-api/memory.rst:43
msgid "realloc (C function)"
msgstr "realloc (função C)"

#: ../../c-api/memory.rst:43
msgid "free (C function)"
msgstr "free (função C)"
