# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# python-doc bot, 2025
# André Moreira <afrmscb@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-25 18:05+0000\n"
"PO-Revision-Date: 2025-09-22 17:54+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % 1000000 == 0 ? 1 : 2;\n"

#: ../../c-api/memory.rst:8
msgid "Memory Management"
msgstr "Gestão de Memória"

#: ../../c-api/memory.rst:17
msgid "Overview"
msgstr "Visão Geral"

#: ../../c-api/memory.rst:19
msgid ""
"Memory management in Python involves a private heap containing all Python "
"objects and data structures. The management of this private heap is ensured "
"internally by the *Python memory manager*.  The Python memory manager has "
"different components which deal with various dynamic storage management "
"aspects, like sharing, segmentation, preallocation or caching."
msgstr ""
"A gestão de memória em Python envolve um *heap* privado que contém todos os "
"objetos e estruturas de dados Python. A gestão deste *heap* privado é "
"garantida internamente pelo *gestor de memória do Python*. O gestor de "
"memória do Python tem diferentes componentes que lidam com vários aspetos da"
" gestão dinâmica de armazenamento, como partilha, segmentação, pré-alocação "
"ou cache."

#: ../../c-api/memory.rst:25
msgid ""
"At the lowest level, a raw memory allocator ensures that there is enough "
"room in the private heap for storing all Python-related data by interacting "
"with the memory manager of the operating system. On top of the raw memory "
"allocator, several object-specific allocators operate on the same heap and "
"implement distinct memory management policies adapted to the peculiarities "
"of every object type. For example, integer objects are managed differently "
"within the heap than strings, tuples or dictionaries because integers imply "
"different storage requirements and speed/space tradeoffs. The Python memory "
"manager thus delegates some of the work to the object-specific allocators, "
"but ensures that the latter operate within the bounds of the private heap."
msgstr ""
"Ao nível mais baixo, um alocador de memória bruta garante que existe espaço "
"suficiente no *heap* privado para armazenar todos os dados relacionados com "
"Python, interagindo com o gestor de memória do sistema operativo. Por cima "
"do alocador de memória bruta, vários alocadores específicos de objetos "
"operam no mesmo *heap* e implementam políticas distintas de gestão de "
"memória, adaptadas às particularidades de cada tipo de objeto. Por exemplo, "
"os objetos inteiros são geridos de forma diferente no *heap* em relação a "
"cadeias de caracteres, tuplos ou dicionários, porque os inteiros implicam "
"requisitos de armazenamento e compromissos de velocidade/espaço distintos. O"
" gestor de memória do Python delega, assim, parte do trabalho aos alocadores"
" específicos de objetos, mas garante que estes operam dentro dos limites do "
"*heap* privado."

#: ../../c-api/memory.rst:36
msgid ""
"It is important to understand that the management of the Python heap is "
"performed by the interpreter itself and that the user has no control over "
"it, even if they regularly manipulate object pointers to memory blocks "
"inside that heap.  The allocation of heap space for Python objects and other"
" internal buffers is performed on demand by the Python memory manager "
"through the Python/C API functions listed in this document."
msgstr ""
"É importante compreender que a gestão do *heap* do Python é realizada pelo "
"próprio intérprete e que o utilizador não tem controlo sobre ela, mesmo que "
"manipule regularmente ponteiros de objetos para blocos de memória dentro "
"desse *heap*. A alocação de espaço no *heap* para objetos Python e outros "
"buffers internos é realizada sob pedido pelo gestor de memória do Python, "
"através das funções da API C/Python listadas neste documento."

#: ../../c-api/memory.rst:49
msgid ""
"To avoid memory corruption, extension writers should never try to operate on"
" Python objects with the functions exported by the C library: "
":c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` and :c:func:`free`.  "
"This will result in  mixed calls between the C allocator and the Python "
"memory manager with fatal consequences, because they implement different "
"algorithms and operate on different heaps.  However, one may safely allocate"
" and release memory blocks with the C library allocator for individual "
"purposes, as shown in the following example::"
msgstr ""
"Para evitar corrupção de memória, os programadores de extensões nunca devem "
"tentar operar em objetos Python com as funções exportadas pela biblioteca C:"
" :c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` e :c:func:`free`. "
"Isto resultará em chamadas misturadas entre o alocador C e o gestor de "
"memória do Python, com consequências fatais, porque implementam algoritmos "
"diferentes e operam em *heaps* distintos. No entanto, pode-se alocar e "
"libertar blocos de memória com o alocador da biblioteca C para fins "
"individuais, como mostrado no exemplo seguinte::"

#: ../../c-api/memory.rst:68
msgid ""
"In this example, the memory request for the I/O buffer is handled by the C "
"library allocator. The Python memory manager is involved only in the "
"allocation of the bytes object returned as a result."
msgstr ""
"Neste exemplo, o pedido de memória para o buffer de I/O é tratado pelo "
"alocador da biblioteca C. O gestor de memória do Python está envolvido "
"apenas na alocação do objeto bytes retornado como resultado."

#: ../../c-api/memory.rst:72
msgid ""
"In most situations, however, it is recommended to allocate memory from the "
"Python heap specifically because the latter is under control of the Python "
"memory manager. For example, this is required when the interpreter is "
"extended with new object types written in C. Another reason for using the "
"Python heap is the desire to *inform* the Python memory manager about the "
"memory needs of the extension module. Even when the requested memory is used"
" exclusively for internal, highly-specific purposes, delegating all memory "
"requests to the Python memory manager causes the interpreter to have a more "
"accurate image of its memory footprint as a whole. Consequently, under "
"certain circumstances, the Python memory manager may or may not trigger "
"appropriate actions, like garbage collection, memory compaction or other "
"preventive procedures. Note that by using the C library allocator as shown "
"in the previous example, the allocated memory for the I/O buffer escapes "
"completely the Python memory manager."
msgstr ""

#: ../../c-api/memory.rst:88
msgid ""
"The :envvar:`PYTHONMALLOC` environment variable can be used to configure the"
" memory allocators used by Python."
msgstr ""
"A variável de ambiente :envvar:`PYTHONMALLOC` pode ser usada para configurar"
" os alocadores de memória usados pelo Python."

#: ../../c-api/memory.rst:91
msgid ""
"The :envvar:`PYTHONMALLOCSTATS` environment variable can be used to print "
"statistics of the :ref:`pymalloc memory allocator <pymalloc>` every time a "
"new pymalloc object arena is created, and on shutdown."
msgstr ""
"A variável de ambiente :envvar:`PYTHONMALLOCSTATS` pode ser usada para "
"imprimir estatísticas do alocador de memória :ref:`pymalloc <pymalloc>` "
"sempre que uma nova arena de objetos pymalloc é criada e no encerramento."

#: ../../c-api/memory.rst:97
msgid "Raw Memory Interface"
msgstr "Interface de Memória Raw"

#: ../../c-api/memory.rst:99
msgid ""
"The following function sets are wrappers to the system allocator. These "
"functions are thread-safe, the :term:`GIL <global interpreter lock>` does "
"not need to be held."
msgstr ""

#: ../../c-api/memory.rst:103
msgid ""
"The :ref:`default raw memory allocator <default-memory-allocators>` uses the"
" following functions: :c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` "
"and :c:func:`free`; call ``malloc(1)`` (or ``calloc(1, 1)``) when requesting"
" zero bytes."
msgstr ""

#: ../../c-api/memory.rst:112 ../../c-api/memory.rst:183
#: ../../c-api/memory.rst:285
msgid ""
"Allocates *n* bytes and returns a pointer of type :c:type:`void*` to the "
"allocated memory, or ``NULL`` if the request fails."
msgstr ""

#: ../../c-api/memory.rst:115
msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyMem_RawMalloc(1)`` had been called instead. The memory will not "
"have been initialized in any way."
msgstr ""
"Solicitar zero bytes retorna um ponteiro não-``NULL`` distinto, se possível,"
" como se ``PyMem_RawMalloc(1)`` tivesse sido chamado. A memória não será "
"inicializada de nenhuma forma."

#: ../../c-api/memory.rst:122 ../../c-api/memory.rst:193
#: ../../c-api/memory.rst:295
msgid ""
"Allocates *nelem* elements each whose size in bytes is *elsize* and returns "
"a pointer of type :c:type:`void*` to the allocated memory, or ``NULL`` if "
"the request fails. The memory is initialized to zeros."
msgstr ""

#: ../../c-api/memory.rst:126
msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyMem_RawCalloc(1, 1)`` had been "
"called instead."
msgstr ""
"Solicitar zero elementos ou elementos com tamanho de zero bytes retorna um "
"ponteiro não-``NULL`` distinto, se possível, como se ``PyMem_RawCalloc(1, "
"1)`` tivesse sido chamado."

#: ../../c-api/memory.rst:135 ../../c-api/memory.rst:206
#: ../../c-api/memory.rst:308
msgid ""
"Resizes the memory block pointed to by *p* to *n* bytes. The contents will "
"be unchanged to the minimum of the old and the new sizes."
msgstr ""
"Redimensiona o bloco de memória apontado por *p* para *n* bytes. O conteúdo "
"será inalterado até ao mínimo dos tamanhos antigo e novo."

#: ../../c-api/memory.rst:138
msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyMem_RawMalloc(n)``; else "
"if *n* is equal to zero, the memory block is resized but is not freed, and "
"the returned pointer is non-``NULL``."
msgstr ""
"Se *p* for ``NULL``, a chamada é equivalente a ``PyMem_RawMalloc(n)``; caso "
"contrário, se *n* for igual a zero, o bloco de memória é redimensionado, mas"
" não libertado, e o ponteiro retornado é não-``NULL``."

#: ../../c-api/memory.rst:142
msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to "
":c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` or "
":c:func:`PyMem_RawCalloc`."
msgstr ""
"A menos que *p* seja ``NULL``, deve ter sido retornado por uma chamada "
"anterior a :c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` ou "
":c:func:`PyMem_RawCalloc`."

#: ../../c-api/memory.rst:146
msgid ""
"If the request fails, :c:func:`PyMem_RawRealloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Se o pedido falhar, :c:func:`PyMem_RawRealloc` retorna ``NULL`` e *p* "
"permanece um ponteiro válido para a área de memória anterior."

#: ../../c-api/memory.rst:152
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a"
" previous call to :c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` or "
":c:func:`PyMem_RawCalloc`.  Otherwise, or if ``PyMem_RawFree(p)`` has been "
"called before, undefined behavior occurs."
msgstr ""
"Liberta o bloco de memória apontado por *p*, que deve ter sido retornado por"
" uma chamada anterior a :c:func:`PyMem_RawMalloc`, "
":c:func:`PyMem_RawRealloc` ou :c:func:`PyMem_RawCalloc`. Caso contrário, ou "
"se ``PyMem_RawFree(p)`` tiver sido chamado anteriormente, ocorre "
"comportamento indefinido."

#: ../../c-api/memory.rst:157 ../../c-api/memory.rst:227
#: ../../c-api/memory.rst:329
msgid "If *p* is ``NULL``, no operation is performed."
msgstr "Se *p* for ``NULL``, nenhuma operação é realizada."

#: ../../c-api/memory.rst:163
msgid "Memory Interface"
msgstr "Interface de Memória"

#: ../../c-api/memory.rst:165 ../../c-api/memory.rst:271
msgid ""
"The following function sets, modeled after the ANSI C standard, but "
"specifying behavior when requesting zero bytes, are available for allocating"
" and releasing memory from the Python heap."
msgstr ""
"Os seguintes conjuntos de funções, modelados segundo o padrão ANSI C, mas "
"especificando o comportamento ao solicitar zero bytes, estão disponíveis "
"para alocar e libertar memória do *heap* do Python."

#: ../../c-api/memory.rst:169
msgid ""
"The :ref:`default memory allocator <default-memory-allocators>` uses the "
":ref:`pymalloc memory allocator <pymalloc>`."
msgstr ""
"O :ref:`alocador de memória predefinido <default-memory-allocators>` usa o "
":ref:`alocador de memória pymalloc <pymalloc>`."

#: ../../c-api/memory.rst:174 ../../c-api/memory.rst:280
msgid ""
"The :term:`GIL <global interpreter lock>` must be held when using these "
"functions."
msgstr ""

#: ../../c-api/memory.rst:179
msgid ""
"The default allocator is now pymalloc instead of system :c:func:`malloc`."
msgstr ""
"O alocador predefinido é agora o pymalloc em vez do :c:func:`malloc` do "
"sistema."

#: ../../c-api/memory.rst:186
msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyMem_Malloc(1)`` had been called instead. The memory will not have "
"been initialized in any way."
msgstr ""
"Solicitar zero bytes retorna um ponteiro não-``NULL`` distinto, se possível,"
" como se ``PyMem_Malloc(1)`` tivesse sido chamado. A memória não será "
"inicializada de nenhuma forma."

#: ../../c-api/memory.rst:197
msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyMem_Calloc(1, 1)`` had been "
"called instead."
msgstr ""
"Solicitar zero elementos ou elementos com tamanho de zero bytes retorna um "
"ponteiro não-``NULL`` distinto, se possível, como se ``PyMem_Calloc(1, 1)`` "
"tivesse sido chamado."

#: ../../c-api/memory.rst:209
msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyMem_Malloc(n)``; else if "
"*n* is equal to zero, the memory block is resized but is not freed, and the "
"returned pointer is non-``NULL``."
msgstr ""
"Se *p* for ``NULL``, a chamada é equivalente a ``PyMem_Malloc(n)``; caso "
"contrário, se *n* for igual a zero, o bloco de memória é redimensionado, mas"
" não libertado, e o ponteiro retornado é não-``NULL``."

#: ../../c-api/memory.rst:213
msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to "
":c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` or :c:func:`PyMem_Calloc`."
msgstr ""
"A menos que *p* seja ``NULL``, deve ter sido retornado por uma chamada "
"anterior a :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` ou "
":c:func:`PyMem_Calloc`."

#: ../../c-api/memory.rst:216
msgid ""
"If the request fails, :c:func:`PyMem_Realloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Se o pedido falhar, :c:func:`PyMem_Realloc` retorna ``NULL`` e *p* permanece"
" um ponteiro válido para a área de memória anterior."

#: ../../c-api/memory.rst:222
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a"
" previous call to :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` or "
":c:func:`PyMem_Calloc`.  Otherwise, or if ``PyMem_Free(p)`` has been called "
"before, undefined behavior occurs."
msgstr ""
"Liberta o bloco de memória apontado por *p*, que deve ter sido retornado por"
" uma chamada anterior a :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` ou "
":c:func:`PyMem_Calloc`. Caso contrário, ou se ``PyMem_Free(p)`` tiver sido "
"chamado anteriormente, ocorre comportamento indefinido."

#: ../../c-api/memory.rst:229
msgid ""
"The following type-oriented macros are provided for convenience.  Note  that"
" *TYPE* refers to any C type."
msgstr ""
"As seguintes macros orientadas a tipos são fornecidas por conveniência. Note"
" que *TYPE* refere-se a qualquer tipo C."

#: ../../c-api/memory.rst:235
msgid ""
"Same as :c:func:`PyMem_Malloc`, but allocates ``(n * sizeof(TYPE))`` bytes "
"of memory.  Returns a pointer cast to :c:type:`TYPE*`.  The memory will not "
"have been initialized in any way."
msgstr ""

#: ../../c-api/memory.rst:242
msgid ""
"Same as :c:func:`PyMem_Realloc`, but the memory block is resized to ``(n * "
"sizeof(TYPE))`` bytes.  Returns a pointer cast to :c:type:`TYPE*`. On "
"return, *p* will be a pointer to the new memory area, or ``NULL`` in the "
"event of failure."
msgstr ""

#: ../../c-api/memory.rst:247
msgid ""
"This is a C preprocessor macro; *p* is always reassigned.  Save the original"
" value of *p* to avoid losing memory when handling errors."
msgstr ""
"Esta é uma macro do pré-processador C; *p* é sempre reatribuído. Guarde o "
"valor original de *p* para evitar perder memória ao tratar erros."

#: ../../c-api/memory.rst:253
msgid "Same as :c:func:`PyMem_Free`."
msgstr "Semelhante a :c:func:`PyMem_Free`."

#: ../../c-api/memory.rst:255
msgid ""
"In addition, the following macro sets are provided for calling the Python "
"memory allocator directly, without involving the C API functions listed "
"above. However, note that their use does not preserve binary compatibility "
"across Python versions and is therefore deprecated in extension modules."
msgstr ""
"Além disso, os seguintes conjuntos de macros são fornecidos para chamar "
"diretamente o alocador de memória do Python, sem envolver as funções da API "
"C listadas acima. No entanto, note que o seu uso não preserva a "
"compatibilidade binária entre versões do Python e, portanto, está obsoleto "
"em módulos de extensão."

#: ../../c-api/memory.rst:260
msgid "``PyMem_MALLOC(size)``"
msgstr "``PyMem_MALLOC(size)``"

#: ../../c-api/memory.rst:261
msgid "``PyMem_NEW(type, size)``"
msgstr "``PyMem_NEW(type, size)``"

#: ../../c-api/memory.rst:262
msgid "``PyMem_REALLOC(ptr, size)``"
msgstr "``PyMem_REALLOC(ptr, size)``"

#: ../../c-api/memory.rst:263
msgid "``PyMem_RESIZE(ptr, type, size)``"
msgstr "``PyMem_RESIZE(ptr, type, size)``"

#: ../../c-api/memory.rst:264
msgid "``PyMem_FREE(ptr)``"
msgstr "``PyMem_FREE(ptr)``"

#: ../../c-api/memory.rst:265
msgid "``PyMem_DEL(ptr)``"
msgstr "``PyMem_DEL(ptr)``"

#: ../../c-api/memory.rst:269
msgid "Object allocators"
msgstr "Alocadores de Objetos"

#: ../../c-api/memory.rst:275
msgid ""
"The :ref:`default object allocator <default-memory-allocators>` uses the "
":ref:`pymalloc memory allocator <pymalloc>`."
msgstr ""
"O :ref:`alocador de objetos predefinido <default-memory-allocators>` usa o "
":ref:`alocador de memória pymalloc <pymalloc>`."

#: ../../c-api/memory.rst:288
msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyObject_Malloc(1)`` had been called instead. The memory will not "
"have been initialized in any way."
msgstr ""
"Solicitar zero bytes retorna um ponteiro não-``NULL`` distinto, se possível,"
" como se ``PyObject_Malloc(1)`` tivesse sido chamado. A memória não será "
"inicializada de nenhuma forma."

#: ../../c-api/memory.rst:299
msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyObject_Calloc(1, 1)`` had been "
"called instead."
msgstr ""
"Solicitar zero elementos ou elementos com tamanho de zero bytes retorna um "
"ponteiro não-``NULL`` distinto, se possível, como se ``PyObject_Calloc(1, "
"1)`` tivesse sido chamado."

#: ../../c-api/memory.rst:311
msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyObject_Malloc(n)``; else "
"if *n* is equal to zero, the memory block is resized but is not freed, and "
"the returned pointer is non-``NULL``."
msgstr ""
"Se *p* for ``NULL``, a chamada é equivalente a ``PyObject_Malloc(n)``; caso "
"contrário, se *n* for igual a zero, o bloco de memória é redimensionado, mas"
" não libertado, e o ponteiro retornado é não-``NULL``."

#: ../../c-api/memory.rst:315
msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to "
":c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` or "
":c:func:`PyObject_Calloc`."
msgstr ""
"A menos que *p* seja ``NULL``, deve ter sido retornado por uma chamada "
"anterior a :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` ou "
":c:func:`PyObject_Calloc`."

#: ../../c-api/memory.rst:318
msgid ""
"If the request fails, :c:func:`PyObject_Realloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Se o pedido falhar, :c:func:`PyObject_Realloc` retorna ``NULL`` e *p* "
"permanece um ponteiro válido para a área de memória anterior."

#: ../../c-api/memory.rst:324
msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a"
" previous call to :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` or "
":c:func:`PyObject_Calloc`.  Otherwise, or if ``PyObject_Free(p)`` has been "
"called before, undefined behavior occurs."
msgstr ""
"Liberta o bloco de memória apontado por *p*, que deve ter sido retornado por"
" uma chamada anterior a :c:func:`PyObject_Malloc`, "
":c:func:`PyObject_Realloc` ou :c:func:`PyObject_Calloc`. Caso contrário, ou "
"se ``PyObject_Free(p)`` tiver sido chamado anteriormente, ocorre "
"comportamento indefinido."

#: ../../c-api/memory.rst:335
msgid "Default Memory Allocators"
msgstr "Alocadores de Memória Predefinidos"

#: ../../c-api/memory.rst:337
msgid "Default memory allocators:"
msgstr "Alocadores de memória predefinidos:"

#: ../../c-api/memory.rst:340
msgid "Configuration"
msgstr "Configuração"

#: ../../c-api/memory.rst:340
msgid "Name"
msgstr "Nome"

#: ../../c-api/memory.rst:340
msgid "PyMem_RawMalloc"
msgstr "PyMem_RawMalloc"

#: ../../c-api/memory.rst:340
msgid "PyMem_Malloc"
msgstr "PyMem_Malloc"

#: ../../c-api/memory.rst:340
msgid "PyObject_Malloc"
msgstr "PyObject_Malloc"

#: ../../c-api/memory.rst:342
msgid "Release build"
msgstr "Compilação de lançamento"

#: ../../c-api/memory.rst:342
msgid "``\"pymalloc\"``"
msgstr "``\"pymalloc\"``"

#: ../../c-api/memory.rst:342 ../../c-api/memory.rst:344
#: ../../c-api/memory.rst:344 ../../c-api/memory.rst:344
msgid "``malloc``"
msgstr "``malloc``"

#: ../../c-api/memory.rst:342 ../../c-api/memory.rst:342
msgid "``pymalloc``"
msgstr "``pymalloc``"

#: ../../c-api/memory.rst:343
msgid "Debug build"
msgstr "Compilação de depuração"

#: ../../c-api/memory.rst:343
msgid "``\"pymalloc_debug\"``"
msgstr "``\"pymalloc_debug\"``"

#: ../../c-api/memory.rst:343 ../../c-api/memory.rst:345
#: ../../c-api/memory.rst:345 ../../c-api/memory.rst:345
msgid "``malloc`` + debug"
msgstr "``malloc`` + depuração"

#: ../../c-api/memory.rst:343 ../../c-api/memory.rst:343
msgid "``pymalloc`` + debug"
msgstr "``pymalloc`` + depuração"

#: ../../c-api/memory.rst:344
msgid "Release build, without pymalloc"
msgstr "Compilação de lançamento, sem pymalloc"

#: ../../c-api/memory.rst:344
msgid "``\"malloc\"``"
msgstr "``\"malloc\"``"

#: ../../c-api/memory.rst:345
msgid "Debug build, without pymalloc"
msgstr "Compilação de depuração, sem pymalloc"

#: ../../c-api/memory.rst:345
msgid "``\"malloc_debug\"``"
msgstr "``\"malloc_debug\"``"

#: ../../c-api/memory.rst:348
msgid "Legend:"
msgstr "Legenda:"

#: ../../c-api/memory.rst:350
msgid "Name: value for :envvar:`PYTHONMALLOC` environment variable"
msgstr ""

#: ../../c-api/memory.rst:351
msgid ""
"``malloc``: system allocators from the standard C library, C functions: "
":c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` and :c:func:`free`"
msgstr ""

#: ../../c-api/memory.rst:353
msgid "``pymalloc``: :ref:`pymalloc memory allocator <pymalloc>`"
msgstr ""

#: ../../c-api/memory.rst:354
msgid "\"+ debug\": with debug hooks installed by :c:func:`PyMem_SetupDebugHooks`"
msgstr ""

#: ../../c-api/memory.rst:358
msgid "Customize Memory Allocators"
msgstr "Personalizar Alocadores de Memória"

#: ../../c-api/memory.rst:364
msgid ""
"Structure used to describe a memory block allocator. The structure has the "
"following fields:"
msgstr ""
"Estrutura usada para descrever um alocador de blocos de memória. A estrutura"
" tem os seguintes campos:"

#: ../../c-api/memory.rst:368 ../../c-api/memory.rst:513
msgid "Field"
msgstr "Campo"

#: ../../c-api/memory.rst:368 ../../c-api/memory.rst:513
msgid "Meaning"
msgstr "Significado"

#: ../../c-api/memory.rst:370 ../../c-api/memory.rst:515
msgid "``void *ctx``"
msgstr "``void *ctx``"

#: ../../c-api/memory.rst:370 ../../c-api/memory.rst:515
msgid "user context passed as first argument"
msgstr "contexto do utilizador passado como primeiro argumento"

#: ../../c-api/memory.rst:372
msgid "``void* malloc(void *ctx, size_t size)``"
msgstr "``void* malloc(void *ctx, size_t size)``"

#: ../../c-api/memory.rst:372
msgid "allocate a memory block"
msgstr "alocar um bloco de memória"

#: ../../c-api/memory.rst:374
msgid "``void* calloc(void *ctx, size_t nelem, size_t elsize)``"
msgstr "``void* calloc(void *ctx, size_t nelem, size_t elsize)``"

#: ../../c-api/memory.rst:374
msgid "allocate a memory block initialized with zeros"
msgstr "alocar um bloco de memória inicializado com zeros"

#: ../../c-api/memory.rst:377
msgid "``void* realloc(void *ctx, void *ptr, size_t new_size)``"
msgstr "``void* realloc(void *ctx, void *ptr, size_t new_size)``"

#: ../../c-api/memory.rst:377
msgid "allocate or resize a memory block"
msgstr "alocar ou redimensionar um bloco de memória"

#: ../../c-api/memory.rst:379
msgid "``void free(void *ctx, void *ptr)``"
msgstr "``void free(void *ctx, void *ptr)``"

#: ../../c-api/memory.rst:379
msgid "free a memory block"
msgstr "libertar um bloco de memória"

#: ../../c-api/memory.rst:382
msgid ""
"The :c:type:`PyMemAllocator` structure was renamed to "
":c:type:`PyMemAllocatorEx` and a new ``calloc`` field was added."
msgstr ""

#: ../../c-api/memory.rst:389
msgid "Enum used to identify an allocator domain. Domains:"
msgstr "Enum usado para identificar um domínio de alocação. Domínios:"

#: ../../c-api/memory.rst:393 ../../c-api/memory.rst:402
#: ../../c-api/memory.rst:411
msgid "Functions:"
msgstr "Funções:"

#: ../../c-api/memory.rst:395
msgid ":c:func:`PyMem_RawMalloc`"
msgstr ":c:func:`PyMem_RawMalloc`"

#: ../../c-api/memory.rst:396
msgid ":c:func:`PyMem_RawRealloc`"
msgstr ":c:func:`PyMem_RawRealloc`"

#: ../../c-api/memory.rst:397
msgid ":c:func:`PyMem_RawCalloc`"
msgstr ":c:func:`PyMem_RawCalloc`"

#: ../../c-api/memory.rst:398
msgid ":c:func:`PyMem_RawFree`"
msgstr ":c:func:`PyMem_RawFree`"

#: ../../c-api/memory.rst:404
msgid ":c:func:`PyMem_Malloc`,"
msgstr ":c:func:`PyMem_Malloc`,"

#: ../../c-api/memory.rst:405
msgid ":c:func:`PyMem_Realloc`"
msgstr ":c:func:`PyMem_Realloc`"

#: ../../c-api/memory.rst:406
msgid ":c:func:`PyMem_Calloc`"
msgstr ":c:func:`PyMem_Calloc`"

#: ../../c-api/memory.rst:407
msgid ":c:func:`PyMem_Free`"
msgstr ":c:func:`PyMem_Free`"

#: ../../c-api/memory.rst:413
msgid ":c:func:`PyObject_Malloc`"
msgstr ":c:func:`PyObject_Malloc`"

#: ../../c-api/memory.rst:414
msgid ":c:func:`PyObject_Realloc`"
msgstr ":c:func:`PyObject_Realloc`"

#: ../../c-api/memory.rst:415
msgid ":c:func:`PyObject_Calloc`"
msgstr ":c:func:`PyObject_Calloc`"

#: ../../c-api/memory.rst:416
msgid ":c:func:`PyObject_Free`"
msgstr ":c:func:`PyObject_Free`"

#: ../../c-api/memory.rst:420
msgid "Get the memory block allocator of the specified domain."
msgstr "Obter o alocador de blocos de memória do domínio especificado."

#: ../../c-api/memory.rst:425
msgid "Set the memory block allocator of the specified domain."
msgstr "Definir o alocador de blocos de memória do domínio especificado."

#: ../../c-api/memory.rst:427
msgid ""
"The new allocator must return a distinct non-``NULL`` pointer when "
"requesting zero bytes."
msgstr ""
"O novo alocador deve retornar um ponteiro não-``NULL`` distinto ao solicitar"
" zero bytes."

#: ../../c-api/memory.rst:430
msgid ""
"For the :c:data:`PYMEM_DOMAIN_RAW` domain, the allocator must be thread-"
"safe: the :term:`GIL <global interpreter lock>` is not held when the "
"allocator is called."
msgstr ""

#: ../../c-api/memory.rst:434
msgid ""
"If the new allocator is not a hook (does not call the previous allocator), "
"the :c:func:`PyMem_SetupDebugHooks` function must be called to reinstall the"
" debug hooks on top on the new allocator."
msgstr ""
"Se o novo alocador não for um *hook* (não chama o alocador anterior), a "
"função :c:func:`PyMem_SetupDebugHooks` deve ser chamada para reinstalar os "
"*hooks* de depuração no novo alocador."

#: ../../c-api/memory.rst:441
msgid "Setup hooks to detect bugs in the Python memory allocator functions."
msgstr ""

#: ../../c-api/memory.rst:443
msgid ""
"Newly allocated memory is filled with the byte ``0xCD`` (``CLEANBYTE``), "
"freed memory is filled with the byte ``0xDD`` (``DEADBYTE``). Memory blocks "
"are surrounded by \"forbidden bytes\" (``FORBIDDENBYTE``: byte ``0xFD``)."
msgstr ""

#: ../../c-api/memory.rst:447
msgid "Runtime checks:"
msgstr "Verificações em tempo de execução:"

#: ../../c-api/memory.rst:449
msgid ""
"Detect API violations, ex: :c:func:`PyObject_Free` called on a buffer "
"allocated by :c:func:`PyMem_Malloc`"
msgstr ""

#: ../../c-api/memory.rst:451
msgid "Detect write before the start of the buffer (buffer underflow)"
msgstr ""

#: ../../c-api/memory.rst:452
msgid "Detect write after the end of the buffer (buffer overflow)"
msgstr ""

#: ../../c-api/memory.rst:453
msgid ""
"Check that the :term:`GIL <global interpreter lock>` is held when allocator "
"functions of :c:data:`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`) and "
":c:data:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) domains are called"
msgstr ""

#: ../../c-api/memory.rst:458
msgid ""
"On error, the debug hooks use the :mod:`tracemalloc` module to get the "
"traceback where a memory block was allocated. The traceback is only "
"displayed if :mod:`tracemalloc` is tracing Python memory allocations and the"
" memory block was traced."
msgstr ""
"Em caso de erro, os *hooks* de depuração usam o módulo :mod:`tracemalloc` "
"para obter o *traceback* de onde um bloco de memória foi alocado. O "
"*traceback* só é apresentado se o :mod:`tracemalloc` estiver a traçar "
"alocações de memória do Python e o bloco de memória tiver sido traçado."

#: ../../c-api/memory.rst:463
msgid ""
"These hooks are :ref:`installed by default <default-memory-allocators>` if "
"Python is compiled in debug mode. The :envvar:`PYTHONMALLOC` environment "
"variable can be used to install debug hooks on a Python compiled in release "
"mode."
msgstr ""

#: ../../c-api/memory.rst:468
msgid ""
"This function now also works on Python compiled in release mode. On error, "
"the debug hooks now use :mod:`tracemalloc` to get the traceback where a "
"memory block was allocated. The debug hooks now also check if the GIL is "
"held when functions of :c:data:`PYMEM_DOMAIN_OBJ` and "
":c:data:`PYMEM_DOMAIN_MEM` domains are called."
msgstr ""

#: ../../c-api/memory.rst:475
msgid ""
"Byte patterns ``0xCB`` (``CLEANBYTE``), ``0xDB`` (``DEADBYTE``) and ``0xFB``"
" (``FORBIDDENBYTE``) have been replaced with ``0xCD``, ``0xDD`` and ``0xFD``"
" to use the same values than Windows CRT debug ``malloc()`` and ``free()``."
msgstr ""

#: ../../c-api/memory.rst:485
msgid "The pymalloc allocator"
msgstr "O alocador pymalloc"

#: ../../c-api/memory.rst:487
msgid ""
"Python has a *pymalloc* allocator optimized for small objects (smaller or "
"equal to 512 bytes) with a short lifetime. It uses memory mappings called "
"\"arenas\" with a fixed size of 256 KiB. It falls back to "
":c:func:`PyMem_RawMalloc` and :c:func:`PyMem_RawRealloc` for allocations "
"larger than 512 bytes."
msgstr ""

#: ../../c-api/memory.rst:492
msgid ""
"*pymalloc* is the :ref:`default allocator <default-memory-allocators>` of "
"the :c:data:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) and "
":c:data:`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`) domains."
msgstr ""

#: ../../c-api/memory.rst:496
msgid "The arena allocator uses the following functions:"
msgstr "O alocador de arenas usa as seguintes funções:"

#: ../../c-api/memory.rst:498
msgid ":c:func:`VirtualAlloc` and :c:func:`VirtualFree` on Windows,"
msgstr ""

#: ../../c-api/memory.rst:499
msgid ":c:func:`mmap` and :c:func:`munmap` if available,"
msgstr ""

#: ../../c-api/memory.rst:500
msgid ":c:func:`malloc` and :c:func:`free` otherwise."
msgstr ":c:func:`malloc` e :c:func:`free` caso contrário."

#: ../../c-api/memory.rst:503
msgid "Customize pymalloc Arena Allocator"
msgstr "Personalizar o Alocador de Arenas do pymalloc"

#: ../../c-api/memory.rst:509
msgid ""
"Structure used to describe an arena allocator. The structure has three "
"fields:"
msgstr ""
"Estrutura usada para descrever um alocador de arenas. A estrutura tem três "
"campos:"

#: ../../c-api/memory.rst:517
msgid "``void* alloc(void *ctx, size_t size)``"
msgstr "``void* alloc(void *ctx, size_t size)``"

#: ../../c-api/memory.rst:517
msgid "allocate an arena of size bytes"
msgstr "alocar uma arena de tamanho *bytes*"

#: ../../c-api/memory.rst:519
msgid "``void free(void *ctx, void *ptr, size_t size)``"
msgstr "``void free(void *ctx, void *ptr, size_t size)``"

#: ../../c-api/memory.rst:519
msgid "free an arena"
msgstr "libertar uma arena"

#: ../../c-api/memory.rst:524
msgid "Get the arena allocator."
msgstr "Obter o alocador de arenas."

#: ../../c-api/memory.rst:528
msgid "Set the arena allocator."
msgstr "Definir o alocador de arenas."

#: ../../c-api/memory.rst:532
msgid "tracemalloc C API"
msgstr "API C do tracemalloc"

#: ../../c-api/memory.rst:538
msgid "Track an allocated memory block in the :mod:`tracemalloc` module."
msgstr "Rastrear um bloco de memória alocado no módulo :mod:`tracemalloc`."

#: ../../c-api/memory.rst:540
msgid ""
"Return ``0`` on success, return ``-1`` on error (failed to allocate memory "
"to store the trace). Return ``-2`` if tracemalloc is disabled."
msgstr ""
"Retorna ``0`` em caso de sucesso, ``-1`` em caso de erro (falha ao alocar "
"memória para armazenar o rastreio). Retorna ``-2`` se o tracemalloc estiver "
"desativado."

#: ../../c-api/memory.rst:543
msgid "If memory block is already tracked, update the existing trace."
msgstr ""
"Se o bloco de memória já estiver a ser rastreado, atualizar o rastreio "
"existente."

#: ../../c-api/memory.rst:547
msgid ""
"Untrack an allocated memory block in the :mod:`tracemalloc` module. Do "
"nothing if the block was not tracked."
msgstr ""
"Deixar de rastrear um bloco de memória alocado no módulo :mod:`tracemalloc`."
" Não fazer nada se o bloco não estiver a ser rastreado."

#: ../../c-api/memory.rst:550
msgid "Return ``-2`` if tracemalloc is disabled, otherwise return ``0``."
msgstr ""
"Retorna ``-2`` se o tracemalloc estiver desativado, caso contrário retorna "
"``0``."

#: ../../c-api/memory.rst:556
msgid "Examples"
msgstr "Exemplos"

#: ../../c-api/memory.rst:558
msgid ""
"Here is the example from section :ref:`memoryoverview`, rewritten so that "
"the I/O buffer is allocated from the Python heap by using the first function"
" set::"
msgstr ""
"Aqui está o exemplo da secção :ref:`memoryoverview`, reescrito de forma a "
"que o buffer de I/O seja alocado a partir do *heap* do Python usando o "
"primeiro conjunto de funções::"

#: ../../c-api/memory.rst:571
msgid "The same code using the type-oriented function set::"
msgstr "O mesmo código usando o conjunto de funções orientadas a tipos::"

#: ../../c-api/memory.rst:583
msgid ""
"Note that in the two examples above, the buffer is always manipulated via "
"functions belonging to the same set. Indeed, it is required to use the same "
"memory API family for a given memory block, so that the risk of mixing "
"different allocators is reduced to a minimum. The following code sequence "
"contains two errors, one of which is labeled as *fatal* because it mixes two"
" different allocators operating on different heaps. ::"
msgstr ""
"Note que nos dois exemplos acima, o buffer é sempre manipulado através de "
"funções pertencentes ao mesmo conjunto. De facto, é necessário usar a mesma "
"família de API de memória para um determinado bloco de memória, de forma a "
"reduzir ao mínimo o risco de misturar alocadores diferentes. A seguinte "
"sequência de código contém dois erros, um dos quais é rotulado como *fatal* "
"porque mistura dois alocadores que operam em *heaps* diferentes.::"

#: ../../c-api/memory.rst:598
msgid ""
"In addition to the functions aimed at handling raw memory blocks from the "
"Python heap, objects in Python are allocated and released with "
":c:func:`PyObject_New`, :c:func:`PyObject_NewVar` and "
":c:func:`PyObject_Del`."
msgstr ""

#: ../../c-api/memory.rst:602
msgid ""
"These will be explained in the next chapter on defining and implementing new"
" object types in C."
msgstr ""
"Estas serão explicadas no próximo capítulo sobre a definição e implementação"
" de novos tipos de objetos em C."
