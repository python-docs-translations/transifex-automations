# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2026, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-07 14:29+0000\n"
"PO-Revision-Date: 2025-09-15 01:03+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../faq/design.rst:3
msgid "Design and History FAQ"
msgstr "FAQ de Design e História"

#: ../../faq/design.rst:6
msgid "Contents"
msgstr "Conteúdos"

#: ../../faq/design.rst:11
msgid "Why does Python use indentation for grouping of statements?"
msgstr ""
"Por que é que o Python usa indentação para o agrupamento de instruções?"

#: ../../faq/design.rst:13
msgid ""
"Guido van Rossum believes that using indentation for grouping is extremely "
"elegant and contributes a lot to the clarity of the average Python program. "
"Most people learn to love this feature after a while."
msgstr ""
"Guido van Rossum acredita que o uso de indentação para agrupamento é "
"extremamente elegante e contribui muito para a clareza do programa médio em "
"Python. A maioria das pessoas aprende a gostar desta funcionalidade após "
"algum tempo."

#: ../../faq/design.rst:17
msgid ""
"Since there are no begin/end brackets there cannot be a disagreement between "
"grouping perceived by the parser and the human reader.  Occasionally C "
"programmers will encounter a fragment of code like this::"
msgstr ""
"Como não existem chavetas de início/fim, não pode haver discordância entre o "
"agrupamento percebido pelo analisador sintático e o leitor humano. "
"Ocasionalmente, programadores em C encontrarão um fragmento de código como "
"este:"

#: ../../faq/design.rst:21
msgid ""
"if (x <= y)\n"
"        x++;\n"
"        y--;\n"
"z++;"
msgstr ""
"if (x <= y)\n"
"        x++;\n"
"        y--;\n"
"z++;"

#: ../../faq/design.rst:26
msgid ""
"Only the ``x++`` statement is executed if the condition is true, but the "
"indentation leads many to believe otherwise.  Even experienced C programmers "
"will sometimes stare at it a long time wondering as to why ``y`` is being "
"decremented even for ``x > y``."
msgstr ""
"Apenas a instrução ``x++`` é executada se a condição for verdadeira, mas a "
"indentação leva muitos a acreditar o contrário. Mesmo programadores "
"experientes em C, por vezes, olham para isto durante muito tempo, "
"questionando-se porque é que ``y`` está a ser decrementado mesmo quando ``x "
"> y``."

#: ../../faq/design.rst:31
msgid ""
"Because there are no begin/end brackets, Python is much less prone to coding-"
"style conflicts.  In C there are many different ways to place the braces. "
"After becoming used to reading and writing code using a particular style, it "
"is normal to feel somewhat uneasy when reading (or being required to write) "
"in a different one."
msgstr ""
"Como não existem chavetas de início/fim, o Python é muito menos propenso a "
"conflitos de estilo de codificação. Em C, existem muitas formas diferentes "
"de colocar as chavetas. Depois de se habituar a ler e escrever código usando "
"um estilo particular, é normal sentir-se um pouco desconfortável ao ler (ou "
"ser obrigado a escrever) noutro estilo."

#: ../../faq/design.rst:38
msgid ""
"Many coding styles place begin/end brackets on a line by themselves.  This "
"makes programs considerably longer and wastes valuable screen space, making "
"it harder to get a good overview of a program.  Ideally, a function should "
"fit on one screen (say, 20--30 lines).  20 lines of Python can do a lot more "
"work than 20 lines of C.  This is not solely due to the lack of begin/end "
"brackets -- the lack of declarations and the high-level data types are also "
"responsible -- but the indentation-based syntax certainly helps."
msgstr ""
"Muitos estilos de codificação colocam as chavetas de início/fim numa linha "
"por si só. Isto torna os programas consideravelmente mais longos e "
"desperdiça espaço valioso no ecrã, tornando mais difícil obter uma boa visão "
"geral de um programa. Idealmente, uma função deve caber num ecrã (digamos, "
"20-30 linhas). 20 linhas de Python podem fazer muito mais trabalho do que 20 "
"linhas de C. Isto não se deve apenas à falta de chavetas de início/fim — a "
"falta de declarações e os tipos de dados de alto nível também são "
"responsáveis — mas a sintaxe baseada em indentação certamente ajuda."

#: ../../faq/design.rst:48
msgid "Why am I getting strange results with simple arithmetic operations?"
msgstr ""
"Por que é que estou a obter resultados estranhos com operações aritméticas "
"simples?"

#: ../../faq/design.rst:50
msgid "See the next question."
msgstr "Veja a próxima pergunta."

#: ../../faq/design.rst:54
msgid "Why are floating-point calculations so inaccurate?"
msgstr "Por que é que os cálculos de vírgula flutuante são tão imprecisos?"

#: ../../faq/design.rst:56
msgid "Users are often surprised by results like this::"
msgstr ""
"Os utilizadores ficam muitas vezes surpreendidos com resultados como este:"

#: ../../faq/design.rst:58
msgid ""
">>> 1.2 - 1.0\n"
"0.19999999999999996"
msgstr ""
">>> 1.2 - 1.0\n"
"0.19999999999999996"

#: ../../faq/design.rst:61
msgid ""
"and think it is a bug in Python.  It's not.  This has little to do with "
"Python, and much more to do with how the underlying platform handles "
"floating-point numbers."
msgstr ""
"e pensam que é um erro no Python. Não é. Isto tem pouco a ver com o Python e "
"muito mais com a forma como a plataforma subjacente trata os números de "
"vírgula flutuante."

#: ../../faq/design.rst:65
msgid ""
"The :class:`float` type in CPython uses a C ``double`` for storage.  A :"
"class:`float` object's value is stored in binary floating-point with a fixed "
"precision (typically 53 bits) and Python uses C operations, which in turn "
"rely on the hardware implementation in the processor, to perform floating-"
"point operations. This means that as far as floating-point operations are "
"concerned, Python behaves like many popular languages including C and Java."
msgstr ""
"O tipo :class:`float` no CPython usa um ``double`` de C para armazenamento. "
"O valor de um objeto :class:`float` é armazenado em vírgula flutuante "
"binária com uma precisão fixa (normalmente 53 bits) e o Python usa operações "
"de C, que, por sua vez, dependem da implementação de hardware no "
"processador, para realizar operações de vírgula flutuante. Isto significa "
"que, no que diz respeito a operações de vírgula flutuante, o Python comporta-"
"se como muitas linguagens populares, incluindo C e Java."

#: ../../faq/design.rst:72
msgid ""
"Many numbers that can be written easily in decimal notation cannot be "
"expressed exactly in binary floating point.  For example, after::"
msgstr ""
"Muitos números que podem ser escritos facilmente em notação decimal não "
"podem ser expressos exatamente em vírgula flutuante binária. Por exemplo, "
"depois de:"

#: ../../faq/design.rst:75
msgid ">>> x = 1.2"
msgstr ">>> x = 1.2"

#: ../../faq/design.rst:77
msgid ""
"the value stored for ``x`` is a (very good) approximation to the decimal "
"value ``1.2``, but is not exactly equal to it.  On a typical machine, the "
"actual stored value is::"
msgstr ""
"o valor armazenado para ``x`` é uma aproximação (muito boa) do valor decimal "
"``1.2``, mas não é exatamente igual a ele. Numa máquina típica, o valor "
"realmente armazenado é:"

#: ../../faq/design.rst:81
msgid "1.0011001100110011001100110011001100110011001100110011 (binary)"
msgstr "1.0011001100110011001100110011001100110011001100110011 (binário)"

#: ../../faq/design.rst:83
msgid "which is exactly::"
msgstr "que é exatamente:"

#: ../../faq/design.rst:85
msgid "1.1999999999999999555910790149937383830547332763671875 (decimal)"
msgstr "1.1999999999999999555910790149937383830547332763671875 (decimal)"

#: ../../faq/design.rst:87
msgid ""
"The typical precision of 53 bits provides Python floats with 15--16 decimal "
"digits of accuracy."
msgstr ""
"A precisão típica de 53 bits fornece aos números de vírgula flutuante do "
"Python 15-16 dígitos decimais de precisão."

#: ../../faq/design.rst:90
msgid ""
"For a fuller explanation, please see the :ref:`floating-point arithmetic "
"<tut-fp-issues>` chapter in the Python tutorial."
msgstr ""
"Para uma explicação mais completa, consulte o capítulo :ref:`aritmética de "
"vírgula flutuante <tut-fp-issues>` no tutorial do Python."

#: ../../faq/design.rst:95
msgid "Why are Python strings immutable?"
msgstr "Por que é que as strings do Python são imutáveis?"

#: ../../faq/design.rst:97
msgid "There are several advantages."
msgstr "Existem várias vantagens."

#: ../../faq/design.rst:99
msgid ""
"One is performance: knowing that a string is immutable means we can allocate "
"space for it at creation time, and the storage requirements are fixed and "
"unchanging.  This is also one of the reasons for the distinction between "
"tuples and lists."
msgstr ""
"Uma é o desempenho: saber que uma string é imutável significa que podemos "
"alocar espaço para ela no momento da criação, e os requisitos de "
"armazenamento são fixos e imutáveis. Isto é também uma das razões para a "
"distinção entre tuplos e listas."

#: ../../faq/design.rst:104
msgid ""
"Another advantage is that strings in Python are considered as \"elemental\" "
"as numbers.  No amount of activity will change the value 8 to anything else, "
"and in Python, no amount of activity will change the string \"eight\" to "
"anything else."
msgstr ""
"Outra vantagem é que as strings em Python são consideradas tão "
"\"elementares\" como os números. Nenhuma quantidade de atividade mudará o "
"valor 8 para qualquer outra coisa, e em Python, nenhuma quantidade de "
"atividade mudará a string \"eight\" para qualquer outra coisa."

#: ../../faq/design.rst:112
msgid "Why must 'self' be used explicitly in method definitions and calls?"
msgstr ""
"Por que é que 'self' deve ser usado explicitamente nas definições e chamadas "
"de métodos?"

#: ../../faq/design.rst:114
msgid ""
"The idea was borrowed from Modula-3.  It turns out to be very useful, for a "
"variety of reasons."
msgstr ""
"A ideia foi emprestada do Modula-3. Revela-se muito útil, por várias razões."

#: ../../faq/design.rst:117
msgid ""
"First, it's more obvious that you are using a method or instance attribute "
"instead of a local variable.  Reading ``self.x`` or ``self.meth()`` makes it "
"absolutely clear that an instance variable or method is used even if you "
"don't know the class definition by heart.  In C++, you can sort of tell by "
"the lack of a local variable declaration (assuming globals are rare or "
"easily recognizable) -- but in Python, there are no local variable "
"declarations, so you'd have to look up the class definition to be sure.  "
"Some C++ and Java coding standards call for instance attributes to have an "
"``m_`` prefix, so this explicitness is still useful in those languages, too."
msgstr ""
"Primeiro, é mais óbvio que está a usar um método ou atributo de instância em "
"vez de uma variável local. Ler ``self.x`` ou ``self.meth()`` torna "
"absolutamente claro que uma variável ou método de instância está a ser "
"usado, mesmo que não saiba a definição da classe de cor. Em C++, pode-se "
"perceber pelo facto de não haver declaração de variável local (assumindo que "
"os globais são raros ou facilmente reconhecíveis) — mas em Python, não "
"existem declarações de variáveis locais, por isso teria de consultar a "
"definição da classe para ter a certeza. Alguns padrões de codificação em C++ "
"e Java exigem que os atributos de instância tenham um prefixo ``m_``, por "
"isso esta explicitação também é útil nessas linguagens."

#: ../../faq/design.rst:127
msgid ""
"Second, it means that no special syntax is necessary if you want to "
"explicitly reference or call the method from a particular class.  In C++, if "
"you want to use a method from a base class which is overridden in a derived "
"class, you have to use the ``::`` operator -- in Python you can write "
"``baseclass.methodname(self, <argument list>)``.  This is particularly "
"useful for :meth:`~object.__init__` methods, and in general in cases where a "
"derived class method wants to extend the base class method of the same name "
"and thus has to call the base class method somehow."
msgstr ""
"Segundo, significa que não é necessária nenhuma sintaxe especial se quiser "
"referenciar ou chamar explicitamente o método de uma classe específica. Em C+"
"+, se quiser usar um método de uma classe base que é substituído numa classe "
"derivada, tem de usar o operador ``::`` -- em Python pode escrever "
"``baseclass.methodname(self, <argument list>)``. Isto é particularmente útil "
"para métodos :meth:`~object.__init__`, e em geral em casos em que um método "
"de uma classe derivada quer estender o método da classe base com o mesmo "
"nome e, portanto, tem de chamar o método da classe base de alguma forma."

#: ../../faq/design.rst:136
msgid ""
"Finally, for instance variables it solves a syntactic problem with "
"assignment: since local variables in Python are (by definition!) those "
"variables to which a value is assigned in a function body (and that aren't "
"explicitly declared global), there has to be some way to tell the "
"interpreter that an assignment was meant to assign to an instance variable "
"instead of to a local variable, and it should preferably be syntactic (for "
"efficiency reasons).  C++ does this through declarations, but Python doesn't "
"have declarations and it would be a pity having to introduce them just for "
"this purpose.  Using the explicit ``self.var`` solves this nicely.  "
"Similarly, for using instance variables, having to write ``self.var`` means "
"that references to unqualified names inside a method don't have to search "
"the instance's directories.  To put it another way, local variables and "
"instance variables live in two different namespaces, and you need to tell "
"Python which namespace to use."
msgstr ""
"Por fim, para variáveis de instância, resolve um problema sintático com a "
"atribuição: uma vez que as variáveis locais em Python são (por definição!) "
"aquelas variáveis às quais um valor é atribuído no corpo de uma função (e "
"que não são explicitamente declaradas globais), tem de haver alguma forma de "
"indicar ao interpretador que uma atribuição se destinava a atribuir a uma "
"variável de instância em vez de a uma variável local, e preferencialmente "
"deve ser sintática (por razões de eficiência). O C++ faz isto através de "
"declarações, mas o Python não tem declarações e seria uma pena ter de as "
"introduzir apenas para este propósito. O uso explícito de ``self.var`` "
"resolve isto de forma elegante. Da mesma forma, para usar variáveis de "
"instância, ter de escrever ``self.var`` significa que as referências a nomes "
"não qualificados dentro de um método não têm de procurar nos diretórios da "
"instância. Em outras palavras, as variáveis locais e as variáveis de "
"instância vivem em dois namespaces diferentes, e é necessário indicar ao "
"Python qual o namespace a usar."

#: ../../faq/design.rst:154
msgid "Why can't I use an assignment in an expression?"
msgstr "Por que é que não posso usar uma atribuição numa expressão?"

#: ../../faq/design.rst:156
msgid "Starting in Python 3.8, you can!"
msgstr "A partir do Python 3.8, já pode!"

#: ../../faq/design.rst:158
msgid ""
"Assignment expressions using the walrus operator ``:=`` assign a variable in "
"an expression::"
msgstr ""
"Expressões de atribuição que usam o operador walrus ``:=`` atribuem uma "
"variável numa expressão:"

#: ../../faq/design.rst:161
msgid ""
"while chunk := fp.read(200):\n"
"   print(chunk)"
msgstr ""
"while chunk := fp.read(200):\n"
"   print(chunk)"

#: ../../faq/design.rst:164
msgid "See :pep:`572` for more information."
msgstr "Consulte o :pep:`572` para mais informações."

#: ../../faq/design.rst:169
msgid ""
"Why does Python use methods for some functionality (e.g. list.index()) but "
"functions for other (e.g. len(list))?"
msgstr ""
"Por que é que o Python usa métodos para algumas funcionalidades (por "
"exemplo, list.index()) mas funções para outras (por exemplo, len(list))?"

#: ../../faq/design.rst:171
msgid "As Guido said:"
msgstr "Como disse o Guido:"

#: ../../faq/design.rst:173
msgid ""
"(a) For some operations, prefix notation just reads better than postfix -- "
"prefix (and infix!) operations have a long tradition in mathematics which "
"likes notations where the visuals help the mathematician thinking about a "
"problem. Compare the easy with which we rewrite a formula like x*(a+b) into "
"x*a + x*b to the clumsiness of doing the same thing using a raw OO notation."
msgstr ""
"(a) Para algumas operações, a notação de prefixo lê-se melhor do que a de "
"posfixo — as operações de prefixo (e infixo!) têm uma longa tradição na "
"matemática, que gosta de notações em que os visuais ajudam o matemático a "
"pensar sobre um problema. Compare a facilidade com que reescrevemos uma "
"fórmula como x*(a+b) em x*a + x*b com a desajeitada forma de fazer o mesmo "
"usando uma notação OO pura."

#: ../../faq/design.rst:180
msgid ""
"(b) When I read code that says len(x) I *know* that it is asking for the "
"length of something. This tells me two things: the result is an integer, and "
"the argument is some kind of container. To the contrary, when I read x."
"len(), I have to already know that x is some kind of container implementing "
"an interface or inheriting from a class that has a standard len(). Witness "
"the confusion we occasionally have when a class that is not implementing a "
"mapping has a get() or keys() method, or something that isn't a file has a "
"write() method."
msgstr ""
"(b) Quando leio código que diz len(x), *sei* que está a pedir o comprimento "
"de algo. Isto diz-me duas coisas: o resultado é um inteiro e o argumento é "
"algum tipo de contentor. Pelo contrário, quando leio x.len(), tenho de saber "
"de antemão que x é algum tipo de contentor que implementa uma interface ou "
"herda de uma classe que tem um len() padrão. Testemunhemos a confusão que "
"por vezes temos quando uma classe que não implementa um mapeamento tem um "
"método get() ou keys(), ou algo que não é um ficheiro tem um método write()."

#: ../../faq/design.rst:189
msgid "https://mail.python.org/pipermail/python-3000/2006-November/004643.html"
msgstr ""
"https://mail.python.org/pipermail/python-3000/2006-November/004643.html"

#: ../../faq/design.rst:193
msgid "Why is join() a string method instead of a list or tuple method?"
msgstr ""
"Por que é que join() é um método de string em vez de um método de lista ou "
"tuplo?"

#: ../../faq/design.rst:195
msgid ""
"Strings became much more like other standard types starting in Python 1.6, "
"when methods were added which give the same functionality that has always "
"been available using the functions of the string module.  Most of these new "
"methods have been widely accepted, but the one which appears to make some "
"programmers feel uncomfortable is::"
msgstr ""
"As strings tornaram-se muito mais semelhantes a outros tipos padrão a partir "
"do Python 1.6, quando foram adicionados métodos que fornecem a mesma "
"funcionalidade que sempre esteve disponível usando as funções do módulo "
"string. A maioria destes novos métodos foi amplamente aceite, mas o que "
"parece deixar alguns programadores desconfortáveis é:"

#: ../../faq/design.rst:201
msgid "\", \".join(['1', '2', '4', '8', '16'])"
msgstr "\"\", \".join(['1', '2', '4', '8', '16'])"

#: ../../faq/design.rst:203
msgid "which gives the result::"
msgstr "que dá o resultado:"

#: ../../faq/design.rst:205
msgid "\"1, 2, 4, 8, 16\""
msgstr "\"1, 2, 4, 8, 16\""

#: ../../faq/design.rst:207
msgid "There are two common arguments against this usage."
msgstr "Existem dois argumentos comuns contra esta utilização."

#: ../../faq/design.rst:209
msgid ""
"The first runs along the lines of: \"It looks really ugly using a method of "
"a string literal (string constant)\", to which the answer is that it might, "
"but a string literal is just a fixed value. If the methods are to be allowed "
"on names bound to strings there is no logical reason to make them "
"unavailable on literals."
msgstr ""
"O primeiro segue a linha de: \"Parece realmente feio usar um método de uma "
"string literal (constante de string)\", ao que a resposta é que pode ser, "
"mas uma string literal é apenas um valor fixo. Se os métodos são permitidos "
"em nomes ligados a strings, não há razão lógica para os tornar indisponíveis "
"em literais."

#: ../../faq/design.rst:215
msgid ""
"The second objection is typically cast as: \"I am really telling a sequence "
"to join its members together with a string constant\".  Sadly, you aren't.  "
"For some reason there seems to be much less difficulty with having :meth:"
"`~str.split` as a string method, since in that case it is easy to see that ::"
msgstr ""
"A segunda objeção é tipicamente apresentada como: \"Estou realmente a dizer "
"a uma sequência para juntar os seus membros com uma constante de string\". "
"Infelizmente, não está. Por alguma razão, parece haver muito menos "
"dificuldade em ter :meth:`~str.split` como um método de string, uma vez que "
"nesse caso é fácil ver que:"

#: ../../faq/design.rst:220
msgid "\"1, 2, 4, 8, 16\".split(\", \")"
msgstr "\"1, 2, 4, 8, 16\".split(\", \")"

#: ../../faq/design.rst:222
msgid ""
"is an instruction to a string literal to return the substrings delimited by "
"the given separator (or, by default, arbitrary runs of white space)."
msgstr ""
"é uma instrução para uma string literal devolver as substrings delimitadas "
"pelo separador dado (ou, por defeito, sequências arbitrárias de espaços em "
"branco)."

#: ../../faq/design.rst:225
msgid ""
":meth:`~str.join` is a string method because in using it you are telling the "
"separator string to iterate over a sequence of strings and insert itself "
"between adjacent elements.  This method can be used with any argument which "
"obeys the rules for sequence objects, including any new classes you might "
"define yourself. Similar methods exist for bytes and bytearray objects."
msgstr ""
":meth:`~str.join` é um método de string porque, ao usá-lo, está a dizer à "
"string separadora para iterar sobre uma sequência de strings e inserir-se a "
"si mesma entre elementos adjacentes. Este método pode ser usado com qualquer "
"argumento que obedeça às regras para objetos de sequência, incluindo "
"quaisquer novas classes que possa definir. Métodos semelhantes existem para "
"objetos bytes e bytearray."

#: ../../faq/design.rst:233
msgid "How fast are exceptions?"
msgstr "Quão rápidas são as exceções?"

#: ../../faq/design.rst:235
msgid ""
"A :keyword:`try`/:keyword:`except` block is extremely efficient if no "
"exceptions are raised.  Actually catching an exception is expensive.  In "
"versions of Python prior to 2.0 it was common to use this idiom::"
msgstr ""
"Um bloco :keyword:`try`/:keyword:`except` é extremamente eficiente se não "
"forem levantadas exceções. Na realidade, capturar uma exceção é dispendioso. "
"Em versões do Python anteriores à 2.0, era comum usar este idioma:"

#: ../../faq/design.rst:240
msgid ""
"try:\n"
"    value = mydict[key]\n"
"except KeyError:\n"
"    mydict[key] = getvalue(key)\n"
"    value = mydict[key]"
msgstr ""
"try:\n"
"    value = mydict[key]\n"
"except KeyError:\n"
"    mydict[key] = getvalue(key)\n"
"    value = mydict[key]"

#: ../../faq/design.rst:246
msgid ""
"This only made sense when you expected the dict to have the key almost all "
"the time.  If that wasn't the case, you coded it like this::"
msgstr ""
"Isto só fazia sentido quando esperava que o dicionário tivesse a chave quase "
"sempre. Se não fosse esse o caso, codificava-se assim:"

#: ../../faq/design.rst:249
msgid ""
"if key in mydict:\n"
"    value = mydict[key]\n"
"else:\n"
"    value = mydict[key] = getvalue(key)"
msgstr ""
"if key in mydict:\n"
"    value = mydict[key]\n"
"else:\n"
"    value = mydict[key] = getvalue(key)"

#: ../../faq/design.rst:254
msgid ""
"For this specific case, you could also use ``value = dict.setdefault(key, "
"getvalue(key))``, but only if the ``getvalue()`` call is cheap enough "
"because it is evaluated in all cases."
msgstr ""
"Para este caso específico, também poderia usar ``value = dict."
"setdefault(key, getvalue(key))``, mas apenas se a chamada ``getvalue()`` for "
"suficientemente barata, porque é avaliada em todos os casos."

#: ../../faq/design.rst:260
msgid "Why isn't there a switch or case statement in Python?"
msgstr "Por que é que não existe uma instrução switch ou case em Python?"

#: ../../faq/design.rst:262
msgid ""
"In general, structured switch statements execute one block of code when an "
"expression has a particular value or set of values. Since Python 3.10 one "
"can easily match literal values, or constants within a namespace, with a "
"``match ... case`` statement. An older alternative is a sequence of ``if... "
"elif... elif... else``."
msgstr ""
"Em geral, as instruções switch estruturadas executam um bloco de código "
"quando uma expressão tem um valor ou conjunto de valores particular. A "
"partir do Python 3.10, pode-se facilmente corresponder valores literais ou "
"constantes dentro de um namespace com uma instrução ``match ... case``. Uma "
"alternativa mais antiga é uma sequência de ``if... elif... elif... else``."

#: ../../faq/design.rst:268
msgid ""
"For cases where you need to choose from a very large number of "
"possibilities, you can create a dictionary mapping case values to functions "
"to call.  For example::"
msgstr ""
"Para casos em que precisa de escolher entre um número muito grande de "
"possibilidades, pode criar um dicionário que mapeia valores de caso para "
"funções a chamar. Por exemplo:"

#: ../../faq/design.rst:272
msgid ""
"functions = {'a': function_1,\n"
"             'b': function_2,\n"
"             'c': self.method_1}\n"
"\n"
"func = functions[value]\n"
"func()"
msgstr ""
"functions = {'a': function_1,\n"
"             'b': function_2,\n"
"             'c': self.method_1}\n"
"\n"
"func = functions[value]\n"
"func()"

#: ../../faq/design.rst:279
msgid ""
"For calling methods on objects, you can simplify yet further by using the :"
"func:`getattr` built-in to retrieve methods with a particular name::"
msgstr ""
"Para chamar métodos em objetos, pode simplificar ainda mais usando a função "
"integrada :func:`getattr` para recuperar métodos com um nome específico:"

#: ../../faq/design.rst:282
msgid ""
"class MyVisitor:\n"
"    def visit_a(self):\n"
"        ...\n"
"\n"
"    def dispatch(self, value):\n"
"        method_name = 'visit_' + str(value)\n"
"        method = getattr(self, method_name)\n"
"        method()"
msgstr ""
"class MyVisitor:\n"
"    def visit_a(self):\n"
"        ...\n"
"\n"
"    def dispatch(self, value):\n"
"        method_name = 'visit_' + str(value)\n"
"        method = getattr(self, method_name)\n"
"        method()"

#: ../../faq/design.rst:291
msgid ""
"It's suggested that you use a prefix for the method names, such as "
"``visit_`` in this example.  Without such a prefix, if values are coming "
"from an untrusted source, an attacker would be able to call any method on "
"your object."
msgstr ""
"É sugerido que use um prefixo para os nomes dos métodos, como ``visit_`` "
"neste exemplo. Sem tal prefixo, se os valores vierem de uma fonte não "
"confiável, um atacante poderia chamar qualquer método no seu objeto."

#: ../../faq/design.rst:295
msgid ""
"Imitating switch with fallthrough, as with C's switch-case-default, is "
"possible, much harder, and less needed."
msgstr ""
"Imitar o switch com fallthrough, como no switch-case-default do C, é "
"possível, muito mais difícil e menos necessário."

#: ../../faq/design.rst:300
msgid ""
"Can't you emulate threads in the interpreter instead of relying on an OS-"
"specific thread implementation?"
msgstr ""
"Não é possível emular threads no interpretador em vez de depender de uma "
"implementação de threads específica do sistema operativo?"

#: ../../faq/design.rst:302
msgid ""
"Answer 1: Unfortunately, the interpreter pushes at least one C stack frame "
"for each Python stack frame.  Also, extensions can call back into Python at "
"almost random moments.  Therefore, a complete threads implementation "
"requires thread support for C."
msgstr ""
"Resposta 1: Infelizmente, o interpretador empilha pelo menos um quadro de "
"pilha C para cada quadro de pilha Python. Além disso, as extensões podem "
"chamar de volta para o Python em momentos quase aleatórios. Portanto, uma "
"implementação completa de threads requer suporte a threads para C."

#: ../../faq/design.rst:307
msgid ""
"Answer 2: Fortunately, there is `Stackless Python <https://github.com/"
"stackless-dev/stackless/wiki>`_, which has a completely redesigned "
"interpreter loop that avoids the C stack."
msgstr ""
"Resposta 2: Felizmente, existe o `Stackless Python <https://github.com/"
"stackless-dev/stackless/wiki>`_, que tem um ciclo de interpretador "
"completamente redesenhado que evita a pilha C."

#: ../../faq/design.rst:312
msgid "Why can't lambda expressions contain statements?"
msgstr "Por que é que as expressões lambda não podem conter instruções?"

#: ../../faq/design.rst:314
msgid ""
"Python lambda expressions cannot contain statements because Python's "
"syntactic framework can't handle statements nested inside expressions.  "
"However, in Python, this is not a serious problem.  Unlike lambda forms in "
"other languages, where they add functionality, Python lambdas are only a "
"shorthand notation if you're too lazy to define a function."
msgstr ""
"As expressões lambda do Python não podem conter instruções porque a "
"framework sintática do Python não consegue lidar com instruções aninhadas "
"dentro de expressões. No entanto, em Python, isto não é um problema sério. "
"Ao contrário das formas lambda noutras linguagens, onde adicionam "
"funcionalidade, as lambdas do Python são apenas uma notação abreviada se for "
"muito preguiçoso para definir uma função."

#: ../../faq/design.rst:320
msgid ""
"Functions are already first class objects in Python, and can be declared in "
"a local scope.  Therefore the only advantage of using a lambda instead of a "
"locally defined function is that you don't need to invent a name for the "
"function -- but that's just a local variable to which the function object "
"(which is exactly the same type of object that a lambda expression yields) "
"is assigned!"
msgstr ""
"As funções já são objetos de primeira classe em Python e podem ser "
"declaradas num âmbito local. Portanto, a única vantagem de usar uma lambda "
"em vez de uma função definida localmente é que não precisa de inventar um "
"nome para a função — mas isso é apenas uma variável local à qual o objeto "
"função (que é exatamente o mesmo tipo de objeto que uma expressão lambda "
"produz) é atribuído!"

#: ../../faq/design.rst:328
msgid "Can Python be compiled to machine code, C or some other language?"
msgstr ""
"O Python pode ser compilado para código de máquina, C ou outra linguagem?"

#: ../../faq/design.rst:330
msgid ""
"`Cython <https://cython.org/>`_ compiles a modified version of Python with "
"optional annotations into C extensions.  `Nuitka <https://nuitka.net/>`_ is "
"an up-and-coming compiler of Python into C++ code, aiming to support the "
"full Python language."
msgstr ""
"O `Cython <https://cython.org/>`_ compila uma versão modificada do Python "
"com anotações opcionais em extensões C. O `Nuitka <https://nuitka.net/>`_ é "
"um compilador em ascensão de Python para código C++, com o objetivo de "
"suportar toda a linguagem Python."

#: ../../faq/design.rst:337
msgid "How does Python manage memory?"
msgstr "Como é que o Python gere a memória?"

#: ../../faq/design.rst:339
msgid ""
"The details of Python memory management depend on the implementation.  The "
"standard implementation of Python, :term:`CPython`, uses reference counting "
"to detect inaccessible objects, and another mechanism to collect reference "
"cycles, periodically executing a cycle detection algorithm which looks for "
"inaccessible cycles and deletes the objects involved. The :mod:`gc` module "
"provides functions to perform a garbage collection, obtain debugging "
"statistics, and tune the collector's parameters."
msgstr ""
"Os detalhes da gestão de memória do Python dependem da implementação. A "
"implementação padrão do Python, :term:`CPython`, usa contagem de referências "
"para detetar objetos inacessíveis e outro mecanismo para recolher ciclos de "
"referência, executando periodicamente um algoritmo de deteção de ciclos que "
"procura ciclos inacessíveis e elimina os objetos envolvidos. O módulo :mod:"
"`gc` fornece funções para realizar uma recolha de lixo, obter estatísticas "
"de depuração e ajustar os parâmetros do recolhedor."

#: ../../faq/design.rst:347
msgid ""
"Other implementations (such as `Jython <https://www.jython.org>`_ or `PyPy "
"<https://pypy.org>`_), however, can rely on a different mechanism such as a "
"full-blown garbage collector.  This difference can cause some subtle porting "
"problems if your Python code depends on the behavior of the reference "
"counting implementation."
msgstr ""
"Outras implementações (como `Jython <https://www.jython.org>`_ ou `PyPy "
"<https://pypy.org>`_), no entanto, podem depender de um mecanismo diferente, "
"como um recolhedor de lixo completo. Esta diferença pode causar alguns "
"problemas subtis de portabilidade se o seu código Python depender do "
"comportamento da implementação de contagem de referências."

#: ../../faq/design.rst:353
msgid ""
"In some Python implementations, the following code (which is fine in "
"CPython) will probably run out of file descriptors::"
msgstr ""
"Em algumas implementações do Python, o seguinte código (que funciona bem no "
"CPython) provavelmente esgotará os descritores de ficheiros:"

#: ../../faq/design.rst:356
msgid ""
"for file in very_long_list_of_files:\n"
"    f = open(file)\n"
"    c = f.read(1)"
msgstr ""
"for file in very_long_list_of_files:\n"
"    f = open(file)\n"
"    c = f.read(1)"

#: ../../faq/design.rst:360
msgid ""
"Indeed, using CPython's reference counting and destructor scheme, each new "
"assignment to ``f`` closes the previous file.  With a traditional GC, "
"however, those file objects will only get collected (and closed) at varying "
"and possibly long intervals."
msgstr ""
"De facto, usando o esquema de contagem de referências e destrutores do "
"CPython, cada nova atribuição a ``f`` fecha o ficheiro anterior. Com um GC "
"tradicional, no entanto, esses objetos de ficheiro só serão recolhidos (e "
"fechados) em intervalos variáveis e possivelmente longos."

#: ../../faq/design.rst:365
msgid ""
"If you want to write code that will work with any Python implementation, you "
"should explicitly close the file or use the :keyword:`with` statement; this "
"will work regardless of memory management scheme::"
msgstr ""
"Se quiser escrever código que funcione com qualquer implementação do Python, "
"deve fechar explicitamente o ficheiro ou usar a instrução :keyword:`with`; "
"isto funcionará independentemente do esquema de gestão de memória:"

#: ../../faq/design.rst:369
msgid ""
"for file in very_long_list_of_files:\n"
"    with open(file) as f:\n"
"        c = f.read(1)"
msgstr ""
"for file in very_long_list_of_files:\n"
"    with open(file) as f:\n"
"        c = f.read(1)"

#: ../../faq/design.rst:375
msgid "Why doesn't CPython use a more traditional garbage collection scheme?"
msgstr ""
"Por que é que o CPython não usa um esquema de recolha de lixo mais "
"tradicional?"

#: ../../faq/design.rst:377
msgid ""
"For one thing, this is not a C standard feature and hence it's not portable. "
"(Yes, we know about the Boehm GC library.  It has bits of assembler code for "
"*most* common platforms, not for all of them, and although it is mostly "
"transparent, it isn't completely transparent; patches are required to get "
"Python to work with it.)"
msgstr ""
"Para começar, isto não é uma funcionalidade padrão de C e, portanto, não é "
"portátil. (Sim, sabemos sobre a biblioteca Boehm GC. Tem bits de código em "
"assembler para *a maioria* das plataformas comuns, não para todas, e embora "
"seja maioritariamente transparente, não é completamente transparente; são "
"necessários patches para fazer o Python funcionar com ela.)"

#: ../../faq/design.rst:383
msgid ""
"Traditional GC also becomes a problem when Python is embedded into other "
"applications.  While in a standalone Python it's fine to replace the "
"standard ``malloc()`` and ``free()`` with versions provided by the GC "
"library, an application embedding Python may want to have its *own* "
"substitute for ``malloc()`` and ``free()``, and may not want Python's.  "
"Right now, CPython works with anything that implements ``malloc()`` and "
"``free()`` properly."
msgstr ""
"A GC tradicional também se torna um problema quando o Python é incorporado "
"noutras aplicações. Embora num Python autónomo seja aceitável substituir o "
"``malloc()`` e ``free()`` padrão por versões fornecidas pela biblioteca GC, "
"uma aplicação que incorpora o Python pode querer ter o seu *próprio* "
"substituto para ``malloc()`` e ``free()``, e pode não querer o do Python. "
"Atualmente, o CPython funciona com qualquer coisa que implemente "
"corretamente ``malloc()`` e ``free()``."

#: ../../faq/design.rst:392
msgid "Why isn't all memory freed when CPython exits?"
msgstr "Por que é que toda a memória não é libertada quando o CPython termina?"

#: ../../faq/design.rst:394
msgid ""
"Objects referenced from the global namespaces of Python modules are not "
"always deallocated when Python exits.  This may happen if there are circular "
"references.  There are also certain bits of memory that are allocated by the "
"C library that are impossible to free (e.g. a tool like Purify will complain "
"about these).  Python is, however, aggressive about cleaning up memory on "
"exit and does try to destroy every single object."
msgstr ""
"Os objetos referenciados a partir dos namespaces globais dos módulos Python "
"não são sempre desalocados quando o Python termina. Isto pode acontecer se "
"existirem referências circulares. Há também certos bits de memória que são "
"alocados pela biblioteca C que são impossíveis de libertar (por exemplo, uma "
"ferramenta como o Purify queixar-se-á deles). No entanto, o Python é "
"agressivo na limpeza da memória na saída e tenta destruir todos os objetos."

#: ../../faq/design.rst:401
msgid ""
"If you want to force Python to delete certain things on deallocation use "
"the :mod:`atexit` module to run a function that will force those deletions."
msgstr ""
"Se quiser forçar o Python a eliminar certas coisas na desalocação, use o "
"módulo :mod:`atexit` para executar uma função que forçará essas eliminações."

#: ../../faq/design.rst:406
msgid "Why are there separate tuple and list data types?"
msgstr "Por que é que existem tipos de dados separados para tuplos e listas?"

#: ../../faq/design.rst:408
msgid ""
"Lists and tuples, while similar in many respects, are generally used in "
"fundamentally different ways.  Tuples can be thought of as being similar to "
"Pascal ``records`` or C ``structs``; they're small collections of related "
"data which may be of different types which are operated on as a group.  For "
"example, a Cartesian coordinate is appropriately represented as a tuple of "
"two or three numbers."
msgstr ""
"As listas e os tuplos, embora semelhantes em muitos aspetos, são geralmente "
"usados de formas fundamentalmente diferentes. Os tuplos podem ser vistos "
"como semelhantes aos ``records`` do Pascal ou às ``structs`` do C; são "
"pequenas coleções de dados relacionados que podem ser de tipos diferentes e "
"que são operados como um grupo. Por exemplo, uma coordenada cartesiana é "
"apropriadamente representada como um tuplo de dois ou três números."

#: ../../faq/design.rst:415
msgid ""
"Lists, on the other hand, are more like arrays in other languages.  They "
"tend to hold a varying number of objects all of which have the same type and "
"which are operated on one-by-one.  For example, :func:`os.listdir('.') <os."
"listdir>` returns a list of strings representing the files in the current "
"directory.  Functions which operate on this output would generally not break "
"if you added another file or two to the directory."
msgstr ""
"As listas, por outro lado, são mais como arrays noutras linguagens. Tendem a "
"conter um número variável de objetos que são todos do mesmo tipo e que são "
"operados um a um. Por exemplo, :func:`os.listdir('.') <os.listdir>` devolve "
"uma lista de strings que representam os ficheiros no diretório atual. As "
"funções que operam nesta saída geralmente não falhariam se adicionasse mais "
"um ou dois ficheiros ao diretório."

#: ../../faq/design.rst:423
msgid ""
"Tuples are immutable, meaning that once a tuple has been created, you can't "
"replace any of its elements with a new value.  Lists are mutable, meaning "
"that you can always change a list's elements.  Only immutable elements can "
"be used as dictionary keys, and hence only tuples and not lists can be used "
"as keys."
msgstr ""
"Os tuplos são imutáveis, o que significa que, uma vez criado um tuplo, não "
"pode substituir nenhum dos seus elementos por um novo valor. As listas são "
"mutáveis, o que significa que pode sempre alterar os elementos de uma lista. "
"Apenas elementos imutáveis podem ser usados como chaves de dicionário e, "
"portanto, apenas tuplos e não listas podem ser usados como chaves."

#: ../../faq/design.rst:430
msgid "How are lists implemented in CPython?"
msgstr "Como é que as listas são implementadas no CPython?"

#: ../../faq/design.rst:432
msgid ""
"CPython's lists are really variable-length arrays, not Lisp-style linked "
"lists. The implementation uses a contiguous array of references to other "
"objects, and keeps a pointer to this array and the array's length in a list "
"head structure."
msgstr ""
"As listas do CPython são, na verdade, arrays de comprimento variável, não "
"listas ligadas ao estilo Lisp. A implementação usa um array contíguo de "
"referências para outros objetos e mantém um ponteiro para este array e o "
"comprimento do array numa estrutura de cabeça de lista."

#: ../../faq/design.rst:436
msgid ""
"This makes indexing a list ``a[i]`` an operation whose cost is independent "
"of the size of the list or the value of the index."
msgstr ""
"Isto faz com que a indexação de uma lista ``a[i]`` seja uma operação cujo "
"custo é independente do tamanho da lista ou do valor do índice."

#: ../../faq/design.rst:439
msgid ""
"When items are appended or inserted, the array of references is resized.  "
"Some cleverness is applied to improve the performance of appending items "
"repeatedly; when the array must be grown, some extra space is allocated so "
"the next few times don't require an actual resize."
msgstr ""
"Quando os itens são adicionados ou inseridos, o array de referências é "
"redimensionado. Alguma astúcia é aplicada para melhorar o desempenho da "
"adição repetida de itens; quando o array tem de ser aumentado, é alocado "
"algum espaço extra para que as próximas vezes não exijam um "
"redimensionamento real."

#: ../../faq/design.rst:446
msgid "How are dictionaries implemented in CPython?"
msgstr "Como é que os dicionários são implementados no CPython?"

#: ../../faq/design.rst:448
msgid ""
"CPython's dictionaries are implemented as resizable hash tables.  Compared "
"to B-trees, this gives better performance for lookup (the most common "
"operation by far) under most circumstances, and the implementation is "
"simpler."
msgstr ""
"Os dicionários do CPython são implementados como tabelas de hash "
"redimensionáveis. Em comparação com as árvores B, isto oferece melhor "
"desempenho para a pesquisa (de longe a operação mais comum) na maioria das "
"circunstâncias, e a implementação é mais simples."

#: ../../faq/design.rst:452
msgid ""
"Dictionaries work by computing a hash code for each key stored in the "
"dictionary using the :func:`hash` built-in function.  The hash code varies "
"widely depending on the key and a per-process seed; for example, "
"``'Python'`` could hash to ``-539294296`` while ``'python'``, a string that "
"differs by a single bit, could hash to ``1142331976``.  The hash code is "
"then used to calculate a location in an internal array where the value will "
"be stored.  Assuming that you're storing keys that all have different hash "
"values, this means that dictionaries take constant time -- *O*\\ (1), in Big-"
"O notation -- to retrieve a key."
msgstr ""
"Os dicionários funcionam calculando um código de hash para cada chave "
"armazenada no dicionário usando a função integrada :func:`hash`. O código de "
"hash varia muito dependendo da chave e de uma semente por processo; por "
"exemplo, ``'Python'`` pode ter um hash de ``-539294296`` enquanto "
"``'python'``, uma string que difere por um único bit, pode ter um hash de "
"``1142331976``. O código de hash é então usado para calcular uma localização "
"num array interno onde o valor será armazenado. Assumindo que está a "
"armazenar chaves que têm todas valores de hash diferentes, isto significa "
"que os dicionários demoram um tempo constante — *O*\\ (1), em notação Big-O "
"— para recuperar uma chave."

#: ../../faq/design.rst:463
msgid "Why must dictionary keys be immutable?"
msgstr "Por que é que as chaves do dicionário têm de ser imutáveis?"

#: ../../faq/design.rst:465
msgid ""
"The hash table implementation of dictionaries uses a hash value calculated "
"from the key value to find the key.  If the key were a mutable object, its "
"value could change, and thus its hash could also change.  But since whoever "
"changes the key object can't tell that it was being used as a dictionary "
"key, it can't move the entry around in the dictionary.  Then, when you try "
"to look up the same object in the dictionary it won't be found because its "
"hash value is different. If you tried to look up the old value it wouldn't "
"be found either, because the value of the object found in that hash bin "
"would be different."
msgstr ""
"A implementação de tabela de hash dos dicionários usa um valor de hash "
"calculado a partir do valor da chave para encontrar a chave. Se a chave "
"fosse um objeto mutável, o seu valor poderia mudar e, portanto, o seu hash "
"também poderia mudar. Mas como quem altera o objeto chave não pode saber que "
"ele estava a ser usado como uma chave de dicionário, não pode mover a "
"entrada no dicionário. Então, quando tentar procurar o mesmo objeto no "
"dicionário, ele não será encontrado porque o seu valor de hash é diferente. "
"Se tentasse procurar o valor antigo, também não seria encontrado, porque o "
"valor do objeto encontrado naquele contentor de hash seria diferente."

#: ../../faq/design.rst:474
msgid ""
"If you want a dictionary indexed with a list, simply convert the list to a "
"tuple first; the function ``tuple(L)`` creates a tuple with the same entries "
"as the list ``L``.  Tuples are immutable and can therefore be used as "
"dictionary keys."
msgstr ""
"Se quiser um dicionário indexado com uma lista, converta simplesmente a "
"lista num tuplo primeiro; a função ``tuple(L)`` cria um tuplo com as mesmas "
"entradas que a lista ``L``. Os tuplos são imutáveis e, portanto, podem ser "
"usados como chaves de dicionário."

#: ../../faq/design.rst:478
msgid "Some unacceptable solutions that have been proposed:"
msgstr "Algumas soluções inaceitáveis que foram propostas:"

#: ../../faq/design.rst:480
msgid ""
"Hash lists by their address (object ID).  This doesn't work because if you "
"construct a new list with the same value it won't be found; e.g.::"
msgstr ""
"Hash de listas pelo seu endereço (ID do objeto). Isto não funciona porque, "
"se construir uma nova lista com o mesmo valor, ela não será encontrada; por "
"exemplo:"

#: ../../faq/design.rst:483
msgid ""
"mydict = {[1, 2]: '12'}\n"
"print(mydict[[1, 2]])"
msgstr ""
"mydict = {[1, 2]: '12'}\n"
"print(mydict[[1, 2]])"

#: ../../faq/design.rst:486
msgid ""
"would raise a :exc:`KeyError` exception because the id of the ``[1, 2]`` "
"used in the second line differs from that in the first line.  In other "
"words, dictionary keys should be compared using ``==``, not using :keyword:"
"`is`."
msgstr ""
"levantaria uma exceção :exc:`KeyError` porque o id do ``[1, 2]`` usado na "
"segunda linha difere do da primeira linha. Em outras palavras, as chaves do "
"dicionário devem ser comparadas usando ``==``, não usando :keyword:`is`."

#: ../../faq/design.rst:490
msgid ""
"Make a copy when using a list as a key.  This doesn't work because the list, "
"being a mutable object, could contain a reference to itself, and then the "
"copying code would run into an infinite loop."
msgstr ""
"Faça uma cópia ao usar uma lista como chave. Isto não funciona porque a "
"lista, sendo um objeto mutável, poderia conter uma referência a si mesma, e "
"então o código de cópia entraria num ciclo infinito."

#: ../../faq/design.rst:494
msgid ""
"Allow lists as keys but tell the user not to modify them.  This would allow "
"a class of hard-to-track bugs in programs when you forgot or modified a list "
"by accident. It also invalidates an important invariant of dictionaries: "
"every value in ``d.keys()`` is usable as a key of the dictionary."
msgstr ""
"Permitir listas como chaves, mas dizer ao utilizador para não as modificar. "
"Isto permitiria uma classe de erros difíceis de rastrear em programas quando "
"se esquecesse ou modificasse uma lista por acidente. Também invalida um "
"invariante importante dos dicionários: todos os valores em ``d.keys()`` são "
"utilizáveis como chave do dicionário."

#: ../../faq/design.rst:499
msgid ""
"Mark lists as read-only once they are used as a dictionary key.  The problem "
"is that it's not just the top-level object that could change its value; you "
"could use a tuple containing a list as a key.  Entering anything as a key "
"into a dictionary would require marking all objects reachable from there as "
"read-only -- and again, self-referential objects could cause an infinite "
"loop."
msgstr ""
"Marcar listas como apenas de leitura uma vez que são usadas como chave de "
"dicionário. O problema é que não é apenas o objeto de nível superior que "
"poderia mudar o seu valor; poderia usar um tuplo contendo uma lista como "
"chave. Inserir qualquer coisa como chave num dicionário exigiria marcar "
"todos os objetos alcançáveis a partir daí como apenas de leitura — e "
"novamente, objetos auto-referenciais poderiam causar um ciclo infinito."

#: ../../faq/design.rst:505
msgid ""
"There is a trick to get around this if you need to, but use it at your own "
"risk: You can wrap a mutable structure inside a class instance which has "
"both a :meth:`~object.__eq__` and a :meth:`~object.__hash__` method. You "
"must then make sure that the hash value for all such wrapper objects that "
"reside in a dictionary (or other hash based structure), remain fixed while "
"the object is in the dictionary (or other structure). ::"
msgstr ""
"Existe um truque para contornar isto, se necessário, mas use-o por sua conta "
"e risco: pode envolver uma estrutura mutável dentro de uma instância de "
"classe que tenha tanto um método :meth:`~object.__eq__` como um método :meth:"
"`~object.__hash__`. Deve então garantir que o valor de hash para todos os "
"objetos wrapper que residem num dicionário (ou outra estrutura baseada em "
"hash) permanece fixo enquanto o objeto está no dicionário (ou outra "
"estrutura)."

#: ../../faq/design.rst:513
msgid ""
"class ListWrapper:\n"
"    def __init__(self, the_list):\n"
"        self.the_list = the_list\n"
"\n"
"    def __eq__(self, other):\n"
"        return self.the_list == other.the_list\n"
"\n"
"    def __hash__(self):\n"
"        l = self.the_list\n"
"        result = 98767 - len(l)*555\n"
"        for i, el in enumerate(l):\n"
"            try:\n"
"                result = result + (hash(el) % 9999999) * 1001 + i\n"
"            except Exception:\n"
"                result = (result % 7777777) + i * 333\n"
"        return result"
msgstr ""
"class ListWrapper:\n"
"    def __init__(self, the_list):\n"
"        self.the_list = the_list\n"
"\n"
"    def __eq__(self, other):\n"
"        return self.the_list == other.the_list\n"
"\n"
"    def __hash__(self):\n"
"        l = self.the_list\n"
"        result = 98767 - len(l)*555\n"
"        for i, el in enumerate(l):\n"
"            try:\n"
"                result = result + (hash(el) % 9999999) * 1001 + i\n"
"            except Exception:\n"
"                result = (result % 7777777) + i * 333\n"
"        return result"

#: ../../faq/design.rst:530
msgid ""
"Note that the hash computation is complicated by the possibility that some "
"members of the list may be unhashable and also by the possibility of "
"arithmetic overflow."
msgstr ""
"Note que o cálculo do hash é complicado pela possibilidade de alguns membros "
"da lista não serem hasháveis e também pela possibilidade de overflow "
"aritmético."

#: ../../faq/design.rst:534
msgid ""
"Furthermore it must always be the case that if ``o1 == o2`` (ie ``o1."
"__eq__(o2) is True``) then ``hash(o1) == hash(o2)`` (ie, ``o1.__hash__() == "
"o2.__hash__()``), regardless of whether the object is in a dictionary or "
"not.  If you fail to meet these restrictions dictionaries and other hash "
"based structures will misbehave."
msgstr ""
"Além disso, deve ser sempre o caso que, se ``o1 == o2`` (ou seja, ``o1."
"__eq__(o2) is True``), então ``hash(o1) == hash(o2)`` (ou seja, ``o1."
"__hash__() == o2.__hash__()``), independentemente de o objeto estar ou não "
"num dicionário. Se não cumprir estas restrições, os dicionários e outras "
"estruturas baseadas em hash comportar-se-ão mal."

#: ../../faq/design.rst:539
msgid ""
"In the case of :class:`!ListWrapper`, whenever the wrapper object is in a "
"dictionary the wrapped list must not change to avoid anomalies.  Don't do "
"this unless you are prepared to think hard about the requirements and the "
"consequences of not meeting them correctly.  Consider yourself warned."
msgstr ""
"No caso de :class:`!ListWrapper`, sempre que o objeto wrapper estiver num "
"dicionário, a lista envolvida não deve mudar para evitar anomalias. Não faça "
"isto a menos que esteja preparado para pensar cuidadosamente nos requisitos "
"e nas consequências de não os cumprir corretamente. Considere-se avisado."

#: ../../faq/design.rst:546
msgid "Why doesn't list.sort() return the sorted list?"
msgstr "Por que é que list.sort() não devolve a lista ordenada?"

#: ../../faq/design.rst:548
msgid ""
"In situations where performance matters, making a copy of the list just to "
"sort it would be wasteful. Therefore, :meth:`list.sort` sorts the list in "
"place. In order to remind you of that fact, it does not return the sorted "
"list.  This way, you won't be fooled into accidentally overwriting a list "
"when you need a sorted copy but also need to keep the unsorted version "
"around."
msgstr ""
"Em situações em que o desempenho importa, fazer uma cópia da lista apenas "
"para a ordenar seria um desperdício. Portanto, :meth:`list.sort` ordena a "
"lista no local. Para o lembrar desse facto, não devolve a lista ordenada. "
"Desta forma, não será enganado a sobrescrever acidentalmente uma lista "
"quando precisar de uma cópia ordenada, mas também precisar de manter a "
"versão não ordenada."

#: ../../faq/design.rst:554
msgid ""
"If you want to return a new list, use the built-in :func:`sorted` function "
"instead.  This function creates a new list from a provided iterable, sorts "
"it and returns it.  For example, here's how to iterate over the keys of a "
"dictionary in sorted order::"
msgstr ""
"Se quiser devolver uma nova lista, use em vez disso a função integrada :func:"
"`sorted`. Esta função cria uma nova lista a partir de um iterável fornecido, "
"ordena-a e devolve-a. Por exemplo, aqui está como iterar sobre as chaves de "
"um dicionário por ordem ordenada:"

#: ../../faq/design.rst:559
msgid ""
"for key in sorted(mydict):\n"
"    ...  # do whatever with mydict[key]..."
msgstr ""
"for key in sorted(mydict):\n"
"    ...  # faça o que quiser com mydict[key]..."

#: ../../faq/design.rst:564
msgid "How do you specify and enforce an interface spec in Python?"
msgstr ""
"Como é que se especifica e impõe uma especificação de interface em Python?"

#: ../../faq/design.rst:566
msgid ""
"An interface specification for a module as provided by languages such as C++ "
"and Java describes the prototypes for the methods and functions of the "
"module.  Many feel that compile-time enforcement of interface specifications "
"helps in the construction of large programs."
msgstr ""
"Uma especificação de interface para um módulo, como fornecida por linguagens "
"como C++ e Java, descreve os protótipos para os métodos e funções do módulo. "
"Muitos acreditam que a imposição em tempo de compilação das especificações "
"de interface ajuda na construção de grandes programas."

#: ../../faq/design.rst:571
msgid ""
"Python 2.6 adds an :mod:`abc` module that lets you define Abstract Base "
"Classes (ABCs).  You can then use :func:`isinstance` and :func:`issubclass` "
"to check whether an instance or a class implements a particular ABC.  The :"
"mod:`collections.abc` module defines a set of useful ABCs such as :class:"
"`~collections.abc.Iterable`, :class:`~collections.abc.Container`, and :class:"
"`~collections.abc.MutableMapping`."
msgstr ""
"O Python 2.6 adiciona um módulo :mod:`abc` que permite definir Classes Base "
"Abstratas (ABCs). Pode então usar :func:`isinstance` e :func:`issubclass` "
"para verificar se uma instância ou uma classe implementa uma ABC específica. "
"O módulo :mod:`collections.abc` define um conjunto de ABCs úteis, como :"
"class:`~collections.abc.Iterable`, :class:`~collections.abc.Container` e :"
"class:`~collections.abc.MutableMapping`."

#: ../../faq/design.rst:578
msgid ""
"For Python, many of the advantages of interface specifications can be "
"obtained by an appropriate test discipline for components."
msgstr ""
"Em Python, muitas das vantagens das especificações de interface podem ser "
"obtidas através de uma disciplina de teste adequada para os componentes."

#: ../../faq/design.rst:581
msgid ""
"A good test suite for a module can both provide a regression test and serve "
"as a module interface specification and a set of examples.  Many Python "
"modules can be run as a script to provide a simple \"self test.\"  Even "
"modules which use complex external interfaces can often be tested in "
"isolation using trivial \"stub\" emulations of the external interface.  The :"
"mod:`doctest` and :mod:`unittest` modules or third-party test frameworks can "
"be used to construct exhaustive test suites that exercise every line of code "
"in a module."
msgstr ""
"Uma boa suite de testes para um módulo pode fornecer tanto um teste de "
"regressão como servir de especificação de interface do módulo e um conjunto "
"de exemplos. Muitos módulos Python podem ser executados como um script para "
"fornecer um simples \"auto-teste\". Mesmo módulos que usam interfaces "
"externas complexas podem frequentemente ser testados em isolamento usando "
"emulações triviais de \"stub\" da interface externa. Os módulos :mod:"
"`doctest` e :mod:`unittest` ou frameworks de teste de terceiros podem ser "
"usados para construir suites de teste exaustivas que exercitem cada linha de "
"código num módulo."

#: ../../faq/design.rst:589
msgid ""
"An appropriate testing discipline can help build large complex applications "
"in Python as well as having interface specifications would.  In fact, it can "
"be better because an interface specification cannot test certain properties "
"of a program.  For example, the :meth:`list.append` method is expected to "
"add new elements to the end of some internal list; an interface "
"specification cannot test that your :meth:`list.append` implementation will "
"actually do this correctly, but it's trivial to check this property in a "
"test suite."
msgstr ""
"Uma disciplina de teste adequada pode ajudar a construir aplicações grandes "
"e complexas em Python tanto quanto ter especificações de interface. Na "
"verdade, pode ser melhor porque uma especificação de interface não pode "
"testar certas propriedades de um programa. Por exemplo, espera-se que o "
"método :meth:`list.append` adicione novos elementos ao final de alguma lista "
"interna; uma especificação de interface não pode testar se a sua "
"implementação de :meth:`list.append` fará isto corretamente, mas é trivial "
"verificar esta propriedade numa suite de testes."

#: ../../faq/design.rst:597
msgid ""
"Writing test suites is very helpful, and you might want to design your code "
"to make it easily tested. One increasingly popular technique, test-driven "
"development, calls for writing parts of the test suite first, before you "
"write any of the actual code.  Of course Python allows you to be sloppy and "
"not write test cases at all."
msgstr ""
"Escrever suites de teste é muito útil, e pode querer projetar o seu código "
"para que seja facilmente testado. Uma técnica cada vez mais popular, o "
"desenvolvimento orientado por testes, exige escrever partes da suite de "
"testes primeiro, antes de escrever qualquer código real. Claro que o Python "
"permite que seja descuidado e não escreva casos de teste de todo."

#: ../../faq/design.rst:605
msgid "Why is there no goto?"
msgstr "Por que é que não existe goto?"

#: ../../faq/design.rst:607
msgid ""
"In the 1970s people realized that unrestricted goto could lead to messy "
"\"spaghetti\" code that was hard to understand and revise. In a high-level "
"language, it is also unneeded as long as there are ways to branch (in "
"Python, with :keyword:`if` statements and :keyword:`or`, :keyword:`and`, "
"and :keyword:`if`/:keyword:`else` expressions) and loop (with :keyword:"
"`while` and :keyword:`for` statements, possibly containing :keyword:"
"`continue` and :keyword:`break`)."
msgstr ""
"Na década de 1970, as pessoas perceberam que o goto sem restrições poderia "
"levar a código \"espaguete\" confuso, difícil de entender e rever. Numa "
"linguagem de alto nível, também é desnecessário, desde que existam formas de "
"ramificar (em Python, com instruções :keyword:`if` e expressões :keyword:"
"`or`, :keyword:`and` e :keyword:`if`/:keyword:`else`) e fazer ciclos (com "
"instruções :keyword:`while` e :keyword:`for`, possivelmente contendo :"
"keyword:`continue` e :keyword:`break`)."

#: ../../faq/design.rst:614
msgid ""
"One can also use exceptions to provide a \"structured goto\" that works even "
"across function calls.  Many feel that exceptions can conveniently emulate "
"all reasonable uses of the ``go`` or ``goto`` constructs of C, Fortran, and "
"other languages.  For example::"
msgstr ""
"Também se podem usar exceções para fornecer um \"goto estruturado\" que "
"funciona mesmo através de chamadas de função. Muitos acreditam que as "
"exceções podem emular convenientemente todos os usos razoáveis das "
"construções ``go`` ou ``goto`` de C, Fortran e outras linguagens. Por "
"exemplo:"

#: ../../faq/design.rst:620
msgid ""
"class label(Exception): pass  # declare a label\n"
"\n"
"try:\n"
"    ...\n"
"    if condition: raise label()  # goto label\n"
"    ...\n"
"except label:  # where to goto\n"
"    pass\n"
"..."
msgstr ""
"class label(Exception): pass  # declarar uma etiqueta\n"
"\n"
"try:\n"
"    ...\n"
"    if condition: raise label()  # goto label\n"
"    ...\n"
"except label:  # para onde ir\n"
"    pass\n"
"..."

#: ../../faq/design.rst:630
msgid ""
"This doesn't allow you to jump into the middle of a loop, but that's usually "
"considered an abuse of ``goto`` anyway.  Use sparingly."
msgstr ""
"Isto não permite saltar para o meio de um ciclo, mas isso é geralmente "
"considerado um abuso de ``goto`` de qualquer forma. Use com moderação."

#: ../../faq/design.rst:635
msgid "Why can't raw strings (r-strings) end with a backslash?"
msgstr ""
"Por que é que as strings brutas (r-strings) não podem terminar com uma barra "
"invertida?"

#: ../../faq/design.rst:637
msgid ""
"More precisely, they can't end with an odd number of backslashes: the "
"unpaired backslash at the end escapes the closing quote character, leaving "
"an unterminated string."
msgstr ""
"Mais precisamente, não podem terminar com um número ímpar de barras "
"invertidas: a barra invertida não emparelhada no final escapa o caractere de "
"aspas de fecho, deixando uma string não terminada."

#: ../../faq/design.rst:641
msgid ""
"Raw strings were designed to ease creating input for processors (chiefly "
"regular expression engines) that want to do their own backslash escape "
"processing. Such processors consider an unmatched trailing backslash to be "
"an error anyway, so raw strings disallow that.  In return, they allow you to "
"pass on the string quote character by escaping it with a backslash.  These "
"rules work well when r-strings are used for their intended purpose."
msgstr ""
"As strings brutas foram concebidas para facilitar a criação de entrada para "
"processadores (principalmente motores de expressões regulares) que pretendem "
"fazer o seu próprio processamento de escape de barra invertida. Tais "
"processadores consideram uma barra invertida final não emparelhada como um "
"erro, por isso as strings brutas não o permitem. Em troca, permitem passar o "
"caractere de aspas da string escapando-o com uma barra invertida. Estas "
"regras funcionam bem quando as r-strings são usadas para o seu propósito "
"intencionado."

#: ../../faq/design.rst:648
msgid ""
"If you're trying to build Windows pathnames, note that all Windows system "
"calls accept forward slashes too::"
msgstr ""
"Se está a tentar construir caminhos do Windows, note que todas as chamadas "
"do sistema Windows também aceitam barras para a frente:"

#: ../../faq/design.rst:651
msgid "f = open(\"/mydir/file.txt\")  # works fine!"
msgstr "f = open(\"/mydir/file.txt\")  # funciona bem!"

#: ../../faq/design.rst:653
msgid ""
"If you're trying to build a pathname for a DOS command, try e.g. one of ::"
msgstr ""
"Se está a tentar construir um caminho para um comando DOS, experimente, por "
"exemplo, uma das seguintes opções:"

#: ../../faq/design.rst:655
msgid ""
"dir = r\"\\this\\is\\my\\dos\\dir\" \"\\\\\"\n"
"dir = r\"\\this\\is\\my\\dos\\dir\\ \"[:-1]\n"
"dir = \"\\\\this\\\\is\\\\my\\\\dos\\\\dir\\\\\""
msgstr ""
"dir = r\"\\this\\is\\my\\dos\\dir\" \"\\\\\"\n"
"dir = r\"\\this\\is\\my\\dos\\dir\\ \"[:-1]\n"
"dir = \"\\\\this\\\\is\\\\my\\\\dos\\\\dir\\\\\""

#: ../../faq/design.rst:661
msgid "Why doesn't Python have a \"with\" statement for attribute assignments?"
msgstr ""
"Por que é que o Python não tem uma instrução \"with\" para atribuições de "
"atributos?"

#: ../../faq/design.rst:663
msgid ""
"Python has a :keyword:`with` statement that wraps the execution of a block, "
"calling code on the entrance and exit from the block.  Some languages have a "
"construct that looks like this::"
msgstr ""
"O Python tem uma instrução :keyword:`with` que envolve a execução de um "
"bloco, chamando código na entrada e saída do bloco. Algumas linguagens têm "
"uma construção que se parece com isto:"

#: ../../faq/design.rst:667
msgid ""
"with obj:\n"
"    a = 1               # equivalent to obj.a = 1\n"
"    total = total + 1   # obj.total = obj.total + 1"
msgstr ""
"with obj:\n"
"    a = 1               # equivalente a obj.a = 1\n"
"    total = total + 1   # obj.total = obj.total + 1"

#: ../../faq/design.rst:671
msgid "In Python, such a construct would be ambiguous."
msgstr "Em Python, tal construção seria ambígua."

#: ../../faq/design.rst:673
msgid ""
"Other languages, such as Object Pascal, Delphi, and C++, use static types, "
"so it's possible to know, in an unambiguous way, what member is being "
"assigned to. This is the main point of static typing -- the compiler "
"*always* knows the scope of every variable at compile time."
msgstr ""
"Outras linguagens, como Object Pascal, Delphi e C++, usam tipos estáticos, "
"por isso é possível saber, de forma inequívoca, a que membro está a ser "
"atribuído um valor. Este é o principal ponto da tipagem estática — o "
"compilador *sempre* conhece o âmbito de cada variável em tempo de compilação."

#: ../../faq/design.rst:678
msgid ""
"Python uses dynamic types. It is impossible to know in advance which "
"attribute will be referenced at runtime. Member attributes may be added or "
"removed from objects on the fly. This makes it impossible to know, from a "
"simple reading, what attribute is being referenced: a local one, a global "
"one, or a member attribute?"
msgstr ""
"O Python usa tipos dinâmicos. É impossível saber antecipadamente qual o "
"atributo que será referenciado em tempo de execução. Os atributos de membro "
"podem ser adicionados ou removidos dos objetos dinamicamente. Isto torna "
"impossível saber, a partir de uma simples leitura, a que atributo se está a "
"referir: um local, um global ou um atributo de membro?"

#: ../../faq/design.rst:684
msgid "For instance, take the following incomplete snippet::"
msgstr "Por exemplo, considere o seguinte excerto incompleto:"

#: ../../faq/design.rst:686
msgid ""
"def foo(a):\n"
"    with a:\n"
"        print(x)"
msgstr ""
"def foo(a):\n"
"    with a:\n"
"        print(x)"

#: ../../faq/design.rst:690
msgid ""
"The snippet assumes that ``a`` must have a member attribute called ``x``. "
"However, there is nothing in Python that tells the interpreter this. What "
"should happen if ``a`` is, let us say, an integer?  If there is a global "
"variable named ``x``, will it be used inside the :keyword:`with` block?  As "
"you see, the dynamic nature of Python makes such choices much harder."
msgstr ""
"O excerto assume que ``a`` deve ter um atributo de membro chamado ``x``. No "
"entanto, não há nada em Python que indique isso ao interpretador. O que "
"deverá acontecer se ``a`` for, digamos, um inteiro? Se existir uma variável "
"global chamada ``x``, será usada dentro do bloco :keyword:`with`? Como pode "
"ver, a natureza dinâmica do Python torna estas escolhas muito mais difíceis."

#: ../../faq/design.rst:696
msgid ""
"The primary benefit of :keyword:`with` and similar language features "
"(reduction of code volume) can, however, easily be achieved in Python by "
"assignment.  Instead of::"
msgstr ""
"O principal benefício de :keyword:`with` e funcionalidades semelhantes da "
"linguagem (redução do volume de código) pode, no entanto, ser facilmente "
"alcançado em Python através de atribuição. Em vez de:"

#: ../../faq/design.rst:699
msgid ""
"function(args).mydict[index][index].a = 21\n"
"function(args).mydict[index][index].b = 42\n"
"function(args).mydict[index][index].c = 63"
msgstr ""
"function(args).mydict[index][index].a = 21\n"
"function(args).mydict[index][index].b = 42\n"
"function(args).mydict[index][index].c = 63"

#: ../../faq/design.rst:703
msgid "write this::"
msgstr "escreva isto:"

#: ../../faq/design.rst:705
msgid ""
"ref = function(args).mydict[index][index]\n"
"ref.a = 21\n"
"ref.b = 42\n"
"ref.c = 63"
msgstr ""
"ref = function(args).mydict[index][index]\n"
"ref.a = 21\n"
"ref.b = 42\n"
"ref.c = 63"

#: ../../faq/design.rst:710
msgid ""
"This also has the side-effect of increasing execution speed because name "
"bindings are resolved at run-time in Python, and the second version only "
"needs to perform the resolution once."
msgstr ""
"Isto também tem o efeito secundário de aumentar a velocidade de execução "
"porque as ligações de nomes são resolvidas em tempo de execução em Python, e "
"a segunda versão só precisa de realizar a resolução uma vez."

#: ../../faq/design.rst:714
msgid ""
"Similar proposals that would introduce syntax to further reduce code volume, "
"such as using a 'leading dot', have been rejected in favour of explicitness "
"(see https://mail.python.org/pipermail/python-ideas/2016-May/040070.html)."
msgstr ""
"Propostas semelhantes que introduziriam sintaxe para reduzir ainda mais o "
"volume de código, como o uso de um 'ponto inicial', foram rejeitadas em "
"favor da explicitude (consulte https://mail.python.org/pipermail/python-"
"ideas/2016-May/040070.html)."

#: ../../faq/design.rst:720
msgid "Why don't generators support the with statement?"
msgstr "Por que é que os geradores não suportam a instrução with?"

#: ../../faq/design.rst:722
msgid ""
"For technical reasons, a generator used directly as a context manager would "
"not work correctly.  When, as is most common, a generator is used as an "
"iterator run to completion, no closing is needed.  When it is, wrap it as :"
"func:`contextlib.closing(generator) <contextlib.closing>` in the :keyword:"
"`with` statement."
msgstr ""
"Por razões técnicas, um gerador usado diretamente como gestor de contexto "
"não funcionaria corretamente. Quando, como é mais comum, um gerador é usado "
"como um iterador executado até ao fim, não é necessário fecho. Quando é "
"necessário, envolva-o como :func:`contextlib.closing(generator) <contextlib."
"closing>` na instrução :keyword:`with`."

#: ../../faq/design.rst:730
msgid "Why are colons required for the if/while/def/class statements?"
msgstr ""
"Por que é que os dois pontos são obrigatórios nas instruções if/while/def/"
"class?"

#: ../../faq/design.rst:732
msgid ""
"The colon is required primarily to enhance readability (one of the results "
"of the experimental ABC language).  Consider this::"
msgstr ""
"O dois pontos é exigido principalmente para melhorar a legibilidade (um dos "
"resultados da linguagem experimental ABC). Considere isto:"

#: ../../faq/design.rst:735
msgid ""
"if a == b\n"
"    print(a)"
msgstr ""
"if a == b\n"
"    print(a)"

#: ../../faq/design.rst:738
msgid "versus ::"
msgstr "versus:"

#: ../../faq/design.rst:740
msgid ""
"if a == b:\n"
"    print(a)"
msgstr ""
"if a == b:\n"
"    print(a)"

#: ../../faq/design.rst:743
msgid ""
"Notice how the second one is slightly easier to read.  Notice further how a "
"colon sets off the example in this FAQ answer; it's a standard usage in "
"English."
msgstr ""
"Repare como o segundo é ligeiramente mais fácil de ler. Repare ainda como um "
"dois pontos destaca o exemplo nesta resposta da FAQ; é um uso padrão em "
"inglês."

#: ../../faq/design.rst:746
msgid ""
"Another minor reason is that the colon makes it easier for editors with "
"syntax highlighting; they can look for colons to decide when indentation "
"needs to be increased instead of having to do a more elaborate parsing of "
"the program text."
msgstr ""
"Outra razão menor é que o dois pontos facilita a vida dos editores com "
"realce de sintaxe; podem procurar dois pontos para decidir quando a "
"indentação precisa de ser aumentada, em vez de terem de fazer uma análise "
"mais elaborada do texto do programa."

#: ../../faq/design.rst:752
msgid "Why does Python allow commas at the end of lists and tuples?"
msgstr "Por que é que o Python permite vírgulas no final de listas e tuplos?"

#: ../../faq/design.rst:754
msgid ""
"Python lets you add a trailing comma at the end of lists, tuples, and "
"dictionaries::"
msgstr ""
"O Python permite adicionar uma vírgula final no final de listas, tuplos e "
"dicionários:"

#: ../../faq/design.rst:757
msgid ""
"[1, 2, 3,]\n"
"('a', 'b', 'c',)\n"
"d = {\n"
"    \"A\": [1, 5],\n"
"    \"B\": [6, 7],  # last trailing comma is optional but good style\n"
"}"
msgstr ""
"[1, 2, 3,]\n"
"('a', 'b', 'c',)\n"
"d = {\n"
"    \"A\": [1, 5],\n"
"    \"B\": [6, 7],  # a última vírgula final é opcional, mas é um bom "
"estilo\n"
"}"

#: ../../faq/design.rst:765
msgid "There are several reasons to allow this."
msgstr "Existem várias razões para permitir isto."

#: ../../faq/design.rst:767
msgid ""
"When you have a literal value for a list, tuple, or dictionary spread across "
"multiple lines, it's easier to add more elements because you don't have to "
"remember to add a comma to the previous line.  The lines can also be "
"reordered without creating a syntax error."
msgstr ""
"Quando tem um valor literal para uma lista, tuplo ou dicionário distribuído "
"por várias linhas, é mais fácil adicionar mais elementos porque não tem de "
"se lembrar de adicionar uma vírgula à linha anterior. As linhas também podem "
"ser reordenadas sem criar um erro de sintaxe."

#: ../../faq/design.rst:772
msgid ""
"Accidentally omitting the comma can lead to errors that are hard to "
"diagnose. For example::"
msgstr ""
"Omitir acidentalmente a vírgula pode levar a erros difíceis de diagnosticar. "
"Por exemplo:"

#: ../../faq/design.rst:775
msgid ""
"x = [\n"
"  \"fee\",\n"
"  \"fie\"\n"
"  \"foo\",\n"
"  \"fum\"\n"
"]"
msgstr ""
"x = [\n"
"  \"fee\",\n"
"  \"fie\"\n"
"  \"foo\",\n"
"  \"fum\"\n"
"]"

#: ../../faq/design.rst:782
msgid ""
"This list looks like it has four elements, but it actually contains three: "
"\"fee\", \"fiefoo\" and \"fum\".  Always adding the comma avoids this source "
"of error."
msgstr ""
"Esta lista parece ter quatro elementos, mas na verdade contém três: \"fee\", "
"\"fiefoo\" e \"fum\". Adicionar sempre a vírgula evita esta fonte de erro."

#: ../../faq/design.rst:785
msgid ""
"Allowing the trailing comma may also make programmatic code generation "
"easier."
msgstr ""
"Permitir a vírgula final também pode facilitar a geração programática de "
"código."
