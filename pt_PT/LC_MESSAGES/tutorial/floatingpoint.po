# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-29 14:16+0000\n"
"PO-Revision-Date: 2025-09-16 00:02+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../tutorial/floatingpoint.rst:10
msgid "Floating-Point Arithmetic:  Issues and Limitations"
msgstr "Aritmética de ponto flutuante: problemas e limitações"

#: ../../tutorial/floatingpoint.rst:16
msgid ""
"Floating-point numbers are represented in computer hardware as base 2 "
"(binary) fractions.  For example, the **decimal** fraction ``0.625`` has "
"value 6/10 + 2/100 + 5/1000, and in the same way the **binary** fraction "
"``0.101`` has value 1/2 + 0/4 + 1/8. These two fractions have identical "
"values, the only real difference being that the first is written in base 10 "
"fractional notation, and the second in base 2."
msgstr ""
"Os números de ponto flutuante são representados no hardware do computador "
"como frações de base 2 (binárias). Por exemplo, a fração **decimal** "
"``0.625`` tem o valor 6/10 + 2/100 + 5/1000, e da mesma forma, a fração "
"**binária** ``0.101`` tem o valor 1/2 + 0/4 + 1/8. Estas duas frações têm "
"valores idênticos, a única diferença real é que a primeira está escrita em "
"notação fracionária de base 10, e a segunda em base 2."

#: ../../tutorial/floatingpoint.rst:23
msgid ""
"Unfortunately, most decimal fractions cannot be represented exactly as "
"binary fractions.  A consequence is that, in general, the decimal floating-"
"point numbers you enter are only approximated by the binary floating-point "
"numbers actually stored in the machine."
msgstr ""
"Infelizmente, a maioria das frações decimais não pode ser representada "
"exatamente como frações binárias. Uma consequência é que, em geral, os "
"números de ponto flutuante decimais que introduz são apenas aproximados "
"pelos números de ponto flutuante binários realmente armazenados na máquina."

#: ../../tutorial/floatingpoint.rst:28
msgid ""
"The problem is easier to understand at first in base 10.  Consider the "
"fraction 1/3.  You can approximate that as a base 10 fraction::"
msgstr ""
"O problema é mais fácil de entender inicialmente em base 10. Considere a "
"fração 1/3. Pode aproximá-la como uma fração de base 10::"

#: ../../tutorial/floatingpoint.rst:31
msgid "0.3"
msgstr "0.3"

#: ../../tutorial/floatingpoint.rst:33 ../../tutorial/floatingpoint.rst:37
msgid "or, better, ::"
msgstr "ou, melhor, ::"

#: ../../tutorial/floatingpoint.rst:35
msgid "0.33"
msgstr "0.33"

#: ../../tutorial/floatingpoint.rst:39
msgid "0.333"
msgstr "0.333"

#: ../../tutorial/floatingpoint.rst:41
msgid ""
"and so on.  No matter how many digits you're willing to write down, the "
"result will never be exactly 1/3, but will be an increasingly better "
"approximation of 1/3."
msgstr ""
"e assim sucessivamente. Não importa quantos dígitos esteja disposto a "
"escrever, o resultado nunca será exatamente 1/3, mas será uma aproximação "
"cada vez melhor de 1/3."

#: ../../tutorial/floatingpoint.rst:45
msgid ""
"In the same way, no matter how many base 2 digits you're willing to use, the "
"decimal value 0.1 cannot be represented exactly as a base 2 fraction.  In "
"base 2, 1/10 is the infinitely repeating fraction ::"
msgstr ""
"Da mesma forma, não importa quantos dígitos de base 2 esteja disposto a "
"usar, o valor decimal 0.1 não pode ser representado exatamente como uma "
"fração de base 2. Em base 2, 1/10 é a fração infinitamente repetida::"

#: ../../tutorial/floatingpoint.rst:49
msgid "0.0001100110011001100110011001100110011001100110011..."
msgstr "0.0001100110011001100110011001100110011001100110011..."

#: ../../tutorial/floatingpoint.rst:51
msgid ""
"Stop at any finite number of bits, and you get an approximation.  On most "
"machines today, floats are approximated using a binary fraction with the "
"numerator using the first 53 bits starting with the most significant bit and "
"with the denominator as a power of two.  In the case of 1/10, the binary "
"fraction is ``3602879701896397 / 2 ** 55`` which is close to but not exactly "
"equal to the true value of 1/10."
msgstr ""
"Pare em qualquer número finito de bits e obterá uma aproximação. Na maioria "
"das máquinas atuais, os números de ponto flutuante são aproximados usando "
"uma fração binária com o numerador a usar os primeiros 53 bits, começando "
"com o bit mais significativo, e o denominador como uma potência de dois. No "
"caso de 1/10, a fração binária é ``3602879701896397 / 2 ** 55``, que está "
"próxima, mas não é exatamente igual ao valor real de 1/10."

#: ../../tutorial/floatingpoint.rst:58
msgid ""
"Many users are not aware of the approximation because of the way values are "
"displayed.  Python only prints a decimal approximation to the true decimal "
"value of the binary approximation stored by the machine.  On most machines, "
"if Python were to print the true decimal value of the binary approximation "
"stored for 0.1, it would have to display::"
msgstr ""
"Muitos utilizadores não estão cientes da aproximação devido à forma como os "
"valores são apresentados. O Python apenas imprime uma aproximação decimal ao "
"valor decimal real da aproximação binária armazenada pela máquina. Na "
"maioria das máquinas, se o Python imprimisse o valor decimal real da "
"aproximação binária armazenada para 0.1, teria de mostrar::"

#: ../../tutorial/floatingpoint.rst:64
msgid ""
">>> 0.1\n"
"0.1000000000000000055511151231257827021181583404541015625"
msgstr ""
">>> 0.1\n"
"0.1000000000000000055511151231257827021181583404541015625"

#: ../../tutorial/floatingpoint.rst:67
msgid ""
"That is more digits than most people find useful, so Python keeps the number "
"of digits manageable by displaying a rounded value instead:"
msgstr ""
"Isso são mais dígitos do que a maioria das pessoas considera útil, por isso "
"o Python mantém o número de dígitos gerível, mostrando um valor arredondado:"

#: ../../tutorial/floatingpoint.rst:70
msgid ""
">>> 1 / 10\n"
"0.1"
msgstr ""
">>> 1 / 10\n"
"0.1"

#: ../../tutorial/floatingpoint.rst:75
msgid ""
"Just remember, even though the printed result looks like the exact value of "
"1/10, the actual stored value is the nearest representable binary fraction."
msgstr ""
"Lembre-se apenas que, embora o resultado impresso pareça o valor exato de "
"1/10, o valor realmente armazenado é a fração binária representável mais "
"próxima."

#: ../../tutorial/floatingpoint.rst:78
msgid ""
"Interestingly, there are many different decimal numbers that share the same "
"nearest approximate binary fraction.  For example, the numbers ``0.1`` and "
"``0.10000000000000001`` and "
"``0.1000000000000000055511151231257827021181583404541015625`` are all "
"approximated by ``3602879701896397 / 2 ** 55``.  Since all of these decimal "
"values share the same approximation, any one of them could be displayed "
"while still preserving the invariant ``eval(repr(x)) == x``."
msgstr ""
"Curiosamente, existem muitos números decimais diferentes que partilham a "
"mesma aproximação binária mais próxima. Por exemplo, os números ``0.1``, "
"``0.10000000000000001`` e "
"``0.1000000000000000055511151231257827021181583404541015625`` são todos "
"aproximados por ``3602879701896397 / 2 ** 55``. Uma vez que todos estes "
"valores decimais partilham a mesma aproximação, qualquer um deles poderia "
"ser apresentado, mantendo ainda o invariante ``eval(repr(x)) == x``."

#: ../../tutorial/floatingpoint.rst:86
msgid ""
"Historically, the Python prompt and built-in :func:`repr` function would "
"choose the one with 17 significant digits, ``0.10000000000000001``.   "
"Starting with Python 3.1, Python (on most systems) is now able to choose the "
"shortest of these and simply display ``0.1``."
msgstr ""
"Historicamente, o prompt do Python e a função integrada :func:`repr` "
"escolheriam a opção com 17 dígitos significativos, ``0.10000000000000001``. "
"A partir do Python 3.1, o Python (na maioria dos sistemas) é agora capaz de "
"escolher a mais curta destas opções e simplesmente apresentar ``0.1``."

#: ../../tutorial/floatingpoint.rst:91
msgid ""
"Note that this is in the very nature of binary floating point: this is not a "
"bug in Python, and it is not a bug in your code either.  You'll see the same "
"kind of thing in all languages that support your hardware's floating-point "
"arithmetic (although some languages may not *display* the difference by "
"default, or in all output modes)."
msgstr ""
"Note que isto é inerente à natureza do ponto flutuante binário: não é um "
"erro no Python, nem é um erro no seu código. Verá o mesmo tipo de coisa em "
"todas as linguagens que suportam a aritmética de ponto flutuante do seu "
"hardware (embora algumas linguagens possam não *mostrar* a diferença por "
"predefinição, ou em todos os modos de saída)."

#: ../../tutorial/floatingpoint.rst:97
msgid ""
"For more pleasant output, you may wish to use string formatting to produce a "
"limited number of significant digits:"
msgstr ""
"Para uma saída mais agradável, pode desejar usar formatação de strings para "
"produzir um número limitado de dígitos significativos:"

#: ../../tutorial/floatingpoint.rst:100
msgid ""
">>> format(math.pi, '.12g')  # give 12 significant digits\n"
"'3.14159265359'\n"
"\n"
">>> format(math.pi, '.2f')   # give 2 digits after the point\n"
"'3.14'\n"
"\n"
">>> repr(math.pi)\n"
"'3.141592653589793'"
msgstr ""
">>> format(math.pi, '.12g')  # dar 12 dígitos significativos\n"
"'3.14159265359'\n"
"\n"
">>> format(math.pi, '.2f')   # dar 2 dígitos após o ponto\n"
"'3.14'\n"
"\n"
">>> repr(math.pi)\n"
"'3.141592653589793'"

#: ../../tutorial/floatingpoint.rst:111
msgid ""
"It's important to realize that this is, in a real sense, an illusion: you're "
"simply rounding the *display* of the true machine value."
msgstr ""
"É importante perceber que isto é, num sentido real, uma ilusão: está "
"simplesmente a arredondar a *apresentação* do valor real da máquina."

#: ../../tutorial/floatingpoint.rst:114
msgid ""
"One illusion may beget another.  For example, since 0.1 is not exactly 1/10, "
"summing three values of 0.1 may not yield exactly 0.3, either:"
msgstr ""
"Uma ilusão pode gerar outra. Por exemplo, uma vez que 0.1 não é exatamente "
"1/10, somar três valores de 0.1 pode não resultar exatamente em 0.3:"

#: ../../tutorial/floatingpoint.rst:117
msgid ""
">>> 0.1 + 0.1 + 0.1 == 0.3\n"
"False"
msgstr ""
">>> 0.1 + 0.1 + 0.1 == 0.3\n"
"False"

#: ../../tutorial/floatingpoint.rst:122
msgid ""
"Also, since the 0.1 cannot get any closer to the exact value of 1/10 and 0.3 "
"cannot get any closer to the exact value of 3/10, then pre-rounding with :"
"func:`round` function cannot help:"
msgstr ""
"Além disso, uma vez que 0.1 não pode aproximar-se mais do valor exato de "
"1/10 e 0.3 não pode aproximar-se mais do valor exato de 3/10, então o pré-"
"arredondamento com a função :func:`round` não pode ajudar:"

#: ../../tutorial/floatingpoint.rst:126
msgid ""
">>> round(0.1, 1) + round(0.1, 1) + round(0.1, 1) == round(0.3, 1)\n"
"False"
msgstr ""
">>> round(0.1, 1) + round(0.1, 1) + round(0.1, 1) == round(0.3, 1)\n"
"False"

#: ../../tutorial/floatingpoint.rst:131
msgid ""
"Though the numbers cannot be made closer to their intended exact values, "
"the :func:`math.isclose` function can be useful for comparing inexact values:"
msgstr ""
"Embora os números não possam ser aproximados aos seus valores exatos "
"pretendidos, a função :func:`math.isclose` pode ser útil para comparar "
"valores inexatos:"

#: ../../tutorial/floatingpoint.rst:134
msgid ""
">>> math.isclose(0.1 + 0.1 + 0.1, 0.3)\n"
"True"
msgstr ""
">>> math.isclose(0.1 + 0.1 + 0.1, 0.3)\n"
"True"

#: ../../tutorial/floatingpoint.rst:139
msgid ""
"Alternatively, the :func:`round` function can be used to compare rough "
"approximations:"
msgstr ""
"Alternativamente, a função :func:`round` pode ser usada para comparar "
"aproximações grosseiras:"

#: ../../tutorial/floatingpoint.rst:142
msgid ""
">>> round(math.pi, ndigits=2) == round(22 / 7, ndigits=2)\n"
"True"
msgstr ""
">>> round(math.pi, ndigits=2) == round(22 / 7, ndigits=2)\n"
"True"

#: ../../tutorial/floatingpoint.rst:147
msgid ""
"Binary floating-point arithmetic holds many surprises like this.  The "
"problem with \"0.1\" is explained in precise detail below, in the "
"\"Representation Error\" section.  See `Examples of Floating Point Problems "
"<https://jvns.ca/blog/2023/01/13/examples-of-floating-point-problems/>`_ for "
"a pleasant summary of how binary floating point works and the kinds of "
"problems commonly encountered in practice.  Also see `The Perils of Floating "
"Point <http://www.indowsway.com/floatingpoint.htm>`_ for a more complete "
"account of other common surprises."
msgstr ""
"A aritmética de ponto flutuante binário reserva muitas surpresas como esta. "
"O problema com \"0.1\" é explicado em detalhe preciso abaixo, na secção "
"\"Erro de Representação\". Consulte `Exemplos de Problemas de Ponto "
"Flutuante <https://jvns.ca/blog/2023/01/13/examples-of-floating-point-"
"problems/>`_ para um resumo agradável de como funciona o ponto flutuante "
"binário e os tipos de problemas comumente encontrados na prática. Consulte "
"também `Os Perigos do Ponto Flutuante <http://www.indowsway.com/"
"floatingpoint.htm>`_ para uma descrição mais completa de outras surpresas "
"comuns."

#: ../../tutorial/floatingpoint.rst:156
msgid ""
"As that says near the end, \"there are no easy answers.\"  Still, don't be "
"unduly wary of floating point!  The errors in Python float operations are "
"inherited from the floating-point hardware, and on most machines are on the "
"order of no more than 1 part in 2\\*\\*53 per operation.  That's more than "
"adequate for most tasks, but you do need to keep in mind that it's not "
"decimal arithmetic and that every float operation can suffer a new rounding "
"error."
msgstr ""
"Como diz no final, \"não há respostas fáceis\". Ainda assim, não tenha "
"receio excessivo do ponto flutuante! Os erros nas operações de ponto "
"flutuante do Python são herdados do hardware de ponto flutuante e, na "
"maioria das máquinas, são da ordem de não mais do que 1 parte em 2\\*\\*53 "
"por operação. Isso é mais do que adequado para a maioria das tarefas, mas é "
"preciso ter em mente que não se trata de aritmética decimal e que toda a "
"operação de ponto flutuante pode sofrer um novo erro de arredondamento."

#: ../../tutorial/floatingpoint.rst:163
msgid ""
"While pathological cases do exist, for most casual use of floating-point "
"arithmetic you'll see the result you expect in the end if you simply round "
"the display of your final results to the number of decimal digits you "
"expect. :func:`str` usually suffices, and for finer control see the :meth:"
"`str.format` method's format specifiers in :ref:`formatstrings`."
msgstr ""
"Embora existam casos patológicos, para a maioria dos usos casuais de "
"aritmética de ponto flutuante, verá o resultado que espera no final se "
"simplesmente arredondar a apresentação dos seus resultados finais para o "
"número de dígitos decimais que espera. :func:`str` geralmente é suficiente "
"e, para um controlo mais fino, consulte os especificadores de formato do "
"método :meth:`str.format` em :ref:`formatstrings`."

#: ../../tutorial/floatingpoint.rst:169
msgid ""
"For use cases which require exact decimal representation, try using the :mod:"
"`decimal` module which implements decimal arithmetic suitable for accounting "
"applications and high-precision applications."
msgstr ""
"Para casos de uso que requeiram representação decimal exata, experimente "
"usar o módulo :mod:`decimal`, que implementa aritmética decimal adequada "
"para aplicações contabilísticas e aplicações de alta precisão."

#: ../../tutorial/floatingpoint.rst:173
msgid ""
"Another form of exact arithmetic is supported by the :mod:`fractions` module "
"which implements arithmetic based on rational numbers (so the numbers like "
"1/3 can be represented exactly)."
msgstr ""
"Outra forma de aritmética exata é suportada pelo módulo :mod:`fractions`, "
"que implementa aritmética baseada em números racionais (assim, números como "
"1/3 podem ser representados exatamente)."

#: ../../tutorial/floatingpoint.rst:177
msgid ""
"If you are a heavy user of floating-point operations you should take a look "
"at the NumPy package and many other packages for mathematical and "
"statistical operations supplied by the SciPy project. See <https://scipy."
"org>."
msgstr ""
"Se for um utilizador intensivo de operações de ponto flutuante, deve dar uma "
"vista de olhos ao pacote NumPy e a muitos outros pacotes para operações "
"matemáticas e estatísticas fornecidos pelo projeto SciPy. Consulte <https://"
"scipy.org>."

#: ../../tutorial/floatingpoint.rst:181
msgid ""
"Python provides tools that may help on those rare occasions when you really "
"*do* want to know the exact value of a float.  The :meth:`float."
"as_integer_ratio` method expresses the value of a float as a fraction:"
msgstr ""
"O Python fornece ferramentas que podem ajudar naquelas raras ocasiões em que "
"realmente *quer* saber o valor exato de um número de ponto flutuante. O "
"método :meth:`float.as_integer_ratio` expressa o valor de um número de ponto "
"flutuante como uma fração:"

#: ../../tutorial/floatingpoint.rst:186
msgid ""
">>> x = 3.14159\n"
">>> x.as_integer_ratio()\n"
"(3537115888337719, 1125899906842624)"
msgstr ""
">>> x = 3.14159\n"
">>> x.as_integer_ratio()\n"
"(3537115888337719, 1125899906842624)"

#: ../../tutorial/floatingpoint.rst:192
msgid ""
"Since the ratio is exact, it can be used to losslessly recreate the original "
"value:"
msgstr ""
"Uma vez que a proporção é exata, pode ser usada para recriar o valor "
"original sem perda:"

#: ../../tutorial/floatingpoint.rst:195
msgid ""
">>> x == 3537115888337719 / 1125899906842624\n"
"True"
msgstr ""
">>> x == 3537115888337719 / 1125899906842624\n"
"True"

#: ../../tutorial/floatingpoint.rst:200
msgid ""
"The :meth:`float.hex` method expresses a float in hexadecimal (base 16), "
"again giving the exact value stored by your computer:"
msgstr ""
"O método :meth:`float.hex` expressa um número de ponto flutuante em "
"hexadecimal (base 16), mostrando novamente o valor exato armazenado pelo seu "
"computador:"

#: ../../tutorial/floatingpoint.rst:203
msgid ""
">>> x.hex()\n"
"'0x1.921f9f01b866ep+1'"
msgstr ""
">>> x.hex()\n"
"'0x1.921f9f01b866ep+1'"

#: ../../tutorial/floatingpoint.rst:208
msgid ""
"This precise hexadecimal representation can be used to reconstruct the float "
"value exactly:"
msgstr ""
"Esta representação hexadecimal precisa pode ser usada para reconstruir o "
"valor de ponto flutuante exatamente:"

#: ../../tutorial/floatingpoint.rst:211
msgid ""
">>> x == float.fromhex('0x1.921f9f01b866ep+1')\n"
"True"
msgstr ""
">>> x == float.fromhex('0x1.921f9f01b866ep+1')\n"
"True"

#: ../../tutorial/floatingpoint.rst:216
msgid ""
"Since the representation is exact, it is useful for reliably porting values "
"across different versions of Python (platform independence) and exchanging "
"data with other languages that support the same format (such as Java and "
"C99)."
msgstr ""
"Uma vez que a representação é exata, é útil para transportar valores de "
"forma fiável entre diferentes versões do Python (independência de "
"plataforma) e trocar dados com outras linguagens que suportam o mesmo "
"formato (como Java e C99)."

#: ../../tutorial/floatingpoint.rst:220
msgid ""
"Another helpful tool is the :func:`sum` function which helps mitigate loss-"
"of-precision during summation.  It uses extended precision for intermediate "
"rounding steps as values are added onto a running total. That can make a "
"difference in overall accuracy so that the errors do not accumulate to the "
"point where they affect the final total:"
msgstr ""
"Outra ferramenta útil é a função :func:`sum`, que ajuda a mitigar a perda de "
"precisão durante a soma. Utiliza precisão estendida para os passos "
"intermédios de arredondamento à medida que os valores são adicionados a um "
"total acumulado. Isso pode fazer a diferença na precisão global, de modo que "
"os erros não se acumulem ao ponto de afetarem o total final:"

#: ../../tutorial/floatingpoint.rst:226
msgid ""
">>> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 == 1.0\n"
"False\n"
">>> sum([0.1] * 10) == 1.0\n"
"True"
msgstr ""
">>> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 == 1.0\n"
"False\n"
">>> sum([0.1] * 10) == 1.0\n"
"True"

#: ../../tutorial/floatingpoint.rst:233
msgid ""
"The :func:`math.fsum` goes further and tracks all of the \"lost digits\" as "
"values are added onto a running total so that the result has only a single "
"rounding.  This is slower than :func:`sum` but will be more accurate in "
"uncommon cases where large magnitude inputs mostly cancel each other out "
"leaving a final sum near zero:"
msgstr ""
"A função :func:`math.fsum` vai mais longe e acompanha todos os \"dígitos "
"perdidos\" à medida que os valores são adicionados a um total acumulado, de "
"modo que o resultado tenha apenas um único arredondamento. Isto é mais lento "
"do que :func:`sum`, mas será mais preciso em casos incomuns em que entradas "
"de grande magnitude se cancelam mutuamente, deixando uma soma final próxima "
"de zero:"

#: ../../tutorial/floatingpoint.rst:239
msgid ""
">>> arr = [-0.10430216751806065, -266310978.67179024, 143401161448607.16,\n"
"...        -143401161400469.7, 266262841.31058735, -0.003244936839808227]\n"
">>> float(sum(map(Fraction, arr)))   # Exact summation with single rounding\n"
"8.042173697819788e-13\n"
">>> math.fsum(arr)                   # Single rounding\n"
"8.042173697819788e-13\n"
">>> sum(arr)                         # Multiple roundings in extended "
"precision\n"
"8.042178034628478e-13\n"
">>> total = 0.0\n"
">>> for x in arr:\n"
"...     total += x                   # Multiple roundings in standard "
"precision\n"
"...\n"
">>> total                            # Straight addition has no correct "
"digits!\n"
"-0.0051575902860057365"
msgstr ""
">>> arr = [-0.10430216751806065, -266310978.67179024, 143401161448607.16,\n"
"...        -143401161400469.7, 266262841.31058735, -0.003244936839808227]\n"
">>> float(sum(map(Fraction, arr)))   # Soma exata com arredondamento único\n"
"8.042173697819788e-13\n"
">>> math.fsum(arr)                   # Arredondamento único\n"
"8.042173697819788e-13\n"
">>> sum(arr)                         # Múltiplos arredondamentos em precisão "
"estendida\n"
"8.042178034628478e-13\n"
">>> total = 0.0\n"
">>> for x in arr:\n"
"...     total += x                   # Múltiplos arredondamentos em precisão "
"padrão\n"
"...\n"
">>> total                            # Adição direta não tem dígitos "
"corretos!\n"
"-0.0051575902860057365"

#: ../../tutorial/floatingpoint.rst:260
msgid "Representation Error"
msgstr "Erro de representação"

#: ../../tutorial/floatingpoint.rst:262
msgid ""
"This section explains the \"0.1\" example in detail, and shows how you can "
"perform an exact analysis of cases like this yourself.  Basic familiarity "
"with binary floating-point representation is assumed."
msgstr ""
"Esta secção explica o exemplo \"0.1\" em detalhe e mostra como pode realizar "
"uma análise exata de casos como este. Assume-se familiaridade básica com a "
"representação de ponto flutuante binário."

#: ../../tutorial/floatingpoint.rst:266
msgid ""
":dfn:`Representation error` refers to the fact that some (most, actually) "
"decimal fractions cannot be represented exactly as binary (base 2) "
"fractions. This is the chief reason why Python (or Perl, C, C++, Java, "
"Fortran, and many others) often won't display the exact decimal number you "
"expect."
msgstr ""
":dfn:`Representation error` refere-se ao facto de que algumas (na verdade, a "
"maioria) frações decimais não podem ser representadas exatamente como "
"frações binárias (base 2). Esta é a principal razão pela qual o Python (ou "
"Perl, C, C++, Java, Fortran, e muitos outros) muitas vezes não apresenta o "
"número decimal exato que espera."

#: ../../tutorial/floatingpoint.rst:271
msgid ""
"Why is that?  1/10 is not exactly representable as a binary fraction.  Since "
"at least 2000, almost all machines use IEEE 754 binary floating-point "
"arithmetic, and almost all platforms map Python floats to IEEE 754 binary64 "
"\"double precision\" values.  IEEE 754 binary64 values contain 53 bits of "
"precision, so on input the computer strives to convert 0.1 to the closest "
"fraction it can of the form *J*/2**\\ *N* where *J* is an integer containing "
"exactly 53 bits. Rewriting ::"
msgstr ""
"Porquê? 1/10 não é exatamente representável como uma fração binária. Desde "
"pelo menos 2000, quase todas as máquinas usam aritmética de ponto flutuante "
"binário IEEE 754, e quase todas as plataformas mapeiam os números de ponto "
"flutuante do Python para valores IEEE 754 binary64 de \"precisão dupla\". Os "
"valores IEEE 754 binary64 contêm 53 bits de precisão, por isso, ao "
"introduzir, o computador tenta converter 0.1 para a fração mais próxima "
"possível da forma *J*/2**\\ *N*, onde *J* é um inteiro contendo exatamente "
"53 bits. Reescrevendo::"

#: ../../tutorial/floatingpoint.rst:280
msgid "1 / 10 ~= J / (2**N)"
msgstr "1 / 10 ~= J / (2**N)"

#: ../../tutorial/floatingpoint.rst:282
msgid "as ::"
msgstr "como::"

#: ../../tutorial/floatingpoint.rst:284
msgid "J ~= 2**N / 10"
msgstr "J ~= 2**N / 10"

#: ../../tutorial/floatingpoint.rst:286
msgid ""
"and recalling that *J* has exactly 53 bits (is ``>= 2**52`` but ``< "
"2**53``), the best value for *N* is 56:"
msgstr ""
"e recordando que *J* tem exatamente 53 bits (é ``>= 2**52`` mas ``< "
"2**53``), o melhor valor para *N* é 56:"

#: ../../tutorial/floatingpoint.rst:289
msgid ""
">>> 2**52 <=  2**56 // 10  < 2**53\n"
"True"
msgstr ""
">>> 2**52 <=  2**56 // 10  < 2**53\n"
"True"

#: ../../tutorial/floatingpoint.rst:294
msgid ""
"That is, 56 is the only value for *N* that leaves *J* with exactly 53 bits.  "
"The best possible value for *J* is then that quotient rounded:"
msgstr ""
"Ou seja, 56 é o único valor para *N* que deixa *J* com exatamente 53 bits. O "
"melhor valor possível para *J* é então esse quociente arredondado:"

#: ../../tutorial/floatingpoint.rst:297
msgid ""
">>> q, r = divmod(2**56, 10)\n"
">>> r\n"
"6"
msgstr ""
">>> q, r = divmod(2**56, 10)\n"
">>> r\n"
"6"

#: ../../tutorial/floatingpoint.rst:303
msgid ""
"Since the remainder is more than half of 10, the best approximation is "
"obtained by rounding up:"
msgstr ""
"Uma vez que o resto é mais de metade de 10, a melhor aproximação é obtida "
"arredondando para cima:"

#: ../../tutorial/floatingpoint.rst:306
msgid ""
">>> q+1\n"
"7205759403792794"
msgstr ""
">>> q+1\n"
"7205759403792794"

#: ../../tutorial/floatingpoint.rst:313
msgid ""
"Therefore the best possible approximation to 1/10 in IEEE 754 double "
"precision is::"
msgstr ""
"Portanto, a melhor aproximação possível para 1/10 em precisão dupla IEEE 754 "
"é::"

#: ../../tutorial/floatingpoint.rst:316
msgid "7205759403792794 / 2 ** 56"
msgstr "7205759403792794 / 2 ** 56"

#: ../../tutorial/floatingpoint.rst:318
msgid ""
"Dividing both the numerator and denominator by two reduces the fraction to::"
msgstr "Dividindo o numerador e o denominador por dois, reduz a fração para::"

#: ../../tutorial/floatingpoint.rst:320
msgid "3602879701896397 / 2 ** 55"
msgstr "3602879701896397 / 2 ** 55"

#: ../../tutorial/floatingpoint.rst:322
msgid ""
"Note that since we rounded up, this is actually a little bit larger than "
"1/10; if we had not rounded up, the quotient would have been a little bit "
"smaller than 1/10.  But in no case can it be *exactly* 1/10!"
msgstr ""
"Note que, uma vez que arredondámos para cima, isto é na verdade um pouco "
"maior do que 1/10; se não tivéssemos arredondado para cima, o quociente "
"teria sido um pouco menor do que 1/10. Mas em nenhum caso pode ser "
"*exatamente* 1/10!"

#: ../../tutorial/floatingpoint.rst:326
msgid ""
"So the computer never \"sees\" 1/10:  what it sees is the exact fraction "
"given above, the best IEEE 754 double approximation it can get:"
msgstr ""
"Portanto, o computador nunca \"vê\" 1/10: o que vê é a fração exata dada "
"acima, a melhor aproximação dupla IEEE 754 que pode obter:"

#: ../../tutorial/floatingpoint.rst:329
msgid ""
">>> 0.1 * 2 ** 55\n"
"3602879701896397.0"
msgstr ""
">>> 0.1 * 2 ** 55\n"
"3602879701896397.0"

#: ../../tutorial/floatingpoint.rst:334
msgid ""
"If we multiply that fraction by 10\\*\\*55, we can see the value out to 55 "
"decimal digits:"
msgstr ""
"Se multiplicarmos essa fração por 10\\*\\*55, podemos ver o valor com 55 "
"dígitos decimais:"

#: ../../tutorial/floatingpoint.rst:337
msgid ""
">>> 3602879701896397 * 10 ** 55 // 2 ** 55\n"
"1000000000000000055511151231257827021181583404541015625"
msgstr ""
">>> 3602879701896397 * 10 ** 55 // 2 ** 55\n"
"1000000000000000055511151231257827021181583404541015625"

#: ../../tutorial/floatingpoint.rst:342
msgid ""
"meaning that the exact number stored in the computer is equal to the decimal "
"value 0.1000000000000000055511151231257827021181583404541015625. Instead of "
"displaying the full decimal value, many languages (including older versions "
"of Python), round the result to 17 significant digits:"
msgstr ""
"significando que o número exato armazenado no computador é igual ao valor "
"decimal 0.1000000000000000055511151231257827021181583404541015625. Em vez de "
"apresentar o valor decimal completo, muitas linguagens (incluindo versões "
"mais antigas do Python) arredondam o resultado para 17 dígitos "
"significativos:"

#: ../../tutorial/floatingpoint.rst:347
msgid ""
">>> format(0.1, '.17f')\n"
"'0.10000000000000001'"
msgstr ""
">>> format(0.1, '.17f')\n"
"'0.10000000000000001'"

#: ../../tutorial/floatingpoint.rst:352
msgid ""
"The :mod:`fractions` and :mod:`decimal` modules make these calculations easy:"
msgstr "Os módulos :mod:`fractions` e :mod:`decimal` facilitam estes cálculos:"

#: ../../tutorial/floatingpoint.rst:355
msgid ""
">>> from decimal import Decimal\n"
">>> from fractions import Fraction\n"
"\n"
">>> Fraction.from_float(0.1)\n"
"Fraction(3602879701896397, 36028797018963968)\n"
"\n"
">>> (0.1).as_integer_ratio()\n"
"(3602879701896397, 36028797018963968)\n"
"\n"
">>> Decimal.from_float(0.1)\n"
"Decimal('0.1000000000000000055511151231257827021181583404541015625')\n"
"\n"
">>> format(Decimal.from_float(0.1), '.17')\n"
"'0.10000000000000001'"
msgstr ""
">>> from decimal import Decimal\n"
">>> from fractions import Fraction\n"
"\n"
">>> Fraction.from_float(0.1)\n"
"Fraction(3602879701896397, 36028797018963968)\n"
"\n"
">>> (0.1).as_integer_ratio()\n"
"(3602879701896397, 36028797018963968)\n"
"\n"
">>> Decimal.from_float(0.1)\n"
"Decimal('0.1000000000000000055511151231257827021181583404541015625')\n"
"\n"
">>> format(Decimal.from_float(0.1), '.17')\n"
"'0.10000000000000001'"
