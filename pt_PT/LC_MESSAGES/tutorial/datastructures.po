# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# André Moreira <afrmscb@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-10-17 16:35+0000\n"
"PO-Revision-Date: 2025-09-22 16:51+0000\n"
"Last-Translator: André Moreira <afrmscb@gmail.com>, 2025\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-doc/"
"teams/5390/pt_PT/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_PT\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../tutorial/datastructures.rst:5
msgid "Data Structures"
msgstr "Estruturas de dados"

#: ../../tutorial/datastructures.rst:7
msgid ""
"This chapter describes some things you've learned about already in more "
"detail, and adds some new things as well."
msgstr ""
"Este capítulo descreve algumas coisas que já aprendeu com mais detalhe e "
"também adiciona algumas novidades."

#: ../../tutorial/datastructures.rst:13
msgid "More on Lists"
msgstr "Mais sobre listas"

#: ../../tutorial/datastructures.rst:15
msgid ""
"The list data type has some more methods.  Here are all of the methods of "
"list objects:"
msgstr ""
"O tipo de dados lista tem mais alguns métodos. Aqui estão todos os métodos "
"dos objetos lista:"

#: ../../tutorial/datastructures.rst:22
msgid ""
"Add an item to the end of the list.  Equivalent to ``a[len(a):] = [x]``."
msgstr ""

#: ../../tutorial/datastructures.rst:28
msgid ""
"Extend the list by appending all the items from the iterable.  Equivalent to "
"``a[len(a):] = iterable``."
msgstr ""

#: ../../tutorial/datastructures.rst:35
msgid ""
"Insert an item at a given position.  The first argument is the index of the "
"element before which to insert, so ``a.insert(0, x)`` inserts at the front "
"of the list, and ``a.insert(len(a), x)`` is equivalent to ``a.append(x)``."
msgstr ""
"Insere um item numa posição dada. O primeiro argumento é o índice do "
"elemento antes do qual inserir, por isso ``a.insert(0, x)`` insere no início "
"da lista, e ``a.insert(len(a), x)`` é equivalente a ``a.append(x)``."

#: ../../tutorial/datastructures.rst:43
msgid ""
"Remove the first item from the list whose value is equal to *x*.  It raises "
"a :exc:`ValueError` if there is no such item."
msgstr ""
"Remove o primeiro item da lista cujo valor é igual a *x*. Levanta um :exc:"
"`ValueError` se não existir tal item."

#: ../../tutorial/datastructures.rst:50
msgid ""
"Remove the item at the given position in the list, and return it.  If no "
"index is specified, ``a.pop()`` removes and returns the last item in the "
"list. It raises an :exc:`IndexError` if the list is empty or the index is "
"outside the list range."
msgstr ""
"Remove o item na posição dada na lista e devolve-o. Se nenhum índice for "
"especificado, ``a.pop()`` remove e devolve o último item na lista. Levanta "
"um :exc:`IndexError` se a lista estiver vazia ou o índice estiver fora do "
"intervalo da lista."

#: ../../tutorial/datastructures.rst:59
msgid "Remove all items from the list.  Equivalent to ``del a[:]``."
msgstr ""

#: ../../tutorial/datastructures.rst:65
msgid ""
"Return zero-based index in the list of the first item whose value is equal "
"to *x*. Raises a :exc:`ValueError` if there is no such item."
msgstr ""

#: ../../tutorial/datastructures.rst:68
msgid ""
"The optional arguments *start* and *end* are interpreted as in the slice "
"notation and are used to limit the search to a particular subsequence of the "
"list.  The returned index is computed relative to the beginning of the full "
"sequence rather than the *start* argument."
msgstr ""
"Os argumentos opcionais *start* e *end* são interpretados como na notação de "
"fatia e são usados para limitar a pesquisa a uma subsequência particular da "
"lista. O índice devolvido é calculado em relação ao início da sequência "
"completa, em vez do argumento *start*."

#: ../../tutorial/datastructures.rst:77
msgid "Return the number of times *x* appears in the list."
msgstr "Devolve o número de vezes que *x* aparece na lista."

#: ../../tutorial/datastructures.rst:83
msgid ""
"Sort the items of the list in place (the arguments can be used for sort "
"customization, see :func:`sorted` for their explanation)."
msgstr ""
"Ordena os itens da lista no local (os argumentos podem ser usados para "
"personalizar a ordenação, consulte :func:`sorted` para a sua explicação)."

#: ../../tutorial/datastructures.rst:90
msgid "Reverse the elements of the list in place."
msgstr "Inverte os elementos da lista no local."

#: ../../tutorial/datastructures.rst:96
msgid "Return a shallow copy of the list.  Equivalent to ``a[:]``."
msgstr ""

#: ../../tutorial/datastructures.rst:99
msgid "An example that uses most of the list methods::"
msgstr "Um exemplo que usa a maioria dos métodos de lista:"

#: ../../tutorial/datastructures.rst:122
msgid ""
"You might have noticed that methods like ``insert``, ``remove`` or ``sort`` "
"that only modify the list have no return value printed -- they return the "
"default ``None``. [#]_  This is a design principle for all mutable data "
"structures in Python."
msgstr ""
"Pode ter notado que métodos como ``insert``, ``remove`` ou ``sort``, que "
"apenas modificam a lista, não têm um valor de retorno impresso — devolvem o "
"valor predefinido ``None``. [#]_ Isto é um princípio de design para todas as "
"estruturas de dados mutáveis em Python."

#: ../../tutorial/datastructures.rst:127
msgid ""
"Another thing you might notice is that not all data can be sorted or "
"compared.  For instance, ``[None, 'hello', 10]`` doesn't sort because "
"integers can't be compared to strings and *None* can't be compared to other "
"types.  Also, there are some types that don't have a defined ordering "
"relation.  For example, ``3+4j < 5+7j`` isn't a valid comparison."
msgstr ""

#: ../../tutorial/datastructures.rst:138
msgid "Using Lists as Stacks"
msgstr "Usar listas como pilhas"

#: ../../tutorial/datastructures.rst:143
msgid ""
"The list methods make it very easy to use a list as a stack, where the last "
"element added is the first element retrieved (\"last-in, first-out\").  To "
"add an item to the top of the stack, use :meth:`~list.append`.  To retrieve "
"an item from the top of the stack, use :meth:`~list.pop` without an explicit "
"index.  For example::"
msgstr ""
"Os métodos de lista tornam muito fácil usar uma lista como uma pilha, onde o "
"último elemento adicionado é o primeiro elemento recuperado (\"último a "
"entrar, primeiro a sair\"). Para adicionar um item ao topo da pilha, use :"
"meth:`~list.append`. Para recuperar um item do topo da pilha, use :meth:"
"`~list.pop` sem um índice explícito. Por exemplo:"

#: ../../tutorial/datastructures.rst:168
msgid "Using Lists as Queues"
msgstr "Usar listas como filas"

#: ../../tutorial/datastructures.rst:172
msgid ""
"It is also possible to use a list as a queue, where the first element added "
"is the first element retrieved (\"first-in, first-out\"); however, lists are "
"not efficient for this purpose.  While appends and pops from the end of list "
"are fast, doing inserts or pops from the beginning of a list is slow "
"(because all of the other elements have to be shifted by one)."
msgstr ""
"Também é possível usar uma lista como uma fila, onde o primeiro elemento "
"adicionado é o primeiro elemento recuperado (\"primeiro a entrar, primeiro a "
"sair\"); no entanto, as listas não são eficientes para este propósito. "
"Embora anexar e remover do final da lista sejam rápidos, fazer inserções ou "
"remoções do início de uma lista é lento (porque todos os outros elementos "
"têm de ser deslocados em uma posição)."

#: ../../tutorial/datastructures.rst:178
msgid ""
"To implement a queue, use :class:`collections.deque` which was designed to "
"have fast appends and pops from both ends.  For example::"
msgstr ""
"Para implementar uma fila, use :class:`collections.deque`, que foi concebida "
"para ter anexações e remoções rápidas em ambas as extremidades. Por exemplo:"

#: ../../tutorial/datastructures.rst:196
msgid "List Comprehensions"
msgstr "Compreensões de lista"

#: ../../tutorial/datastructures.rst:198
msgid ""
"List comprehensions provide a concise way to create lists. Common "
"applications are to make new lists where each element is the result of some "
"operations applied to each member of another sequence or iterable, or to "
"create a subsequence of those elements that satisfy a certain condition."
msgstr ""
"As compreensões de lista fornecem uma forma concisa de criar listas. "
"Aplicações comuns incluem criar novas listas onde cada elemento é o "
"resultado de algumas operações aplicadas a cada membro de outra sequência ou "
"iterável, ou criar uma subsequência daqueles elementos que satisfazem uma "
"determinada condição."

#: ../../tutorial/datastructures.rst:203
msgid "For example, assume we want to create a list of squares, like::"
msgstr ""
"Por exemplo, assumamos que queremos criar uma lista de quadrados, como:"

#: ../../tutorial/datastructures.rst:212
msgid ""
"Note that this creates (or overwrites) a variable named ``x`` that still "
"exists after the loop completes.  We can calculate the list of squares "
"without any side effects using::"
msgstr ""
"Note que isto cria (ou sobrescreve) uma variável chamada ``x`` que ainda "
"existe após o ciclo terminar. Podemos calcular a lista de quadrados sem "
"quaisquer efeitos secundários usando:"

#: ../../tutorial/datastructures.rst:218
msgid "or, equivalently::"
msgstr "ou, equivalentemente:"

#: ../../tutorial/datastructures.rst:222
msgid "which is more concise and readable."
msgstr "que é mais conciso e legível."

#: ../../tutorial/datastructures.rst:224
msgid ""
"A list comprehension consists of brackets containing an expression followed "
"by a :keyword:`!for` clause, then zero or more :keyword:`!for` or :keyword:`!"
"if` clauses.  The result will be a new list resulting from evaluating the "
"expression in the context of the :keyword:`!for` and :keyword:`!if` clauses "
"which follow it. For example, this listcomp combines the elements of two "
"lists if they are not equal::"
msgstr ""
"Uma compreensão de lista consiste em parênteses retos contendo uma expressão "
"seguida de uma cláusula :keyword:`!for`, depois zero ou mais cláusulas :"
"keyword:`!for` ou :keyword:`!if`. O resultado será uma nova lista resultante "
"da avaliação da expressão no contexto das cláusulas :keyword:`!for` e :"
"keyword:`!if` que a seguem. Por exemplo, esta compreensão de lista combina "
"os elementos de duas listas se não forem iguais:"

#: ../../tutorial/datastructures.rst:234
msgid "and it's equivalent to::"
msgstr "e é equivalente a:"

#: ../../tutorial/datastructures.rst:245
msgid ""
"Note how the order of the :keyword:`for` and :keyword:`if` statements is the "
"same in both these snippets."
msgstr ""
"Note como a ordem das instruções :keyword:`for` e :keyword:`if` é a mesma "
"nestes dois excertos."

#: ../../tutorial/datastructures.rst:248
msgid ""
"If the expression is a tuple (e.g. the ``(x, y)`` in the previous example), "
"it must be parenthesized. ::"
msgstr ""
"Se a expressão for um tuplo (por exemplo, o ``(x, y)`` no exemplo anterior), "
"deve ser colocado entre parênteses:"

#: ../../tutorial/datastructures.rst:279
msgid ""
"List comprehensions can contain complex expressions and nested functions::"
msgstr ""
"As compreensões de lista podem conter expressões complexas e funções "
"aninhadas:"

#: ../../tutorial/datastructures.rst:286
msgid "Nested List Comprehensions"
msgstr "Compreensões de lista aninhadas"

#: ../../tutorial/datastructures.rst:288
msgid ""
"The initial expression in a list comprehension can be any arbitrary "
"expression, including another list comprehension."
msgstr ""
"A expressão inicial numa compreensão de lista pode ser qualquer expressão "
"arbitrária, incluindo outra compreensão de lista."

#: ../../tutorial/datastructures.rst:291
msgid ""
"Consider the following example of a 3x4 matrix implemented as a list of 3 "
"lists of length 4::"
msgstr ""
"Considere o seguinte exemplo de uma matriz 3x4 implementada como uma lista "
"de 3 listas de comprimento 4:"

#: ../../tutorial/datastructures.rst:300
msgid "The following list comprehension will transpose rows and columns::"
msgstr "A seguinte compreensão de lista transpõe linhas e colunas:"

#: ../../tutorial/datastructures.rst:305
msgid ""
"As we saw in the previous section, the inner list comprehension is evaluated "
"in the context of the :keyword:`for` that follows it, so this example is "
"equivalent to::"
msgstr ""
"Como vimos na secção anterior, a compreensão de lista interna é avaliada no "
"contexto do :keyword:`for` que a segue, por isso este exemplo é equivalente "
"a:"

#: ../../tutorial/datastructures.rst:316
msgid "which, in turn, is the same as::"
msgstr "que, por sua vez, é o mesmo que:"

#: ../../tutorial/datastructures.rst:329
msgid ""
"In the real world, you should prefer built-in functions to complex flow "
"statements. The :func:`zip` function would do a great job for this use case::"
msgstr ""
"No mundo real, deve preferir funções incorporadas a instruções de fluxo "
"complexas. A função :func:`zip` faria um ótimo trabalho para este caso de "
"uso:"

#: ../../tutorial/datastructures.rst:335
msgid ""
"See :ref:`tut-unpacking-arguments` for details on the asterisk in this line."
msgstr ""
"Consulte :ref:`tut-unpacking-arguments` para detalhes sobre o asterisco "
"nesta linha."

#: ../../tutorial/datastructures.rst:340
msgid "The :keyword:`!del` statement"
msgstr "A instrução :keyword:`!del`"

#: ../../tutorial/datastructures.rst:342
msgid ""
"There is a way to remove an item from a list given its index instead of its "
"value: the :keyword:`del` statement.  This differs from the :meth:`~list."
"pop` method which returns a value.  The :keyword:`!del` statement can also "
"be used to remove slices from a list or clear the entire list (which we did "
"earlier by assignment of an empty list to the slice).  For example::"
msgstr ""
"Existe uma forma de remover um item de uma lista dado o seu índice em vez do "
"seu valor: a instrução :keyword:`del`. Isto difere do método :meth:`~list."
"pop`, que devolve um valor. A instrução :keyword:`!del` também pode ser "
"usada para remover fatias de uma lista ou limpar a lista inteira (que "
"fizemos anteriormente atribuindo uma lista vazia à fatia). Por exemplo:"

#: ../../tutorial/datastructures.rst:359
msgid ":keyword:`del` can also be used to delete entire variables::"
msgstr ":keyword:`del` também pode ser usado para apagar variáveis inteiras:"

#: ../../tutorial/datastructures.rst:363
msgid ""
"Referencing the name ``a`` hereafter is an error (at least until another "
"value is assigned to it).  We'll find other uses for :keyword:`del` later."
msgstr ""
"Referenciar o nome ``a`` a partir daqui é um erro (pelo menos até que outro "
"valor lhe seja atribuído). Encontraremos outros usos para :keyword:`del` "
"mais tarde."

#: ../../tutorial/datastructures.rst:370
msgid "Tuples and Sequences"
msgstr "Tuplos e sequências"

#: ../../tutorial/datastructures.rst:372
msgid ""
"We saw that lists and strings have many common properties, such as indexing "
"and slicing operations.  They are two examples of *sequence* data types "
"(see :ref:`typesseq`).  Since Python is an evolving language, other sequence "
"data types may be added.  There is also another standard sequence data type: "
"the *tuple*."
msgstr ""
"Vimos que listas e strings têm muitas propriedades comuns, como operações de "
"indexação e fatiamento. São dois exemplos de tipos de dados *sequência* "
"(consulte :ref:`typesseq`). Uma vez que Python é uma linguagem em evolução, "
"outros tipos de dados de sequência podem ser adicionados. Existe também "
"outro tipo de dados de sequência padrão: o *tuplo*."

#: ../../tutorial/datastructures.rst:378
msgid ""
"A tuple consists of a number of values separated by commas, for instance::"
msgstr ""
"Um tuplo consiste num número de valores separados por vírgulas, por exemplo:"

#: ../../tutorial/datastructures.rst:400
msgid ""
"As you see, on output tuples are always enclosed in parentheses, so that "
"nested tuples are interpreted correctly; they may be input with or without "
"surrounding parentheses, although often parentheses are necessary anyway (if "
"the tuple is part of a larger expression).  It is not possible to assign to "
"the individual items of a tuple, however it is possible to create tuples "
"which contain mutable objects, such as lists."
msgstr ""
"Como vê, na saída, os tuplos são sempre envolvidos por parênteses, para que "
"os tuplos aninhados sejam interpretados corretamente; podem ser introduzidos "
"com ou sem parênteses envolventes, embora muitas vezes os parênteses sejam "
"necessários de qualquer forma (se o tuplo fizer parte de uma expressão "
"maior). Não é possível atribuir aos itens individuais de um tuplo, no "
"entanto, é possível criar tuplos que contenham objetos mutáveis, como listas."

#: ../../tutorial/datastructures.rst:407
msgid ""
"Though tuples may seem similar to lists, they are often used in different "
"situations and for different purposes. Tuples are :term:`immutable`, and "
"usually contain a heterogeneous sequence of elements that are accessed via "
"unpacking (see later in this section) or indexing (or even by attribute in "
"the case of :func:`namedtuples <collections.namedtuple>`). Lists are :term:"
"`mutable`, and their elements are usually homogeneous and are accessed by "
"iterating over the list."
msgstr ""
"Embora os tuplos possam parecer semelhantes às listas, são muitas vezes "
"usados em situações diferentes e para fins diferentes. Os tuplos são :term:"
"`imutáveis` e geralmente contêm uma sequência heterogénea de elementos que "
"são acedidos através de desempacotamento (veja mais adiante nesta secção) ou "
"indexação (ou mesmo por atributo no caso de :func:`namedtuples <collections."
"namedtuple>`). As listas são :term:`mutáveis`, e os seus elementos são "
"geralmente homogéneos e são acedidos iterando sobre a lista."

#: ../../tutorial/datastructures.rst:415
msgid ""
"A special problem is the construction of tuples containing 0 or 1 items: the "
"syntax has some extra quirks to accommodate these.  Empty tuples are "
"constructed by an empty pair of parentheses; a tuple with one item is "
"constructed by following a value with a comma (it is not sufficient to "
"enclose a single value in parentheses). Ugly, but effective.  For example::"
msgstr ""
"Um problema especial é a construção de tuplos contendo 0 ou 1 itens: a "
"sintaxe tem algumas particularidades para acomodar estes casos. Tuplos "
"vazios são construídos por um par de parênteses vazios; um tuplo com um item "
"é construído seguindo um valor com uma vírgula (não é suficiente envolver um "
"único valor em parênteses). Feio, mas eficaz. Por exemplo:"

#: ../../tutorial/datastructures.rst:430
msgid ""
"The statement ``t = 12345, 54321, 'hello!'`` is an example of *tuple "
"packing*: the values ``12345``, ``54321`` and ``'hello!'`` are packed "
"together in a tuple. The reverse operation is also possible::"
msgstr ""
"A instrução ``t = 12345, 54321, 'olá!'`` é um exemplo de *empacotamento de "
"tuplo*: os valores ``12345``, ``54321`` e ``'olá!'`` são empacotados juntos "
"num tuplo. A operação inversa também é possível:"

#: ../../tutorial/datastructures.rst:436
msgid ""
"This is called, appropriately enough, *sequence unpacking* and works for any "
"sequence on the right-hand side.  Sequence unpacking requires that there are "
"as many variables on the left side of the equals sign as there are elements "
"in the sequence.  Note that multiple assignment is really just a combination "
"of tuple packing and sequence unpacking."
msgstr ""
"Isto é chamado, apropriadamente, *desempacotamento de sequência* e funciona "
"para qualquer sequência do lado direito. O desempacotamento de sequência "
"requer que haja tantas variáveis do lado esquerdo do sinal de igual quanto "
"elementos na sequência. Note que a atribuição múltipla é realmente apenas "
"uma combinação de empacotamento de tuplo e desempacotamento de sequência."

#: ../../tutorial/datastructures.rst:446
msgid "Sets"
msgstr "Conjuntos"

#: ../../tutorial/datastructures.rst:448
msgid ""
"Python also includes a data type for *sets*.  A set is an unordered "
"collection with no duplicate elements.  Basic uses include membership "
"testing and eliminating duplicate entries.  Set objects also support "
"mathematical operations like union, intersection, difference, and symmetric "
"difference."
msgstr ""
"Python também inclui um tipo de dados para *conjuntos*. Um conjunto é uma "
"coleção não ordenada sem elementos duplicados. Usos básicos incluem teste de "
"pertença e eliminação de entradas duplicadas. Os objetos conjunto também "
"suportam operações matemáticas como união, interseção, diferença e diferença "
"simétrica."

#: ../../tutorial/datastructures.rst:453
msgid ""
"Curly braces or the :func:`set` function can be used to create sets.  Note: "
"to create an empty set you have to use ``set()``, not ``{}``; the latter "
"creates an empty dictionary, a data structure that we discuss in the next "
"section."
msgstr ""
"Chavetas ou a função :func:`set` podem ser usadas para criar conjuntos. Note "
"que para criar um conjunto vazio tem de usar ``set()``, não ``{}``; este "
"último cria um dicionário vazio, uma estrutura de dados que discutiremos na "
"próxima secção."

#: ../../tutorial/datastructures.rst:457
msgid "Here is a brief demonstration::"
msgstr "Aqui está uma breve demonstração:"

#: ../../tutorial/datastructures.rst:482
msgid ""
"Similarly to :ref:`list comprehensions <tut-listcomps>`, set comprehensions "
"are also supported::"
msgstr ""
"De forma semelhante às :ref:`compreensões de lista <tut-listcomps>`, as "
"compreensões de conjunto também são suportadas:"

#: ../../tutorial/datastructures.rst:493
msgid "Dictionaries"
msgstr "Dicionários"

#: ../../tutorial/datastructures.rst:495
msgid ""
"Another useful data type built into Python is the *dictionary* (see :ref:"
"`typesmapping`). Dictionaries are sometimes found in other languages as "
"\"associative memories\" or \"associative arrays\".  Unlike sequences, which "
"are indexed by a range of numbers, dictionaries are indexed by *keys*, which "
"can be any immutable type; strings and numbers can always be keys.  Tuples "
"can be used as keys if they contain only strings, numbers, or tuples; if a "
"tuple contains any mutable object either directly or indirectly, it cannot "
"be used as a key. You can't use lists as keys, since lists can be modified "
"in place using index assignments, slice assignments, or methods like :meth:"
"`~list.append` and :meth:`~list.extend`."
msgstr ""
"Outro tipo de dados útil incorporado no Python é o *dicionário* (consulte :"
"ref:`typesmapping`). Os dicionários são por vezes encontrados noutras "
"linguagens como \"memórias associativas\" ou \"arrays associativos\". Ao "
"contrário das sequências, que são indexadas por um intervalo de números, os "
"dicionários são indexados por *chaves*, que podem ser de qualquer tipo "
"imutável; strings e números podem sempre ser chaves. Os tuplos podem ser "
"usados como chaves se contiverem apenas strings, números ou tuplos; se um "
"tuplo contiver qualquer objeto mutável diretamente ou indiretamente, não "
"pode ser usado como chave. Não pode usar listas como chaves, uma vez que as "
"listas podem ser modificadas no local usando atribuições de índice, "
"atribuições de fatia ou métodos como :meth:`~list.append` e :meth:`~list."
"extend`."

#: ../../tutorial/datastructures.rst:506
msgid ""
"It is best to think of a dictionary as a set of *key: value* pairs, with the "
"requirement that the keys are unique (within one dictionary). A pair of "
"braces creates an empty dictionary: ``{}``. Placing a comma-separated list "
"of key:value pairs within the braces adds initial key:value pairs to the "
"dictionary; this is also the way dictionaries are written on output."
msgstr ""
"É melhor pensar num dicionário como um conjunto de pares *chave: valor*, com "
"o requisito de que as chaves sejam únicas (dentro de um dicionário). Um par "
"de chavetas cria um dicionário vazio: ``{}``. Colocar uma lista separada por "
"vírgulas de pares chave:valor dentro das chavetas adiciona pares chave:valor "
"iniciais ao dicionário; esta é também a forma como os dicionários são "
"escritos na saída."

#: ../../tutorial/datastructures.rst:512
msgid ""
"The main operations on a dictionary are storing a value with some key and "
"extracting the value given the key.  It is also possible to delete a key:"
"value pair with ``del``. If you store using a key that is already in use, "
"the old value associated with that key is forgotten.  It is an error to "
"extract a value using a non-existent key."
msgstr ""
"As principais operações num dicionário são armazenar um valor com alguma "
"chave e extrair o valor dada a chave. Também é possível apagar um par chave:"
"valor com ``del``. Se armazenar usando uma chave que já está em uso, o valor "
"antigo associado a essa chave é esquecido. É um erro extrair um valor usando "
"uma chave inexistente."

#: ../../tutorial/datastructures.rst:518
msgid ""
"Performing ``list(d)`` on a dictionary returns a list of all the keys used "
"in the dictionary, in insertion order (if you want it sorted, just use "
"``sorted(d)`` instead). To check whether a single key is in the dictionary, "
"use the :keyword:`in` keyword."
msgstr ""
"Executar ``list(d)`` num dicionário devolve uma lista de todas as chaves "
"usadas no dicionário, por ordem de inserção (se quiser ordenado, use "
"``sorted(d)`` em vez disso). Para verificar se uma chave está no dicionário, "
"use a palavra-chave :keyword:`in`."

#: ../../tutorial/datastructures.rst:523
msgid "Here is a small example using a dictionary::"
msgstr "Aqui está um pequeno exemplo usando um dicionário:"

#: ../../tutorial/datastructures.rst:544
msgid ""
"The :func:`dict` constructor builds dictionaries directly from sequences of "
"key-value pairs::"
msgstr ""
"O construtor :func:`dict` cria dicionários diretamente a partir de "
"sequências de pares chave-valor:"

#: ../../tutorial/datastructures.rst:550
msgid ""
"In addition, dict comprehensions can be used to create dictionaries from "
"arbitrary key and value expressions::"
msgstr ""
"Além disso, as compreensões de dicionário podem ser usadas para criar "
"dicionários a partir de expressões arbitrárias de chave e valor:"

#: ../../tutorial/datastructures.rst:556
msgid ""
"When the keys are simple strings, it is sometimes easier to specify pairs "
"using keyword arguments::"
msgstr ""
"Quando as chaves são strings simples, às vezes é mais fácil especificar "
"pares usando argumentos nomeados:"

#: ../../tutorial/datastructures.rst:566
msgid "Looping Techniques"
msgstr "Técnicas de iteração"

#: ../../tutorial/datastructures.rst:568
msgid ""
"When looping through dictionaries, the key and corresponding value can be "
"retrieved at the same time using the :meth:`~dict.items` method. ::"
msgstr ""
"Ao iterar através de dicionários, a chave e o valor correspondente podem ser "
"recuperados ao mesmo tempo usando o método :meth:`~dict.items`:"

#: ../../tutorial/datastructures.rst:578
msgid ""
"When looping through a sequence, the position index and corresponding value "
"can be retrieved at the same time using the :func:`enumerate` function. ::"
msgstr ""
"Ao iterar através de uma sequência, o índice de posição e o valor "
"correspondente podem ser recuperados ao mesmo tempo usando a função :func:"
"`enumerate`:"

#: ../../tutorial/datastructures.rst:588
msgid ""
"To loop over two or more sequences at the same time, the entries can be "
"paired with the :func:`zip` function. ::"
msgstr ""
"Para iterar sobre duas ou mais sequências ao mesmo tempo, as entradas podem "
"ser emparelhadas com a função :func:`zip`:"

#: ../../tutorial/datastructures.rst:600
msgid ""
"To loop over a sequence in reverse, first specify the sequence in a forward "
"direction and then call the :func:`reversed` function. ::"
msgstr ""
"Para iterar sobre uma sequência na ordem inversa, primeiro especifique a "
"sequência na direção direta e depois chame a função :func:`reversed`:"

#: ../../tutorial/datastructures.rst:612
msgid ""
"To loop over a sequence in sorted order, use the :func:`sorted` function "
"which returns a new sorted list while leaving the source unaltered. ::"
msgstr ""
"Para iterar sobre uma sequência por ordem ordenada, use a função :func:"
"`sorted`, que devolve uma nova lista ordenada, deixando a fonte inalterada:"

#: ../../tutorial/datastructures.rst:626
msgid ""
"Using :func:`set` on a sequence eliminates duplicate elements. The use of :"
"func:`sorted` in combination with :func:`set` over a sequence is an "
"idiomatic way to loop over unique elements of the sequence in sorted "
"order. ::"
msgstr ""
"Usar :func:`set` numa sequência elimina elementos duplicados. O uso de :func:"
"`sorted` em combinação com :func:`set` sobre uma sequência é uma forma "
"idiomática de iterar sobre elementos únicos da sequência por ordem ordenada:"

#: ../../tutorial/datastructures.rst:639
msgid ""
"It is sometimes tempting to change a list while you are looping over it; "
"however, it is often simpler and safer to create a new list instead. ::"
msgstr ""
"Às vezes é tentador alterar uma lista enquanto se itera sobre ela; no "
"entanto, é muitas vezes mais simples e seguro criar uma nova lista em vez "
"disso:"

#: ../../tutorial/datastructures.rst:656
msgid "More on Conditions"
msgstr "Mais sobre condições"

#: ../../tutorial/datastructures.rst:658
msgid ""
"The conditions used in ``while`` and ``if`` statements can contain any "
"operators, not just comparisons."
msgstr ""
"As condições usadas nas instruções ``while`` e ``if`` podem conter quaisquer "
"operadores, não apenas comparações."

#: ../../tutorial/datastructures.rst:662
msgid ""
"The comparison operators ``in`` and ``not in`` are membership tests that "
"determine whether a value is in (or not in) a container.  The operators "
"``is`` and ``is not`` compare whether two objects are really the same "
"object.  All comparison operators have the same priority, which is lower "
"than that of all numerical operators."
msgstr ""
"Os operadores de comparação ``in`` e ``not in`` são testes de pertença que "
"determinam se um valor está (ou não está) num contentor. Os operadores "
"``is`` e ``is not`` comparam se dois objetos são realmente o mesmo objeto. "
"Todos os operadores de comparação têm a mesma prioridade, que é inferior à "
"de todos os operadores numéricos."

#: ../../tutorial/datastructures.rst:668
msgid ""
"Comparisons can be chained.  For example, ``a < b == c`` tests whether ``a`` "
"is less than ``b`` and moreover ``b`` equals ``c``."
msgstr ""
"As comparações podem ser encadeadas. Por exemplo, ``a < b == c`` testa se "
"``a`` é menor que ``b`` e, além disso, se ``b`` é igual a ``c``."

#: ../../tutorial/datastructures.rst:671
msgid ""
"Comparisons may be combined using the Boolean operators ``and`` and ``or``, "
"and the outcome of a comparison (or of any other Boolean expression) may be "
"negated with ``not``.  These have lower priorities than comparison "
"operators; between them, ``not`` has the highest priority and ``or`` the "
"lowest, so that ``A and not B or C`` is equivalent to ``(A and (not B)) or "
"C``. As always, parentheses can be used to express the desired composition."
msgstr ""
"As comparações podem ser combinadas usando os operadores booleanos ``and`` e "
"``or``, e o resultado de uma comparação (ou de qualquer outra expressão "
"booleana) pode ser negado com ``not``. Estes têm prioridades mais baixas do "
"que os operadores de comparação; entre eles, ``not`` tem a prioridade mais "
"alta e ``or`` a mais baixa, por isso ``A and not B or C`` é equivalente a "
"``(A and (not B)) or C``. Como sempre, os parênteses podem ser usados para "
"expressar a composição desejada."

#: ../../tutorial/datastructures.rst:678
msgid ""
"The Boolean operators ``and`` and ``or`` are so-called *short-circuit* "
"operators: their arguments are evaluated from left to right, and evaluation "
"stops as soon as the outcome is determined.  For example, if ``A`` and ``C`` "
"are true but ``B`` is false, ``A and B and C`` does not evaluate the "
"expression ``C``.  When used as a general value and not as a Boolean, the "
"return value of a short-circuit operator is the last evaluated argument."
msgstr ""
"Os operadores booleanos ``and`` e ``or`` são chamados operadores de *curto-"
"circuito*: os seus argumentos são avaliados da esquerda para a direita, e a "
"avaliação para assim que o resultado é determinado. Por exemplo, se ``A`` e "
"``C`` forem verdadeiros, mas ``B`` for falso, ``A and B and C`` não avalia a "
"expressão ``C``. Quando usados como um valor geral e não como um booleano, o "
"valor de retorno de um operador de curto-circuito é o último argumento "
"avaliado."

#: ../../tutorial/datastructures.rst:685
msgid ""
"It is possible to assign the result of a comparison or other Boolean "
"expression to a variable.  For example, ::"
msgstr ""
"É possível atribuir o resultado de uma comparação ou outra expressão "
"booleana a uma variável. Por exemplo:"

#: ../../tutorial/datastructures.rst:693
msgid ""
"Note that in Python, unlike C, assignment inside expressions must be done "
"explicitly with the :ref:`walrus operator <why-can-t-i-use-an-assignment-in-"
"an-expression>` ``:=``. This avoids a common class of problems encountered "
"in C programs: typing ``=`` in an expression when ``==`` was intended."
msgstr ""
"Note que em Python, ao contrário de C, a atribuição dentro de expressões "
"deve ser feita explicitamente com o :ref:`operador walrus <why-can-t-i-use-"
"an-assignment-in-an-expression>` ``:=``. Isto evita uma classe comum de "
"problemas encontrados em programas C: digitar ``=`` numa expressão quando "
"``==`` era pretendido."

#: ../../tutorial/datastructures.rst:703
msgid "Comparing Sequences and Other Types"
msgstr "Comparação de sequências e outros tipos"

#: ../../tutorial/datastructures.rst:704
msgid ""
"Sequence objects typically may be compared to other objects with the same "
"sequence type. The comparison uses *lexicographical* ordering: first the "
"first two items are compared, and if they differ this determines the outcome "
"of the comparison; if they are equal, the next two items are compared, and "
"so on, until either sequence is exhausted. If two items to be compared are "
"themselves sequences of the same type, the lexicographical comparison is "
"carried out recursively.  If all items of two sequences compare equal, the "
"sequences are considered equal. If one sequence is an initial sub-sequence "
"of the other, the shorter sequence is the smaller (lesser) one.  "
"Lexicographical ordering for strings uses the Unicode code point number to "
"order individual characters. Some examples of comparisons between sequences "
"of the same type::"
msgstr ""
"Os objetos de sequência podem tipicamente ser comparados com outros objetos "
"do mesmo tipo de sequência. A comparação usa a ordenação *lexicográfica*: "
"primeiro, os dois primeiros itens são comparados, e se forem diferentes, "
"isto determina o resultado da comparação; se forem iguais, os dois itens "
"seguintes são comparados, e assim sucessivamente, até que uma das sequências "
"seja esgotada. Se dois itens a serem comparados forem eles próprios "
"sequências do mesmo tipo, a comparação lexicográfica é realizada "
"recursivamente. Se todos os itens de duas sequências forem iguais, as "
"sequências são consideradas iguais. Se uma sequência for uma subsequência "
"inicial da outra, a sequência mais curta é a menor. A ordenação "
"lexicográfica para strings usa o número do ponto de código Unicode para "
"ordenar caracteres individuais. Alguns exemplos de comparações entre "
"sequências do mesmo tipo:"

#: ../../tutorial/datastructures.rst:724
msgid ""
"Note that comparing objects of different types with ``<`` or ``>`` is legal "
"provided that the objects have appropriate comparison methods.  For example, "
"mixed numeric types are compared according to their numeric value, so 0 "
"equals 0.0, etc.  Otherwise, rather than providing an arbitrary ordering, "
"the interpreter will raise a :exc:`TypeError` exception."
msgstr ""
"Note que comparar objetos de tipos diferentes com ``<`` ou ``>`` é legal "
"desde que os objetos tenham métodos de comparação apropriados. Por exemplo, "
"tipos numéricos mistos são comparados de acordo com o seu valor numérico, "
"por isso 0 é igual a 0.0, etc. Caso contrário, em vez de fornecer uma "
"ordenação arbitrária, o interpretador levantará uma exceção :exc:`TypeError`."

#: ../../tutorial/datastructures.rst:732
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../tutorial/datastructures.rst:733
msgid ""
"Other languages may return the mutated object, which allows method chaining, "
"such as ``d->insert(\"a\")->remove(\"b\")->sort();``."
msgstr ""
"Outras linguagens podem devolver o objeto mutado, o que permite o "
"encadeamento de métodos, como ``d->insert(\"a\")->remove(\"b\")->sort();``."
