# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Persian (https://app.transifex.com/python-doc/teams/5390/"
"fa/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fa\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../glossary.rst:5
msgid "Glossary"
msgstr "واژه‌نامه"

#: ../../glossary.rst:10
msgid "``>>>``"
msgstr "``>>>``"

#: ../../glossary.rst:12
msgid ""
"The default Python prompt of the :term:`interactive` shell.  Often seen for "
"code examples which can be executed interactively in the interpreter."
msgstr ""
"اعلان پیش‌فرض پایتون از پوسته :term:`interactive. اغلب برای نمونه های کدی که "
"می توانند به صورت تعاملی در مفسر اجرا شوند دیده می شود."

#: ../../glossary.rst:15
msgid "``...``"
msgstr "``...``"

#: ../../glossary.rst:17
msgid "Can refer to:"
msgstr "می تواند ارجاع شود به :"

#: ../../glossary.rst:19
msgid ""
"The default Python prompt of the :term:`interactive` shell when entering the "
"code for an indented code block, when within a pair of matching left and "
"right delimiters (parentheses, square brackets, curly braces or triple "
"quotes), or after specifying a decorator."
msgstr ""
"اعلان پیش‌فرض پایتون پوسته :term:`interactive` هنگام وارد کردن کد برای یک "
"بلوک کد تورفتگی، زمانی که در یک جفت جداکننده چپ و راست منطبق است (پرانتز، "
"پرانتز، براکت‌های فرفری یا نقل قول‌های سه‌گانه)، یا پس از تعیین دکوراتور."

#: ../../glossary.rst:24
msgid "The :const:`Ellipsis` built-in constant."
msgstr "Wbudowanej stałej :const:`Ellipsis`."

#: ../../glossary.rst:25
msgid "abstract base class"
msgstr "abstrakcyjna klasa bazowa"

#: ../../glossary.rst:27
msgid ""
"Abstract base classes complement :term:`duck-typing` by providing a way to "
"define interfaces when other techniques like :func:`hasattr` would be clumsy "
"or subtly wrong (for example with :ref:`magic methods <special-lookup>`).  "
"ABCs introduce virtual subclasses, which are classes that don't inherit from "
"a class but are still recognized by :func:`isinstance` and :func:"
"`issubclass`; see the :mod:`abc` module documentation.  Python comes with "
"many built-in ABCs for data structures (in the :mod:`collections.abc` "
"module), numbers (in the :mod:`numbers` module), streams (in the :mod:`io` "
"module), import finders and loaders (in the :mod:`importlib.abc` module).  "
"You can create your own ABCs with the :mod:`abc` module."
msgstr ""
"Абстрактні базові класи доповнюють :term:`duck-typing`, надаючи спосіб для "
"визначення інтерфейсів, коли інші методи, такі як :func:`hasattr`, були б "
"незручними або дещо неправильними (наприклад, з :ref:`магічними методами "
"<special-lookup>`). ABC вводить віртуальні підкласи, що є класами, які не "
"успадковуються від класу, але все ще можуть розпізнватися за допомогою :func:"
"`isinstance` та :func:`issubclass`; дивіться документацію модуля :mod:`abc`. "
"Python має багато вбудованх ABC для різних структур(у модулі :mod:"
"`collections.abc`), чисел (у модулі :mod:`numbers`), потоків (у модулі :mod:"
"`io`) , шукачів імпортів і завантажувачів (у модулі :mod:`importlib.abc`). "
"Ви можете створювати власні азбуки за допомогою модуля :mod:`abc`."

#: ../../glossary.rst:38
msgid "annotation"
msgstr "حاشیه نویسی"

#: ../../glossary.rst:40
msgid ""
"A label associated with a variable, a class attribute or a function "
"parameter or return value, used by convention as a :term:`type hint`."
msgstr ""
"Etykieta powiązana ze zmienną, atrybutem klasy lub parametrem funkcji lub "
"wartością zwracaną, używana zgodnie z konwencją jako :term:`type hint`."

#: ../../glossary.rst:44
msgid ""
"Annotations of local variables cannot be accessed at runtime, but "
"annotations of global variables, class attributes, and functions are stored "
"in the :attr:`__annotations__` special attribute of modules, classes, and "
"functions, respectively."
msgstr ""

#: ../../glossary.rst:50
msgid ""
"See :term:`variable annotation`, :term:`function annotation`, :pep:`484` "
"and :pep:`526`, which describe this functionality. Also see :ref:"
"`annotations-howto` for best practices on working with annotations."
msgstr ""

#: ../../glossary.rst:54
msgid "argument"
msgstr "آرگومان"

#: ../../glossary.rst:56
msgid ""
"A value passed to a :term:`function` (or :term:`method`) when calling the "
"function.  There are two kinds of argument:"
msgstr ""
"Значення, яке передається :term:`function` (або :term:`method`) під час "
"виклику функції. Існує два види аргументів:"

#: ../../glossary.rst:59
msgid ""
":dfn:`keyword argument`: an argument preceded by an identifier (e.g. "
"``name=``) in a function call or passed as a value in a dictionary preceded "
"by ``**``.  For example, ``3`` and ``5`` are both keyword arguments in the "
"following calls to :func:`complex`::"
msgstr ""
":dfn:`keyword argument`: аргумент, якому передує ідентифікатор (наприклад, "
"``name=``) під час виклику функції або передається як значення в словнику "
"перед яким ``**``. Наприклад, ``3`` і ``5`` є ключовими аргументами в "
"наступних викликах :func:`complex`::"

#: ../../glossary.rst:64
msgid ""
"complex(real=3, imag=5)\n"
"complex(**{'real': 3, 'imag': 5})"
msgstr ""
"complex(real=3, imag=5)\n"
"complex(**{'real': 3, 'imag': 5})"

#: ../../glossary.rst:67
msgid ""
":dfn:`positional argument`: an argument that is not a keyword argument. "
"Positional arguments can appear at the beginning of an argument list and/or "
"be passed as elements of an :term:`iterable` preceded by ``*``. For example, "
"``3`` and ``5`` are both positional arguments in the following calls::"
msgstr ""
":dfn:`positional argument`: аргумент, який не є аргументом ключового слова. "
"Позиційні аргументи можуть з’являтися на початку списку аргументів і/або "
"передаватися як елементи :term:`iterable`, яким передує ``*``. Наприклад, "
"``3`` і ``5`` є позиційними аргументами в наступних викликах:"

#: ../../glossary.rst:73
msgid ""
"complex(3, 5)\n"
"complex(*(3, 5))"
msgstr ""
"complex(3, 5)\n"
"complex(*(3, 5))"

#: ../../glossary.rst:76
msgid ""
"Arguments are assigned to the named local variables in a function body. See "
"the :ref:`calls` section for the rules governing this assignment. "
"Syntactically, any expression can be used to represent an argument; the "
"evaluated value is assigned to the local variable."
msgstr ""
"Аргументи призначаються названим локальним змінним у тілі функції. "
"Перегляньте розділ :ref:`calls` для правил, що регулюють це призначення. "
"Синтаксично будь-який вираз можна використовувати для представлення "
"аргументу; обчислене значення присвоюється локальній змінній."

#: ../../glossary.rst:81
msgid ""
"See also the :term:`parameter` glossary entry, the FAQ question on :ref:`the "
"difference between arguments and parameters <faq-argument-vs-parameter>`, "
"and :pep:`362`."
msgstr ""
"Дивіться також :term:`parameter` глосарій, питання FAQ про :ref:`різницю між "
"аргументами та параметрами <faq-argument-vs-parameter>`, і :pep:`362`."

#: ../../glossary.rst:84
msgid "asynchronous context manager"
msgstr "manajer konteks asinkron"

#: ../../glossary.rst:86
msgid ""
"An object which controls the environment seen in an :keyword:`async with` "
"statement by defining :meth:`~object.__aenter__` and :meth:`~object."
"__aexit__` methods.  Introduced by :pep:`492`."
msgstr ""
"Об'єкт, що контролює оточення, вказаний у інструкції :keyword:`async with`  "
"визначенням методів :meth:`~object.__aenter__` і :meth:`~object.__aexit__`. "
"Запроваджено у :pep:`492`."

#: ../../glossary.rst:89
msgid "asynchronous generator"
msgstr "pembangkit asinkron"

#: ../../glossary.rst:91
msgid ""
"A function which returns an :term:`asynchronous generator iterator`.  It "
"looks like a coroutine function defined with :keyword:`async def` except "
"that it contains :keyword:`yield` expressions for producing a series of "
"values usable in an :keyword:`async for` loop."
msgstr ""
"Функція, яка повертає :term:`asynchronous generator iterator`. Це виглядає "
"як функція співпрограми, визначена за допомогою :keyword:`async def`, за "
"винятком того, що вона містить вирази :keyword:`yield` для створення серії "
"значень, які можна використовувати в циклі :keyword:`async for`."

#: ../../glossary.rst:96
msgid ""
"Usually refers to an asynchronous generator function, but may refer to an "
"*asynchronous generator iterator* in some contexts.  In cases where the "
"intended meaning isn't clear, using the full terms avoids ambiguity."
msgstr ""
"Зазвичай відноситься до функції асинхронного генератора, але в деяких "
"контекстах може посилатися на *ітератор асинхронного генератора*. У "
"випадках, коли передбачуване значення не є зрозумілим, використання повних "
"термінів дозволяє уникнути двозначності."

#: ../../glossary.rst:100
msgid ""
"An asynchronous generator function may contain :keyword:`await` expressions "
"as well as :keyword:`async for`, and :keyword:`async with` statements."
msgstr ""
"Функція асинхронного генератора може містити вирази :keyword:`await`, а "
"також оператори :keyword:`async for` і :keyword:`async with`."

#: ../../glossary.rst:103
msgid "asynchronous generator iterator"
msgstr "iterator generator asinkron"

#: ../../glossary.rst:105
msgid "An object created by a :term:`asynchronous generator` function."
msgstr "Sebuah objek dibuat oleh fungsi :term:`asynchronous generator`."

#: ../../glossary.rst:107
msgid ""
"This is an :term:`asynchronous iterator` which when called using the :meth:"
"`~object.__anext__` method returns an awaitable object which will execute "
"the body of the asynchronous generator function until the next :keyword:"
"`yield` expression."
msgstr ""
"Це :term:`асинхронний ітератор`, який при виклику за допомогою методу :meth:"
"`~object.__anext__`  повертає очікуваний об'єкт, який виконає тіло функції "
"асинхронного генератора до наступного виразу :keyword:`yield`."

#: ../../glossary.rst:112
msgid ""
"Each :keyword:`yield` temporarily suspends processing, remembering the "
"execution state (including local variables and pending try-statements).  "
"When the *asynchronous generator iterator* effectively resumes with another "
"awaitable returned by :meth:`~object.__anext__`, it picks up where it left "
"off.  See :pep:`492` and :pep:`525`."
msgstr ""
"Каждое: ключевое слово: `helipt` временно приостанавливает обработку, "
"запоминая состояние выполнения (включая локальные переменные и ожидающие "
"пробуждения). Когда * асинхронный итератор генератора * эффективно "
"возобновляется с другим ожидаемым возвращением: Meth: `~ Object .__ "
"anext__`, он поднимает, где он остановился. См.: PEP: `492` и: PEP:` 525`."

#: ../../glossary.rst:117
msgid "asynchronous iterable"
msgstr "асинхронний ітерований"

#: ../../glossary.rst:119
msgid ""
"An object, that can be used in an :keyword:`async for` statement. Must "
"return an :term:`asynchronous iterator` from its :meth:`~object.__aiter__` "
"method.  Introduced by :pep:`492`."
msgstr ""
"Об'єкт, який можна використовувати в інструкції :keyword:`async for`. "
"Повинен повертати an :term:`асинхронний ітератор` своїм методом :meth:"
"`~object.__aiter__` .  Запроваджено у  :pep:`492`."

#: ../../glossary.rst:122
msgid "asynchronous iterator"
msgstr "iterator asinkron"

#: ../../glossary.rst:124
msgid ""
"An object that implements the :meth:`~object.__aiter__` and :meth:`~object."
"__anext__` methods.  :meth:`~object.__anext__` must return an :term:"
"`awaitable` object. :keyword:`async for` resolves the awaitables returned by "
"an asynchronous iterator's :meth:`~object.__anext__` method until it raises "
"a :exc:`StopAsyncIteration` exception.  Introduced by :pep:`492`."
msgstr ""
"Об'єкт, який реалізує методи :meth:`~object.__aiter__` та :meth:`~object."
"__anext__`. :meth:`~object.__anext__` має повертати  :term:`очікуваний`  "
"об'єкт. :keyword:`async for` обчислює очікувані об'єкти, повернуті методом "
"асинхронноо ітератора :meth:`~object.__anext__`, доки він не створює "
"виняток :exc:`StopAsyncIteration`.  Запроваджено :pep:`492`."

#: ../../glossary.rst:129
msgid "attribute"
msgstr "ویژگی"

#: ../../glossary.rst:131
msgid ""
"A value associated with an object which is usually referenced by name using "
"dotted expressions. For example, if an object *o* has an attribute *a* it "
"would be referenced as *o.a*."
msgstr ""
"Значение, связанное с объектом, на который обычно ссылаются по имени, "
"используя выражения, разделенные точками. Например, если объект *o* имеет "
"атрибут *a*, на него будет ссылаться как *oa*."

#: ../../glossary.rst:136
msgid ""
"It is possible to give an object an attribute whose name is not an "
"identifier as defined by :ref:`identifiers`, for example using :func:"
"`setattr`, if the object allows it. Such an attribute will not be accessible "
"using a dotted expression, and would instead need to be retrieved with :func:"
"`getattr`."
msgstr ""
"Можно присвоить объекту атрибут, имя которого не является идентификатором, "
"как определено в :ref:`identifiers`, например, используя :func:`setattr`, "
"если объект это позволяет. Такой атрибут не будет доступен с помощью "
"выражения, разделенного точками, и вместо этого его необходимо будет "
"получить с помощью :func:`getattr`."

#: ../../glossary.rst:141
msgid "awaitable"
msgstr "انتظارپذیر"

#: ../../glossary.rst:143
msgid ""
"An object that can be used in an :keyword:`await` expression.  Can be a :"
"term:`coroutine` or an object with an :meth:`~object.__await__` method. See "
"also :pep:`492`."
msgstr ""
"Объект, который можно использовать в выражении :keyword:`await`. Может быть :"
"term:`coroutine` или объектом с :meth:`~object.__await__`. См. также :pep:"
"`492`."

#: ../../glossary.rst:146
msgid "BDFL"
msgstr "BDFL"

#: ../../glossary.rst:148
msgid ""
"Benevolent Dictator For Life, a.k.a. `Guido van Rossum <https://gvanrossum."
"github.io/>`_, Python's creator."
msgstr ""
"Доброзичливий диктатор на все життя (BDFL - Benevolent Dictator For Life), "
"також відомий як `Гвідо ван Россум <https://gvanrossum.github.io/>`_, "
"творець Python."

#: ../../glossary.rst:150
msgid "binary file"
msgstr "plik binarny"

#: ../../glossary.rst:152
msgid ""
"A :term:`file object` able to read and write :term:`bytes-like objects "
"<bytes-like object>`. Examples of binary files are files opened in binary "
"mode (``'rb'``, ``'wb'`` or ``'rb+'``), :data:`sys.stdin.buffer <sys."
"stdin>`, :data:`sys.stdout.buffer <sys.stdout>`, and instances of :class:`io."
"BytesIO` and :class:`gzip.GzipFile`."
msgstr ""
":term:`файловый объект`, способный читать и записывать :term:`байтоподобные "
"объекты <байтоподобный объект>`. Примерами двоичных файлов являются файлы, "
"открытые в двоичном режиме (``'rb'``, ``'wb'`` или ``'rb+'``), :data:`sys."
"stdin.buffer <sys.stdin> `, :data:`sys.stdout.buffer <sys.stdout>` и "
"экземпляры :class:`io.BytesIO` и :class:`gzip.GzipFile`."

#: ../../glossary.rst:159
msgid ""
"See also :term:`text file` for a file object able to read and write :class:"
"`str` objects."
msgstr ""
"Дивіться також :term:`text file` для об’єкта файлу, здатного читати та "
"записувати об’єкти :class:`str`."

#: ../../glossary.rst:161
msgid "borrowed reference"
msgstr "запозичене посилання"

#: ../../glossary.rst:163
msgid ""
"In Python's C API, a borrowed reference is a reference to an object, where "
"the code using the object does not own the reference. It becomes a dangling "
"pointer if the object is destroyed. For example, a garbage collection can "
"remove the last :term:`strong reference` to the object and so destroy it."
msgstr ""
"В API C Python заимствованная ссылка — это ссылка на объект, при этом код, "
"использующий этот объект, не владеет ссылкой. Он становится висячим "
"указателем, если объект уничтожается. Например, сборщик мусора может удалить "
"последнюю :term:`строгую ссылку` на объект и тем самым уничтожить его."

#: ../../glossary.rst:169
msgid ""
"Calling :c:func:`Py_INCREF` on the :term:`borrowed reference` is recommended "
"to convert it to a :term:`strong reference` in-place, except when the object "
"cannot be destroyed before the last usage of the borrowed reference. The :c:"
"func:`Py_NewRef` function can be used to create a new :term:`strong "
"reference`."
msgstr ""
"Виклик :c:func:`Py_INCREF` для :term:`borrowed reference` рекомендовано для "
"перетворення його на :term:`strong reference` на місці, за винятком "
"випадків, коли об’єкт не можна знищити до останнього використання "
"запозиченого посилання. Функцію :c:func:`Py_NewRef` можна використати для "
"створення нового :term:`strong reference`."

#: ../../glossary.rst:174
msgid "bytes-like object"
msgstr "байтоподібний об'єкт"

#: ../../glossary.rst:176
msgid ""
"An object that supports the :ref:`bufferobjects` and can export a C-:term:"
"`contiguous` buffer. This includes all :class:`bytes`, :class:`bytearray`, "
"and :class:`array.array` objects, as well as many common :class:`memoryview` "
"objects.  Bytes-like objects can be used for various operations that work "
"with binary data; these include compression, saving to a binary file, and "
"sending over a socket."
msgstr ""
"Об’єкт, який підтримує :ref:`bufferobjects` і може експортувати буфер C-:"
"term:`contiguous`. Це включає всі об’єкти :class:`bytes`, :class:`bytearray` "
"і :class:`array.array`, а також багато поширених об’єктів :class:"
"`memoryview`. Байтоподібні об'єкти можна використовувати для різних "
"операцій, які працюють з двійковими даними; вони включають стиснення, "
"збереження у бінарний файл і надсилання через сокет."

#: ../../glossary.rst:183
msgid ""
"Some operations need the binary data to be mutable.  The documentation often "
"refers to these as \"read-write bytes-like objects\".  Example mutable "
"buffer objects include :class:`bytearray` and a :class:`memoryview` of a :"
"class:`bytearray`. Other operations require the binary data to be stored in "
"immutable objects (\"read-only bytes-like objects\"); examples of these "
"include :class:`bytes` and a :class:`memoryview` of a :class:`bytes` object."
msgstr ""
"Для деяких операцій двійкові дані повинні бути змінними. У документації вони "
"часто називаються \"байтоподібними об’єктами читання-запису\". Приклади "
"змінних буферних об’єктів включають :class:`bytearray` і :class:"
"`memoryview` :class:`bytearray`. Інші операції вимагають, щоб двійкові дані "
"зберігалися в незмінних об’єктах (\"байтоподібні об’єкти лише для "
"читання\"); прикладами таких є :class:`bytes` і :class:`memoryview` об’єкта :"
"class:`bytes`."

#: ../../glossary.rst:191
msgid "bytecode"
msgstr "کدبایتی"

#: ../../glossary.rst:193
msgid ""
"Python source code is compiled into bytecode, the internal representation of "
"a Python program in the CPython interpreter.  The bytecode is also cached in "
"``.pyc`` files so that executing the same file is faster the second time "
"(recompilation from source to bytecode can be avoided).  This \"intermediate "
"language\" is said to run on a :term:`virtual machine` that executes the "
"machine code corresponding to each bytecode. Do note that bytecodes are not "
"expected to work between different Python virtual machines, nor to be stable "
"between Python releases."
msgstr ""
"Вихідний код Python компілюється в байт-код, внутрішнє представлення "
"програми Python в інтерпретаторі CPython. Байт-код також кешується у файлах "
"``.pyc``, тому виконання того самого файлу відбувається швидше вдруге (можна "
"уникнути перекомпіляції з вихідного коду в байт-код). Кажуть, що ця "
"\"проміжна мова\" працює на :term:`virtual machine`, яка виконує машинний "
"код, що відповідає кожному байт-коду. Зауважте, що байт-коди не повинні "
"працювати між різними віртуальними машинами Python, а також бути стабільними "
"між випусками Python."

#: ../../glossary.rst:203
msgid ""
"A list of bytecode instructions can be found in the documentation for :ref:"
"`the dis module <bytecodes>`."
msgstr ""
"Daftar instruksi-instruksi bytecode dapat ditemukan di dokumentasi pada :ref:"
"`the dis module <bytecodes>`."

#: ../../glossary.rst:205
msgid "callable"
msgstr "викликний"

#: ../../glossary.rst:207
msgid ""
"A callable is an object that can be called, possibly with a set of arguments "
"(see :term:`argument`), with the following syntax::"
msgstr ""
"Вызываемый объект — это объект, который можно вызвать, возможно, с набором "
"аргументов (см. :term:`argument`), используя следующий синтаксис::"

#: ../../glossary.rst:210
msgid "callable(argument1, argument2, argumentN)"
msgstr "callable(argument1, argument2, argumentN)"

#: ../../glossary.rst:212
msgid ""
"A :term:`function`, and by extension a :term:`method`, is a callable. An "
"instance of a class that implements the :meth:`~object.__call__` method is "
"also a callable."
msgstr ""
":term:`function` и, как следствие, :term:`method` являются вызываемыми. "
"Экземпляр класса, реализующего метод :meth:`~object.__call__`, также "
"является вызываемым."

#: ../../glossary.rst:215
msgid "callback"
msgstr "wywołanie zwrotne"

#: ../../glossary.rst:217
msgid ""
"A subroutine function which is passed as an argument to be executed at some "
"point in the future."
msgstr ""
"Функція підпрограми, яка передається як аргумент для виконання в певний "
"момент у майбутньому."

#: ../../glossary.rst:219
msgid "class"
msgstr "کلاس"

#: ../../glossary.rst:221
msgid ""
"A template for creating user-defined objects. Class definitions normally "
"contain method definitions which operate on instances of the class."
msgstr ""
"Шаблон для створення користувальницьких об'єктів. Визначення класу зазвичай "
"містять визначення методів, які працюють над екземплярами класу."

#: ../../glossary.rst:224
msgid "class variable"
msgstr "змінна класу"

#: ../../glossary.rst:226
msgid ""
"A variable defined in a class and intended to be modified only at class "
"level (i.e., not in an instance of the class)."
msgstr ""
"Змінна, визначена в класі та призначена для зміни лише на рівні класу (тобто "
"не в екземплярі класу)."

#: ../../glossary.rst:228
msgid "closure variable"
msgstr "переменная закрытия"

#: ../../glossary.rst:230
msgid ""
"A :term:`free variable` referenced from a :term:`nested scope` that is "
"defined in an outer scope rather than being resolved at runtime from the "
"globals or builtin namespaces. May be explicitly defined with the :keyword:"
"`nonlocal` keyword to allow write access, or implicitly defined if the "
"variable is only being read."
msgstr ""
":term:`свободная переменная`, на которую ссылается :term:`вложенная область "
"видимости`, которая определена во внешней области, а не разрешается во время "
"выполнения из глобальных переменных или встроенных пространств имен. Может "
"быть явно определено с помощью ключевого слова :keyword:`nonlocal`, чтобы "
"разрешить доступ для записи, или неявно определено, если переменная только "
"читается."

#: ../../glossary.rst:235
msgid ""
"For example, in the ``inner`` function in the following code, both ``x`` and "
"``print`` are :term:`free variables <free variable>`, but only ``x`` is a "
"*closure variable*::"
msgstr ""
"Например, в функции ``inner`` в следующем коде и ``x``, и ``print`` "
"являются :term:`свободными переменными <свободная переменная>`, но только "
"``x`` является *переменная закрытия*::"

#: ../../glossary.rst:238
msgid ""
"def outer():\n"
"    x = 0\n"
"    def inner():\n"
"        nonlocal x\n"
"        x += 1\n"
"        print(x)\n"
"    return inner"
msgstr ""
"def outer():\n"
"x = 0\n"
"def inner():\n"
"nonlocal x\n"
"x += 1\n"
"print(x)\n"
"return inner"

#: ../../glossary.rst:246
msgid ""
"Due to the :attr:`codeobject.co_freevars` attribute (which, despite its "
"name, only includes the names of closure variables rather than listing all "
"referenced free variables), the more general :term:`free variable` term is "
"sometimes used even when the intended meaning is to refer specifically to "
"closure variables."
msgstr ""
"Из-за атрибута :attr:`codeobject.co_freevars` (который, несмотря на свое "
"название, включает только имена замыкающих переменных, а не список всех "
"свободных переменных, на которые ссылаются), иногда даже используется более "
"общий термин :term:`свободная переменная` когда предполагаемое значение "
"состоит в том, чтобы относиться конкретно к переменным замыкания."

#: ../../glossary.rst:250
msgid "complex number"
msgstr "عدد مختلط"

#: ../../glossary.rst:252
msgid ""
"An extension of the familiar real number system in which all numbers are "
"expressed as a sum of a real part and an imaginary part.  Imaginary numbers "
"are real multiples of the imaginary unit (the square root of ``-1``), often "
"written ``i`` in mathematics or ``j`` in engineering.  Python has built-in "
"support for complex numbers, which are written with this latter notation; "
"the imaginary part is written with a ``j`` suffix, e.g., ``3+1j``.  To get "
"access to complex equivalents of the :mod:`math` module, use :mod:`cmath`.  "
"Use of complex numbers is a fairly advanced mathematical feature.  If you're "
"not aware of a need for them, it's almost certain you can safely ignore them."
msgstr ""
"Розширення відомої дійсної системи числення, у якій усі числа виражаються як "
"сума дійсної та уявної частин. Уявні числа — це дійсні кратні уявної одиниці "
"(квадратного кореня з ``-1``), які часто пишуться ``i`` в математиці або "
"``j`` в інженерії. Python має вбудовану підтримку комплексних чисел, які "
"записуються з використанням цієї останньої нотації; уявна частина "
"записується з суфіксом ``j``, наприклад, ``3+1j``. Щоб отримати доступ до "
"комплексних еквівалентів модуля :mod:`math`, використовуйте :mod:`cmath`. "
"Використання комплексних чисел є досить просунутою математичною функцією. "
"Якщо ви не усвідомлюєте потреби в них, майже впевнено, що можете спокійно їх "
"ігнорувати."

#: ../../glossary.rst:262
msgid "context"
msgstr "kontekst"

#: ../../glossary.rst:264
msgid ""
"This term has different meanings depending on where and how it is used. Some "
"common meanings:"
msgstr ""
"Этот термин имеет разные значения в зависимости от того, где и как он "
"используется. Некоторые общие значения:"

#: ../../glossary.rst:267
msgid ""
"The temporary state or environment established by a :term:`context manager` "
"via a :keyword:`with` statement."
msgstr ""
"Временное состояние или среда, установленная :term:`контекстным менеджером` "
"с помощью оператора :keyword:`with`."

#: ../../glossary.rst:269
msgid ""
"The collection of key­value bindings associated with a particular :class:"
"`contextvars.Context` object and accessed via :class:`~contextvars."
"ContextVar` objects.  Also see :term:`context variable`."
msgstr ""
"Коллекция привязок значений ключа, связанных с конкретным объектом :class:"
"`contextvars.Context` и доступ к которым осуществляется через объекты :class:"
"`~contextvars.ContextVar`. Также смотрите :term:`контекстную переменную`."

#: ../../glossary.rst:273
msgid ""
"A :class:`contextvars.Context` object.  Also see :term:`current context`."
msgstr ""
"Объект :class:`contextvars.Context`. Также см. :term:`текущий контекст`."

#: ../../glossary.rst:275
msgid "context management protocol"
msgstr "پروتکل مدیریت زمینه"

#: ../../glossary.rst:277
msgid ""
"The :meth:`~object.__enter__` and :meth:`~object.__exit__` methods called by "
"the :keyword:`with` statement.  See :pep:`343`."
msgstr ""
"Методы :meth:`~object.__enter__` и :meth:`~object.__exit__`, вызываемые "
"оператором :keyword:`with`. См. :pep:`343`."

#: ../../glossary.rst:279
msgid "context manager"
msgstr "مدیر زمینه"

#: ../../glossary.rst:281
msgid ""
"An object which implements the :term:`context management protocol` and "
"controls the environment seen in a :keyword:`with` statement.  See :pep:"
"`343`."
msgstr ""
"Объект, который реализует :term:`протокол управления контекстом` и управляет "
"средой, видимой в операторе :keyword:`with`. См. :pep:`343`."

#: ../../glossary.rst:284
msgid "context variable"
msgstr "контекстна змінна"

#: ../../glossary.rst:286
msgid ""
"A variable whose value depends on which context is the :term:`current "
"context`.  Values are accessed via :class:`contextvars.ContextVar` objects.  "
"Context variables are primarily used to isolate state between concurrent "
"asynchronous tasks."
msgstr ""
"Переменная, значение которой зависит от того, какой контекст является :term:"
"`текущим контекстом`. Доступ к значениям осуществляется через объекты :class:"
"`contextvars.ContextVar`. Переменные контекста в основном используются для "
"изоляции состояния между параллельными асинхронными задачами."

#: ../../glossary.rst:290
msgid "contiguous"
msgstr "суміжний"

#: ../../glossary.rst:294
msgid ""
"A buffer is considered contiguous exactly if it is either *C-contiguous* or "
"*Fortran contiguous*.  Zero-dimensional buffers are C and Fortran "
"contiguous.  In one-dimensional arrays, the items must be laid out in memory "
"next to each other, in order of increasing indexes starting from zero.  In "
"multidimensional C-contiguous arrays, the last index varies the fastest when "
"visiting items in order of memory address.  However, in Fortran contiguous "
"arrays, the first index varies the fastest."
msgstr ""
"Буфер вважається безперервним, якщо він *C-суміжний* або *Fortran "
"безперервний*. Нульвимірні буфери є суміжними на C і Fortran. В одновимірних "
"масивах елементи повинні розташовуватися в пам’яті поруч один з одним у "
"порядку зростання індексів, починаючи з нуля. У багатовимірних C-суміжних "
"масивах останній індекс змінюється найшвидше під час відвідування елементів "
"у порядку адреси пам’яті. Однак у безперервних масивах Fortran перший індекс "
"змінюється найшвидше."

#: ../../glossary.rst:302
msgid "coroutine"
msgstr "همروند"

#: ../../glossary.rst:304
msgid ""
"Coroutines are a more generalized form of subroutines. Subroutines are "
"entered at one point and exited at another point.  Coroutines can be "
"entered, exited, and resumed at many different points.  They can be "
"implemented with the :keyword:`async def` statement.  See also :pep:`492`."
msgstr ""
"Співпрограми є більш узагальненою формою підпрограм. Підпрограми вводяться в "
"одній точці і виходять з іншої. У співпрограми можна ввійти, вийти з них і "
"відновити їх у багатьох різних точках. Їх можна реалізувати за допомогою "
"оператора :keyword:`async def`. Дивіться також :pep:`492`."

#: ../../glossary.rst:309
msgid "coroutine function"
msgstr "функція співпрограми"

#: ../../glossary.rst:311
msgid ""
"A function which returns a :term:`coroutine` object.  A coroutine function "
"may be defined with the :keyword:`async def` statement, and may contain :"
"keyword:`await`, :keyword:`async for`, and :keyword:`async with` keywords.  "
"These were introduced by :pep:`492`."
msgstr ""
"Функція, яка повертає об’єкт :term:`coroutine`. Функція співпрограми може "
"бути визначена оператором :keyword:`async def` і може містити ключові слова :"
"keyword:`await`, :keyword:`async for` і :keyword:`async with`. Їх "
"представив :pep:`492`."

#: ../../glossary.rst:316
msgid "CPython"
msgstr "سی‌پایتون"

#: ../../glossary.rst:318
msgid ""
"The canonical implementation of the Python programming language, as "
"distributed on `python.org <https://www.python.org>`_.  The term \"CPython\" "
"is used when necessary to distinguish this implementation from others such "
"as Jython or IronPython."
msgstr ""
"Канонічна реалізація мови програмування Python, яка розповсюджується на "
"`python.org <https://www.python.org>`_. Термін \"CPython\" використовується, "
"коли необхідно відрізнити цю реалізацію від інших, таких як Jython або "
"IronPython."

#: ../../glossary.rst:322
msgid "current context"
msgstr "bieżący kontekst"

#: ../../glossary.rst:324
msgid ""
"The :term:`context` (:class:`contextvars.Context` object) that is currently "
"used by :class:`~contextvars.ContextVar` objects to access (get or set) the "
"values of :term:`context variables <context variable>`.  Each thread has its "
"own current context.  Frameworks for executing asynchronous tasks (see :mod:"
"`asyncio`) associate each task with a context which becomes the current "
"context whenever the task starts or resumes execution."
msgstr ""
"Объект :term:`context` (:class:`contextvars.Context`), который в настоящее "
"время используется объектами :class:`~contextvars.ContextVar` для доступа "
"(получения или установки) к значениям :term:`context переменных < "
"контекстная переменная>`. Каждый поток имеет свой собственный текущий "
"контекст. Платформы для выполнения асинхронных задач (см. :mod:`asyncio`) "
"связывают каждую задачу с контекстом, который становится текущим контекстом "
"всякий раз, когда задача запускается или возобновляет выполнение."

#: ../../glossary.rst:330
msgid "decorator"
msgstr "تزیینگر"

#: ../../glossary.rst:332
msgid ""
"A function returning another function, usually applied as a function "
"transformation using the ``@wrapper`` syntax.  Common examples for "
"decorators are :func:`classmethod` and :func:`staticmethod`."
msgstr ""
"Функція, що повертає іншу функцію, зазвичай застосовується як перетворення "
"функції за допомогою синтаксису ``@wrapper``. Типовими прикладами для "
"декораторів є :func:`classmethod` і :func:`staticmethod`."

#: ../../glossary.rst:336
msgid ""
"The decorator syntax is merely syntactic sugar, the following two function "
"definitions are semantically equivalent::"
msgstr ""
"Синтаксис декоратора є просто синтаксичним цукром, наступні два визначення "
"функції семантично еквівалентні:"

#: ../../glossary.rst:339
msgid ""
"def f(arg):\n"
"    ...\n"
"f = staticmethod(f)\n"
"\n"
"@staticmethod\n"
"def f(arg):\n"
"    ..."
msgstr ""
"def f(arg):\n"
"    ...\n"
"f = staticmethod(f)\n"
"\n"
"@staticmethod\n"
"def f(arg):\n"
"    ..."

#: ../../glossary.rst:347
msgid ""
"The same concept exists for classes, but is less commonly used there.  See "
"the documentation for :ref:`function definitions <function>` and :ref:`class "
"definitions <class>` for more about decorators."
msgstr ""
"Така сама концепція існує для класів, але використовується там рідше. "
"Перегляньте документацію щодо :ref:`визначення функцій <function>` та :ref:"
"`визначення класів <class>`, щоб дізнатися більше про декоратори."

#: ../../glossary.rst:350
msgid "descriptor"
msgstr "شرح دهنده"

#: ../../glossary.rst:352
msgid ""
"Any object which defines the methods :meth:`~object.__get__`, :meth:`~object."
"__set__`, or :meth:`~object.__delete__`. When a class attribute is a "
"descriptor, its special binding behavior is triggered upon attribute "
"lookup.  Normally, using *a.b* to get, set or delete an attribute looks up "
"the object named *b* in the class dictionary for *a*, but if *b* is a "
"descriptor, the respective descriptor method gets called.  Understanding "
"descriptors is a key to a deep understanding of Python because they are the "
"basis for many features including functions, methods, properties, class "
"methods, static methods, and reference to super classes."
msgstr ""
"Любой объект, который определяет методы :meth:`~object.__get__`, :meth:"
"`~object.__set__` или :meth:`~object.__delete__`. Если атрибут класса "
"является дескриптором, его особое поведение привязки запускается при поиске "
"атрибута. Обычно использование *ab* для получения, установки или удаления "
"атрибута ищет объект с именем *b* в словаре класса для *a*, но если *b* "
"является дескриптором, вызывается соответствующий метод дескриптора. "
"Понимание дескрипторов является ключом к глубокому пониманию Python, "
"поскольку они являются основой для многих функций, включая функции, методы, "
"свойства, методы классов, статические методы и ссылки на суперклассы."

#: ../../glossary.rst:363
msgid ""
"For more information about descriptors' methods, see :ref:`descriptors` or "
"the :ref:`Descriptor How To Guide <descriptorhowto>`."
msgstr ""
"Для отримання додаткової інформації про методи дескрипторів див. :ref:"
"`descriptors` або :ref:`Посібник з використання дескрипторів "
"<descriptorhowto>`."

#: ../../glossary.rst:365
msgid "dictionary"
msgstr "واژه‌نامه"

#: ../../glossary.rst:367
msgid ""
"An associative array, where arbitrary keys are mapped to values.  The keys "
"can be any object with :meth:`~object.__hash__` and :meth:`~object.__eq__` "
"methods. Called a hash in Perl."
msgstr ""
"Ассоциативный массив, в котором произвольные ключи сопоставляются значениям. "
"Ключами может быть любой объект с методами :meth:`~object.__hash__` и :meth:"
"`~object.__eq__`. Вызывается хешем в Perl."

#: ../../glossary.rst:371
msgid "dictionary comprehension"
msgstr "dictionary comprehension"

#: ../../glossary.rst:373
msgid ""
"A compact way to process all or part of the elements in an iterable and "
"return a dictionary with the results. ``results = {n: n ** 2 for n in "
"range(10)}`` generates a dictionary containing key ``n`` mapped to value ``n "
"** 2``. See :ref:`comprehensions`."
msgstr ""
"Компактний спосіб обробки всіх або частини елементів у ітерації та "
"повернення словника з результатами. ``results = {n: n ** 2 for n in "
"range(10)}`` генерує словник, що містить ключ ``n``, зіставлений зі "
"значенням ``n ** 2``. Дивіться :ref:`comprehensions`."

#: ../../glossary.rst:377
msgid "dictionary view"
msgstr "перегляд словника"

#: ../../glossary.rst:379
msgid ""
"The objects returned from :meth:`dict.keys`, :meth:`dict.values`, and :meth:"
"`dict.items` are called dictionary views. They provide a dynamic view on the "
"dictionary’s entries, which means that when the dictionary changes, the view "
"reflects these changes. To force the dictionary view to become a full list "
"use ``list(dictview)``.  See :ref:`dict-views`."
msgstr ""
"Об’єкти, що повертаються з :meth:`dict.keys`, :meth:`dict.values` і :meth:"
"`dict.items`, називаються представленнями словника. Вони забезпечують "
"динамічний перегляд словникових статей, що означає, що коли словник "
"змінюється, перегляд відображає ці зміни. Щоб змусити перегляд словника "
"стати повним списком, використовуйте ``list(dictview)``. Перегляньте :ref:"
"`dict-views`."

#: ../../glossary.rst:385
msgid "docstring"
msgstr "رشتهٔ مستند"

#: ../../glossary.rst:387
msgid ""
"A string literal which appears as the first expression in a class, function "
"or module.  While ignored when the suite is executed, it is recognized by "
"the compiler and put into the :attr:`~definition.__doc__` attribute of the "
"enclosing class, function or module.  Since it is available via "
"introspection, it is the canonical place for documentation of the object."
msgstr ""
"Строковый литерал, который появляется как первое выражение в классе, функции "
"или модуле. Хотя он игнорируется при выполнении пакета, он распознается "
"компилятором и помещается в атрибут :attr:`~definition.__doc__` включающего "
"класса, функции или модуля. Поскольку он доступен через самоанализ, это "
"каноническое место для документации объекта."

#: ../../glossary.rst:393
msgid "duck-typing"
msgstr "Качина типізація"

#: ../../glossary.rst:395
msgid ""
"A programming style which does not look at an object's type to determine if "
"it has the right interface; instead, the method or attribute is simply "
"called or used (\"If it looks like a duck and quacks like a duck, it must be "
"a duck.\")  By emphasizing interfaces rather than specific types, well-"
"designed code improves its flexibility by allowing polymorphic "
"substitution.  Duck-typing avoids tests using :func:`type` or :func:"
"`isinstance`.  (Note, however, that duck-typing can be complemented with :"
"term:`abstract base classes <abstract base class>`.)  Instead, it typically "
"employs :func:`hasattr` tests or :term:`EAFP` programming."
msgstr ""
"Стиль програмування, який не дивиться на тип об’єкта, щоб визначити, чи має "
"він правильний інтерфейс; замість цього метод або атрибут просто "
"викликається або використовується (\"Якщо він схожий на качку і крякає як "
"качка, це має бути качка\".) Підкреслюючи інтерфейси, а не конкретні типи, "
"добре розроблений код покращує свою гнучкість, дозволяючи поліморфне "
"заміщення. Duck-введення дозволяє уникнути тестів з використанням :func:"
"`type` або :func:`isinstance`. (Однак зауважте, що качиний тип може бути "
"доповнений :term:`абстрактними базовими класами <abstract base class>`.) "
"Замість цього зазвичай використовуються :func:`hasattr` тести або :term:"
"`EAFP` програмування."

#: ../../glossary.rst:404
msgid "EAFP"
msgstr "EAFP"

#: ../../glossary.rst:406
msgid ""
"Easier to ask for forgiveness than permission.  This common Python coding "
"style assumes the existence of valid keys or attributes and catches "
"exceptions if the assumption proves false.  This clean and fast style is "
"characterized by the presence of many :keyword:`try` and :keyword:`except` "
"statements.  The technique contrasts with the :term:`LBYL` style common to "
"many other languages such as C."
msgstr ""
"Легше попросити вибачення, ніж дозволу (Easier to ask for forgiveness than "
"permission). Цей поширений стиль кодування Python припускає існування "
"дійсних ключів або атрибутів і перехоплює винятки, якщо припущення виявиться "
"хибним. Цей чистий і швидкий стиль характеризується наявністю багатьох "
"операторів :keyword:`try` і :keyword:`except`. Техніка контрастує зі стилем :"
"term:`LBYL`, поширеним у багатьох інших мовах, таких як C."

#: ../../glossary.rst:412
msgid "expression"
msgstr "عبارت"

#: ../../glossary.rst:414
msgid ""
"A piece of syntax which can be evaluated to some value.  In other words, an "
"expression is an accumulation of expression elements like literals, names, "
"attribute access, operators or function calls which all return a value.  In "
"contrast to many other languages, not all language constructs are "
"expressions.  There are also :term:`statement`\\s which cannot be used as "
"expressions, such as :keyword:`while`.  Assignments are also statements, not "
"expressions."
msgstr ""
"Частина синтаксису, яка може бути оцінена до певного значення. Іншими "
"словами, вираз — це сукупність елементів виразу, таких як літерали, імена, "
"доступ до атрибутів, оператори або виклики функцій, які повертають значення. "
"На відміну від багатьох інших мов, не всі мовні конструкції є виразами. "
"Існують також :term:`statement`\\s, які не можна використовувати як вирази, "
"наприклад :keyword:`while`. Присвоєння також є операторами, а не виразами."

#: ../../glossary.rst:421
msgid "extension module"
msgstr "moduł rozszerzenia"

#: ../../glossary.rst:423
msgid ""
"A module written in C or C++, using Python's C API to interact with the core "
"and with user code."
msgstr ""
"Модуль, написаний мовою C або C++, який використовує C API Python для "
"взаємодії з ядром і кодом користувача."

#: ../../glossary.rst:425
msgid "f-string"
msgstr "رشتهٔ f"

#: ../../glossary.rst:427
msgid ""
"String literals prefixed with ``'f'`` or ``'F'`` are commonly called \"f-"
"strings\" which is short for :ref:`formatted string literals <f-strings>`.  "
"See also :pep:`498`."
msgstr ""
"Рядкові літерали з префіксом ``'f'`` або ``'F'`` зазвичай називаються \"f-"
"рядками\", що є скороченням від :ref:`форматованих рядкових літералів <f-"
"strings>`. Дивіться також :pep:`498`."

#: ../../glossary.rst:430
msgid "file object"
msgstr "شی فایل"

#: ../../glossary.rst:432
msgid ""
"An object exposing a file-oriented API (with methods such as :meth:`!read` "
"or :meth:`!write`) to an underlying resource.  Depending on the way it was "
"created, a file object can mediate access to a real on-disk file or to "
"another type of storage or communication device (for example standard input/"
"output, in-memory buffers, sockets, pipes, etc.).  File objects are also "
"called :dfn:`file-like objects` or :dfn:`streams`."
msgstr ""
"Объект, предоставляющий файлово-ориентированный API (с такими методами, как :"
"meth:`!read` или :meth:`!write`) базовому ресурсу. В зависимости от способа "
"создания файловый объект может обеспечивать доступ к реальному файлу на "
"диске или к другому типу устройства хранения или связи (например, "
"стандартному вводу/выводу, буферам в памяти, сокетам, каналам и т. д.). . "
"Файловые объекты также называются :dfn:`файлоподобными объектами` или :dfn:"
"`streams`."

#: ../../glossary.rst:440
msgid ""
"There are actually three categories of file objects: raw :term:`binary files "
"<binary file>`, buffered :term:`binary files <binary file>` and :term:`text "
"files <text file>`. Their interfaces are defined in the :mod:`io` module.  "
"The canonical way to create a file object is by using the :func:`open` "
"function."
msgstr ""
"Фактично існує три категорії файлових об’єктів: необроблені :term:`бінарні "
"файли <binary file>`, буферизовані :term:`бінарні файли <binary file>` і :"
"term:`текстові файли <text file>`. Їхні інтерфейси визначені в модулі :mod:"
"`io`. Канонічний спосіб створення файлового об’єкта – це використання "
"функції :func:`open`."

#: ../../glossary.rst:445
msgid "file-like object"
msgstr "файлоподібний об'єкт"

#: ../../glossary.rst:447
msgid "A synonym for :term:`file object`."
msgstr "Синонім :term:`file object`."

#: ../../glossary.rst:448
msgid "filesystem encoding and error handler"
msgstr "кодування файлової системи та обробник помилок"

#: ../../glossary.rst:450
msgid ""
"Encoding and error handler used by Python to decode bytes from the operating "
"system and encode Unicode to the operating system."
msgstr ""
"Кодування та обробник помилок, які використовуються Python для декодування "
"байтів з операційної системи та кодування Unicode до операційної системи."

#: ../../glossary.rst:453
msgid ""
"The filesystem encoding must guarantee to successfully decode all bytes "
"below 128. If the file system encoding fails to provide this guarantee, API "
"functions can raise :exc:`UnicodeError`."
msgstr ""
"Кодування файлової системи має гарантувати успішне декодування всіх байтів "
"нижче 128. Якщо кодування файлової системи не забезпечує цю гарантію, "
"функції API можуть викликати :exc:`UnicodeError`."

#: ../../glossary.rst:457
msgid ""
"The :func:`sys.getfilesystemencoding` and :func:`sys."
"getfilesystemencodeerrors` functions can be used to get the filesystem "
"encoding and error handler."
msgstr ""
"Функції :func:`sys.getfilesystemencoding` і :func:`sys."
"getfilesystemencodeerrors` можна використовувати для отримання кодування "
"файлової системи та обробника помилок."

#: ../../glossary.rst:461
msgid ""
"The :term:`filesystem encoding and error handler` are configured at Python "
"startup by the :c:func:`PyConfig_Read` function: see :c:member:`~PyConfig."
"filesystem_encoding` and :c:member:`~PyConfig.filesystem_errors` members of :"
"c:type:`PyConfig`."
msgstr ""
":term:`filesystem encoding and error handler` налаштовуються під час запуску "
"Python за допомогою функції :c:func:`PyConfig_Read`: див. :c:member:"
"`~PyConfig.filesystem_encoding` і :c:member:`~PyConfig. filesystem_errors` "
"члени :c:type:`PyConfig`."

#: ../../glossary.rst:466
msgid "See also the :term:`locale encoding`."
msgstr "Дивіться також :term:`locale encoding`."

#: ../../glossary.rst:467
msgid "finder"
msgstr "یابنده"

#: ../../glossary.rst:469
msgid ""
"An object that tries to find the :term:`loader` for a module that is being "
"imported."
msgstr ""
"Об’єкт, який намагається знайти :term:`loader` для модуля, який імпортується."

#: ../../glossary.rst:472
msgid ""
"There are two types of finder: :term:`meta path finders <meta path finder>` "
"for use with :data:`sys.meta_path`, and :term:`path entry finders <path "
"entry finder>` for use with :data:`sys.path_hooks`."
msgstr ""
"Существует два типа средств поиска: :term:`поисковики метапутей <поиск "
"метапутей>` для использования с :data:`sys.meta_path` и :term:`поисковики "
"записей пути <поиск записей путей>` для использования с: данные:`sys."
"path_hooks`."

#: ../../glossary.rst:476
msgid ""
"See :ref:`finders-and-loaders` and :mod:`importlib` for much more detail."
msgstr ""
"Более подробную информацию смотрите в :ref:`finders-and-loaders` и :mod:"
"`importlib`."

#: ../../glossary.rst:477
msgid "floor division"
msgstr "поділ поверху"

#: ../../glossary.rst:479
msgid ""
"Mathematical division that rounds down to nearest integer.  The floor "
"division operator is ``//``.  For example, the expression ``11 // 4`` "
"evaluates to ``2`` in contrast to the ``2.75`` returned by float true "
"division.  Note that ``(-11) // 4`` is ``-3`` because that is ``-2.75`` "
"rounded *downward*. See :pep:`238`."
msgstr ""
"Математичне ділення, яке округлюється до найближчого цілого числа. Оператор "
"поділу підлоги – ``//``. Наприклад, вираз ``11 // 4`` обчислюється як ``2`` "
"на відміну від ``2,75``, яке повертає float true division. Зауважте, що "
"``(-11) // 4`` є ``-3``, тому що це ``-2,75``, округлене *униз*. Дивіться :"
"pep:`238`."

#: ../../glossary.rst:484
msgid "free threading"
msgstr "бесплатная резьба"

#: ../../glossary.rst:486
msgid ""
"A threading model where multiple threads can run Python bytecode "
"simultaneously within the same interpreter.  This is in contrast to the :"
"term:`global interpreter lock` which allows only one thread to execute "
"Python bytecode at a time.  See :pep:`703`."
msgstr ""
"Модель потоков, в которой несколько потоков могут одновременно выполнять "
"байт-код Python в одном интерпретаторе. Это контрастирует с глобальной "
"блокировкой интерпретатора, которая позволяет только одному потоку "
"одновременно выполнять байт-код Python. См. :pep:`703`."

#: ../../glossary.rst:490
msgid "free variable"
msgstr "свободная переменная"

#: ../../glossary.rst:492
msgid ""
"Formally, as defined in the :ref:`language execution model <bind_names>`, a "
"free variable is any variable used in a namespace which is not a local "
"variable in that namespace. See :term:`closure variable` for an example. "
"Pragmatically, due to the name of the :attr:`codeobject.co_freevars` "
"attribute, the term is also sometimes used as a synonym for :term:`closure "
"variable`."
msgstr ""
"Формально, как определено в :ref:`модели выполнения языка <bind_names>`, "
"свободная переменная — это любая переменная, используемая в пространстве "
"имен, которая не является локальной переменной в этом пространстве имен. "
"Пример см. в разделе :term:`замыкающая переменная`. С прагматической точки "
"зрения, из-за названия атрибута :attr:`codeobject.co_freevars`, этот термин "
"также иногда используется как синоним :term:`закрывающей переменной`."

#: ../../glossary.rst:497
msgid "function"
msgstr "تابع"

#: ../../glossary.rst:499
msgid ""
"A series of statements which returns some value to a caller. It can also be "
"passed zero or more :term:`arguments <argument>` which may be used in the "
"execution of the body. See also :term:`parameter`, :term:`method`, and the :"
"ref:`function` section."
msgstr ""
"Серія операторів, які повертають певне значення абоненту. Йому також можна "
"передати нуль або більше :term:`аргументів <argument>`, які можуть бути "
"використані під час виконання тіла. Дивіться також :term:`parameter`, :term:"
"`method` і розділ :ref:`function`."

#: ../../glossary.rst:503
msgid "function annotation"
msgstr "anotasi fungsi"

#: ../../glossary.rst:505
msgid "An :term:`annotation` of a function parameter or return value."
msgstr ":term:`annotation` параметра функції або значення, що повертається."

#: ../../glossary.rst:507
msgid ""
"Function annotations are usually used for :term:`type hints <type hint>`: "
"for example, this function is expected to take two :class:`int` arguments "
"and is also expected to have an :class:`int` return value::"
msgstr ""
"Анотації функцій зазвичай використовуються для :term:`підказок типу <type "
"hint>`: наприклад, ця функція має приймати два аргументи :class:`int` і "
"також має повертати значення :class:`int`::"

#: ../../glossary.rst:512
msgid ""
"def sum_two_numbers(a: int, b: int) -> int:\n"
"   return a + b"
msgstr ""
"def sum_two_numbers(a: int, b: int) -> int:\n"
"   return a + b"

#: ../../glossary.rst:515
msgid "Function annotation syntax is explained in section :ref:`function`."
msgstr "Синтаксис анотації функції пояснюється в розділі :ref:`function`."

#: ../../glossary.rst:517
msgid ""
"See :term:`variable annotation` and :pep:`484`, which describe this "
"functionality. Also see :ref:`annotations-howto` for best practices on "
"working with annotations."
msgstr ""
"Див. :term:`variable annotation` і :pep:`484`, які описують цю "
"функціональність. Також перегляньте :ref:`annotations-howto`, щоб дізнатися "
"про найкращі практики роботи з анотаціями."

#: ../../glossary.rst:521
msgid "__future__"
msgstr "__future__"

#: ../../glossary.rst:523
msgid ""
"A :ref:`future statement <future>`, ``from __future__ import <feature>``, "
"directs the compiler to compile the current module using syntax or semantics "
"that will become standard in a future release of Python. The :mod:"
"`__future__` module documents the possible values of *feature*.  By "
"importing this module and evaluating its variables, you can see when a new "
"feature was first added to the language and when it will (or did) become the "
"default::"
msgstr ""
":ref:`інструкція future <future>`, ``from __future__ import <feature>``, "
"вказує компілятору скомпілювати поточний модуль, використовуючи синтаксис "
"або семантику, які стануть стандартними в майбутньому випуску Python. "
"Модуль :mod:`__future__` документує можливі значення *feature*. Імпортувавши "
"цей модуль та оцінивши його змінні, ви можете побачити, коли нова функція "
"була вперше додана до мови та коли вона стане (або стала) типовою::"

#: ../../glossary.rst:531
msgid ""
">>> import __future__\n"
">>> __future__.division\n"
"_Feature((2, 2, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0), 8192)"
msgstr ""
">>> import __future__\n"
">>> __future__.division\n"
"_Feature((2, 2, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0), 8192)"

#: ../../glossary.rst:534
msgid "garbage collection"
msgstr "zbieranie śmieci"

#: ../../glossary.rst:536
msgid ""
"The process of freeing memory when it is not used anymore.  Python performs "
"garbage collection via reference counting and a cyclic garbage collector "
"that is able to detect and break reference cycles.  The garbage collector "
"can be controlled using the :mod:`gc` module."
msgstr ""
"Процес звільнення пам'яті, коли вона більше не використовується. Python "
"виконує збирання сміття за допомогою підрахунку посилань і циклічного "
"збирача сміття, здатного виявляти та розривати цикли посилань. Збирачем "
"сміття можна керувати за допомогою модуля :mod:`gc`."

#: ../../glossary.rst:541 ../../glossary.rst:542
msgid "generator"
msgstr "تولید کننده"

#: ../../glossary.rst:544
msgid ""
"A function which returns a :term:`generator iterator`.  It looks like a "
"normal function except that it contains :keyword:`yield` expressions for "
"producing a series of values usable in a for-loop or that can be retrieved "
"one at a time with the :func:`next` function."
msgstr ""
"Функція, яка повертає :term:`generator iterator`. Це виглядає як звичайна "
"функція, за винятком того, що вона містить вирази :keyword:`yield` для "
"створення серії значень, які можна використовувати в циклі for або які можна "
"отримати по одному за допомогою функції :func:`next`."

#: ../../glossary.rst:549
msgid ""
"Usually refers to a generator function, but may refer to a *generator "
"iterator* in some contexts.  In cases where the intended meaning isn't "
"clear, using the full terms avoids ambiguity."
msgstr ""
"Зазвичай відноситься до функції-генератора, але в деяких контекстах може "
"посилатися на *ітератор-генератор*. У випадках, коли передбачуване значення "
"не є зрозумілим, використання повних термінів дозволяє уникнути двозначності."

#: ../../glossary.rst:552
msgid "generator iterator"
msgstr "ітератор генератора"

#: ../../glossary.rst:554
msgid "An object created by a :term:`generator` function."
msgstr "Об’єкт, створений функцією :term:`generator`."

#: ../../glossary.rst:556
msgid ""
"Each :keyword:`yield` temporarily suspends processing, remembering the "
"execution state (including local variables and pending try-statements).  "
"When the *generator iterator* resumes, it picks up where it left off (in "
"contrast to functions which start fresh on every invocation)."
msgstr ""
"Каждое: ключевое слово: `helipt` временно приостанавливает обработку, "
"запоминая состояние выполнения (включая локальные переменные и ожидающие "
"пробуждения). Когда итератор * генератора * возобновляется, он поднимается с "
"того места, где он остановился (в отличие от функций, которые начинаются "
"только на каждом вызове)."

#: ../../glossary.rst:562 ../../glossary.rst:563
msgid "generator expression"
msgstr "генераторний вираз"

#: ../../glossary.rst:565
msgid ""
"An :term:`expression` that returns an :term:`iterator`.  It looks like a "
"normal expression followed by a :keyword:`!for` clause defining a loop "
"variable, range, and an optional :keyword:`!if` clause.  The combined "
"expression generates values for an enclosing function::"
msgstr ""
"An :term:`expression`  которое возвращает  :term:`iterator`.  Оно выглядит "
"как обычное выражение, за которым следует предложение :keyword:`!for`, "
"определяющее переменную цикла, диапазон, и необязательное предложение :"
"keyword:`!if`. Комбинированное выражение генерирует значения для включающей "
"функции:: "

#: ../../glossary.rst:570
msgid ""
">>> sum(i*i for i in range(10))         # sum of squares 0, 1, 4, ... 81\n"
"285"
msgstr ""
">>> sum(i*i for i in range(10))         # sum of squares 0, 1, 4, ... 81\n"
"285"

#: ../../glossary.rst:572
msgid "generic function"
msgstr "fungsi generik"

#: ../../glossary.rst:574
msgid ""
"A function composed of multiple functions implementing the same operation "
"for different types. Which implementation should be used during a call is "
"determined by the dispatch algorithm."
msgstr ""
"Функція, що складається з кількох функцій, які реалізують ту саму операцію "
"для різних типів. Яку реалізацію слід використовувати під час виклику, "
"визначається алгоритмом диспетчеризації."

#: ../../glossary.rst:578
msgid ""
"See also the :term:`single dispatch` glossary entry, the :func:`functools."
"singledispatch` decorator, and :pep:`443`."
msgstr ""
"Дивіться також запис глосарію :term:`single dispatch`, декоратор :func:"
"`functools.singledispatch` і :pep:`443`."

#: ../../glossary.rst:580
msgid "generic type"
msgstr "родовий тип"

#: ../../glossary.rst:582
msgid ""
"A :term:`type` that can be parameterized; typically a :ref:`container "
"class<sequence-types>` such as :class:`list` or :class:`dict`. Used for :"
"term:`type hints <type hint>` and :term:`annotations <annotation>`."
msgstr ""
":term:`type`, який можна параметризувати; зазвичай це :ref:`клас-контейнер "
"<sequence-types>`, наприклад :class:`list` або :class:`dict`. "
"Використовується для :term:`підказок типу <type hint>` та :term:`анотацій "
"<annotation>`."

#: ../../glossary.rst:587
msgid ""
"For more details, see :ref:`generic alias types<types-genericalias>`, :pep:"
"`483`, :pep:`484`, :pep:`585`, and the :mod:`typing` module."
msgstr ""
"Для отримання додаткової інформації див. :ref:`загальні типи псевдонімів "
"<types-genericalias>`, :pep:`483`, :pep:`484`, :pep:`585` і модуль :mod:"
"`typing`."

#: ../../glossary.rst:589
msgid "GIL"
msgstr "GIL"

#: ../../glossary.rst:591
msgid "See :term:`global interpreter lock`."
msgstr "Lihat :term:`global interpreter lock`."

#: ../../glossary.rst:592
msgid "global interpreter lock"
msgstr "kunci interpreter global"

#: ../../glossary.rst:594
msgid ""
"The mechanism used by the :term:`CPython` interpreter to assure that only "
"one thread executes Python :term:`bytecode` at a time. This simplifies the "
"CPython implementation by making the object model (including critical built-"
"in types such as :class:`dict`) implicitly safe against concurrent access.  "
"Locking the entire interpreter makes it easier for the interpreter to be "
"multi-threaded, at the expense of much of the parallelism afforded by multi-"
"processor machines."
msgstr ""
"Механізм, який використовується інтерпретатором :term:`CPython`, щоб "
"гарантувати, що лише один потік виконує :term:`bytecode` Python за раз. Це "
"спрощує реалізацію CPython, роблячи об’єктну модель (включно з критично "
"важливими вбудованими типами, такими як :class:`dict`) неявно захищеною від "
"одночасного доступу. Блокування всього інтерпретатора полегшує "
"багатопотоковість інтерпретатора за рахунок більшої частини паралелізму, "
"який надають багатопроцесорні машини."

#: ../../glossary.rst:603
msgid ""
"However, some extension modules, either standard or third-party, are "
"designed so as to release the GIL when doing computationally intensive tasks "
"such as compression or hashing.  Also, the GIL is always released when doing "
"I/O."
msgstr ""
"Однако некоторые модули расширения, как стандартные, так и сторонние, "
"разработаны таким образом, чтобы освобождать GIL при выполнении ресурсоемких "
"задач, таких как сжатие или хеширование. Кроме того, GIL всегда "
"освобождается при выполнении ввода-вывода."

#: ../../glossary.rst:608
msgid ""
"As of Python 3.13, the GIL can be disabled using the :option:`--disable-gil` "
"build configuration. After building Python with this option, code must be "
"run with :option:`-X gil=0 <-X>` or after setting the :envvar:`PYTHON_GIL=0 "
"<PYTHON_GIL>` environment variable. This feature enables improved "
"performance for multi-threaded applications and makes it easier to use multi-"
"core CPUs efficiently. For more details, see :pep:`703`."
msgstr ""
"Начиная с Python 3.13, GIL можно отключить с помощью конфигурации сборки :"
"option:`--disable-gil`. После сборки Python с этой опцией код необходимо "
"запустить с :option:`-X gil=0 <-X>` или после установки переменной среды :"
"envvar:`PYTHON_GIL=0 <PYTHON_GIL>`. Эта функция позволяет повысить "
"производительность многопоточных приложений и упрощает эффективное "
"использование многоядерных процессоров. Для получения более подробной "
"информации см. :pep:`703`."

#: ../../glossary.rst:614
msgid "hash-based pyc"
msgstr "на основі хешу pyc"

#: ../../glossary.rst:616
msgid ""
"A bytecode cache file that uses the hash rather than the last-modified time "
"of the corresponding source file to determine its validity. See :ref:`pyc-"
"invalidation`."
msgstr ""
"Файл кешу байт-коду, який використовує хеш, а не час останньої зміни "
"відповідного вихідного файлу для визначення його дійсності. Перегляньте :ref:"
"`pyc-invalidation`."

#: ../../glossary.rst:619
msgid "hashable"
msgstr "хешований"

#: ../../glossary.rst:621
msgid ""
"An object is *hashable* if it has a hash value which never changes during "
"its lifetime (it needs a :meth:`~object.__hash__` method), and can be "
"compared to other objects (it needs an :meth:`~object.__eq__` method). "
"Hashable objects which compare equal must have the same hash value."
msgstr ""
"Объект является *хешируемым*, если он имеет хеш-значение, которое никогда не "
"меняется в течение его существования (для этого требуется метод :meth:"
"`~object.__hash__`) и его можно сравнивать с другими объектами (для этого "
"нужен :meth:`~ метод object.__eq__`). Хешируемые объекты, которые "
"сравниваются равными, должны иметь одинаковое значение хеш-функции."

#: ../../glossary.rst:627
msgid ""
"Hashability makes an object usable as a dictionary key and a set member, "
"because these data structures use the hash value internally."
msgstr ""
"Хешування робить об’єкт придатним для використання як ключ словника та член "
"набору, оскільки ці структури даних використовують хеш-значення внутрішньо."

#: ../../glossary.rst:630
msgid ""
"Most of Python's immutable built-in objects are hashable; mutable containers "
"(such as lists or dictionaries) are not; immutable containers (such as "
"tuples and frozensets) are only hashable if their elements are hashable.  "
"Objects which are instances of user-defined classes are hashable by "
"default.  They all compare unequal (except with themselves), and their hash "
"value is derived from their :func:`id`."
msgstr ""
"Більшість незмінних вбудованих об’єктів Python можна хешувати; змінні "
"контейнери (такі як списки або словники) не є; незмінні контейнери (такі як "
"кортежі та заморожені набори) можна хешувати, лише якщо їх елементи "
"хешуються. Об’єкти, які є екземплярами визначених користувачем класів, "
"хешуються за замовчуванням. Усі вони порівнюються неоднаково (за винятком "
"самих себе), і їх хеш-значення походить від їхнього :func:`id`."

#: ../../glossary.rst:637
msgid "IDLE"
msgstr "IDLE"

#: ../../glossary.rst:639
msgid ""
"An Integrated Development and Learning Environment for Python. :ref:`idle` "
"is a basic editor and interpreter environment which ships with the standard "
"distribution of Python."
msgstr ""
"Большинство неизменяемых встроенных объектов Python являются хешируемыми; "
"изменяемые контейнеры (такие как списки или словари) — нет; неизменяемые "
"контейнеры (такие как кортежи и замороженные наборы) хешируются только в том "
"случае, если их элементы хешируются. Объекты, являющиеся экземплярами "
"пользовательских классов, по умолчанию хешируются. Все они сравниваются "
"неравными (кроме самих себя), а их хеш-значение получается из их :func:`id`."

#: ../../glossary.rst:642
msgid "immortal"
msgstr "nieśmiertelne"

#: ../../glossary.rst:644
msgid ""
"*Immortal objects* are a CPython implementation detail introduced in :pep:"
"`683`."
msgstr ""
"*Бессмертные объекты* — это деталь реализации CPython, представленная в :pep:"
"`683`."

#: ../../glossary.rst:647
msgid ""
"If an object is immortal, its :term:`reference count` is never modified, and "
"therefore it is never deallocated while the interpreter is running. For "
"example, :const:`True` and :const:`None` are immortal in CPython."
msgstr ""
"Если объект бессмертен, его счетчик ссылок никогда не изменяется и, "
"следовательно, он никогда не освобождается во время работы интерпретатора. "
"Например, :const:`True` и :const:`None` бессмертны в CPython."

#: ../../glossary.rst:650
msgid "immutable"
msgstr "تغییرناپذیر"

#: ../../glossary.rst:652
msgid ""
"An object with a fixed value.  Immutable objects include numbers, strings "
"and tuples.  Such an object cannot be altered.  A new object has to be "
"created if a different value has to be stored.  They play an important role "
"in places where a constant hash value is needed, for example as a key in a "
"dictionary."
msgstr ""
"Об’єкт із фіксованим значенням. До незмінних об’єктів належать числа, рядки "
"та кортежі. Такий об'єкт не можна змінити. Якщо потрібно зберегти інше "
"значення, потрібно створити новий об’єкт. Вони відіграють важливу роль у "
"місцях, де потрібне постійне хеш-значення, наприклад, як ключ у словнику."

#: ../../glossary.rst:657
msgid "import path"
msgstr "шлях імпорту"

#: ../../glossary.rst:659
msgid ""
"A list of locations (or :term:`path entries <path entry>`) that are searched "
"by the :term:`path based finder` for modules to import. During import, this "
"list of locations usually comes from :data:`sys.path`, but for subpackages "
"it may also come from the parent package's ``__path__`` attribute."
msgstr ""
"Список розташувань (або :term:`записів шляху <path entry>`), у яких :term:"
"`path based finder` шукає модулі для імпорту. Під час імпорту цей список "
"розташувань зазвичай надходить із :data:`sys.path`, але для підпакетів він "
"також може надходити з атрибута ``__path__`` батьківського пакета."

#: ../../glossary.rst:664
msgid "importing"
msgstr "درون‌ریزی"

#: ../../glossary.rst:666
msgid ""
"The process by which Python code in one module is made available to Python "
"code in another module."
msgstr ""
"Процес, за допомогою якого код Python в одному модулі стає доступним для "
"коду Python в іншому модулі."

#: ../../glossary.rst:668
msgid "importer"
msgstr "درون‌ریز"

#: ../../glossary.rst:670
msgid ""
"An object that both finds and loads a module; both a :term:`finder` and :"
"term:`loader` object."
msgstr ""
"Об’єкт, який знаходить і завантажує модуль; як об’єкт :term:`finder`, так і :"
"term:`loader`."

#: ../../glossary.rst:672
msgid "interactive"
msgstr "تعاملی"

#: ../../glossary.rst:674
msgid ""
"Python has an interactive interpreter which means you can enter statements "
"and expressions at the interpreter prompt, immediately execute them and see "
"their results.  Just launch ``python`` with no arguments (possibly by "
"selecting it from your computer's main menu). It is a very powerful way to "
"test out new ideas or inspect modules and packages (remember ``help(x)``). "
"For more on interactive mode, see :ref:`tut-interac`."
msgstr ""
"Python имеет интерактивный интерпретатор, что означает, что вы можете "
"вводить операторы и выражения в приглашении интерпретатора, немедленно "
"выполнять их и видеть результаты. Просто запустите Python без аргументов "
"(возможно, выбрав его в главном меню вашего компьютера). Это очень мощный "
"способ протестировать новые идеи или проверить модули и пакеты (помните "
"``help(x)``). Подробнее об интерактивном режиме см. :ref:`tut-interac`."

#: ../../glossary.rst:681
msgid "interpreted"
msgstr "تفسیر شده"

#: ../../glossary.rst:683
msgid ""
"Python is an interpreted language, as opposed to a compiled one, though the "
"distinction can be blurry because of the presence of the bytecode compiler.  "
"This means that source files can be run directly without explicitly creating "
"an executable which is then run. Interpreted languages typically have a "
"shorter development/debug cycle than compiled ones, though their programs "
"generally also run more slowly.  See also :term:`interactive`."
msgstr ""
"Python є інтерпретованою мовою, на відміну від скомпільованої, хоча "
"відмінність може бути розмитою через наявність компілятора байт-коду. Це "
"означає, що вихідні файли можна запускати безпосередньо без явного створення "
"виконуваного файлу, який потім запускається. Інтерпретовані мови зазвичай "
"мають коротший цикл розробки/налагодження, ніж скомпільовані, хоча їхні "
"програми також працюють повільніше. Дивіться також :term:`interactive`."

#: ../../glossary.rst:690
msgid "interpreter shutdown"
msgstr "вимкнення перекладача"

#: ../../glossary.rst:692
msgid ""
"When asked to shut down, the Python interpreter enters a special phase where "
"it gradually releases all allocated resources, such as modules and various "
"critical internal structures.  It also makes several calls to the :term:"
"`garbage collector <garbage collection>`. This can trigger the execution of "
"code in user-defined destructors or weakref callbacks. Code executed during "
"the shutdown phase can encounter various exceptions as the resources it "
"relies on may not function anymore (common examples are library modules or "
"the warnings machinery)."
msgstr ""
"Коли його попросять завершити роботу, інтерпретатор Python переходить у "
"спеціальну фазу, де він поступово звільняє всі виділені ресурси, такі як "
"модулі та різні критичні внутрішні структури. Він також робить кілька "
"викликів до :term:`збирача сміття <garbage collection>`. Це може ініціювати "
"виконання коду в визначених користувачем деструкторах або зворотних викликах "
"weakref. Код, який виконується під час фази завершення роботи, може "
"зіткнутися з різними винятками, оскільки ресурси, на які він покладається, "
"можуть більше не функціонувати (поширеними прикладами є бібліотечні модулі "
"або механізм попереджень)."

#: ../../glossary.rst:701
msgid ""
"The main reason for interpreter shutdown is that the ``__main__`` module or "
"the script being run has finished executing."
msgstr ""
"Основною причиною вимкнення інтерпретатора є завершення виконання модуля "
"``__main__`` або сценарію, який виконується."

#: ../../glossary.rst:703
msgid "iterable"
msgstr "تکرارپذیر"

#: ../../glossary.rst:705
msgid ""
"An object capable of returning its members one at a time. Examples of "
"iterables include all sequence types (such as :class:`list`, :class:`str`, "
"and :class:`tuple`) and some non-sequence types like :class:`dict`, :term:"
"`file objects <file object>`, and objects of any classes you define with an :"
"meth:`~object.__iter__` method or with a :meth:`~object.__getitem__` method "
"that implements :term:`sequence` semantics."
msgstr ""
"Объект, способный вернуть своих членов по одному. Примеры итмеров включают "
"все типы последовательностей (например: класс: `list`,: класс:` str` и: "
"class: `tuple`) и некоторые типы не последовательности, такие как: класс:` "
"dict`,: термин: `file-объекты object>` и объекты любых классов, которые вы "
"определяете с помощью: meth: ~ object. : Термин: `последовательность "
"'семантика."

#: ../../glossary.rst:713
msgid ""
"Iterables can be used in a :keyword:`for` loop and in many other places "
"where a sequence is needed (:func:`zip`, :func:`map`, ...).  When an "
"iterable object is passed as an argument to the built-in function :func:"
"`iter`, it returns an iterator for the object.  This iterator is good for "
"one pass over the set of values.  When using iterables, it is usually not "
"necessary to call :func:`iter` or deal with iterator objects yourself.  The :"
"keyword:`for` statement does that automatically for you, creating a "
"temporary unnamed variable to hold the iterator for the duration of the "
"loop.  See also :term:`iterator`, :term:`sequence`, and :term:`generator`."
msgstr ""
"Итерации можно использовать в цикле :keyword:`for` и во многих других "
"местах, где необходима последовательность (:func:`zip`, :func:`map`, ...). "
"Когда итерируемый объект передается в качестве аргумента встроенной функции :"
"func:`iter`, она возвращает итератор для объекта. Этот итератор хорош для "
"одного прохода по набору значений. При использовании итераторов обычно нет "
"необходимости вызывать :func:`iter` или самостоятельно работать с объектами-"
"итераторами. Оператор :keyword:`for` делает это автоматически, создавая "
"временную безымянную переменную для хранения итератора на протяжении всего "
"цикла. См. также :term:`iterator`, :term:`sequence` и :term:`generator`."

#: ../../glossary.rst:723
msgid "iterator"
msgstr "تکرار کننده"

#: ../../glossary.rst:725
msgid ""
"An object representing a stream of data.  Repeated calls to the iterator's :"
"meth:`~iterator.__next__` method (or passing it to the built-in function :"
"func:`next`) return successive items in the stream.  When no more data are "
"available a :exc:`StopIteration` exception is raised instead.  At this "
"point, the iterator object is exhausted and any further calls to its :meth:`!"
"__next__` method just raise :exc:`StopIteration` again.  Iterators are "
"required to have an :meth:`~iterator.__iter__` method that returns the "
"iterator object itself so every iterator is also iterable and may be used in "
"most places where other iterables are accepted.  One notable exception is "
"code which attempts multiple iteration passes.  A container object (such as "
"a :class:`list`) produces a fresh new iterator each time you pass it to the :"
"func:`iter` function or use it in a :keyword:`for` loop.  Attempting this "
"with an iterator will just return the same exhausted iterator object used in "
"the previous iteration pass, making it appear like an empty container."
msgstr ""
"Объект, представляющий поток данных. Повторные вызовы метода итератора :meth:"
"`~iterator.__next__` (или передача его встроенной функции :func:`next`) "
"возвращают последовательные элементы в потоке. Когда больше нет доступных "
"данных, вместо этого возникает исключение :exc:`StopIteration`. На этом "
"этапе объект итератора исчерпан, и любые дальнейшие вызовы его метода :meth:"
"`!__next__` просто снова вызовут :exc:`StopIteration`. Итераторы должны "
"иметь метод :meth:`~iterator.__iter__`, который возвращает сам объект "
"итератора, поэтому каждый итератор также является итерируемым и может "
"использоваться в большинстве мест, где принимаются другие итераторы. Одним "
"заметным исключением является код, который пытается выполнить несколько "
"итераций. Объект-контейнер (например, :class:`list`) создает новый новый "
"итератор каждый раз, когда вы передаете его функции :func:`iter` или "
"используете его в цикле :keyword:`for`. Попытка сделать это с помощью "
"итератора просто вернет тот же самый исчерпанный объект итератора, который "
"использовался на предыдущем проходе итерации, делая его похожим на пустой "
"контейнер."

#: ../../glossary.rst:740
msgid "More information can be found in :ref:`typeiter`."
msgstr "Informasi lebih lanjut dapat ditemukan di :ref:`typeiter`."

#: ../../glossary.rst:744
msgid ""
"CPython does not consistently apply the requirement that an iterator define :"
"meth:`~iterator.__iter__`. And also please note that the free-threading "
"CPython does not guarantee the thread-safety of iterator operations."
msgstr ""
"CPython не всегда последовательно применяет требование, чтобы итератор "
"определял :meth:`~iterator.__iter__`. Также обратите внимание, что CPython "
"со свободной поточностью не гарантирует потокобезопасность операций "
"итератора."

#: ../../glossary.rst:749
msgid "key function"
msgstr "fungsi kunci"

#: ../../glossary.rst:751
msgid ""
"A key function or collation function is a callable that returns a value used "
"for sorting or ordering.  For example, :func:`locale.strxfrm` is used to "
"produce a sort key that is aware of locale specific sort conventions."
msgstr ""
"Ключова функція або функція зіставлення — це виклик, який повертає значення, "
"яке використовується для сортування або впорядкування. Наприклад, :func:"
"`locale.strxfrm` використовується для створення ключа сортування, який "
"враховує умови сортування для певної мови."

#: ../../glossary.rst:756
msgid ""
"A number of tools in Python accept key functions to control how elements are "
"ordered or grouped.  They include :func:`min`, :func:`max`, :func:`sorted`, :"
"meth:`list.sort`, :func:`heapq.merge`, :func:`heapq.nsmallest`, :func:`heapq."
"nlargest`, and :func:`itertools.groupby`."
msgstr ""
"Кілька інструментів у Python приймають ключові функції для керування тим, як "
"елементи впорядковуються чи групуються. Серед них :func:`min`, :func:`max`, :"
"func:`sorted`, :meth:`list.sort`, :func:`heapq.merge`, :func:`heapq."
"nsmallest`, :func:`heapq.nlargest` і :func:`itertools.groupby`."

#: ../../glossary.rst:762
msgid ""
"There are several ways to create a key function.  For example. the :meth:"
"`str.lower` method can serve as a key function for case insensitive sorts.  "
"Alternatively, a key function can be built from a :keyword:`lambda` "
"expression such as ``lambda r: (r[0], r[2])``.  Also, :func:`operator."
"attrgetter`, :func:`operator.itemgetter`, and :func:`operator.methodcaller` "
"are three key function constructors.  See the :ref:`Sorting HOW TO "
"<sortinghowto>` for examples of how to create and use key functions."
msgstr ""
"Существует несколько способов создания ключевой функции. Например. метод :"
"meth:`str.lower` может служить ключевой функцией для сортировок без учета "
"регистра. Альтернативно, ключевая функция может быть построена из выражения :"
"keyword:`lambda`, например ``lambda r: (r[0], r[2])``. Кроме того, :func:"
"`operator.attrgetter`, :func:`operator.itemgetter` и :func:`operator."
"methodcaller` являются тремя ключевыми конструкторами функций. См. :ref:"
"`Sorting HOW TO <sortinghowto>` для примеров того, как создавать и "
"использовать ключевые функции."

#: ../../glossary.rst:769
msgid "keyword argument"
msgstr "argumen kata kunci"

#: ../../glossary.rst:771 ../../glossary.rst:1086
msgid "See :term:`argument`."
msgstr "Zobacz :term:`argument`."

#: ../../glossary.rst:772
msgid "lambda"
msgstr "لاندا"

#: ../../glossary.rst:774
msgid ""
"An anonymous inline function consisting of a single :term:`expression` which "
"is evaluated when the function is called.  The syntax to create a lambda "
"function is ``lambda [parameters]: expression``"
msgstr ""
"Анонімна вбудована функція, що складається з одного :term:`expression`, який "
"обчислюється під час виклику функції. Синтаксис створення лямбда-функції "
"такий: ``лямбда [параметри]: вираз``"

#: ../../glossary.rst:777
msgid "LBYL"
msgstr "LBYL"

#: ../../glossary.rst:779
msgid ""
"Look before you leap.  This coding style explicitly tests for pre-conditions "
"before making calls or lookups.  This style contrasts with the :term:`EAFP` "
"approach and is characterized by the presence of many :keyword:`if` "
"statements."
msgstr ""
"Сім разів відміряй, один раз відріж. Цей стиль кодування явно перевіряє "
"попередні умови перед здійсненням викликів або пошуку. Цей стиль контрастує "
"з підходом :term:`EAFP` і характеризується наявністю багатьох операторів :"
"keyword:`if`."

#: ../../glossary.rst:784
msgid ""
"In a multi-threaded environment, the LBYL approach can risk introducing a "
"race condition between \"the looking\" and \"the leaping\".  For example, "
"the code, ``if key in mapping: return mapping[key]`` can fail if another "
"thread removes *key* from *mapping* after the test, but before the lookup. "
"This issue can be solved with locks or by using the EAFP approach."
msgstr ""
"У багатопоточному середовищі підхід LBYL може загрожувати введенням умов "
"змагання між \"дивлячим\" і \"стрибаючим\". Наприклад, код ``if key in "
"mapping: return mapping[key]`` може завершитися помилкою, якщо інший потік "
"видаляє *key* із *mapping* після перевірки, але перед пошуком. Цю проблему "
"можна вирішити за допомогою блокувань або використання підходу EAFP."

#: ../../glossary.rst:789
msgid "lexical analyzer"
msgstr "лексический анализатор"

#: ../../glossary.rst:792
msgid "Formal name for the *tokenizer*; see :term:`token`."
msgstr "Официальное название для *токенизатора*; см. :term:`token`."

#: ../../glossary.rst:793
msgid "list"
msgstr "سیاهه"

#: ../../glossary.rst:795
msgid ""
"A built-in Python :term:`sequence`.  Despite its name it is more akin to an "
"array in other languages than to a linked list since access to elements is "
"*O*\\ (1)."
msgstr ""
"Встроенный Python :term:`sequence`. Несмотря на свое название, в других "
"языках он больше похож на массив, чем на связанный список, поскольку доступ "
"к элементам осуществляется через *O*\\ (1)."

#: ../../glossary.rst:798
msgid "list comprehension"
msgstr "розуміння списку"

#: ../../glossary.rst:800
msgid ""
"A compact way to process all or part of the elements in a sequence and "
"return a list with the results.  ``result = ['{:#04x}'.format(x) for x in "
"range(256) if x % 2 == 0]`` generates a list of strings containing even hex "
"numbers (0x..) in the range from 0 to 255. The :keyword:`if` clause is "
"optional.  If omitted, all elements in ``range(256)`` are processed."
msgstr ""
"Компактний спосіб обробки всіх або частини елементів у послідовності та "
"повернення списку з результатами. ``result = ['{:#04x}'.format(x) for x in "
"range(256) if x % 2 == 0]`` створює список рядків, що містять парні "
"шістнадцяткові числа (0x..) у діапазон від 0 до 255. Речення :keyword:`if` є "
"необов’язковим. Якщо опущено, обробляються всі елементи в діапазоні (256)."

#: ../../glossary.rst:806
msgid "loader"
msgstr "بار کننده"

#: ../../glossary.rst:808
msgid ""
"An object that loads a module. It must define the :meth:`!exec_module` and :"
"meth:`!create_module` methods to implement the :class:`~importlib.abc."
"Loader` interface. A loader is typically returned by a :term:`finder`. See "
"also:"
msgstr ""
"Объект, загружающий модуль. Он должен определять методы :meth:`!exec_module` "
"и :meth:`!create_module` для реализации интерфейса :class:`~importlib.abc."
"Loader`. Загрузчик обычно возвращается :term:`finder`. См. также:"

#: ../../glossary.rst:814
msgid ":ref:`finders-and-loaders`"
msgstr ":ref:`finders-and-loaders`"

#: ../../glossary.rst:815
msgid ":class:`importlib.abc.Loader`"
msgstr ":class:`importlib.abc.Loader`"

#: ../../glossary.rst:816
msgid ":pep:`302`"
msgstr ":pep:`302`"

#: ../../glossary.rst:817
msgid "locale encoding"
msgstr "кодування локалі"

#: ../../glossary.rst:819
msgid ""
"On Unix, it is the encoding of the LC_CTYPE locale. It can be set with :func:"
"`locale.setlocale(locale.LC_CTYPE, new_locale) <locale.setlocale>`."
msgstr ""
"В Unix это кодировка локали LC_CTYPE. Его можно установить с помощью :func:"
"`locale.setlocale(locale.LC_CTYPE, new_locale) <locale.setlocale>`."

#: ../../glossary.rst:822
msgid "On Windows, it is the ANSI code page (ex: ``\"cp1252\"``)."
msgstr "В Windows это кодовая страница ANSI (например: ``\"cp1252\"``)."

#: ../../glossary.rst:824
msgid ""
"On Android and VxWorks, Python uses ``\"utf-8\"`` as the locale encoding."
msgstr ""
"В Android и VxWorks Python использует «utf-8» в качестве кодировки локали."

#: ../../glossary.rst:826
msgid ":func:`locale.getencoding` can be used to get the locale encoding."
msgstr ""
":func:`locale.getencoding` можно использовать для получения кодировки локали."

#: ../../glossary.rst:828
msgid "See also the :term:`filesystem encoding and error handler`."
msgstr "См. также :term:`кодирование файловой системы и обработчик ошибок`."

#: ../../glossary.rst:829
msgid "magic method"
msgstr "metoda magiczna"

#: ../../glossary.rst:833
msgid "An informal synonym for :term:`special method`."
msgstr "Неофіційний синонім слова :term:`special method`."

#: ../../glossary.rst:834
msgid "mapping"
msgstr "نگاشت"

#: ../../glossary.rst:836
msgid ""
"A container object that supports arbitrary key lookups and implements the "
"methods specified in the :class:`collections.abc.Mapping` or :class:"
"`collections.abc.MutableMapping` :ref:`abstract base classes <collections-"
"abstract-base-classes>`.  Examples include :class:`dict`, :class:"
"`collections.defaultdict`, :class:`collections.OrderedDict` and :class:"
"`collections.Counter`."
msgstr ""
"Объект-контейнер, который поддерживает поиск по произвольным ключам и "
"реализует методы, указанные в :class:`collections.abc.Mapping` или :class:"
"`collections.abc.MutableMapping` :ref:`abstract базовых классах <collections-"
"abstract-base- классы>`. Примеры: :class:`dict`, :class:`collections."
"defaultdict`, :class:`collections.OrderedDict` и :class:`collections."
"Counter`."

#: ../../glossary.rst:842
msgid "meta path finder"
msgstr "мета-шлях пошуку"

#: ../../glossary.rst:844
msgid ""
"A :term:`finder` returned by a search of :data:`sys.meta_path`.  Meta path "
"finders are related to, but different from :term:`path entry finders <path "
"entry finder>`."
msgstr ""
":term:`finder`, що повертається в результаті пошуку :data:`sys.meta_path`. "
"Засоби пошуку меташляхів пов’язані з :term:`засобами пошуку записів шляху "
"<path entry finder>`, але відрізняються від них."

#: ../../glossary.rst:848
msgid ""
"See :class:`importlib.abc.MetaPathFinder` for the methods that meta path "
"finders implement."
msgstr ""
"Перегляньте :class:`importlib.abc.MetaPathFinder` методи, які реалізують "
"засоби пошуку меташляхів."

#: ../../glossary.rst:850
msgid "metaclass"
msgstr "ابرکلاس"

#: ../../glossary.rst:852
msgid ""
"The class of a class.  Class definitions create a class name, a class "
"dictionary, and a list of base classes.  The metaclass is responsible for "
"taking those three arguments and creating the class.  Most object oriented "
"programming languages provide a default implementation.  What makes Python "
"special is that it is possible to create custom metaclasses.  Most users "
"never need this tool, but when the need arises, metaclasses can provide "
"powerful, elegant solutions.  They have been used for logging attribute "
"access, adding thread-safety, tracking object creation, implementing "
"singletons, and many other tasks."
msgstr ""
"Клас класу. Визначення класу створюють назву класу, словник класу та список "
"базових класів. Метаклас відповідає за отримання цих трьох аргументів і "
"створення класу. Більшість об'єктно-орієнтованих мов програмування "
"забезпечують реалізацію за замовчуванням. Що робить Python особливим, так це "
"те, що можна створювати власні метакласи. Більшості користувачів цей "
"інструмент ніколи не потрібен, але коли виникає потреба, метакласи можуть "
"надати потужні та елегантні рішення. Вони використовувалися для реєстрації "
"доступу до атрибутів, додавання потокової безпеки, відстеження створення "
"об’єктів, реалізації одиночних елементів і багатьох інших завдань."

#: ../../glossary.rst:862
msgid "More information can be found in :ref:`metaclasses`."
msgstr "Informasi lebih lanjut dapat ditemukan di :ref:`metaclasses`."

#: ../../glossary.rst:831 ../../glossary.rst:863 ../../glossary.rst:1236
msgid "method"
msgstr "روش"

#: ../../glossary.rst:865
msgid ""
"A function which is defined inside a class body.  If called as an attribute "
"of an instance of that class, the method will get the instance object as its "
"first :term:`argument` (which is usually called ``self``). See :term:"
"`function` and :term:`nested scope`."
msgstr ""
"Функція, яка визначена всередині тіла класу. Якщо викликати його як атрибут "
"примірника цього класу, метод отримає об’єкт примірника як свій перший :term:"
"`argument` (який зазвичай називається ``self``). Див. :term:`function` і :"
"term:`nested scope`."

#: ../../glossary.rst:869
msgid "method resolution order"
msgstr "порядок вирішення методу"

#: ../../glossary.rst:871
msgid ""
"Method Resolution Order is the order in which base classes are searched for "
"a member during lookup. See :ref:`python_2.3_mro` for details of the "
"algorithm used by the Python interpreter since the 2.3 release."
msgstr ""
"Порядок разрешения метода — это порядок, в котором базовые классы ищут член "
"во время поиска. См. :ref:`python_2.3_mro` для получения подробной "
"информации об алгоритме, используемом интерпретатором Python начиная с "
"версии 2.3."

#: ../../glossary.rst:874
msgid "module"
msgstr "پیمانه"

#: ../../glossary.rst:876
msgid ""
"An object that serves as an organizational unit of Python code.  Modules "
"have a namespace containing arbitrary Python objects.  Modules are loaded "
"into Python by the process of :term:`importing`."
msgstr ""
"Об’єкт, який є організаційною одиницею коду Python. Модулі мають простір "
"імен, що містить довільні об’єкти Python. Модулі завантажуються в Python за "
"допомогою процесу :term:`importing`."

#: ../../glossary.rst:880
msgid "See also :term:`package`."
msgstr "Lihat juga :term:`package`."

#: ../../glossary.rst:881
msgid "module spec"
msgstr "модуль спец"

#: ../../glossary.rst:883
msgid ""
"A namespace containing the import-related information used to load a module. "
"An instance of :class:`importlib.machinery.ModuleSpec`."
msgstr ""
"Простір імен, що містить пов’язану з імпортом інформацію, яка "
"використовується для завантаження модуля. Екземпляр :class:`importlib."
"machinery.ModuleSpec`."

#: ../../glossary.rst:886
msgid "See also :ref:`module-specs`."
msgstr "См. также :ref:`module-specs`."

#: ../../glossary.rst:887
msgid "MRO"
msgstr "MRO"

#: ../../glossary.rst:889
msgid "See :term:`method resolution order`."
msgstr "Lihat :term:`method resolution order`."

#: ../../glossary.rst:890
msgid "mutable"
msgstr "تغییرپذیر"

#: ../../glossary.rst:892
msgid ""
"Mutable objects can change their value but keep their :func:`id`.  See also :"
"term:`immutable`."
msgstr ""
"Змінні об’єкти можуть змінювати своє значення, але зберігають свій :func:"
"`id`. Дивіться також :term:`immutable`."

#: ../../glossary.rst:894
msgid "named tuple"
msgstr "nazwana krotka"

#: ../../glossary.rst:896
msgid ""
"The term \"named tuple\" applies to any type or class that inherits from "
"tuple and whose indexable elements are also accessible using named "
"attributes.  The type or class may have other features as well."
msgstr ""
"Термін \"іменований кортеж\" застосовується до будь-якого типу або класу, "
"який успадковує кортеж і чиї індексовані елементи також доступні за "
"допомогою іменованих атрибутів. Тип або клас також можуть мати інші "
"особливості."

#: ../../glossary.rst:900
msgid ""
"Several built-in types are named tuples, including the values returned by :"
"func:`time.localtime` and :func:`os.stat`.  Another example is :data:`sys."
"float_info`::"
msgstr ""
"Кілька вбудованих типів є іменованими кортежами, включаючи значення, що "
"повертаються :func:`time.localtime` і :func:`os.stat`. Інший приклад: :data:"
"`sys.float_info`::"

#: ../../glossary.rst:904
msgid ""
">>> sys.float_info[1]                   # indexed access\n"
"1024\n"
">>> sys.float_info.max_exp              # named field access\n"
"1024\n"
">>> isinstance(sys.float_info, tuple)   # kind of tuple\n"
"True"
msgstr ""
">>> sys.float_info[1]                   # indexed access\n"
"1024\n"
">>> sys.float_info.max_exp              # named field access\n"
"1024\n"
">>> isinstance(sys.float_info, tuple)   # kind of tuple\n"
"True"

#: ../../glossary.rst:911
msgid ""
"Some named tuples are built-in types (such as the above examples). "
"Alternatively, a named tuple can be created from a regular class definition "
"that inherits from :class:`tuple` and that defines named fields.  Such a "
"class can be written by hand, or it can be created by inheriting :class:"
"`typing.NamedTuple`, or with the factory function :func:`collections."
"namedtuple`.  The latter techniques also add some extra methods that may not "
"be found in hand-written or built-in named tuples."
msgstr ""
"Некоторые именованные кортежи являются встроенными типами (например, "
"приведенные выше примеры). В качестве альтернативы именованный кортеж можно "
"создать из определения обычного класса, который наследуется от :class:"
"`tuple` и определяет именованные поля. Такой класс можно написать вручную "
"или создать путем наследования :class:`typing.NamedTuple` или с помощью "
"фабричной функции :func:`collections.namedtuple`. Последние методы также "
"добавляют некоторые дополнительные методы, которых нет в рукописных или "
"встроенных именованных кортежах."

#: ../../glossary.rst:919
msgid "namespace"
msgstr "فضانام"

#: ../../glossary.rst:921
msgid ""
"The place where a variable is stored.  Namespaces are implemented as "
"dictionaries.  There are the local, global and built-in namespaces as well "
"as nested namespaces in objects (in methods).  Namespaces support modularity "
"by preventing naming conflicts.  For instance, the functions :func:`builtins."
"open <.open>` and :func:`os.open` are distinguished by their namespaces.  "
"Namespaces also aid readability and maintainability by making it clear which "
"module implements a function.  For instance, writing :func:`random.seed` or :"
"func:`itertools.islice` makes it clear that those functions are implemented "
"by the :mod:`random` and :mod:`itertools` modules, respectively."
msgstr ""
"Місце, де зберігається змінна. Простори імен реалізовані як словники. "
"Існують локальні, глобальні та вбудовані простори імен, а також вкладені "
"простори імен в об’єктах (у методах). Простори імен підтримують модульність, "
"запобігаючи конфліктам імен. Наприклад, функції :func:`builtins.open <."
"open>` і :func:`os.open` відрізняються своїми просторами імен. Простори імен "
"також сприяють читабельності та зручності обслуговування, пояснюючи, який "
"модуль реалізує функцію. Наприклад, написання :func:`random.seed` або :func:"
"`itertools.islice` дає зрозуміти, що ці функції реалізовані модулями :mod:"
"`random` і :mod:`itertools` відповідно."

#: ../../glossary.rst:931
msgid "namespace package"
msgstr "пакет простору імен"

#: ../../glossary.rst:933
msgid ""
"A :term:`package` which serves only as a container for subpackages. "
"Namespace packages may have no physical representation, and specifically are "
"not like a :term:`regular package` because they have no ``__init__.py`` file."
msgstr ""
"Пакет :term:`package`, который служит только как контейнер для подпакетов. "
"Пакеты пространства имен могут не иметь физического представления и, в "
"частности, не похожи на :term:`regular package`, поскольку у них нет файла "
"``__init__.py``."

#: ../../glossary.rst:938
msgid ""
"Namespace packages allow several individually installable packages to have a "
"common parent package. Otherwise, it is recommended to use a :term:`regular "
"package`."
msgstr ""
"Пакеты пространства имен позволяют нескольким индивидуально устанавливаемым "
"пакетам иметь общий родительский пакет. В противном случае рекомендуется "
"использовать :term:`regular package`."

#: ../../glossary.rst:941
msgid ""
"For more information, see :pep:`420` and :ref:`reference-namespace-package`."
msgstr ""
"Для получения дополнительной информации см. :pep:`420` и :ref:`reference-"
"namespace-package`."

#: ../../glossary.rst:943
msgid "See also :term:`module`."
msgstr "Lihat juga :term:`module`."

#: ../../glossary.rst:944
msgid "nested scope"
msgstr "вкладена область"

#: ../../glossary.rst:946
msgid ""
"The ability to refer to a variable in an enclosing definition.  For "
"instance, a function defined inside another function can refer to variables "
"in the outer function.  Note that nested scopes by default work only for "
"reference and not for assignment.  Local variables both read and write in "
"the innermost scope.  Likewise, global variables read and write to the "
"global namespace.  The :keyword:`nonlocal` allows writing to outer scopes."
msgstr ""
"Можливість посилатися на змінну в охоплюючому визначенні. Наприклад, "
"функція, визначена всередині іншої функції, може посилатися на змінні у "
"зовнішній функції. Зауважте, що вкладені області за замовчуванням працюють "
"лише для довідки, а не для призначення. Локальні змінні читають і записують "
"у внутрішній області видимості. Так само глобальні змінні читають і "
"записують у глобальний простір імен. :keyword:`nonlocal` дозволяє писати у "
"зовнішні області."

#: ../../glossary.rst:953
msgid "new-style class"
msgstr "клас нового стилю"

#: ../../glossary.rst:955
msgid ""
"Old name for the flavor of classes now used for all class objects.  In "
"earlier Python versions, only new-style classes could use Python's newer, "
"versatile features like :attr:`~object.__slots__`, descriptors, properties, :"
"meth:`~object.__getattribute__`, class methods, and static methods."
msgstr ""
"Старое название разновидности классов теперь используется для всех объектов "
"классов. В более ранних версиях Python только классы нового стиля могли "
"использовать новые универсальные функции Python, такие как :attr:`~object."
"__slots__`, дескрипторы, свойства, :meth:`~object.__getattribute__`, методы "
"класса и статические методы."

#: ../../glossary.rst:960
msgid "object"
msgstr "شی"

#: ../../glossary.rst:962
msgid ""
"Any data with state (attributes or value) and defined behavior (methods).  "
"Also the ultimate base class of any :term:`new-style class`."
msgstr ""
"Будь-які дані зі станом (атрибути або значення) і визначеною поведінкою "
"(методи). Також остаточний базовий клас будь-якого :term:`new-style class`."

#: ../../glossary.rst:965
msgid "optimized scope"
msgstr "оптимизированный объем"

#: ../../glossary.rst:967
msgid ""
"A scope where target local variable names are reliably known to the compiler "
"when the code is compiled, allowing optimization of read and write access to "
"these names. The local namespaces for functions, generators, coroutines, "
"comprehensions, and generator expressions are optimized in this fashion. "
"Note: most interpreter optimizations are applied to all scopes, only those "
"relying on a known set of local and nonlocal variable names are restricted "
"to optimized scopes."
msgstr ""
"Область, в которой имена целевых локальных переменных надежно известны "
"компилятору при компиляции кода, что позволяет оптимизировать доступ для "
"чтения и записи к этим именам. Таким образом оптимизируются локальные "
"пространства имен для функций, генераторов, сопрограмм, понятий и выражений "
"генераторов. Примечание. Большинство оптимизаций интерпретатора применяются "
"ко всем областям, только те, которые полагаются на известный набор имен "
"локальных и нелокальных переменных, ограничены оптимизированными областями."

#: ../../glossary.rst:974
msgid "package"
msgstr "بسته"

#: ../../glossary.rst:976
msgid ""
"A Python :term:`module` which can contain submodules or recursively, "
"subpackages.  Technically, a package is a Python module with a ``__path__`` "
"attribute."
msgstr ""
":term:`модуль` Python, що може містити підмодулі чи, рекурсивно, підпакети. "
"З технічного боку, пакет є модулем Python з атрибутом ``__path__``."

#: ../../glossary.rst:980
msgid "See also :term:`regular package` and :term:`namespace package`."
msgstr "Дивіться також :term:`regular package` і :term:`namespace package`."

#: ../../glossary.rst:981
msgid "parameter"
msgstr "پارامتر"

#: ../../glossary.rst:983
msgid ""
"A named entity in a :term:`function` (or method) definition that specifies "
"an :term:`argument` (or in some cases, arguments) that the function can "
"accept.  There are five kinds of parameter:"
msgstr ""
"Іменована сутність у визначенні :term:`function` (або методу), яка визначає :"
"term:`argument` (або в деяких випадках аргументи), які функція може "
"прийняти. Є п'ять типів параметрів:"

#: ../../glossary.rst:987
msgid ""
":dfn:`positional-or-keyword`: specifies an argument that can be passed "
"either :term:`positionally <argument>` or as a :term:`keyword argument "
"<argument>`.  This is the default kind of parameter, for example *foo* and "
"*bar* in the following::"
msgstr ""
":dfn:`positional-or-keyword`: визначає аргумент, який можна передати :term:"
"`позиційно <argument>` або як :term:`аргумент ключового слова <argument>`. "
"Це тип параметра за замовчуванням, наприклад *foo* і *bar* у наступному::"

#: ../../glossary.rst:992
msgid "def func(foo, bar=None): ..."
msgstr "def func(foo, bar=None): ..."

#: ../../glossary.rst:996
msgid ""
":dfn:`positional-only`: specifies an argument that can be supplied only by "
"position. Positional-only parameters can be defined by including a ``/`` "
"character in the parameter list of the function definition after them, for "
"example *posonly1* and *posonly2* in the following::"
msgstr ""
":dfn:`positional-only`: визначає аргумент, який можна надати лише за "
"позицією. Лише позиційні параметри можна визначити, включивши символ ``/`` у "
"список параметрів визначення функції після них, наприклад *posonly1* і "
"*posonly2* у наступному::"

#: ../../glossary.rst:1001
msgid "def func(posonly1, posonly2, /, positional_or_keyword): ..."
msgstr "def func(posonly1, posonly2, /, positional_or_keyword): ..."

#: ../../glossary.rst:1005
msgid ""
":dfn:`keyword-only`: specifies an argument that can be supplied only by "
"keyword.  Keyword-only parameters can be defined by including a single var-"
"positional parameter or bare ``*`` in the parameter list of the function "
"definition before them, for example *kw_only1* and *kw_only2* in the "
"following::"
msgstr ""
":dfn:`keyword-only`: визначає аргумент, який можна надати лише за ключовим "
"словом. Параметри, що містять лише ключове слово, можна визначити, включивши "
"один змінний позиційний параметр або голий ``*`` у список параметрів "
"визначення функції перед ними, наприклад *kw_only1* і *kw_only2* у "
"наступному:"

#: ../../glossary.rst:1011
msgid "def func(arg, *, kw_only1, kw_only2): ..."
msgstr "def func(arg, *, kw_only1, kw_only2): ..."

#: ../../glossary.rst:1013
msgid ""
":dfn:`var-positional`: specifies that an arbitrary sequence of positional "
"arguments can be provided (in addition to any positional arguments already "
"accepted by other parameters).  Such a parameter can be defined by "
"prepending the parameter name with ``*``, for example *args* in the "
"following::"
msgstr ""
":dfn:`var-positional`: вказує, що можна надати довільну послідовність "
"позиційних аргументів (на додаток до будь-яких позиційних аргументів, уже "
"прийнятих іншими параметрами). Такий параметр можна визначити, додавши перед "
"назвою параметра ``*``, наприклад *args* у наступному::"

#: ../../glossary.rst:1019
msgid "def func(*args, **kwargs): ..."
msgstr "def func(*args, **kwargs): ..."

#: ../../glossary.rst:1021
msgid ""
":dfn:`var-keyword`: specifies that arbitrarily many keyword arguments can be "
"provided (in addition to any keyword arguments already accepted by other "
"parameters).  Such a parameter can be defined by prepending the parameter "
"name with ``**``, for example *kwargs* in the example above."
msgstr ""
":dfn:`var-keyword`: вказує, що можна надати довільну кількість аргументів "
"ключових слів (на додаток до будь-яких аргументів ключових слів, які вже "
"прийняті іншими параметрами). Такий параметр можна визначити, додавши перед "
"назвою параметра ``**``, наприклад *kwargs* у прикладі вище."

#: ../../glossary.rst:1027
msgid ""
"Parameters can specify both optional and required arguments, as well as "
"default values for some optional arguments."
msgstr ""
"Параметри можуть вказувати як необов’язкові, так і обов’язкові аргументи, а "
"також значення за умовчанням для деяких необов’язкових аргументів."

#: ../../glossary.rst:1030
msgid ""
"See also the :term:`argument` glossary entry, the FAQ question on :ref:`the "
"difference between arguments and parameters <faq-argument-vs-parameter>`, "
"the :class:`inspect.Parameter` class, the :ref:`function` section, and :pep:"
"`362`."
msgstr ""
"Дивіться також :term:`argument` глосарій, питання FAQ про :ref:`різницю між "
"аргументами та параметрами <faq-argument-vs-parameter>`, :class:`inspect."
"Parameter` клас, :ref:`function` розділ та :pep:`362`."

#: ../../glossary.rst:1034
msgid "path entry"
msgstr "запис шляху"

#: ../../glossary.rst:1036
msgid ""
"A single location on the :term:`import path` which the :term:`path based "
"finder` consults to find modules for importing."
msgstr ""
"Єдине розташування на :term:`import path`, до якого :term:`path based "
"finder` звертається, щоб знайти модулі для імпорту."

#: ../../glossary.rst:1038
msgid "path entry finder"
msgstr "шукач запису шляху"

#: ../../glossary.rst:1040
msgid ""
"A :term:`finder` returned by a callable on :data:`sys.path_hooks` (i.e. a :"
"term:`path entry hook`) which knows how to locate modules given a :term:"
"`path entry`."
msgstr ""
":term:`finder`, що повертається викликом на :data:`sys.path_hooks` (тобто :"
"term:`path entry hook`), який знає, як знаходити модулі за допомогою :term:"
"`path entry`."

#: ../../glossary.rst:1044
msgid ""
"See :class:`importlib.abc.PathEntryFinder` for the methods that path entry "
"finders implement."
msgstr ""
"Перегляньте :class:`importlib.abc.PathEntryFinder` методи, які реалізують "
"засоби пошуку запису шляху."

#: ../../glossary.rst:1046
msgid "path entry hook"
msgstr "гачок входу шляху"

#: ../../glossary.rst:1048
msgid ""
"A callable on the :data:`sys.path_hooks` list which returns a :term:`path "
"entry finder` if it knows how to find modules on a specific :term:`path "
"entry`."
msgstr ""
"Вызываемая функция в списке :data:`sys.path_hooks``, которая возвращает :"
"term:`path entry finder` если он знает, как найти модули по определенной :"
"term:`записи пути`. "

#: ../../glossary.rst:1051
msgid "path based finder"
msgstr "пошук на основі шляху"

#: ../../glossary.rst:1053
msgid ""
"One of the default :term:`meta path finders <meta path finder>` which "
"searches an :term:`import path` for modules."
msgstr ""
"Один із стандартних :term:`мета-шляхів пошуку <meta path finder>`, який "
"шукає :term:`import path` для модулів."

#: ../../glossary.rst:1055
msgid "path-like object"
msgstr "шляхоподібний об’єкт"

#: ../../glossary.rst:1057
msgid ""
"An object representing a file system path. A path-like object is either a :"
"class:`str` or :class:`bytes` object representing a path, or an object "
"implementing the :class:`os.PathLike` protocol. An object that supports the :"
"class:`os.PathLike` protocol can be converted to a :class:`str` or :class:"
"`bytes` file system path by calling the :func:`os.fspath` function; :func:"
"`os.fsdecode` and :func:`os.fsencode` can be used to guarantee a :class:"
"`str` or :class:`bytes` result instead, respectively. Introduced by :pep:"
"`519`."
msgstr ""
"Об'єкт, що представляє шлях до файлової системи. Шляховий об’єкт – це або :"
"class:`str`, або :class:`bytes` об’єкт, що представляє шлях, або об’єкт, що "
"реалізує протокол :class:`os.PathLike`. Об’єкт, який підтримує протокол :"
"class:`os.PathLike`, можна перетворити на шлях файлової системи :class:`str` "
"або :class:`bytes` шляхом виклику функції :func:`os.fspath`; :func:`os."
"fsdecode` і :func:`os.fsencode` можна використовувати, щоб гарантувати "
"результат :class:`str` або :class:`bytes` відповідно. Представлений :pep:"
"`519`."

#: ../../glossary.rst:1065
msgid "PEP"
msgstr "PEP"

#: ../../glossary.rst:1067
msgid ""
"Python Enhancement Proposal. A PEP is a design document providing "
"information to the Python community, or describing a new feature for Python "
"or its processes or environment. PEPs should provide a concise technical "
"specification and a rationale for proposed features."
msgstr ""
"Пропозиція вдосконалення Python. PEP — це проектний документ, який надає "
"інформацію спільноті Python або описує нову функцію для Python або його "
"процеси чи середовище. Публічні діячі повинні надавати стислу технічну "
"специфікацію та обґрунтування запропонованих функцій."

#: ../../glossary.rst:1073
msgid ""
"PEPs are intended to be the primary mechanisms for proposing major new "
"features, for collecting community input on an issue, and for documenting "
"the design decisions that have gone into Python. The PEP author is "
"responsible for building consensus within the community and documenting "
"dissenting opinions."
msgstr ""
"PEP мають бути основними механізмами для пропонування основних нових "
"функцій, для збору інформації спільноти щодо проблеми та для документування "
"проектних рішень, які увійшли в Python. Автор PEP відповідає за формування "
"консенсусу в спільноті та документування особливих думок."

#: ../../glossary.rst:1079
msgid "See :pep:`1`."
msgstr "Zob. :pep:`1`."

#: ../../glossary.rst:1080
msgid "portion"
msgstr "część"

#: ../../glossary.rst:1082
msgid ""
"A set of files in a single directory (possibly stored in a zip file) that "
"contribute to a namespace package, as defined in :pep:`420`."
msgstr ""
"Набір файлів в одному каталозі (можливо, збережених у файлі zip), які "
"входять до пакету простору імен, як визначено в :pep:`420`."

#: ../../glossary.rst:1084
msgid "positional argument"
msgstr "позиційний аргумент"

#: ../../glossary.rst:1087
msgid "provisional API"
msgstr "тимчасовий API"

#: ../../glossary.rst:1089
msgid ""
"A provisional API is one which has been deliberately excluded from the "
"standard library's backwards compatibility guarantees.  While major changes "
"to such interfaces are not expected, as long as they are marked provisional, "
"backwards incompatible changes (up to and including removal of the "
"interface) may occur if deemed necessary by core developers.  Such changes "
"will not be made gratuitously -- they will occur only if serious fundamental "
"flaws are uncovered that were missed prior to the inclusion of the API."
msgstr ""
"Попередній API — це той, який був навмисно виключений із гарантій зворотної "
"сумісності стандартної бібліотеки. Хоча суттєвих змін у таких інтерфейсах не "
"очікується, доки вони позначені як тимчасові, зворотні несумісні зміни (аж "
"до видалення інтерфейсу включно) можуть відбутися, якщо розробники ядра "
"вважають це за потрібне. Такі зміни не будуть внесені безоплатно — вони "
"відбудуться лише за умови виявлення серйозних фундаментальних недоліків, які "
"були пропущені до включення API."

#: ../../glossary.rst:1098
msgid ""
"Even for provisional APIs, backwards incompatible changes are seen as a "
"\"solution of last resort\" - every attempt will still be made to find a "
"backwards compatible resolution to any identified problems."
msgstr ""
"Навіть для тимчасових API зворотні несумісні зміни розглядаються як "
"\"вирішення останньої інстанції\" — все одно будуть зроблені всі спроби "
"знайти зворотно сумісне вирішення будь-яких виявлених проблем."

#: ../../glossary.rst:1102
msgid ""
"This process allows the standard library to continue to evolve over time, "
"without locking in problematic design errors for extended periods of time.  "
"See :pep:`411` for more details."
msgstr ""
"Цей процес дозволяє стандартній бібліотеці продовжувати розвиватися з часом, "
"не блокуючи проблемні помилки проектування протягом тривалих періодів часу. "
"Дивіться :pep:`411` для більш детальної інформації."

#: ../../glossary.rst:1105
msgid "provisional package"
msgstr "тимчасовий пакет"

#: ../../glossary.rst:1107
msgid "See :term:`provisional API`."
msgstr "Lihat :term:`provisional API`."

#: ../../glossary.rst:1108
msgid "Python 3000"
msgstr "Python 3000"

#: ../../glossary.rst:1110
msgid ""
"Nickname for the Python 3.x release line (coined long ago when the release "
"of version 3 was something in the distant future.)  This is also abbreviated "
"\"Py3k\"."
msgstr ""
"Псевдонім для рядка випусків Python 3.x (придуманий давно, коли випуск "
"версії 3 був чимось у віддаленому майбутньому). Це також скорочено \"Py3k\"."

#: ../../glossary.rst:1113
msgid "Pythonic"
msgstr "پایتونی"

#: ../../glossary.rst:1115
msgid ""
"An idea or piece of code which closely follows the most common idioms of the "
"Python language, rather than implementing code using concepts common to "
"other languages.  For example, a common idiom in Python is to loop over all "
"elements of an iterable using a :keyword:`for` statement.  Many other "
"languages don't have this type of construct, so people unfamiliar with "
"Python sometimes use a numerical counter instead::"
msgstr ""
"Ідея або фрагмент коду, який точно відповідає найпоширенішим ідіомам мови "
"Python, а не реалізує код за допомогою концепцій, спільних для інших мов. "
"Наприклад, поширена ідіома в Python полягає в тому, щоб перебирати всі "
"елементи ітерованого за допомогою оператора :keyword:`for`. Багато інших мов "
"не мають такого типу конструкції, тому люди, які не знайомі з Python, іноді "
"замість цього використовують числовий лічильник::"

#: ../../glossary.rst:1122
msgid ""
"for i in range(len(food)):\n"
"    print(food[i])"
msgstr ""
"for i in range(len(food)):\n"
"    print(food[i])"

#: ../../glossary.rst:1125
msgid "As opposed to the cleaner, Pythonic method::"
msgstr "На відміну від очищувача, метод Pythonic::"

#: ../../glossary.rst:1127
msgid ""
"for piece in food:\n"
"    print(piece)"
msgstr ""
"for piece in food:\n"
"    print(piece)"

#: ../../glossary.rst:1129
msgid "qualified name"
msgstr "nama yang memenuhi syarat"

#: ../../glossary.rst:1131
msgid ""
"A dotted name showing the \"path\" from a module's global scope to a class, "
"function or method defined in that module, as defined in :pep:`3155`.  For "
"top-level functions and classes, the qualified name is the same as the "
"object's name::"
msgstr ""
"Назва з крапками, що вказує \"шлях\" від глобальної області видимості модуля "
"до класу, функції або методу, визначеного в цьому модулі, як визначено в :"
"pep:`3155`. Для функцій і класів верхнього рівня кваліфіковане ім’я "
"збігається з ім’ям об’єкта::"

#: ../../glossary.rst:1136
msgid ""
">>> class C:\n"
"...     class D:\n"
"...         def meth(self):\n"
"...             pass\n"
"...\n"
">>> C.__qualname__\n"
"'C'\n"
">>> C.D.__qualname__\n"
"'C.D'\n"
">>> C.D.meth.__qualname__\n"
"'C.D.meth'"
msgstr ""
">>> class C:\n"
"...     class D:\n"
"...         def meth(self):\n"
"...             pass\n"
"...\n"
">>> C.__qualname__\n"
"'C'\n"
">>> C.D.__qualname__\n"
"'C.D'\n"
">>> C.D.meth.__qualname__\n"
"'C.D.meth'"

#: ../../glossary.rst:1148
msgid ""
"When used to refer to modules, the *fully qualified name* means the entire "
"dotted path to the module, including any parent packages, e.g. ``email.mime."
"text``::"
msgstr ""
"Коли використовується для позначення модулів, *повне ім’я* означає весь шлях "
"до модуля, розділений крапками, включаючи будь-які батьківські пакети, напр. "
"``email.mime.text``::"

#: ../../glossary.rst:1152
msgid ""
">>> import email.mime.text\n"
">>> email.mime.text.__name__\n"
"'email.mime.text'"
msgstr ""
">>> import email.mime.text\n"
">>> email.mime.text.__name__\n"
"'email.mime.text'"

#: ../../glossary.rst:1155
msgid "reference count"
msgstr "jumlah referensi"

#: ../../glossary.rst:1157
msgid ""
"The number of references to an object.  When the reference count of an "
"object drops to zero, it is deallocated.  Some objects are :term:`immortal` "
"and have reference counts that are never modified, and therefore the objects "
"are never deallocated.  Reference counting is generally not visible to "
"Python code, but it is a key element of the :term:`CPython` implementation.  "
"Programmers can call the :func:`sys.getrefcount` function to return the "
"reference count for a particular object."
msgstr ""
"Количество ссылок на объект. Когда счетчик ссылок объекта падает до нуля, он "
"освобождается. Некоторые объекты являются :term:`бессмертными` и имеют "
"счетчики ссылок, которые никогда не изменяются, и поэтому объекты никогда не "
"освобождаются. Подсчет ссылок обычно не виден коду Python, но он является "
"ключевым элементом реализации :term:`CPython`. Программисты могут вызвать "
"функцию :func:`sys.getrefcount`, чтобы вернуть счетчик ссылок для "
"определенного объекта."

#: ../../glossary.rst:1166
msgid ""
"In :term:`CPython`, reference counts are not considered to be stable or well-"
"defined values; the number of references to an object, and how that number "
"is affected by Python code, may be different between versions."
msgstr ""

#: ../../glossary.rst:1170
msgid "regular package"
msgstr "paket biasa"

#: ../../glossary.rst:1172
msgid ""
"A traditional :term:`package`, such as a directory containing an ``__init__."
"py`` file."
msgstr ""
"Традиційний :term:`package`, як-от каталог, що містить файл ``__init__.py``."

#: ../../glossary.rst:1175
msgid "See also :term:`namespace package`."
msgstr "Lihat juga :term:`namespace package`."

#: ../../glossary.rst:1176
msgid "REPL"
msgstr "REPL"

#: ../../glossary.rst:1178
msgid ""
"An acronym for the \"read–eval–print loop\", another name for the :term:"
"`interactive` interpreter shell."
msgstr ""
"Акронім від \"read–eval–print loop\" (цикл читання-обчислення-вивід), інша "
"назва для :term:`інтерактивної` оболонки інтерпретатора."

#: ../../glossary.rst:1180
msgid "__slots__"
msgstr "__slots__"

#: ../../glossary.rst:1182
msgid ""
"A declaration inside a class that saves memory by pre-declaring space for "
"instance attributes and eliminating instance dictionaries.  Though popular, "
"the technique is somewhat tricky to get right and is best reserved for rare "
"cases where there are large numbers of instances in a memory-critical "
"application."
msgstr ""
"Оголошення всередині класу, яке економить пам’ять шляхом попереднього "
"оголошення місця для атрибутів екземпляра та видалення словників "
"екземплярів. Незважаючи на те, що ця техніка популярна, її дещо складно "
"застосувати, і її найкраще використовувати для рідкісних випадків, коли в "
"програмі, критичній до пам’яті, є велика кількість екземплярів."

#: ../../glossary.rst:1187
msgid "sequence"
msgstr "دنباله"

#: ../../glossary.rst:1189
msgid ""
"An :term:`iterable` which supports efficient element access using integer "
"indices via the :meth:`~object.__getitem__` special method and defines a :"
"meth:`~object.__len__` method that returns the length of the sequence. Some "
"built-in sequence types are :class:`list`, :class:`str`, :class:`tuple`, "
"and :class:`bytes`. Note that :class:`dict` also supports :meth:`~object."
"__getitem__` and :meth:`!__len__`, but is considered a mapping rather than a "
"sequence because the lookups use arbitrary :term:`hashable` keys rather than "
"integers."
msgstr ""
":term:`iterable`, который поддерживает эффективный доступ к элементам с "
"использованием целочисленных индексов через специальный метод :meth:`~object."
"__getitem__` и определяет метод :meth:`~object.__len__`, который возвращает "
"длину последовательности. Некоторые встроенные типы последовательностей: :"
"class:`list`, :class:`str`, :class:`tuple` и :class:`bytes`. Обратите "
"внимание, что :class:`dict` также поддерживает :meth:`~object.__getitem__` "
"и :meth:`!__len__`, но считается отображением, а не последовательностью, "
"поскольку при поиске используются произвольные :term:`hashable` ключи. чем "
"целые числа."

#: ../../glossary.rst:1198
msgid ""
"The :class:`collections.abc.Sequence` abstract base class defines a much "
"richer interface that goes beyond just :meth:`~object.__getitem__` and :meth:"
"`~object.__len__`, adding :meth:`!count`, :meth:`!index`, :meth:`~object."
"__contains__`, and :meth:`~object.__reversed__`. Types that implement this "
"expanded interface can be registered explicitly using :func:`~abc.ABCMeta."
"register`. For more documentation on sequence methods generally, see :ref:"
"`Common Sequence Operations <typesseq-common>`."
msgstr ""
"Абстрактный базовый класс :class:`collections.abc.Sequence` определяет "
"гораздо более богатый интерфейс, который выходит за рамки просто :meth:"
"`~object.__getitem__` и :meth:`~object.__len__`, добавляя :meth:`!count `, :"
"meth:`!index`, :meth:`~object.__contains__` и :meth:`~object.__reversed__`. "
"Типы, реализующие этот расширенный интерфейс, могут быть зарегистрированы "
"явно с помощью :func:`~abc.ABCMeta.register`. Дополнительную документацию по "
"методам последовательности см. в разделе «Общие операции с "
"последовательностями <typesseq-common>»."

#: ../../glossary.rst:1207
msgid "set comprehension"
msgstr "встановити розуміння"

#: ../../glossary.rst:1209
msgid ""
"A compact way to process all or part of the elements in an iterable and "
"return a set with the results. ``results = {c for c in 'abracadabra' if c "
"not in 'abc'}`` generates the set of strings ``{'r', 'd'}``.  See :ref:"
"`comprehensions`."
msgstr ""
"Компактний спосіб обробки всіх або частини елементів у ітерації та "
"повернення набору з результатами. ``results = {c for c in 'abracadabra' if c "
"not in 'abc'}`` генерує набір рядків ``{'r', 'd'}``. Дивіться :ref:"
"`comprehensions`."

#: ../../glossary.rst:1213
msgid "single dispatch"
msgstr "єдина відправка"

#: ../../glossary.rst:1215
msgid ""
"A form of :term:`generic function` dispatch where the implementation is "
"chosen based on the type of a single argument."
msgstr ""
"Форма відправки :term:`generic function`, де реалізація вибирається на "
"основі типу одного аргументу."

#: ../../glossary.rst:1217
msgid "slice"
msgstr "برش"

#: ../../glossary.rst:1219
msgid ""
"An object usually containing a portion of a :term:`sequence`.  A slice is "
"created using the subscript notation, ``[]`` with colons between numbers "
"when several are given, such as in ``variable_name[1:3:5]``.  The bracket "
"(subscript) notation uses :class:`slice` objects internally."
msgstr ""
"Об’єкт, який зазвичай містить частину :term:`sequence`. Зріз створюється з "
"використанням нижнього індексу ``[]`` з двокрапками між числами, якщо "
"вказано кілька, наприклад, ``variable_name[1:3:5]``. Нотація в дужках "
"(підрядковому) використовує внутрішньо об’єкти :class:`slice`."

#: ../../glossary.rst:1223
msgid "soft deprecated"
msgstr "мягкий устаревший"

#: ../../glossary.rst:1225
msgid ""
"A soft deprecated API should not be used in new code, but it is safe for "
"already existing code to use it. The API remains documented and tested, but "
"will not be enhanced further."
msgstr ""
"Мягко устаревший API не следует использовать в новом коде, но его можно "
"безопасно использовать в уже существующем коде. API остается "
"документированным и протестированным, но не будет улучшаться дальше."

#: ../../glossary.rst:1229
msgid ""
"Soft deprecation, unlike normal deprecation, does not plan on removing the "
"API and will not emit warnings."
msgstr ""
"Мягкое устаревание, в отличие от обычного устаревания, не предполагает "
"удаление API и не выдает предупреждений."

#: ../../glossary.rst:1232
msgid ""
"See `PEP 387: Soft Deprecation <https://peps.python.org/pep-0387/#soft-"
"deprecation>`_."
msgstr ""
"См. `PEP 387: Мягкое прекращение поддержки <https://peps.python.org/pep-0387/"
"#soft-deprecation>`_."

#: ../../glossary.rst:1234
msgid "special method"
msgstr "спеціальний метод"

#: ../../glossary.rst:1238
msgid ""
"A method that is called implicitly by Python to execute a certain operation "
"on a type, such as addition.  Such methods have names starting and ending "
"with double underscores.  Special methods are documented in :ref:"
"`specialnames`."
msgstr ""
"Метод, який неявно викликається Python для виконання певної операції над "
"типом, наприклад додавання. Такі методи мають назви, що починаються і "
"закінчуються подвійним підкресленням. Спеціальні методи описані в :ref:"
"`specialnames`."

#: ../../glossary.rst:1242
msgid "standard library"
msgstr ""

#: ../../glossary.rst:1244
msgid ""
"The collection of :term:`packages <package>`, :term:`modules <module>` and :"
"term:`extension modules <extension module>` distributed as a part of the "
"official Python interpreter package.  The exact membership of the collection "
"may vary based on platform, available system libraries, or other criteria.  "
"Documentation can be found at :ref:`library-index`."
msgstr ""

#: ../../glossary.rst:1250
msgid ""
"See also :data:`sys.stdlib_module_names` for a list of all possible standard "
"library module names."
msgstr ""

#: ../../glossary.rst:1252
msgid "statement"
msgstr "بیانیه"

#: ../../glossary.rst:1254
msgid ""
"A statement is part of a suite (a \"block\" of code).  A statement is either "
"an :term:`expression` or one of several constructs with a keyword, such as :"
"keyword:`if`, :keyword:`while` or :keyword:`for`."
msgstr ""
"Оператор є частиною набору (\"блоку\" коду). Інструкція є або :term:"
"`expression`, або однією з кількох конструкцій із ключовим словом, таким як :"
"keyword:`if`, :keyword:`while` або :keyword:`for`."

#: ../../glossary.rst:1257
msgid "static type checker"
msgstr "проверка статического типа"

#: ../../glossary.rst:1259
msgid ""
"An external tool that reads Python code and analyzes it, looking for issues "
"such as incorrect types. See also :term:`type hints <type hint>` and the :"
"mod:`typing` module."
msgstr ""
"Внешний инструмент, который читает код Python и анализирует его, выявляя "
"такие проблемы, как неправильные типы. См. также :term:`typehints "
"<typehint>` и модуль :mod:`typing`."

#: ../../glossary.rst:1262
msgid "stdlib"
msgstr ""

#: ../../glossary.rst:1264
msgid "An abbreviation of :term:`standard library`."
msgstr ""

#: ../../glossary.rst:1265
msgid "strong reference"
msgstr "сильна посилання"

#: ../../glossary.rst:1267
msgid ""
"In Python's C API, a strong reference is a reference to an object which is "
"owned by the code holding the reference.  The strong reference is taken by "
"calling :c:func:`Py_INCREF` when the reference is created and released with :"
"c:func:`Py_DECREF` when the reference is deleted."
msgstr ""
"В API C Python сильная ссылка — это ссылка на объект, владельцем которого "
"является код, содержащий ссылку. Сильная ссылка берется путем вызова :c:func:"
"`Py_INCREF` при создании ссылки и освобождается с помощью :c:func:"
"`Py_DECREF` при удалении ссылки."

#: ../../glossary.rst:1273
msgid ""
"The :c:func:`Py_NewRef` function can be used to create a strong reference to "
"an object. Usually, the :c:func:`Py_DECREF` function must be called on the "
"strong reference before exiting the scope of the strong reference, to avoid "
"leaking one reference."
msgstr ""
"Функцію :c:func:`Py_NewRef` можна використовувати для створення сильного "
"посилання на об’єкт. Зазвичай функцію :c:func:`Py_DECREF` потрібно викликати "
"для сильного посилання перед виходом із області сильного посилання, щоб "
"уникнути витоку одного посилання."

#: ../../glossary.rst:1278
msgid "See also :term:`borrowed reference`."
msgstr "Дивіться також :term:`borrowed reference`."

#: ../../glossary.rst:1279
msgid "text encoding"
msgstr "kodowanie tekstu"

#: ../../glossary.rst:1281
msgid ""
"A string in Python is a sequence of Unicode code points (in range "
"``U+0000``--``U+10FFFF``). To store or transfer a string, it needs to be "
"serialized as a sequence of bytes."
msgstr ""
"Рядок у Python — це послідовність кодових точок Unicode (у діапазоні "
"``U+0000``--``U+10FFFF``). Щоб зберегти або передати рядок, його потрібно "
"серіалізувати як послідовність байтів."

#: ../../glossary.rst:1285
msgid ""
"Serializing a string into a sequence of bytes is known as \"encoding\", and "
"recreating the string from the sequence of bytes is known as \"decoding\"."
msgstr ""
"Серіалізація рядка в послідовність байтів відома як \"кодування\", а "
"відтворення рядка з послідовності байтів відоме як \"декодування\"."

#: ../../glossary.rst:1288
msgid ""
"There are a variety of different text serialization :ref:`codecs <standard-"
"encodings>`, which are collectively referred to as \"text encodings\"."
msgstr ""
"Istnieje wiele różnych serializacji tekstu :ref:`codecs <standard-"
"encodings>`, które są zbiorczo określane jako \"kodowanie tekstu\"."

#: ../../glossary.rst:1291
msgid "text file"
msgstr "plik tekstowy"

#: ../../glossary.rst:1293
msgid ""
"A :term:`file object` able to read and write :class:`str` objects. Often, a "
"text file actually accesses a byte-oriented datastream and handles the :term:"
"`text encoding` automatically. Examples of text files are files opened in "
"text mode (``'r'`` or ``'w'``), :data:`sys.stdin`, :data:`sys.stdout`, and "
"instances of :class:`io.StringIO`."
msgstr ""
":term:`Obiekt pliku <file object>` może odczytywać i zapisywać obiekty :"
"class:`str`. Często plik tekstowy faktycznie uzyskuje dostęp do strumienia "
"danych zorientowanego na bajty i automatycznie obsługuje :term:`kodowanie "
"tekstu <text encoding>`. Przykładami plików tekstowych są pliki otwierane w "
"trybie tekstowym (``'r'`` lub ``'w'``), :data:`sys.stdin`, :data:`sys."
"stdout` i instancje :class:`io.StringIO`."

#: ../../glossary.rst:1300
msgid ""
"See also :term:`binary file` for a file object able to read and write :term:"
"`bytes-like objects <bytes-like object>`."
msgstr ""
"Дивіться також :term:`binary file` щодо файлового об’єкта, здатного читати "
"та записувати :term:`байтоподібні об’єкти <bytes-like object>`."

#: ../../glossary.rst:1302
msgid "token"
msgstr "token (жетон)"

#: ../../glossary.rst:1305
msgid ""
"A small unit of source code, generated by the :ref:`lexical analyzer "
"<lexical>` (also called the *tokenizer*). Names, numbers, strings, "
"operators, newlines and similar are represented by tokens."
msgstr ""
"Небольшая единица исходного кода, сгенерированная :ref:`лексическим "
"анализатором <lexical>` (также называемым *токенизатором*). Имена, числа, "
"строки, операторы, переводы строк и т. п. представлены токенами."

#: ../../glossary.rst:1310
msgid ""
"The :mod:`tokenize` module exposes Python's lexical analyzer. The :mod:"
"`token` module contains information on the various types of tokens."
msgstr ""
"Модуль :mod:`tokenize` раскрывает лексический анализатор Python. Модуль :mod:"
"`token` содержит информацию о различных типах токенов."

#: ../../glossary.rst:1313
msgid "triple-quoted string"
msgstr "teks tiga-kutip"

#: ../../glossary.rst:1315
msgid ""
"A string which is bound by three instances of either a quotation mark (\") "
"or an apostrophe (').  While they don't provide any functionality not "
"available with single-quoted strings, they are useful for a number of "
"reasons.  They allow you to include unescaped single and double quotes "
"within a string and they can span multiple lines without the use of the "
"continuation character, making them especially useful when writing "
"docstrings."
msgstr ""
"Рядок, обмежений трьома лапками (\") або апострофом ('). Хоча вони не "
"надають жодної функції, недоступної для рядків із одинарними лапками, вони "
"корисні з кількох причин. Вони дозволяють ви можете включити неекрановані "
"одинарні та подвійні лапки в рядок, і вони можуть охоплювати кілька рядків "
"без використання символу продовження, що робить їх особливо корисними під "
"час написання рядків документів."

#: ../../glossary.rst:1322
msgid "type"
msgstr "گونه"

#: ../../glossary.rst:1324
msgid ""
"The type of a Python object determines what kind of object it is; every "
"object has a type.  An object's type is accessible as its :attr:`~object."
"__class__` attribute or can be retrieved with ``type(obj)``."
msgstr ""
"Тип об'єкта Python визначає, що це за об'єкт; кожен об'єкт має тип.  Тип "
"об'єкта доступний як атрибут :attr:`~object.__class__`, або може бути "
"отриманий за допомогою ``type(obj)``."

#: ../../glossary.rst:1328
msgid "type alias"
msgstr "псевдонім типу"

#: ../../glossary.rst:1330
msgid "A synonym for a type, created by assigning the type to an identifier."
msgstr "Синонім типу, створений шляхом присвоєння типу ідентифікатору."

#: ../../glossary.rst:1332
msgid ""
"Type aliases are useful for simplifying :term:`type hints <type hint>`. For "
"example::"
msgstr ""
"Псевдоніми типів корисні для спрощення :term:`підказок типу <type hint>`. "
"Наприклад::"

#: ../../glossary.rst:1335
msgid ""
"def remove_gray_shades(\n"
"        colors: list[tuple[int, int, int]]) -> list[tuple[int, int, int]]:\n"
"    pass"
msgstr ""
"def remove_gray_shades(\n"
"        colors: list[tuple[int, int, int]]) -> list[tuple[int, int, int]]:\n"
"    pass"

#: ../../glossary.rst:1339
msgid "could be made more readable like this::"
msgstr "можна зробити більш читабельним таким чином::"

#: ../../glossary.rst:1341
msgid ""
"Color = tuple[int, int, int]\n"
"\n"
"def remove_gray_shades(colors: list[Color]) -> list[Color]:\n"
"    pass"
msgstr ""
"Color = tuple[int, int, int]\n"
"\n"
"def remove_gray_shades(colors: list[Color]) -> list[Color]:\n"
"    pass"

#: ../../glossary.rst:1346 ../../glossary.rst:1360
msgid "See :mod:`typing` and :pep:`484`, which describe this functionality."
msgstr "Перегляньте :mod:`typing` і :pep:`484`, які описують цю функцію."

#: ../../glossary.rst:1347
msgid "type hint"
msgstr "підказка типу"

#: ../../glossary.rst:1349
msgid ""
"An :term:`annotation` that specifies the expected type for a variable, a "
"class attribute, or a function parameter or return value."
msgstr ""
":term:`annotation`, яка визначає очікуваний тип для змінної, атрибута класу "
"або параметра функції чи значення, що повертається."

#: ../../glossary.rst:1352
msgid ""
"Type hints are optional and are not enforced by Python but they are useful "
"to :term:`static type checkers <static type checker>`. They can also aid "
"IDEs with code completion and refactoring."
msgstr ""
"Підказки типу є необов'язковими і не вимагаються Python, але вони корисні "
"для :term:`програм для статичної перевірки типів <static type checker>`. "
"Вони також можуть допомогти IDE з завершенням коду та рефакторингом."

#: ../../glossary.rst:1356
msgid ""
"Type hints of global variables, class attributes, and functions, but not "
"local variables, can be accessed using :func:`typing.get_type_hints`."
msgstr ""
"Доступ до підказок типу глобальних змінних, атрибутів класу та функцій, але "
"не локальних змінних, можна отримати за допомогою :func:`typing."
"get_type_hints`."

#: ../../glossary.rst:1361
msgid "universal newlines"
msgstr "خطوط جدید جهانی"

#: ../../glossary.rst:1363
msgid ""
"A manner of interpreting text streams in which all of the following are "
"recognized as ending a line: the Unix end-of-line convention ``'\\n'``, the "
"Windows convention ``'\\r\\n'``, and the old Macintosh convention "
"``'\\r'``.  See :pep:`278` and :pep:`3116`, as well as :func:`bytes."
"splitlines` for an additional use."
msgstr ""
"Спосіб інтерпретації текстових потоків, у якому все наступне розпізнається "
"як завершення рядка: угода Unix про кінець рядка ``'\\n'``, угода Windows "
"``'\\r\\n'``, і стару конвенцію Macintosh ``'\\r'``. Перегляньте :pep:`278` "
"і :pep:`3116`, а також :func:`bytes.splitlines` для додаткового використання."

#: ../../glossary.rst:1368
msgid "variable annotation"
msgstr "anotasi variabel"

#: ../../glossary.rst:1370
msgid "An :term:`annotation` of a variable or a class attribute."
msgstr ":term:`annotation` змінної або атрибута класу."

#: ../../glossary.rst:1372
msgid ""
"When annotating a variable or a class attribute, assignment is optional::"
msgstr ""
"При анотуванні змінної або атрибута класу призначення є необов’язковим:"

#: ../../glossary.rst:1374
msgid ""
"class C:\n"
"    field: 'annotation'"
msgstr ""
"class C:\n"
"    field: 'annotation'"

#: ../../glossary.rst:1377
msgid ""
"Variable annotations are usually used for :term:`type hints <type hint>`: "
"for example this variable is expected to take :class:`int` values::"
msgstr ""
"Анотації змінних зазвичай використовуються для :term:`підказок типу <type "
"hint>`: наприклад, очікується, що ця змінна прийматиме значення :class:"
"`int`::"

#: ../../glossary.rst:1381
msgid "count: int = 0"
msgstr "count: int = 0"

#: ../../glossary.rst:1383
msgid "Variable annotation syntax is explained in section :ref:`annassign`."
msgstr "Синтаксис анотації змінної пояснюється в розділі :ref:`annassign`."

#: ../../glossary.rst:1385
msgid ""
"See :term:`function annotation`, :pep:`484` and :pep:`526`, which describe "
"this functionality. Also see :ref:`annotations-howto` for best practices on "
"working with annotations."
msgstr ""
"Перегляньте :term:`function annotation`, :pep:`484` та :pep:`526`, які "
"описують цю функціональність. Також перегляньте :ref:`annotations-howto`, "
"щоб дізнатися про найкращі практики роботи з анотаціями."

#: ../../glossary.rst:1389
msgid "virtual environment"
msgstr "lingkungan virtual"

#: ../../glossary.rst:1391
msgid ""
"A cooperatively isolated runtime environment that allows Python users and "
"applications to install and upgrade Python distribution packages without "
"interfering with the behaviour of other Python applications running on the "
"same system."
msgstr ""
"Lingkungan runtime kooperatif yang memungkinkan pengguna dan aplikasi Python "
"untuk menginstal dan memperbarui paket distribusi Python tanpa mengganggu "
"perilaku aplikasi Python lain yang berjalan pada sistem yang sama."

#: ../../glossary.rst:1396
msgid "See also :mod:`venv`."
msgstr "Lihat juga :mod:`venv`."

#: ../../glossary.rst:1397
msgid "virtual machine"
msgstr "mesin virtual"

#: ../../glossary.rst:1399
msgid ""
"A computer defined entirely in software.  Python's virtual machine executes "
"the :term:`bytecode` emitted by the bytecode compiler."
msgstr ""
"Комп’ютер, повністю визначений програмним забезпеченням. Віртуальна машина "
"Python виконує :term:`bytecode`, виданий компілятором байт-коду."

#: ../../glossary.rst:1401
msgid "Zen of Python"
msgstr "Дзен Python"

#: ../../glossary.rst:1403
msgid ""
"Listing of Python design principles and philosophies that are helpful in "
"understanding and using the language.  The listing can be found by typing "
"\"``import this``\" at the interactive prompt."
msgstr ""
"Перелік принципів дизайну та філософії Python, які допоможуть зрозуміти та "
"використовувати мову. Перелік можна знайти, ввівши \"``import this``\" в "
"інтерактивному рядку."

#: ../../glossary.rst:292
msgid "C-contiguous"
msgstr "С-непрерывный"

#: ../../glossary.rst:292
msgid "Fortran contiguous"
msgstr "Непрерывность Fortran"

#: ../../glossary.rst:831
msgid "magic"
msgstr "magia"

#: ../../glossary.rst:1236
msgid "special"
msgstr "specjalne"
