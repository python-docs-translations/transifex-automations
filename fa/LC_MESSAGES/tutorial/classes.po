# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-05-08 05:08+0000\n"
"PO-Revision-Date: 2023-05-24 02:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Persian (https://app.transifex.com/python-doc/teams/5390/"
"fa/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fa\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../tutorial/classes.rst:5
msgid "Classes"
msgstr "کلاس ها"

#: ../../tutorial/classes.rst:7
msgid ""
"Classes provide a means of bundling data and functionality together.  "
"Creating a new class creates a new *type* of object, allowing new "
"*instances* of that type to be made.  Each class instance can have "
"attributes attached to it for maintaining its state.  Class instances can "
"also have methods (defined by its class) for modifying its state."
msgstr ""
"کلاس ها وسیله ای را برای بسته بندی کردن داده و عملکرد با هم فراهم می کنند. "
"ایجاد یک کلاس جدید، نوع جدیدی ایجاد می کند که اجازه می دهد موارد جدیدی از آن "
"نوع ساخته شود. هر نمونه از کلاس می تواند صفاتی داشته باشد که به آن متصل شده "
"اند تا وضعیت آن را حفظ کنند. نمونه های کلاس می توانند همچنین متدهایی (که "
"توسط کلاس تعریف شده اند) داشته باشند تا وضعیت آن را تغییر دهند."

#: ../../tutorial/classes.rst:13
msgid ""
"Compared with other programming languages, Python's class mechanism adds "
"classes with a minimum of new syntax and semantics.  It is a mixture of the "
"class mechanisms found in C++ and Modula-3.  Python classes provide all the "
"standard features of Object Oriented Programming: the class inheritance "
"mechanism allows multiple base classes, a derived class can override any "
"methods of its base class or classes, and a method can call the method of a "
"base class with the same name.  Objects can contain arbitrary amounts and "
"kinds of data.  As is true for modules, classes partake of the dynamic "
"nature of Python: they are created at runtime, and can be modified further "
"after creation."
msgstr ""
"در مقایسه با دیگر زبان های برنامه نویسی، مکانیزم کلاس در پایتون کلاس ها را "
"با حداقل قواعد و معناشناسی جدید اضافه می کند. این مکانیزم ترکیبی از مکانیزم "
"های کلاسی است که در C++ و Modula-3 یافت می شود. کلاس های پایتون تمام ویژگی "
"های استاندارد برنامه نویسی شی گرا را فراهم می کنند: مکانیزم ارث بری کلاس ها "
"اجازه می دهد کلاس های پایه متعددی داشته باشید، یک کلاس مشتق می تواند هر یک "
"از متدهای کلاس های پایه خود را بازنویسی کند و یک متد می تواند متدی از کلاس "
"پایه با همان نام را فراخوانی کند. اشیاء می توانند حاوی مقادیر و انواع داده "
"ای دلخواه باشند. همان طور که برای ماژول ها صادق است، کلاس ها نیز از طبیعت "
"پویا در پایتون برخوردارند: آن ها در زمان اجرا ایجاد می شوند و می توانند پس "
"از ایجاد بیشتر تغییر داده شوند."

#: ../../tutorial/classes.rst:23
msgid ""
"In C++ terminology, normally class members (including the data members) are "
"*public* (except see below :ref:`tut-private`), and all member functions are "
"*virtual*.  As in Modula-3, there are no shorthands for referencing the "
"object's members from its methods: the method function is declared with an "
"explicit first argument representing the object, which is provided "
"implicitly by the call.  As in Smalltalk, classes themselves are objects.  "
"This provides semantics for importing and renaming.  Unlike C++ and "
"Modula-3, built-in types can be used as base classes for extension by the "
"user.  Also, like in C++, most built-in operators with special syntax "
"(arithmetic operators, subscripting etc.) can be redefined for class "
"instances."
msgstr ""
"در اصطلاحات C++، معمولاً اعضای کلاس (از جمله اعضای داده) *public* هستند (به "
"جز موردی که در پایین :ref:`tut-private` ذکر شده است)، و تمامی توابع عضو "
"مجازی  هستند. همان طور که در Modula-3، هیچ میانبرهایی برای ارجاع به اعضای "
"شیء از متدهای آن وجود ندارد: تابع متد با یک آرگومان اول صریح که نمایانگر شیء "
"است، اعلام می شود که این آرگومان به صورت ضمنی توسط فراخوانی فراهم می شود. "
"همان طور که در Smalltalk، خود کلاس ها اشیاء هستند. این ویژگی معناشناسی برای "
"وارد کردن و تغییر نام را فراهم می آورد. برخلاف C++ و Modula-3، نوع های داخلی "
"می توانند به عنوان کلاس های پایه برای توسعه توسط کاربر استفاده شوند. همچنین، "
"مانند C++، بیشتر عملگرهای داخلی با نحوی خاص (عملگرهای ریاضی، زیرنویسی و "
"غیره) می توانند برای نمونه های کلاس بازتعریف شوند."

#: ../../tutorial/classes.rst:34
msgid ""
"(Lacking universally accepted terminology to talk about classes, I will make "
"occasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, "
"since its object-oriented semantics are closer to those of Python than C++, "
"but I expect that few readers have heard of it.)"
msgstr ""
"چون ترمینولوژی جهانی پذیرفته شده ای برای صحبت در مورد کلاس ها وجود ندارد، "
"گاهی از اصطلاحات Smalltalk و C++ استفاده می کنم. ترجیح می دادم از اصطلاحات "
"Modula-3 استفاده کنم، زیرا معناشناسی شی گرا آن به پایتون نزدیک تر از C++ "
"است، ولی انتظار دارم که تعداد کمی از خوانندگان با آن آشنا باشند."

#: ../../tutorial/classes.rst:43
msgid "A Word About Names and Objects"
msgstr "یک کلمه درباره نام ها و اشیاء"

#: ../../tutorial/classes.rst:45
msgid ""
"Objects have individuality, and multiple names (in multiple scopes) can be "
"bound to the same object.  This is known as aliasing in other languages.  "
"This is usually not appreciated on a first glance at Python, and can be "
"safely ignored when dealing with immutable basic types (numbers, strings, "
"tuples).  However, aliasing has a possibly surprising effect on the "
"semantics of Python code involving mutable objects such as lists, "
"dictionaries, and most other types. This is usually used to the benefit of "
"the program, since aliases behave like pointers in some respects.  For "
"example, passing an object is cheap since only a pointer is passed by the "
"implementation; and if a function modifies an object passed as an argument, "
"the caller will see the change --- this eliminates the need for two "
"different argument passing mechanisms as in Pascal."
msgstr ""
"اشیاء دارای فردیت هستند و نام های متعدد (در حوزه های متعدد) را می توان به یک "
"شی محدود کرد.  این در زبان های دیگر به نام مستعار شناخته می شود.  معمولاً در "
"نگاه اول پایتون به این موضوع توجهی نمی‌شود، و می‌توان با خیال راحت از انواع "
"اولیه تغییرناپذیر (اعداد, رشته‌ها, تاپل‌ها) صرف نظر کرد.  با این حال، نام "
"مستعار یک اثر احتمالاً شگفت‌انگیز بر معنایی کد پایتون شامل اشیاء قابل تغییر "
"مانند فهرست‌ها، دیکشنری‌ها و بسیاری از انواع دیگر دارد. این معمولاً به نفع "
"برنامه استفاده می شود، زیرا نام مستعار در برخی موارد مانند اشاره گر عمل می "
"کنند.  به عنوان مثال، ارسال یک شی کم هزینه است زیرا تنها یک اشاره گر توسط "
"پیاده سازی ارسال می شود. و اگر تابعی شیء ارسال شده به عنوان آرگومان را تغییر "
"دهد، فراخواننده این تغییر را مشاهده خواهد کرد --- این امر نیاز به دو مکانیسم "
"مختلف ارسال آرگومان مانند پاسکال را از بین می برد."

#: ../../tutorial/classes.rst:61
msgid "Python Scopes and Namespaces"
msgstr "محدوده ها و فضای نام ها در پایتون"

#: ../../tutorial/classes.rst:63
msgid ""
"Before introducing classes, I first have to tell you something about "
"Python's scope rules.  Class definitions play some neat tricks with "
"namespaces, and you need to know how scopes and namespaces work to fully "
"understand what's going on. Incidentally, knowledge about this subject is "
"useful for any advanced Python programmer."
msgstr ""
"قبل از معرفی کلاس ها، ابتدا باید چیزی درباره قوانین حوزه  در پایتون به شما "
"بگویم. تعریف کلاس ها چند ترفند جالب با فضاهای نام انجام می دهد و برای اینکه "
"به طور کامل متوجه شوید چه می گذرد، باید بدانید که حوزه ها و فضاهای نام چگونه "
"کار می کنند. ضمناً، آگاهی از این موضوع برای هر برنامه نویس پیشرفته پایتون "
"مفید است."

#: ../../tutorial/classes.rst:69
msgid "Let's begin with some definitions."
msgstr "بیایید با چند تعریف شروع کنیم."

#: ../../tutorial/classes.rst:71
msgid ""
"A *namespace* is a mapping from names to objects.  Most namespaces are "
"currently implemented as Python dictionaries, but that's normally not "
"noticeable in any way (except for performance), and it may change in the "
"future.  Examples of namespaces are: the set of built-in names (containing "
"functions such as :func:`abs`, and built-in exception names); the global "
"names in a module; and the local names in a function invocation.  In a sense "
"the set of attributes of an object also form a namespace.  The important "
"thing to know about namespaces is that there is absolutely no relation "
"between names in different namespaces; for instance, two different modules "
"may both define a function ``maximize`` without confusion --- users of the "
"modules must prefix it with the module name."
msgstr ""
"یک *namespace* نقشه ای از نام ها به اشیاء است. بیشتر فضاهای نام در حال حاضر "
"به عنوان دیکشنری های پایتون پیاده سازی شده اند، اما این معمولاً به هیچ وجه "
"قابل مشاهده نیست (به جز از نظر کارایی)، و ممکن است در آینده تغییر کند. مثال "
"هایی از فضاهای نام عبارتند از: مجموعه نام های داخلی (شامل توابعی مانند :func:"
"`abs` و نام های استثناء داخلی)؛ نام های جهانی در یک ماژول؛ و نام های محلی در "
"اجرای یک تابع. به نوعی، مجموعه ویژگی های یک شیء نیز یک فضای نام تشکیل می "
"دهند. نکته مهمی که درباره فضاهای نام باید بدانید این است که بین نام ها در "
"فضاهای نام مختلف هیچ رابطه ای وجود ندارد؛ برای مثال، دو ماژول مختلف ممکن است "
"هر دو یک تابع به نام ``maximize`` تعریف کنند بدون ایجاد سردرگمی --- کاربران "
"ماژول ها باید آن را با نام ماژول مقدمه کنند."

#: ../../tutorial/classes.rst:82
msgid ""
"By the way, I use the word *attribute* for any name following a dot --- for "
"example, in the expression ``z.real``, ``real`` is an attribute of the "
"object ``z``.  Strictly speaking, references to names in modules are "
"attribute references: in the expression ``modname.funcname``, ``modname`` is "
"a module object and ``funcname`` is an attribute of it.  In this case there "
"happens to be a straightforward mapping between the module's attributes and "
"the global names defined in the module: they share the same namespace!  [#]_"
msgstr ""
"من از کلمه صفت به همراه یک نقطه استفاده میکنم برای مثال \n"
"z.real\n"
"\"real\" یک صفت برای شی زد هست.به طور دقیق، ارجاعات به نام‌ها در ماژول‌ها، "
"ارجاعات ویژگی هستند: در عبارت``modname.funcname``\n"
"``modname`` یک شی از ماژول هست و ``funcname``صفتی از ان.\n"
"در این مثال برخسب اتفاق مپینگ بین صفت ماژول و تعاریف عمومی اسم هر دو از یک  "
"namespace! استفاده میکنند[#]_ "

#: ../../tutorial/classes.rst:90
msgid ""
"Attributes may be read-only or writable.  In the latter case, assignment to "
"attributes is possible.  Module attributes are writable: you can write "
"``modname.the_answer = 42``.  Writable attributes may also be deleted with "
"the :keyword:`del` statement.  For example, ``del modname.the_answer`` will "
"remove the attribute :attr:`!the_answer` from the object named by "
"``modname``."
msgstr ""
"ویژگی ها ممکن است فقط خواندنی یا قابل نوشتن باشند. در حالت دوم، اختصاص دادن "
"به ویژگی ها ممکن است. ویژگی های ماژول قابل نوشتن هستند: می توانید ``modname."
"the_answer = 42`` را بنویسید. ویژگی های قابل نوشتن را می توان با دستور :"
"keyword:`del` نیز حذف کرد. به عنوان مثال، ``del modname.the_answer`` ویژگی :"
"attr:`!the_answer` را از شیئی که توسط ``modname`` نامگذاری شده است حذف خواهد "
"کرد."

#: ../../tutorial/classes.rst:96
msgid ""
"Namespaces are created at different moments and have different lifetimes.  "
"The namespace containing the built-in names is created when the Python "
"interpreter starts up, and is never deleted.  The global namespace for a "
"module is created when the module definition is read in; normally, module "
"namespaces also last until the interpreter quits.  The statements executed "
"by the top-level invocation of the interpreter, either read from a script "
"file or interactively, are considered part of a module called :mod:"
"`__main__`, so they have their own global namespace.  (The built-in names "
"actually also live in a module; this is called :mod:`builtins`.)"
msgstr ""
"فضاهای نام در لحظات مختلف ایجاد می شوند و دارای طول عمرهای متفاوتی هستند. "
"فضای نام که شامل نام های داخلی است، زمانی که مفسر پایتون شروع به کار می کند "
"ایجاد می شود و هرگز حذف نمی شود. فضای نام عمومی برای یک ماژول زمانی که تعریف "
"ماژول خوانده می شود ایجاد می گردد؛ به طور معمول، فضاهای نام ماژول نیز تا "
"زمانی که مفسر پایان یابد باقی می مانند. دستوراتی که توسط اجرای سطح بالای "
"مفسر، یا از فایل اسکریپت خوانده شده یا به طور تعاملی اجرا می شوند، به عنوان "
"بخشی از ماژولی به نام :mod:`__main__` در نظر گرفته می شوند، بنابراین آن ها "
"فضای نام عمومی خود را دارند. (نام های داخلی در واقع همچنین در ماژول زندگی می "
"کنند؛ این ماژول :mod:`builtins` نامیده می شود.)"

#: ../../tutorial/classes.rst:106
msgid ""
"The local namespace for a function is created when the function is called, "
"and deleted when the function returns or raises an exception that is not "
"handled within the function.  (Actually, forgetting would be a better way to "
"describe what actually happens.)  Of course, recursive invocations each have "
"their own local namespace."
msgstr ""
"فضای نام محلی برای یک تابع زمانی ایجاد می شود که تابع فراخوانی شود و زمانی "
"که تابع برگردد یا استثنایی که در داخل تابع رسیدگی نشده باشد، حذف می شود. (در "
"واقع، فراموش کردن راه بهتری برای توصیف چیزی است که واقعاً اتفاق می افتد.) "
"البته، هر فراخوانی بازگشتی فضای نام محلی خود را دارد."

#: ../../tutorial/classes.rst:112
msgid ""
"A *scope* is a textual region of a Python program where a namespace is "
"directly accessible.  \"Directly accessible\" here means that an unqualified "
"reference to a name attempts to find the name in the namespace."
msgstr ""
"یک *scope* یک ناحیه متنی از یک برنامه پایتون است که در آن یک فضای نام به طور "
"مستقیم قابل دستیابی است. \"به طور مستقیم قابل دستیابی\" در اینجا به این معنی "
"است که یک ارجاع بدون صلاحیت به یک نام تلاش می کند تا نام را در فضای نام پیدا "
"کند."

#: ../../tutorial/classes.rst:116
msgid ""
"Although scopes are determined statically, they are used dynamically. At any "
"time during execution, there are 3 or 4 nested scopes whose namespaces are "
"directly accessible:"
msgstr ""
"اگرچه حوزه ها به صورت ایستا تعیین می شوند، اما به صورت پویا مورد استفاده "
"قرار می گیرند. در هر لحظه ای از اجرای برنامه، ۳ یا ۴ حوزه ی تودرتو وجود "
"دارند که فضای نام های آنها به طور مستقیم قابل دسترسی است:"

#: ../../tutorial/classes.rst:120
msgid "the innermost scope, which is searched first, contains the local names"
msgstr "درونی ترین حوزه، که ابتدا جستجو می شود، شامل نام های محلی است"

#: ../../tutorial/classes.rst:121
msgid ""
"the scopes of any enclosing functions, which are searched starting with the "
"nearest enclosing scope, contain non-local, but also non-global names"
msgstr ""
"حوزه های هر تابع محاطی که جستجو از نزدیک ترین حوزه محاطی شروع می شود، شامل "
"نام هایی است که نه محلی هستند و نه سراسری."

#: ../../tutorial/classes.rst:123
msgid "the next-to-last scope contains the current module's global names"
msgstr "حوزه قبل از آخر شامل نام های عمومی ماژول جاری است."

#: ../../tutorial/classes.rst:124
msgid ""
"the outermost scope (searched last) is the namespace containing built-in "
"names"
msgstr ""
"بیرونی ترین حوزه (که در نهایت جستجو می شود) نام فضایی است که شامل نام های "
"پیش ساخته است."

#: ../../tutorial/classes.rst:126
msgid ""
"If a name is declared global, then all references and assignments go "
"directly to the next-to-last scope containing the module's global names.  To "
"rebind variables found outside of the innermost scope, the :keyword:"
"`nonlocal` statement can be used; if not declared nonlocal, those variables "
"are read-only (an attempt to write to such a variable will simply create a "
"*new* local variable in the innermost scope, leaving the identically named "
"outer variable unchanged)."
msgstr ""
"اگر یک نام به صورت global اعلام شود، تمام ارجاعات و تخصیص ها مستقیماً به "
"آخرین حوزه ماقبل، که شامل نام های سراسری ماژول است، می روند. برای انتساب "
"مجدد متغیرهایی که خارج از داخلی ترین حوزه یافت می شوند، می توان از عبارت :"
"keyword:`nonlocal` استفاده کرد؛ اگر به صورت nonlocal اعلام نشده باشند، آن "
"متغیرها فقط قابل خواندن خواهند بود (تلاش برای نوشتن به چنین متغیری به سادگی "
"یک متغیر محلی *new* را در داخلی ترین حوزه ایجاد می کند و متغیر هم نام بیرونی "
"را بدون تغییر باقی می گذارد)."

#: ../../tutorial/classes.rst:133
msgid ""
"Usually, the local scope references the local names of the (textually) "
"current function.  Outside functions, the local scope references the same "
"namespace as the global scope: the module's namespace. Class definitions "
"place yet another namespace in the local scope."
msgstr ""
"معمولاً، حوزه محلی به نام های محلی تابع (متنی) جاری اشاره می کند. خارج از "
"توابع، حوزه محلی به همان فضای نامی که حوزه سراسری را تشکیل می دهد اشاره می "
"کند: فضای نام ماژول. تعریف های کلاس، فضای نام دیگری را در حوزه محلی قرار می "
"دهند."

#: ../../tutorial/classes.rst:138
msgid ""
"It is important to realize that scopes are determined textually: the global "
"scope of a function defined in a module is that module's namespace, no "
"matter from where or by what alias the function is called.  On the other "
"hand, the actual search for names is done dynamically, at run time --- "
"however, the language definition is evolving towards static name resolution, "
"at \"compile\" time, so don't rely on dynamic name resolution!  (In fact, "
"local variables are already determined statically.)"
msgstr ""
"مهم است که متوجه شویم حوزه ها به صورت متنی تعیین می شوند: حوزه ی سراسری یک "
"تابع که در یک ماژول تعریف شده است، فضای نام آن ماژول است، بدون توجه به اینکه "
"از کجا یا با چه نام مستعاری آن تابع فراخوانی می شود. از طرف دیگر، جستجوی "
"واقعی برای نام ها به صورت پویا و در زمان اجرا انجام می شود --- با این حال، "
"تعریف زبان در حال حرکت به سمت حل نام ها به صورت ایستا، در زمان \"کامپایل\" "
"است، بنابراین به حل نام به صورت پویا اتکا نکنید! (در واقع، متغیرهای محلی از "
"قبل به صورت ایستا تعیین می شوند.)"

#: ../../tutorial/classes.rst:146
msgid ""
"A special quirk of Python is that -- if no :keyword:`global` or :keyword:"
"`nonlocal` statement is in effect -- assignments to names always go into the "
"innermost scope. Assignments do not copy data --- they just bind names to "
"objects.  The same is true for deletions: the statement ``del x`` removes "
"the binding of ``x`` from the namespace referenced by the local scope.  In "
"fact, all operations that introduce new names use the local scope: in "
"particular, :keyword:`import` statements and function definitions bind the "
"module or function name in the local scope."
msgstr ""
"یکی از ویژگی های خاص پایتون این است که اگر هیچ بیانیه :keyword:`global` یا :"
"keyword:`nonlocal` در حال اجرا نباشد، اختصاص نام ها همیشه در حیطه داخلی ترین "
"صورت می گیرد. اختصاص نام ها داده ها را کپی نمی کند، بلکه فقط نام ها را به "
"اشیاء متصل می کند. این موضوع در مورد حذف نیز صدق می کند: بیانیه ``del x`` "
"اتصال ``x`` را از فضای نام ارجاع شده توسط حیطه محلی حذف می کند. در واقع، "
"تمام عملیات هایی که نام های جدیدی معرفی می کنند از حیطه محلی استفاده می "
"کنند: به خصوص، بیانیه های :keyword:`import` و تعریف تابع نام ماژول یا تابع "
"را در حیطه محلی متصل می کنند."

#: ../../tutorial/classes.rst:154
msgid ""
"The :keyword:`global` statement can be used to indicate that particular "
"variables live in the global scope and should be rebound there; the :keyword:"
"`nonlocal` statement indicates that particular variables live in an "
"enclosing scope and should be rebound there."
msgstr ""
"بیانیه :keyword:`global` می تواند برای نشان دادن اینکه متغیرهای خاصی در حوزه "
"جهانی هستند و باید در آنجا بازبسته شوند، استفاده شود؛ بیانیه :keyword:"
"`nonlocal` نشان می دهد که متغیرهای خاصی در یک حوزه محاط کننده قرار دارند و "
"باید در آنجا بازبسته شوند."

#: ../../tutorial/classes.rst:162
msgid "Scopes and Namespaces Example"
msgstr "مثال محدوده ها و فضاهای نام"

#: ../../tutorial/classes.rst:164
msgid ""
"This is an example demonstrating how to reference the different scopes and "
"namespaces, and how :keyword:`global` and :keyword:`nonlocal` affect "
"variable binding::"
msgstr ""
"این یک مثال است که نشان می دهد چگونه به حوزه ها و نام فضاهای مختلف ارجاع "
"دهید، و چگونه :keyword:`global` و :keyword:`nonlocal` بر بایندینگ متغیر "
"تأثیر می گذارند::"

#: ../../tutorial/classes.rst:191
msgid "The output of the example code is:"
msgstr "خروجی کد مثال به صورت زیر است:"

#: ../../tutorial/classes.rst:200
msgid ""
"Note how the *local* assignment (which is default) didn't change "
"*scope_test*\\'s binding of *spam*.  The :keyword:`nonlocal` assignment "
"changed *scope_test*\\'s binding of *spam*, and the :keyword:`global` "
"assignment changed the module-level binding."
msgstr ""
"توجه کنید که انتساب *local* (که به صورت پیش فرض است) تغییر در ارتباط "
"*scope_test* با *spam* ایجاد نکرد. انتساب :keyword:`nonlocal` ارتباط "
"*scope_test* با *spam* را تغییر داد و انتساب :keyword:`global` ارتباط در سطح "
"ماژول را تغییر داد."

#: ../../tutorial/classes.rst:205
msgid ""
"You can also see that there was no previous binding for *spam* before the :"
"keyword:`global` assignment."
msgstr ""
"همچنین می توانید ببینید که هیچ اتصال قبلی برای *spam* قبل از انتساب :keyword:"
"`global` وجود نداشت."

#: ../../tutorial/classes.rst:212
msgid "A First Look at Classes"
msgstr "در نگاه اول به کلاس ها"

#: ../../tutorial/classes.rst:214
msgid ""
"Classes introduce a little bit of new syntax, three new object types, and "
"some new semantics."
msgstr ""
"کلاس ها اندکی سینتکس جدید، سه نوع شئ جدید و برخی مفاهیم معنایی جدید معرفی می "
"کنند."

#: ../../tutorial/classes.rst:221
msgid "Class Definition Syntax"
msgstr "قواعد تعریف کلاس"

#: ../../tutorial/classes.rst:223
msgid "The simplest form of class definition looks like this::"
msgstr "ساده ترین شکل تعریف کلاس به این صورت است:"

#: ../../tutorial/classes.rst:232
msgid ""
"Class definitions, like function definitions (:keyword:`def` statements) "
"must be executed before they have any effect.  (You could conceivably place "
"a class definition in a branch of an :keyword:`if` statement, or inside a "
"function.)"
msgstr ""
"تعاریف کلاس، مانند تعاریف تابع (:keyword:`def` statements)، باید قبل از "
"اینکه تأثیری داشته باشند اجرا شوند. (می توانید تعریف یک کلاس را به طور قابل "
"تصوری در یکی از شاخه های یک :keyword:`if` statement یا داخل یک تابع قرار "
"دهید.)"

#: ../../tutorial/classes.rst:236
msgid ""
"In practice, the statements inside a class definition will usually be "
"function definitions, but other statements are allowed, and sometimes useful "
"--- we'll come back to this later.  The function definitions inside a class "
"normally have a peculiar form of argument list, dictated by the calling "
"conventions for methods --- again, this is explained later."
msgstr ""
"در عمل، دستورات داخل تعریف یک کلاس معمولاً شامل تعریف توابع خواهد بود، اما "
"استفاده از دستورات دیگر مجاز است و گاهی اوقات مفید است — بعدها به این موضوع "
"باز خواهیم گشت. تعریف توابع داخل یک کلاس معمولاً شکل خاصی از لیست آرگومان ها "
"دارد که توسط قراردادهای فراخوانی برای متدها تعیین می شود — باز هم، این موضوع "
"بعداً توضیح داده خواهد شد."

#: ../../tutorial/classes.rst:242
msgid ""
"When a class definition is entered, a new namespace is created, and used as "
"the local scope --- thus, all assignments to local variables go into this "
"new namespace.  In particular, function definitions bind the name of the new "
"function here."
msgstr ""
"هنگامی که یک تعریف کلاس وارد می شود، یک فضای نام جدید ایجاد می شود و به "
"عنوان محدوده محلی استفاده می شود --- بنابراین، تمامی انتساب ها به متغیر های "
"محلی وارد این فضای نام جدید می شوند. به طور خاص، تعاریف تابع، نام تابع جدید "
"را در اینجا متصل می کنند."

#: ../../tutorial/classes.rst:247
msgid ""
"When a class definition is left normally (via the end), a *class object* is "
"created.  This is basically a wrapper around the contents of the namespace "
"created by the class definition; we'll learn more about class objects in the "
"next section.  The original local scope (the one in effect just before the "
"class definition was entered) is reinstated, and the class object is bound "
"here to the class name given in the class definition header (:class:`!"
"ClassName` in the example)."
msgstr ""
"هنگامی که تعریف یک کلاس به صورت طبیعی (از طریق پایان) به پایان می رسد، یک "
"*class object* ایجاد می شود. این در واقع یک پوشش است بر محتوای فضای نامی که "
"توسط تعریف کلاس ایجاد شده است؛ در بخش بعدی بیشتر درباره اشیاء کلاس یاد "
"خواهیم گرفت. حوزه محلی اولیه (همان که قبل از ورود به تعریف کلاس وجود داشت) "
"دوباره فعال می شود و شیء کلاس به نامی که در سربرگ تعریف کلاس داده شده است (:"
"class:`!ClassName` در مثال) متصل می شود."

#: ../../tutorial/classes.rst:259
msgid "Class Objects"
msgstr "اشیاء کلاس"

#: ../../tutorial/classes.rst:261
msgid ""
"Class objects support two kinds of operations: attribute references and "
"instantiation."
msgstr ""
"شیءهای کلاس از دو نوع عملیات پشتیبانی می کنند: ارجاع به ویژگی ها و نمونه "
"سازی."

#: ../../tutorial/classes.rst:264
msgid ""
"*Attribute references* use the standard syntax used for all attribute "
"references in Python: ``obj.name``.  Valid attribute names are all the names "
"that were in the class's namespace when the class object was created.  So, "
"if the class definition looked like this::"
msgstr ""
"برای استفاده از *Attribute references* از نحو استانداردی استفاده کنید که "
"برای تمامی مرجع های ویژگی در پایتون به کار می رود: ``obj.name``. نام های "
"ویژگی معتبر شامل تمامی نام هایی هستند که در فضای نام کلاس در هنگام ایجاد شیء "
"کلاس بودند. بنابراین، اگر تعریف کلاس به این صورت باشد:"

#: ../../tutorial/classes.rst:276
msgid ""
"then ``MyClass.i`` and ``MyClass.f`` are valid attribute references, "
"returning an integer and a function object, respectively. Class attributes "
"can also be assigned to, so you can change the value of ``MyClass.i`` by "
"assignment. :attr:`!__doc__` is also a valid attribute, returning the "
"docstring belonging to the class: ``\"A simple example class\"``."
msgstr ""

#: ../../tutorial/classes.rst:282
msgid ""
"Class *instantiation* uses function notation.  Just pretend that the class "
"object is a parameterless function that returns a new instance of the class. "
"For example (assuming the above class)::"
msgstr ""
"کلاس *instantiation* از نماد تابعی استفاده می کند. فقط فرض کنید که شیء کلاس "
"یک تابع بدون پارامتر است که نمونه جدیدی از کلاس را برمی گرداند. برای مثال "
"(با فرض وجود کلاس فوق):"

#: ../../tutorial/classes.rst:288
msgid ""
"creates a new *instance* of the class and assigns this object to the local "
"variable ``x``."
msgstr ""
"شیء جدیدی از کلاس *instance* ایجاد کرده و این شیء را به متغیر محلی ``x`` "
"اختصاص می دهد."

#: ../../tutorial/classes.rst:291
msgid ""
"The instantiation operation (\"calling\" a class object) creates an empty "
"object. Many classes like to create objects with instances customized to a "
"specific initial state. Therefore a class may define a special method named :"
"meth:`~object.__init__`, like this::"
msgstr ""
"عملیات نمونه سازی (برای مثال \"صدا زدن\" یک شیء کلاس) یک شیء خالی ایجاد می "
"کند. بسیاری از کلاس ها تمایل دارند اشیائی با نمونه های شخصی سازی شده به یک "
"حالت اولیه خاص ایجاد کنند. به همین دلیل یک کلاس ممکن است یک متد ویژه به نام :"
"meth:`~object.__init__` تعریف کند، مانند این:"

#: ../../tutorial/classes.rst:299
msgid ""
"When a class defines an :meth:`~object.__init__` method, class instantiation "
"automatically invokes :meth:`!__init__` for the newly created class "
"instance.  So in this example, a new, initialized instance can be obtained "
"by::"
msgstr ""
"وقتی یک کلاس متدی با نام :meth:`~object.__init__` را تعریف می کند، ایجاد یک "
"نمونه از کلاس به صورت خودکار :meth:`!__init__` را برای نمونه تازه ساخته شده "
"فراخوانی می کند. بنابراین، در این مثال، یک نمونه جدید و مقداردهی اولیه شده "
"را می توان به این صورت به دست آورد:"

#: ../../tutorial/classes.rst:305
msgid ""
"Of course, the :meth:`~object.__init__` method may have arguments for "
"greater flexibility.  In that case, arguments given to the class "
"instantiation operator are passed on to :meth:`!__init__`.  For example, ::"
msgstr ""
"البته، متد :meth:`~object.__init__` می تواند برای انعطاف پذیری بیشتر دارای "
"آرگومان باشد. در این صورت، آرگومان هایی که به عملگر ایجاد کلاس داده می شوند "
"به :meth:`!__init__` منتقل می شوند. برای مثال: :"

#: ../../tutorial/classes.rst:322
msgid "Instance Objects"
msgstr "شیء های نمونه"

#: ../../tutorial/classes.rst:324
msgid ""
"Now what can we do with instance objects?  The only operations understood by "
"instance objects are attribute references.  There are two kinds of valid "
"attribute names: data attributes and methods."
msgstr ""
"اکنون با اشیاء نمونه چه کاری می توانیم انجام دهیم؟ تنها عملیاتی که توسط "
"اشیاء نمونه قابل درک است، ارجاع به ویژگی ها است. دو نوع نام ویژگی معتبر وجود "
"دارد: ویژگی های داده و متدها."

#: ../../tutorial/classes.rst:328
msgid ""
"*data attributes* correspond to \"instance variables\" in Smalltalk, and to "
"\"data members\" in C++.  Data attributes need not be declared; like local "
"variables, they spring into existence when they are first assigned to.  For "
"example, if ``x`` is the instance of :class:`!MyClass` created above, the "
"following piece of code will print the value ``16``, without leaving a "
"trace::"
msgstr ""
"*data attributes* در Smalltalk به \"متغیرهای نمونه\" و در C++ به \"اعضای "
"داده\" اشاره دارد. ویژگی های داده نیازی به اعلام ندارند؛ مانند متغیرهای "
"محلی، آن ها زمانی که برای اولین بار به آن ها مقداری تخصیص داده می شود، به "
"وجود می آیند. برای مثال، اگر ``x`` نمونه ای از :class:`!MyClass` باشد که در "
"بالا ایجاد شده است، تکه کد زیر مقدار ``16`` را چاپ خواهد کرد، بدون اینکه "
"اثری باقی بگذارد::"

#: ../../tutorial/classes.rst:340
msgid ""
"The other kind of instance attribute reference is a *method*. A method is a "
"function that \"belongs to\" an object.  (In Python, the term method is not "
"unique to class instances: other object types can have methods as well.  For "
"example, list objects have methods called append, insert, remove, sort, and "
"so on. However, in the following discussion, we'll use the term method "
"exclusively to mean methods of class instance objects, unless explicitly "
"stated otherwise.)"
msgstr ""

#: ../../tutorial/classes.rst:349
msgid ""
"Valid method names of an instance object depend on its class.  By "
"definition, all attributes of a class that are function  objects define "
"corresponding methods of its instances.  So in our example, ``x.f`` is a "
"valid method reference, since ``MyClass.f`` is a function, but ``x.i`` is "
"not, since ``MyClass.i`` is not.  But ``x.f`` is not the same thing as "
"``MyClass.f`` --- it is a *method object*, not a function object."
msgstr ""
"نام های معتبر برای متدهای یک شیء نمونه به کلاس آن بستگی دارد. به طور تعریف "
"شده، تمام ویژگی های یک کلاس که اشیاء تابع باشند، متدهای متناظر نمونه های آن "
"کلاس را تعریف می کنند. بنابراین در مثال ما، ``x.f`` یک مرجع متد معتبر است، "
"چون ``MyClass.f`` یک تابع است، اما ``x.i`` نیست، چون ``MyClass.i`` نیست. با "
"این حال، ``x.f`` معادل ``MyClass.f`` نیست --- این یک *method object* است، نه "
"یک شیء تابع."

#: ../../tutorial/classes.rst:360
msgid "Method Objects"
msgstr "اشیای متد"

#: ../../tutorial/classes.rst:362
msgid "Usually, a method is called right after it is bound::"
msgstr "معمولاً یک متد بلافاصله بعد از اینکه مرتبط شد فراخوانی می شود::"

#: ../../tutorial/classes.rst:366
msgid ""
"In the :class:`!MyClass` example, this will return the string ``'hello "
"world'``. However, it is not necessary to call a method right away: ``x.f`` "
"is a method object, and can be stored away and called at a later time.  For "
"example::"
msgstr ""
"در مثال :class:`!MyClass` این رشته را برمی گرداند ``'hello world'``. با این "
"حال، لازم نیست که بلافاصله یک متد را فراخوانی کنید: ``x.f`` یک شیء متد است و "
"می تواند ذخیره شود و در زمان دیگری فراخوانی شود. به عنوان مثال::"

#: ../../tutorial/classes.rst:374
msgid "will continue to print ``hello world`` until the end of time."
msgstr "تا پایان زمان به چاپ ``hello world`` ادامه خواهد داد."

#: ../../tutorial/classes.rst:376
msgid ""
"What exactly happens when a method is called?  You may have noticed that ``x."
"f()`` was called without an argument above, even though the function "
"definition for :meth:`!f` specified an argument.  What happened to the "
"argument? Surely Python raises an exception when a function that requires an "
"argument is called without any --- even if the argument isn't actually "
"used..."
msgstr ""
"دقیقاً چه اتفاقی می افتد وقتی که یک متد فراخوانی می شود؟ شاید متوجه شده باشید "
"که ``x.f()`` بدون آرگومان فراخوانی شد، حتی با این که تعریف تابع برای :meth:`!"
"f` یک آرگومان مشخص کرده است. چه بر سر آرگومان آمد؟ به احتمال زیاد پایتون یک "
"استثناء مطرح می کند وقتی که تابعی که نیازمند یک آرگومان است، بدون هیچ "
"آرگومانی فراخوانی شود --- حتی اگر آرگومان به طور واقعی مورد استفاده قرار "
"نگیرد..."

#: ../../tutorial/classes.rst:382
msgid ""
"Actually, you may have guessed the answer: the special thing about methods "
"is that the instance object is passed as the first argument of the "
"function.  In our example, the call ``x.f()`` is exactly equivalent to "
"``MyClass.f(x)``.  In general, calling a method with a list of *n* arguments "
"is equivalent to calling the corresponding function with an argument list "
"that is created by inserting the method's instance object before the first "
"argument."
msgstr ""
"در واقع، شاید پاسخ را حدس زده باشید: ویژگی خاص متدها این است که شیء نمونه به "
"عنوان اولین آرگومان به تابع ارسال می شود. در مثال ما، فراخوانی ``x.f()`` "
"دقیقا معادل ``MyClass.f(x)`` است. به طور کلی، فراخوانی یک متد با لیستی از "
"آرگومان ها *n* معادل فراخوانی تابع متناظر با یک لیست آرگومان است که با وارد "
"کردن شیء نمونه متد قبل از اولین آرگومان ایجاد می شود."

#: ../../tutorial/classes.rst:389
msgid ""
"In general, methods work as follows.  When a non-data attribute of an "
"instance is referenced, the instance's class is searched. If the name "
"denotes a valid class attribute that is a function object, references to "
"both the instance object and the function object are packed into a method "
"object.  When the method object is called with an argument list, a new "
"argument list is constructed from the instance object and the argument list, "
"and the function object is called with this new argument list."
msgstr ""
"به طور کلی، متدها به صورت زیر عمل می کنند. وقتی یک ویژگی غیر داده ای از یک "
"نمونه ارجاع داده می شود، کلاس نمونه جستجو می شود. اگر نام نشان دهنده یک "
"ویژگی معتبر کلاس باشد که یک شیء تابع است، ارجاعات به هر دو شیء نمونه و شیء "
"تابع در یک شیء متد بسته بندی می شوند. هنگامی که شیء متد با یک فهرست آرگومان "
"فراخوانی می شود، یک فهرست آرگومان جدید از شیء نمونه و فهرست آرگومان ساخته می "
"شود، و شیء تابع با این فهرست آرگومان جدید فراخوانی می شود."

#: ../../tutorial/classes.rst:402
msgid "Class and Instance Variables"
msgstr "کلاس و متغیرهای نمونه"

#: ../../tutorial/classes.rst:404
msgid ""
"Generally speaking, instance variables are for data unique to each instance "
"and class variables are for attributes and methods shared by all instances "
"of the class::"
msgstr ""
"به طور کلی، متغیر های نمونه برای داده های منحصر به فرد هر نمونه و متغیر های "
"کلاسی برای خصوصیات و روش هایی استفاده می شوند که توسط تمام نمونه های کلاس به "
"اشتراک گذاشته می شوند::"

#: ../../tutorial/classes.rst:426
msgid ""
"As discussed in :ref:`tut-object`, shared data can have possibly surprising "
"effects with involving :term:`mutable` objects such as lists and "
"dictionaries. For example, the *tricks* list in the following code should "
"not be used as a class variable because just a single list would be shared "
"by all *Dog* instances::"
msgstr ""
"همانطور که در :ref:`tut-object` بحث شد، داده های مشترک می توانند تأثیرات "
"شگفت آوری در گیر کردن اشیاء :term:`mutable` مانند لیست ها و دیکشنری ها داشته "
"باشند. به عنوان مثال، لیست *tricks* در کد زیر نباید به عنوان یک متغیر کلاس "
"استفاده شود زیرا تنها یک لیست توسط تمام نمونه های *Dog* به اشتراک گذاشته می "
"شود::"

#: ../../tutorial/classes.rst:449
msgid "Correct design of the class should use an instance variable instead::"
msgstr "طراحی صحیح کلاس باید به جای آن از یک متغیر نمونه استفاده کند::"

#: ../../tutorial/classes.rst:473
msgid "Random Remarks"
msgstr "نکات تصادفی"

#: ../../tutorial/classes.rst:477
msgid ""
"If the same attribute name occurs in both an instance and in a class, then "
"attribute lookup prioritizes the instance::"
msgstr ""
"اگر یک نام ویژگی هم در یک نمونه و هم در یک کلاس وجود داشته باشد، جستجوی "
"ویژگی به نمونه اولویت می دهد::"

#: ../../tutorial/classes.rst:492
msgid ""
"Data attributes may be referenced by methods as well as by ordinary users "
"(\"clients\") of an object.  In other words, classes are not usable to "
"implement pure abstract data types.  In fact, nothing in Python makes it "
"possible to enforce data hiding --- it is all based upon convention.  (On "
"the other hand, the Python implementation, written in C, can completely hide "
"implementation details and control access to an object if necessary; this "
"can be used by extensions to Python written in C.)"
msgstr ""
"ویژگی های داده ها ممکن است هم توسط متدها و هم توسط کاربران عادی "
"(\"مشتریان\") یک شیء مورد استفاده قرار گیرند. به عبارت دیگر، کلاس ها برای "
"پیاده سازی انواع داده های انتزاعی ناب قابل استفاده نیستند. در واقع، هیچ چیزی "
"در پایتون امکان پنهان سازی داده ها را به طور کامل فراهم نمی کند --- همه چیز "
"بر اساس قرارداد انجام می شود. (از طرف دیگر، پیاده سازی پایتون که به زبان C "
"نوشته شده است، می تواند جزئیات پیاده سازی را به طور کامل پنهان کند و در صورت "
"نیاز دسترسی به یک شیء را کنترل نماید؛ این قابلیت می تواند توسط افزونه های "
"نوشته شده به زبان C برای پایتون استفاده شود.)"

#: ../../tutorial/classes.rst:500
msgid ""
"Clients should use data attributes with care --- clients may mess up "
"invariants maintained by the methods by stamping on their data attributes.  "
"Note that clients may add data attributes of their own to an instance object "
"without affecting the validity of the methods, as long as name conflicts are "
"avoided --- again, a naming convention can save a lot of headaches here."
msgstr ""
"مشتریان باید با دقت از ویژگی های داده استفاده کنند --- ممکن است مشتریان با "
"تداخل در ویژگی های داده خود، ناپایداری هایی که توسط متدها حفظ می شود را به "
"هم بزنند. توجه داشته باشید که مشتریان ممکن است ویژگی های داده خود را بدون "
"تأثیر بر اعتبار متدها به یک شیء مثال اضافه کنند، به شرط اینکه از تداخل نام "
"ها جلوگیری شود --- مجدد، یک کنوانسیون نام گذاری می تواند بسیاری از مشکلات را "
"در اینجا حل کند."

#: ../../tutorial/classes.rst:506
msgid ""
"There is no shorthand for referencing data attributes (or other methods!) "
"from within methods.  I find that this actually increases the readability of "
"methods: there is no chance of confusing local variables and instance "
"variables when glancing through a method."
msgstr ""
"هیچ روش کوتاهی برای ارجاع به ویژگی های داده (یا روش های دیگر!) از درون متدها "
"وجود ندارد. من معتقدم که این در واقع خوانایی متدها را افزایش می دهد: هیچ "
"احتمالی برای اشتباه گرفتن متغیرهای محلی و متغیرهای نمونه در هنگام مرور سریع "
"یک متد وجود ندارد."

#: ../../tutorial/classes.rst:511
msgid ""
"Often, the first argument of a method is called ``self``.  This is nothing "
"more than a convention: the name ``self`` has absolutely no special meaning "
"to Python.  Note, however, that by not following the convention your code "
"may be less readable to other Python programmers, and it is also conceivable "
"that a *class browser* program might be written that relies upon such a "
"convention."
msgstr ""
"اغلباً، اولین آرگومان یک متد ``self`` نامیده می شود. این تنها یک قرارداد است: "
"نام ``self`` هیچ معنای خاصی برای پایتون ندارد. اما توجه داشته باشید که با "
"رعایت نکردن این قرارداد، امکان دارد کد شما برای دیگر برنامه نویسان پایتون "
"کمتر قابل خواندن باشد و همچنین ممکن است یک برنامه *class browser* نوشته شود "
"که به چنین قراردادی وابسته باشد."

#: ../../tutorial/classes.rst:517
msgid ""
"Any function object that is a class attribute defines a method for instances "
"of that class.  It is not necessary that the function definition is "
"textually enclosed in the class definition: assigning a function object to a "
"local variable in the class is also ok.  For example::"
msgstr ""
"هر شیء تابع ای که یک ویژگی کلاس باشد، یک متد برای نمونه های آن کلاس تعریف می "
"کند. ضروری نیست که تعریف تابع به طور متنی در تعریف کلاس قرار بگیرد: تخصیص یک "
"شیء تابع به یک متغیر محلی در کلاس نیز قابل قبول است. برای مثال:"

#: ../../tutorial/classes.rst:534
msgid ""
"Now ``f``, ``g`` and ``h`` are all attributes of class :class:`!C` that "
"refer to function objects, and consequently they are all methods of "
"instances of :class:`!C` --- ``h`` being exactly equivalent to ``g``.  Note "
"that this practice usually only serves to confuse the reader of a program."
msgstr ""
"اکنون ``f``، ``g`` و ``h`` همگی خصوصیاتی از کلاس :class:`!C` هستند که به "
"اشیاء تابع اشاره دارند و به تبع آن، همگی متدهای نمونه های :class:`!C` هستند "
"--- ``h`` دقیقاً معادل ``g`` است. توجه داشته باشید که این رویکرد معمولاً تنها "
"باعث سردرگمی خواننده یک برنامه می شود."

#: ../../tutorial/classes.rst:539
msgid ""
"Methods may call other methods by using method attributes of the ``self`` "
"argument::"
msgstr ""
"متدها می توانند با استفاده از ویژگی های متد آرگومان ``self``، متدهای دیگر را "
"فراخوانی کنند:"

#: ../../tutorial/classes.rst:553
msgid ""
"Methods may reference global names in the same way as ordinary functions.  "
"The global scope associated with a method is the module containing its "
"definition.  (A class is never used as a global scope.)  While one rarely "
"encounters a good reason for using global data in a method, there are many "
"legitimate uses of the global scope: for one thing, functions and modules "
"imported into the global scope can be used by methods, as well as functions "
"and classes defined in it.  Usually, the class containing the method is "
"itself defined in this global scope, and in the next section we'll find some "
"good reasons why a method would want to reference its own class."
msgstr ""
"متدها می توانند به همان شکلی که توابع عادی به نام های عمومی ارجاع می دهند، "
"به نام های عمومی دسترسی داشته باشند. دامنه عمومی مرتبط با یک متد، ماژولی است "
"که تعریف آن را در بر می گیرد. (یک کلاس هرگز به عنوان یک دامنه عمومی استفاده "
"نمی شود.) در حالی که به ندرت دلایل خوبی برای استفاده از داده های عمومی در یک "
"متد دیده می شود، استفاده زیادی از دامنه عمومی وجود دارد: برای مثال، توابع و "
"ماژول هایی که به دامنه عمومی وارد شده اند، می توانند توسط متدها و همچنین "
"توابع و کلاس هایی که در آن تعریف شده اند، استفاده شوند. به طور معمول، کلاسی "
"که حاوی متد است، به خودی خود در این دامنه عمومی تعریف می شود و در بخش بعدی "
"به دلایل خوبی خواهیم پرداخت که چرا یک متد ممکن است بخواهد به کلاس خودش ارجاع "
"دهد."

#: ../../tutorial/classes.rst:563
msgid ""
"Each value is an object, and therefore has a *class* (also called its "
"*type*). It is stored as ``object.__class__``."
msgstr ""
"هر مقدار یک شیء است، و بنابراین دارای *class* (که همچنین به عنوان *type* "
"نامیده می شود) است. این به صورت ``object.__class__`` ذخیره می شود."

#: ../../tutorial/classes.rst:570
msgid "Inheritance"
msgstr "وراثت"

#: ../../tutorial/classes.rst:572
msgid ""
"Of course, a language feature would not be worthy of the name \"class\" "
"without supporting inheritance.  The syntax for a derived class definition "
"looks like this::"
msgstr ""
"البته، یک ویژگی زبانی بدون پشتیبانی از ارث بری شایسته ی نام \"کلاس\" نخواهد "
"بود.  نحو تعریف یک کلاس مشتق به این شکل است::"

#: ../../tutorial/classes.rst:583
msgid ""
"The name :class:`!BaseClassName` must be defined in a scope containing the "
"derived class definition.  In place of a base class name, other arbitrary "
"expressions are also allowed.  This can be useful, for example, when the "
"base class is defined in another module::"
msgstr ""

#: ../../tutorial/classes.rst:590
msgid ""
"Execution of a derived class definition proceeds the same as for a base "
"class. When the class object is constructed, the base class is remembered.  "
"This is used for resolving attribute references: if a requested attribute is "
"not found in the class, the search proceeds to look in the base class.  This "
"rule is applied recursively if the base class itself is derived from some "
"other class."
msgstr ""
"اجرای تعریف یک کلاس مشتق شده به همان صورتی که برای یک کلاس پایه انجام می "
"شود، پیش می رود. وقتی شیء کلاس ساخته می شود، کلاس پایه به خاطر سپرده می شود. "
"این برای حل مرجع های ویژگی استفاده می شود: اگر یک ویژگی درخواست شده در کلاس "
"پیدا نشود، جستجو به کلاس پایه ادامه می یابد. این قاعده به صورت بازگشتی اعمال "
"می شود اگر کلاس پایه خود از کلاس دیگری مشتق شده باشد."

#: ../../tutorial/classes.rst:596
msgid ""
"There's nothing special about instantiation of derived classes: "
"``DerivedClassName()`` creates a new instance of the class.  Method "
"references are resolved as follows: the corresponding class attribute is "
"searched, descending down the chain of base classes if necessary, and the "
"method reference is valid if this yields a function object."
msgstr ""
"چیزی خاصی درباره ایجاد نمونه از کلاس های مشتق شده وجود ندارد: "
"``DerivedClassName()`` یک نمونه جدید از کلاس را ایجاد می کند. به روش های "
"ارجاع به این صورت پرداخته می شود: ویژگی کلاس متناظر جستجو می شود، و در صورت "
"لزوم به سمت پایین زنجیره کلاس های پایه حرکت کرده و اگر این جستجو یک شیء تابع "
"را برگرداند، ارجاع به روش معتبر است."

#: ../../tutorial/classes.rst:602
msgid ""
"Derived classes may override methods of their base classes.  Because methods "
"have no special privileges when calling other methods of the same object, a "
"method of a base class that calls another method defined in the same base "
"class may end up calling a method of a derived class that overrides it.  "
"(For C++ programmers: all methods in Python are effectively ``virtual``.)"
msgstr ""
"کلاس های مشتق شده ممکن است متدهای کلاس های پایه خود را بازنویسی کنند. از "
"آنجایی که متدها هنگام فراخوانی سایر متدهای همان شیء هیچ امتیاز ویژه ای "
"ندارند، یک متد از کلاس پایه که متد دیگری را که در همان کلاس پایه تعریف شده "
"فراخوانی می کند ممکن است در نهایت متدی از یک کلاس مشتق شده را که آن را "
"بازنویسی کرده است، فراخوانی کند. (برای برنامه نویسان C++: تمام متدها در "
"پایتون به طور مؤثر ``virtual`` هستند.)"

#: ../../tutorial/classes.rst:608
msgid ""
"An overriding method in a derived class may in fact want to extend rather "
"than simply replace the base class method of the same name. There is a "
"simple way to call the base class method directly: just call ``BaseClassName."
"methodname(self, arguments)``.  This is occasionally useful to clients as "
"well.  (Note that this only works if the base class is accessible as "
"``BaseClassName`` in the global scope.)"
msgstr ""
"در یک کلاس مشتق شده، یک متد جایگزین می تواند بخواهد به جای اینکه صرفاً متد "
"کلاس پایه با همان نام را جایگزین کند، آن را گسترش دهد. یک راه ساده برای "
"فراخوانی مستقیم متد کلاس پایه وجود دارد: فقط ``BaseClassName."
"methodname(self, arguments)`` را فراخوانی کنید. این روش گاهی برای کاربران "
"نیز مفید است. (توجه داشته باشید که این تنها زمانی کار می کند که کلاس پایه به "
"عنوان ``BaseClassName`` در حوزهٔ جهانی در دسترس باشد.)"

#: ../../tutorial/classes.rst:615
msgid "Python has two built-in functions that work with inheritance:"
msgstr "پایتون دو تابع داخلی دارد که با ارث بری کار می کنند:"

#: ../../tutorial/classes.rst:617
msgid ""
"Use :func:`isinstance` to check an instance's type: ``isinstance(obj, int)`` "
"will be ``True`` only if ``obj.__class__`` is :class:`int` or some class "
"derived from :class:`int`."
msgstr ""
"از :func:`isinstance` برای بررسی نوع یک نمونه استفاده کنید: "
"``isinstance(obj, int)`` فقط زمانی ``True`` خواهد بود که ``obj.__class__`` "
"برابر با :class:`int` یا کلاسی که از :class:`int` مشتق شده است باشد."

#: ../../tutorial/classes.rst:621
msgid ""
"Use :func:`issubclass` to check class inheritance: ``issubclass(bool, int)`` "
"is ``True`` since :class:`bool` is a subclass of :class:`int`.  However, "
"``issubclass(float, int)`` is ``False`` since :class:`float` is not a "
"subclass of :class:`int`."
msgstr ""
"از :func:`issubclass` برای بررسی وراثت کلاس ها استفاده کنید: "
"``issubclass(bool, int)`` از ``True`` است چونکه :class:`bool` یک زیرکلاس از :"
"class:`int` است. با این حال، ``issubclass(float, int)`` از ``False`` نیست "
"چونکه :class:`float` یک زیرکلاس از :class:`int` نیست."

#: ../../tutorial/classes.rst:631
msgid "Multiple Inheritance"
msgstr "وراثت چندگانه"

#: ../../tutorial/classes.rst:633
msgid ""
"Python supports a form of multiple inheritance as well.  A class definition "
"with multiple base classes looks like this::"
msgstr ""
"پایتون از نوعی از وراثت چندگانه نیز پشتیبانی می کند. تعریف یک کلاس با چندین "
"کلاس پایه به این شکل است::"

#: ../../tutorial/classes.rst:643
msgid ""
"For most purposes, in the simplest cases, you can think of the search for "
"attributes inherited from a parent class as depth-first, left-to-right, not "
"searching twice in the same class where there is an overlap in the "
"hierarchy. Thus, if an attribute is not found in :class:`!DerivedClassName`, "
"it is searched for in :class:`!Base1`, then (recursively) in the base "
"classes of :class:`!Base1`, and if it was not found there, it was searched "
"for in :class:`!Base2`, and so on."
msgstr ""
"برای بیشتر مقاصد، در ساده ترین موارد، می توانید جستجوی ویژگی های به ارث برده "
"شده از یک کلاس والد را به صورت عمق اول، از چپ به راست در نظر بگیرید، به طوری "
"که در جایی که در سلسله مراتب هم پوشانی وجود دارد، در یک کلاس دوبار جستجو "
"نشود. بنابراین، اگر یک ویژگی در :class:`!DerivedClassName` پیدا نشد، در :"
"class:`!Base1` جستجو می شود، سپس (به صورت بازگشتی) در کلاس های پایه :class:`!"
"Base1` جستجو می شود، و اگر در آنجا یافت نشد، در :class:`!Base2` جستجو می "
"شود، و به همین ترتیب ادامه دارد."

#: ../../tutorial/classes.rst:650
msgid ""
"In fact, it is slightly more complex than that; the method resolution order "
"changes dynamically to support cooperative calls to :func:`super`.  This "
"approach is known in some other multiple-inheritance languages as call-next-"
"method and is more powerful than the super call found in single-inheritance "
"languages."
msgstr ""
"در واقع، این کمی پیچیده تر از آن است؛ ترتیب حل روش به صورت دینامیکی تغییر می "
"کند تا از فراخوانی های تعاونی برای :func:`super` پشتیبانی کند. این رویکرد در "
"برخی زبان های چند-ارث بری دیگر به عنوان call-next-method شناخته می شود و "
"قدرتمندتر از فراخوانی super که در زبان های ارث بری منفرد یافت می شود، است."

#: ../../tutorial/classes.rst:656
msgid ""
"Dynamic ordering is necessary because all cases of multiple inheritance "
"exhibit one or more diamond relationships (where at least one of the parent "
"classes can be accessed through multiple paths from the bottommost class).  "
"For example, all classes inherit from :class:`object`, so any case of "
"multiple inheritance provides more than one path to reach :class:`object`.  "
"To keep the base classes from being accessed more than once, the dynamic "
"algorithm linearizes the search order in a way that preserves the left-to-"
"right ordering specified in each class, that calls each parent only once, "
"and that is monotonic (meaning that a class can be subclassed without "
"affecting the precedence order of its parents). Taken together, these "
"properties make it possible to design reliable and extensible classes with "
"multiple inheritance.  For more detail, see https://www.python.org/download/"
"releases/2.3/mro/."
msgstr ""

#: ../../tutorial/classes.rst:673
msgid "Private Variables"
msgstr "متغیرهای خصوصی"

#: ../../tutorial/classes.rst:675
msgid ""
"\"Private\" instance variables that cannot be accessed except from inside an "
"object don't exist in Python.  However, there is a convention that is "
"followed by most Python code: a name prefixed with an underscore (e.g. "
"``_spam``) should be treated as a non-public part of the API (whether it is "
"a function, a method or a data member).  It should be considered an "
"implementation detail and subject to change without notice."
msgstr ""
"متغیرهای نمونه \"خصوصی\" که نمی توان به جز از داخل یک شیء به آن ها دسترسی "
"داشت در پایتون وجود ندارند. با این حال، یک قرارداد وجود دارد که توسط بیشتر "
"کدهای پایتون رعایت می شود: یک نام که با یک آندرلاین پیشوند شده است (برای "
"مثال ``_spam``) باید به عنوان بخشی غیرعمومی از API در نظر گرفته شود (چه "
"کاربرد یک تابع، یک روش یا یک عضو داده باشد). باید به عنوان یک جزئیات پیاده "
"سازی تلقی شود و ممکن است بدون هشدار قبلی تغییر کند."

#: ../../tutorial/classes.rst:685
msgid ""
"Since there is a valid use-case for class-private members (namely to avoid "
"name clashes of names with names defined by subclasses), there is limited "
"support for such a mechanism, called :dfn:`name mangling`.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with leading underscore(s) "
"stripped.  This mangling is done without regard to the syntactic position of "
"the identifier, as long as it occurs within the definition of a class."
msgstr ""
"از آنجا که استفاده موجه ای برای اعضای خصوصی کلاس وجود دارد (یعنی به منظور "
"جلوگیری از تداخل نام ها با نام هایی که توسط زیرکلاس ها تعریف شده اند)، "
"پشتیبانی محدودی برای چنین مکانیزمی به نام :dfn:`تغییر نام` وجود دارد. هر "
"شناسه ای به فرم ``__spam`` (حداقل با دو زیرخط ابتدایی و حداکثر یک زیرخط "
"انتهایی) به صورت متنی با ``_classname__spam`` جایگزین می شود، که در آن "
"``classname`` نام کلاس جاری است با حذف زیرخط های اولیه. این تغییر نام بدون "
"توجه به موقعیت نحوی شناسه انجام می شود، تا زمانی که در تعریف یک کلاس رخ دهد."

#: ../../tutorial/classes.rst:694
msgid ""
"Name mangling is helpful for letting subclasses override methods without "
"breaking intraclass method calls.  For example::"
msgstr ""
"نام گذاری مخفی برای اجازه دادن به زیربخش ها برای نادیده گرفتن روش ها بدون "
"شکستن فراخوانی های روش درون کلاسی مفید است. به عنوان مثال:"

#: ../../tutorial/classes.rst:716
msgid ""
"The above example would work even if ``MappingSubclass`` were to introduce a "
"``__update`` identifier since it is replaced with ``_Mapping__update`` in "
"the ``Mapping`` class  and ``_MappingSubclass__update`` in the "
"``MappingSubclass`` class respectively."
msgstr ""
"مثال بالا حتی اگر ``MappingSubclass`` یک شناسه ``__update`` معرفی کند نیز "
"کار خواهد کرد زیرا در کلاس ``Mapping`` با ``_Mapping__update`` و در کلاس "
"``MappingSubclass`` با ``_MappingSubclass__update`` جایگزین می شود."

#: ../../tutorial/classes.rst:721
msgid ""
"Note that the mangling rules are designed mostly to avoid accidents; it "
"still is possible to access or modify a variable that is considered "
"private.  This can even be useful in special circumstances, such as in the "
"debugger."
msgstr ""
"توجه داشته باشید که قوانین مبهم سازی عمدتاً برای جلوگیری از تصادفات طراحی شده "
"اند؛ همچنان ممکن است به یک متغیر که خصوصی محسوب می شود دسترسی پیدا کرده یا "
"آن را تغییر دهید. این امر حتی می تواند در شرایط خاص، مانند درون دیباگر مفید "
"باشد."

#: ../../tutorial/classes.rst:725
msgid ""
"Notice that code passed to ``exec()`` or ``eval()`` does not consider the "
"classname of the invoking class to be the current class; this is similar to "
"the effect of the ``global`` statement, the effect of which is likewise "
"restricted to code that is byte-compiled together.  The same restriction "
"applies to ``getattr()``, ``setattr()`` and ``delattr()``, as well as when "
"referencing ``__dict__`` directly."
msgstr ""
"توجه داشته باشید که کدی که به ``exec()`` یا ``eval()`` ارسال می شود، "
"classname کلاس فراخوانی شده را به عنوان کلاس فعلی در نظر نمی گیرد؛ این مشابه "
"تأثیر جمله ``global`` است که اثر آن نیز به کدی محدود می شود که با هم byte-"
"compiled شده اند. همین محدودیت برای ``getattr()``، ``setattr()`` و "
"``delattr()`` نیز اعمال می شود، همچنین زمانی که به طور مستقیم به "
"``__dict__`` ارجاع داده می شود."

#: ../../tutorial/classes.rst:736
msgid "Odds and Ends"
msgstr "Odds and Ends"

#: ../../tutorial/classes.rst:738
msgid ""
"Sometimes it is useful to have a data type similar to the Pascal \"record\" "
"or C \"struct\", bundling together a few named data items. The idiomatic "
"approach is to use :mod:`dataclasses` for this purpose::"
msgstr ""
"گاهی اوقات داشتن یک نوع داده مشابه به \"record\" در زبان Pascal یا "
"\"struct\" در زبان C، که چند آیتم داده ای با نام های مشخص را با هم جمع می "
"کند، مفید است. روش ایدیوماتیک برای این منظور استفاده از :mod:`dataclasses` "
"است::"

#: ../../tutorial/classes.rst:758
msgid ""
"A piece of Python code that expects a particular abstract data type can "
"often be passed a class that emulates the methods of that data type "
"instead.  For instance, if you have a function that formats some data from a "
"file object, you can define a class with methods :meth:`~io.TextIOBase.read` "
"and :meth:`~io.TextIOBase.readline` that get the data from a string buffer "
"instead, and pass it as an argument."
msgstr ""
"وقتی که یک قطعه کد Python نیاز به یک نوع داده انتزاعی خاص دارد، اغلب می توان "
"بجای آن یک کلاسی که روش های آن نوع داده را شبیه سازی می کند، پاس کرد. به "
"عنوان مثال، اگر تابعی دارید که داده هایی را از یک شیء فایل فرمت می کند، می "
"توانید کلاسی با روش های :meth:`~io.TextIOBase.read` و :meth:`~io.TextIOBase."
"readline` تعریف کنید که داده ها را از یک بافر رشته ای دریافت کند و آن را به "
"عنوان یک آرگومان پاس کنید."

#: ../../tutorial/classes.rst:770
msgid ""
":ref:`Instance method objects <instance-methods>` have attributes, too: :"
"attr:`m.__self__ <method.__self__>` is the instance object with the method :"
"meth:`!m`, and :attr:`m.__func__ <method.__func__>` is the :ref:`function "
"object <user-defined-funcs>` corresponding to the method."
msgstr ""
":ref:`Instance method objects <instance-methods>` نیز ویژگی هایی دارند: :"
"attr:`m.__self__ <method.__self__>` شیء نمونه با متد :meth:`!m` است و :attr:"
"`m.__func__ <method.__func__>` همان :ref:`function object <user-defined-"
"funcs>` مربوط به متد است."

#: ../../tutorial/classes.rst:780
msgid "Iterators"
msgstr "ترتیب دهنده ها"

#: ../../tutorial/classes.rst:782
msgid ""
"By now you have probably noticed that most container objects can be looped "
"over using a :keyword:`for` statement::"
msgstr ""
"احتمالاً تا حالا متوجه شده اید که اکثر اشیاء ظرفی می توانند با استفاده از یک "
"عبارت :keyword:`for` حلقه زده شوند::"

#: ../../tutorial/classes.rst:796
msgid ""
"This style of access is clear, concise, and convenient.  The use of "
"iterators pervades and unifies Python.  Behind the scenes, the :keyword:"
"`for` statement calls :func:`iter` on the container object.  The function "
"returns an iterator object that defines the method :meth:`~iterator."
"__next__` which accesses elements in the container one at a time.  When "
"there are no more elements, :meth:`~iterator.__next__` raises a :exc:"
"`StopIteration` exception which tells the :keyword:`!for` loop to "
"terminate.  You can call the :meth:`~iterator.__next__` method using the :"
"func:`next` built-in function; this example shows how it all works::"
msgstr ""
"این سبک دسترسی واضح، مختصر و راحت است. استفاده از پیمانه ها در سراسر Python "
"گسترده و یگانه است. در پشت صحنه، عبارت :keyword:`for` تابع :func:`iter` را "
"بر روی شیء ظرف فراخوانی می کند. این تابع شیء پیمانه ای را برمی گرداند که "
"متد :meth:`~iterator.__next__` را تعریف می کند که عناصر را در ظرف یکی یکی "
"دسترسی می دهد. زمانی که دیگر هیچ عنصری باقی نیست، :meth:`~iterator.__next__` "
"یک استثنای :exc:`StopIteration` را برمی انگیزد که به حلقه ی :keyword:`!for` "
"می گوید که متوقف شود. شما می توانید متد :meth:`~iterator.__next__` را با "
"استفاده از تابع داخلی :func:`next` فراخوانی کنید؛ این مثال نشان می دهد که "
"همه این کارها چگونه انجام می شود:"

#: ../../tutorial/classes.rst:821
msgid ""
"Having seen the mechanics behind the iterator protocol, it is easy to add "
"iterator behavior to your classes.  Define an :meth:`~container.__iter__` "
"method which returns an object with a :meth:`~iterator.__next__` method.  If "
"the class defines :meth:`!__next__`, then :meth:`!__iter__` can just return "
"``self``::"
msgstr ""
"با مشاهده مکانیزم های پشت پروتکل تکرارگر، افزودن رفتار تکرارگر به کلاس "
"هایتان آسان است. یک متد :meth:`~container.__iter__` تعریف کنید که یک شیء با "
"متد :meth:`~iterator.__next__` را بازگشت دهد. اگر کلاس :meth:`!__next__` را "
"تعریف کند، آنگاه :meth:`!__iter__` می تواند فقط ``self`` را بازگرداند::"

#: ../../tutorial/classes.rst:858
msgid "Generators"
msgstr "تولیدکننده ها"

#: ../../tutorial/classes.rst:860
msgid ""
":term:`Generators <generator>` are a simple and powerful tool for creating "
"iterators.  They are written like regular functions but use the :keyword:"
"`yield` statement whenever they want to return data.  Each time :func:`next` "
"is called on it, the generator resumes where it left off (it remembers all "
"the data values and which statement was last executed).  An example shows "
"that generators can be trivially easy to create::"
msgstr ""
":term:`Generators <generator>` یک ابزار ساده و قدرتمند برای ایجاد "
"اینتراتورها هستند. آنها مانند توابع عادی نوشته می شوند اما هر زمان که می "
"خواهند داده ای را بازگردانند از دستور :keyword:`yield` استفاده می کنند. هر "
"بار که :func:`next` بر روی آن فراخوانی می شود، مولد از جایی که متوقف شده "
"ادامه می یابد (تمام مقادیر داده ها و اینکه آخرین دستور اجرا شده چه بوده را "
"به خاطر می آورد). یک مثال نشان می دهد که ایجاد مولدها می تواند به طرز "
"باورنکردنی ساده باشد::"

#: ../../tutorial/classes.rst:881
msgid ""
"Anything that can be done with generators can also be done with class-based "
"iterators as described in the previous section.  What makes generators so "
"compact is that the :meth:`~iterator.__iter__` and :meth:`~generator."
"__next__` methods are created automatically."
msgstr ""
"هر چیزی که با تولیدکننده ها (generators) قابل انجام است، می تواند با استفاده "
"از تکرارگرهای مبتنی بر کلاس نیز انجام شود، همانطور که در بخش قبلی توضیح داده "
"شد. آنچه تولیدکننده ها را فشرده می کند، این است که روش های :meth:`~iterator."
"__iter__` و :meth:`~generator.__next__` به طور خودکار ایجاد می شوند."

#: ../../tutorial/classes.rst:886
msgid ""
"Another key feature is that the local variables and execution state are "
"automatically saved between calls.  This made the function easier to write "
"and much more clear than an approach using instance variables like ``self."
"index`` and ``self.data``."
msgstr ""
"یکی دیگر از ویژگی های کلیدی این است که متغیرهای محلی و وضعیت اجرا به طور "
"خودکار بین فراخوانی ها ذخیره می شوند. این امر نوشتن تابع را آسان تر و خیلی "
"واضح تر از رویکردی که از متغیرهای نمونه ای مانند ``self.index`` و ``self."
"data`` استفاده می کند، کرده است."

#: ../../tutorial/classes.rst:891
msgid ""
"In addition to automatic method creation and saving program state, when "
"generators terminate, they automatically raise :exc:`StopIteration`. In "
"combination, these features make it easy to create iterators with no more "
"effort than writing a regular function."
msgstr ""
"علاوه بر ایجاد خودکار متدها و ذخیره سازی وضعیت برنامه، زمانی که جنراتورها "
"خاتمه می یابند، به طور خودکار :exc:`StopIteration` را ایجاد می کنند. این "
"ویژگی ها به صورت ترکیبی، ساختن تکرارگرها را به همان سادگی نوشتن یک تابع عادی "
"امکان پذیر می سازند."

#: ../../tutorial/classes.rst:900
msgid "Generator Expressions"
msgstr ""
"Generator Expressions\n"
"\n"
"تعبیرات مولد شبیه به لیست  comprehensions هستند ولی به جای تولید یک لیست "
"کامل، یک مولد ایجاد می کنند که مقادیر را به تدریج تولید می کند. این می تواند "
"باعث بهینه سازی حافظه شود و برای پردازش داده های بزرگ مفید باشد. تعبیرات "
"مولد به کمک پرانتز دور نتیجه نوشته می شوند، در حالی که لیست  comprehensions "
"از براکت ها استفاده می کنند."

#: ../../tutorial/classes.rst:902
msgid ""
"Some simple generators can be coded succinctly as expressions using a syntax "
"similar to list comprehensions but with parentheses instead of square "
"brackets. These expressions are designed for situations where the generator "
"is used right away by an enclosing function.  Generator expressions are more "
"compact but less versatile than full generator definitions and tend to be "
"more memory friendly than equivalent list comprehensions."
msgstr ""
"برخی از مولدهای ساده را می توان به صورت مختصر به عنوان عباراتی با استفاده از "
"یک نحو مشابه با درک لیست ها اما با پرانتز به جای کروشه کد کرد. این عبارات "
"برای موقعیت هایی طراحی شده اند که در آن مولد بلافاصله توسط یک تابع فراگیر "
"استفاده می شود. عبارات مولد فشرده تر اما کمتر انعطاف پذیر از تعاریف کامل "
"مولد هستند و به طور معمول نسبت به درک لیست های معادل، حافظه بیشتری را صرفه "
"جویی می کنند."

#: ../../tutorial/classes.rst:909
msgid "Examples::"
msgstr "مثال ها::"

#: ../../tutorial/classes.rst:930
msgid "Footnotes"
msgstr "پاورقی ها"

#: ../../tutorial/classes.rst:931
msgid ""
"Except for one thing.  Module objects have a secret read-only attribute "
"called :attr:`~object.__dict__` which returns the dictionary used to "
"implement the module's namespace; the name :attr:`~object.__dict__` is an "
"attribute but not a global name. Obviously, using this violates the "
"abstraction of namespace implementation, and should be restricted to things "
"like post-mortem debuggers."
msgstr ""

#: ../../tutorial/classes.rst:347
msgid "object"
msgstr "شیء"

#: ../../tutorial/classes.rst:347
msgid "method"
msgstr "متد"

#: ../../tutorial/classes.rst:682
msgid "name"
msgstr "نام"

#: ../../tutorial/classes.rst:682
msgid "mangling"
msgstr "مخفی سازی نام"
