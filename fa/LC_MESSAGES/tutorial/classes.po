# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 14:21+0000\n"
"PO-Revision-Date: 2025-07-18 18:50+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Persian (https://app.transifex.com/python-doc/teams/5390/"
"fa/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fa\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../tutorial/classes.rst:5
msgid "Classes"
msgstr "کلاس ها"

#: ../../tutorial/classes.rst:7
msgid ""
"Classes provide a means of bundling data and functionality together.  "
"Creating a new class creates a new *type* of object, allowing new "
"*instances* of that type to be made.  Each class instance can have "
"attributes attached to it for maintaining its state.  Class instances can "
"also have methods (defined by its class) for modifying its state."
msgstr ""
"کلاس ها وسیله ای را برای بسته بندی کردن داده و عملکرد با هم فراهم می کنند. "
"ایجاد یک کلاس جدید، نوع جدیدی ایجاد می کند که اجازه می دهد موارد جدیدی از آن "
"نوع ساخته شود. هر نمونه از کلاس می تواند صفاتی داشته باشد که به آن متصل شده "
"اند تا وضعیت آن را حفظ کنند. نمونه های کلاس می توانند همچنین متدهایی (که "
"توسط کلاس تعریف شده اند) داشته باشند تا وضعیت آن را تغییر دهند."

#: ../../tutorial/classes.rst:13
msgid ""
"Compared with other programming languages, Python's class mechanism adds "
"classes with a minimum of new syntax and semantics.  It is a mixture of the "
"class mechanisms found in C++ and Modula-3.  Python classes provide all the "
"standard features of Object Oriented Programming: the class inheritance "
"mechanism allows multiple base classes, a derived class can override any "
"methods of its base class or classes, and a method can call the method of a "
"base class with the same name.  Objects can contain arbitrary amounts and "
"kinds of data.  As is true for modules, classes partake of the dynamic "
"nature of Python: they are created at runtime, and can be modified further "
"after creation."
msgstr ""
"در مقایسه با دیگر زبان های برنامه نویسی، مکانیزم کلاس در پایتون کلاس ها را "
"با حداقل قواعد و معناشناسی جدید اضافه می کند. این مکانیزم ترکیبی از مکانیزم "
"های کلاسی است که در C++ و Modula-3 یافت می شود. کلاس های پایتون تمام ویژگی "
"های استاندارد برنامه نویسی شی گرا را فراهم می کنند: مکانیزم ارث بری کلاس ها "
"اجازه می دهد کلاس های پایه متعددی داشته باشید، یک کلاس مشتق می تواند هر یک "
"از متدهای کلاس های پایه خود را بازنویسی کند و یک متد می تواند متدی از کلاس "
"پایه با همان نام را فراخوانی کند. اشیاء می توانند حاوی مقادیر و انواع داده "
"ای دلخواه باشند. همان طور که برای ماژول ها صادق است، کلاس ها نیز از طبیعت "
"پویا در پایتون برخوردارند: آن ها در زمان اجرا ایجاد می شوند و می توانند پس "
"از ایجاد بیشتر تغییر داده شوند."

#: ../../tutorial/classes.rst:23
msgid ""
"In C++ terminology, normally class members (including the data members) are "
"*public* (except see below :ref:`tut-private`), and all member functions are "
"*virtual*.  As in Modula-3, there are no shorthands for referencing the "
"object's members from its methods: the method function is declared with an "
"explicit first argument representing the object, which is provided "
"implicitly by the call.  As in Smalltalk, classes themselves are objects.  "
"This provides semantics for importing and renaming.  Unlike C++ and "
"Modula-3, built-in types can be used as base classes for extension by the "
"user.  Also, like in C++, most built-in operators with special syntax "
"(arithmetic operators, subscripting etc.) can be redefined for class "
"instances."
msgstr ""
"در اصطلاحات C++، معمولاً اعضای کلاس (از جمله اعضای داده) *public* هستند (به "
"جز موردی که در پایین :ref:`tut-private` ذکر شده است)، و تمامی توابع عضو "
"مجازی  هستند. همان طور که در Modula-3، هیچ میانبرهایی برای ارجاع به اعضای "
"شیء از متدهای آن وجود ندارد: تابع متد با یک آرگومان اول صریح که نمایانگر شیء "
"است، اعلام می شود که این آرگومان به صورت ضمنی توسط فراخوانی فراهم می شود. "
"همان طور که در Smalltalk، خود کلاس ها اشیاء هستند. این ویژگی معناشناسی برای "
"وارد کردن و تغییر نام را فراهم می آورد. برخلاف C++ و Modula-3، نوع های داخلی "
"می توانند به عنوان کلاس های پایه برای توسعه توسط کاربر استفاده شوند. همچنین، "
"مانند C++، بیشتر عملگرهای داخلی با نحوی خاص (عملگرهای ریاضی، زیرنویسی و "
"غیره) می توانند برای نمونه های کلاس بازتعریف شوند."

#: ../../tutorial/classes.rst:34
msgid ""
"(Lacking universally accepted terminology to talk about classes, I will make "
"occasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, "
"since its object-oriented semantics are closer to those of Python than C++, "
"but I expect that few readers have heard of it.)"
msgstr ""
"(با نبود اصطلاحات پذیرفته شده جهانی برای صحبت درباره کلاس‌ها، گاهی از "
"اصطلاحات Smalltalk و C++ استفاده خواهم کرد. من از اصطلاحات Modula-3 استفاده "
"می‌کردم، چون معنای شیءگرای آن به پایتون نزدیک‌تر از C++ است، اما انتظار دارم "
"که تعداد کمی از خوانندگان با آن آشنا باشند.)"

#: ../../tutorial/classes.rst:43
msgid "A Word About Names and Objects"
msgstr "سخنی درباره نام‌ها و اشیاء"

#: ../../tutorial/classes.rst:45
msgid ""
"Objects have individuality, and multiple names (in multiple scopes) can be "
"bound to the same object.  This is known as aliasing in other languages.  "
"This is usually not appreciated on a first glance at Python, and can be "
"safely ignored when dealing with immutable basic types (numbers, strings, "
"tuples).  However, aliasing has a possibly surprising effect on the "
"semantics of Python code involving mutable objects such as lists, "
"dictionaries, and most other types. This is usually used to the benefit of "
"the program, since aliases behave like pointers in some respects.  For "
"example, passing an object is cheap since only a pointer is passed by the "
"implementation; and if a function modifies an object passed as an argument, "
"the caller will see the change --- this eliminates the need for two "
"different argument passing mechanisms as in Pascal."
msgstr ""
"شیء‌ها هویت دارند و چندین نام (در چندین حوزه دید) می‌توانند به یک شیء واحد "
"متصل شوند. این در زبان‌های دیگر به «تخصیص نام مستعار» «aliasing» معروف است. "
"این موضوع معمولاً در اولین نگاه به پایتون قابل درک نیست و هنگام کار با انواع "
"پایه غیرقابل تغییر (مثل اعداد، رشته‌ها، تاپل‌ها) می‌توان آن را نادیده گرفت. اما "
"تخصیص نام مستعار می‌تواند تأثیر قابل توجهی روی معنای کد پایتون داشته باشد، به "
"ویژه وقتی با اشیاء قابل تغییر مثل لیست‌ها، دیکشنری‌ها و بیشتر انواع دیگر سر و "
"کار داریم. این ویژگی معمولاً به نفع برنامه است، زیرا نام‌های مستعار در برخی "
"موارد مانند اشاره‌گرها رفتار می‌کنند. برای مثال، ارسال یک شیء کم‌هزینه است چون "
"فقط یک اشاره‌گر توسط پیاده‌سازی ارسال می‌شود؛ و اگر تابعی شیء ارسال‌شده را تغییر "
"دهد، فراخواننده این تغییر را خواهد دید — این ویژگی باعث می‌شود نیازی به دو "
"مکانیزم مختلف برای ارسال آرگومان همانند پاسکال نباشد."

#: ../../tutorial/classes.rst:61
msgid "Python Scopes and Namespaces"
msgstr "محدوده ها و فضای نام ها در پایتون"

#: ../../tutorial/classes.rst:63
msgid ""
"Before introducing classes, I first have to tell you something about "
"Python's scope rules.  Class definitions play some neat tricks with "
"namespaces, and you need to know how scopes and namespaces work to fully "
"understand what's going on. Incidentally, knowledge about this subject is "
"useful for any advanced Python programmer."
msgstr ""
"قبل از معرفی کلاس ها، ابتدا باید چیزی درباره قوانین حوزه  در پایتون به شما "
"بگویم. تعریف کلاس ها چند ترفند جالب با فضاهای نام انجام می دهد و برای اینکه "
"به طور کامل متوجه شوید چه می گذرد، باید بدانید که حوزه ها و فضاهای نام چگونه "
"کار می کنند. ضمناً، آگاهی از این موضوع برای هر برنامه نویس پیشرفته پایتون "
"مفید است."

#: ../../tutorial/classes.rst:69
msgid "Let's begin with some definitions."
msgstr "بیایید با چند تعریف شروع کنیم."

#: ../../tutorial/classes.rst:71
msgid ""
"A *namespace* is a mapping from names to objects.  Most namespaces are "
"currently implemented as Python dictionaries, but that's normally not "
"noticeable in any way (except for performance), and it may change in the "
"future.  Examples of namespaces are: the set of built-in names (containing "
"functions such as :func:`abs`, and built-in exception names); the global "
"names in a module; and the local names in a function invocation.  In a sense "
"the set of attributes of an object also form a namespace.  The important "
"thing to know about namespaces is that there is absolutely no relation "
"between names in different namespaces; for instance, two different modules "
"may both define a function ``maximize`` without confusion --- users of the "
"modules must prefix it with the module name."
msgstr ""
"«فضای نام»  *namespace* نگاشتی است از نام‌ها به اشیا. بیشتر فضای نام‌ها در حال "
"حاضر به‌صورت دیکشنری‌های پایتون پیاده‌سازی شده‌اند، اما معمولاً این موضوع (به جز "
"در بازدهی «performance» ) قابل مشاهده نیست و ممکن است در آینده تغییر کند. "
"مثال‌هایی از فضای نام عبارت‌اند از: مجموعه نام‌های داخلی (که شامل توابعی مثل :"
"func:`abs` و نام‌های استثنائات داخلی است)؛ نام‌های سراسری در یک ماژول؛ و "
"نام‌های محلی در یک فراخوانی تابع. به نوعی، مجموعه صفات «attributes» یک شی نیز "
"یک فضای نام را تشکیل می‌دهد. نکته مهم درباره فضای نام‌ها این است که هیچ "
"ارتباطی بین نام‌ها در فضای نام‌های مختلف وجود ندارد؛ برای مثال، دو ماژول مختلف "
"می‌توانند هر دو تابعی با نام ``maximize`` تعریف کنند بدون اینکه ابهامی پیش "
"بیاید — استفاده‌کنندگان از ماژول‌ها باید نام ماژول را به عنوان پیشوند بیاورند."

#: ../../tutorial/classes.rst:82
msgid ""
"By the way, I use the word *attribute* for any name following a dot --- for "
"example, in the expression ``z.real``, ``real`` is an attribute of the "
"object ``z``.  Strictly speaking, references to names in modules are "
"attribute references: in the expression ``modname.funcname``, ``modname`` is "
"a module object and ``funcname`` is an attribute of it.  In this case there "
"happens to be a straightforward mapping between the module's attributes and "
"the global names defined in the module: they share the same namespace!  [#]_"
msgstr ""
"به‌هرحال، من واژهٔ *ویژگی* «*attribute*» را برای هر نامی که بعد از یک نقطه "
"بیاید به کار می‌برم — برای مثال، در عبارت ``z.real``, ``real`` یک ویژگیِ شیءِ "
"``z`` است. از نظر دقیق‌تر، ارجاع به نام‌ها در ماژول‌ها نیز نوعی ارجاع به ویژگی "
"محسوب می‌شود: در عبارت ``modname.funcname``, ``modname``  یک شیءِ ماژول است و "
"``funcname`` یکی از ویژگی‌های آن است. در این حالت، نگاشتی ساده و مستقیم بین "
"ویژگی‌های ماژول و نام‌های سراسری تعریف‌شده در آن وجود دارد: هر دو یک فضای نام "
"(namespace) را به اشتراک می‌گذارند! [#]_"

#: ../../tutorial/classes.rst:90
msgid ""
"Attributes may be read-only or writable.  In the latter case, assignment to "
"attributes is possible.  Module attributes are writable: you can write "
"``modname.the_answer = 42``.  Writable attributes may also be deleted with "
"the :keyword:`del` statement.  For example, ``del modname.the_answer`` will "
"remove the attribute :attr:`!the_answer` from the object named by "
"``modname``."
msgstr ""
"ویژگی ها ممکن است فقط خواندنی یا قابل نوشتن باشند. در حالت دوم، اختصاص دادن "
"به ویژگی ها ممکن است. ویژگی های ماژول قابل نوشتن هستند: می توانید ``modname."
"the_answer = 42`` را بنویسید. ویژگی های قابل نوشتن را می توان با دستور :"
"keyword:`del` نیز حذف کرد. به عنوان مثال، ``del modname.the_answer`` ویژگی :"
"attr:`!the_answer` را از شیئی که توسط ``modname`` نامگذاری شده است حذف خواهد "
"کرد."

#: ../../tutorial/classes.rst:96
msgid ""
"Namespaces are created at different moments and have different lifetimes.  "
"The namespace containing the built-in names is created when the Python "
"interpreter starts up, and is never deleted.  The global namespace for a "
"module is created when the module definition is read in; normally, module "
"namespaces also last until the interpreter quits.  The statements executed "
"by the top-level invocation of the interpreter, either read from a script "
"file or interactively, are considered part of a module called :mod:"
"`__main__`, so they have their own global namespace.  (The built-in names "
"actually also live in a module; this is called :mod:`builtins`.)"
msgstr ""
"فضاهای نام در لحظات مختلف ایجاد می شوند و دارای طول عمرهای متفاوتی هستند. "
"فضای نام که شامل نام های داخلی است، زمانی که مفسر پایتون شروع به کار می کند "
"ایجاد می شود و هرگز حذف نمی شود. فضای نام عمومی برای یک ماژول زمانی که تعریف "
"ماژول خوانده می شود ایجاد می گردد؛ به طور معمول، فضاهای نام ماژول نیز تا "
"زمانی که مفسر پایان یابد باقی می مانند. دستوراتی که توسط اجرای سطح بالای "
"مفسر، یا از فایل اسکریپت خوانده شده یا به طور تعاملی اجرا می شوند، به عنوان "
"بخشی از ماژولی به نام :mod:`__main__` در نظر گرفته می شوند، بنابراین آن ها "
"فضای نام عمومی خود را دارند. (نام‌های درون‌ساخت نیز در واقع در یک ماژول قرار "
"دارند؛ این ماژول :mod:`builtins` نامیده می شود.)"

#: ../../tutorial/classes.rst:106
msgid ""
"The local namespace for a function is created when the function is called, "
"and deleted when the function returns or raises an exception that is not "
"handled within the function.  (Actually, forgetting would be a better way to "
"describe what actually happens.)  Of course, recursive invocations each have "
"their own local namespace."
msgstr ""
"فضای نام محلی برای یک تابع زمانی ایجاد می‌شود که تابع فراخوانی شود و زمانی که "
"تابع بازمی‌گردد یا استثنایی پرتاب می‌کند که در درون تابع مدیریت نمی‌شود، حذف "
"می‌گردد. (در واقع، «فراموش شدن» توصیف بهتری برای چیزی است که واقعاً اتفاق "
"می‌افتد.) البته، هر فراخوانی بازگشتی، فضای نام محلی خودش را دارد."

#: ../../tutorial/classes.rst:112
msgid ""
"A *scope* is a textual region of a Python program where a namespace is "
"directly accessible.  \"Directly accessible\" here means that an unqualified "
"reference to a name attempts to find the name in the namespace."
msgstr ""
"یک *دامنه* «*scope*» یک ناحیه متنی از یک برنامه پایتون است که در آن یک فضای "
"نام «namespace» به طور مستقیم قابل دستیابی است. \"به طور مستقیم قابل "
"دستیابی\" در اینجا به این معنی است که یک ارجاع بدون صلاحیت به یک نام تلاش می "
"کند تا نام «name» را در فضای نام «namespace» پیدا کند."

#: ../../tutorial/classes.rst:116
msgid ""
"Although scopes are determined statically, they are used dynamically. At any "
"time during execution, there are 3 or 4 nested scopes whose namespaces are "
"directly accessible:"
msgstr ""
"اگرچه حوزه ها به صورت ایستا تعیین می شوند، اما به صورت پویا مورد استفاده "
"قرار می گیرند. در هر لحظه ای از اجرای برنامه، ۳ یا ۴ حوزه ی تودرتو وجود "
"دارند که فضای نام های آنها به طور مستقیم قابل دسترسی است:"

#: ../../tutorial/classes.rst:120
msgid "the innermost scope, which is searched first, contains the local names"
msgstr "درونی ترین حوزه، که ابتدا جستجو می شود، شامل نام های محلی است"

#: ../../tutorial/classes.rst:121
msgid ""
"the scopes of any enclosing functions, which are searched starting with the "
"nearest enclosing scope, contain non-local, but also non-global names"
msgstr ""
"حوزه های هر تابع محاطی که جستجو از نزدیک ترین حوزه محاطی شروع می شود، شامل "
"نام هایی است که نه محلی هستند و نه سراسری."

#: ../../tutorial/classes.rst:123
msgid "the next-to-last scope contains the current module's global names"
msgstr "حوزه قبل از آخر شامل نام های عمومی ماژول جاری است."

#: ../../tutorial/classes.rst:124
msgid ""
"the outermost scope (searched last) is the namespace containing built-in "
"names"
msgstr ""
"بیرونی ترین حوزه (که در نهایت جستجو می شود) نام فضایی است که شامل نام های "
"پیش ساخته است."

#: ../../tutorial/classes.rst:126
msgid ""
"If a name is declared global, then all references and assignments go "
"directly to the next-to-last scope containing the module's global names.  To "
"rebind variables found outside of the innermost scope, the :keyword:"
"`nonlocal` statement can be used; if not declared nonlocal, those variables "
"are read-only (an attempt to write to such a variable will simply create a "
"*new* local variable in the innermost scope, leaving the identically named "
"outer variable unchanged)."
msgstr ""
"اگر یک نام به صورت global اعلام شود، تمام ارجاعات و تخصیص ها مستقیماً به "
"آخرین حوزه ماقبل، که شامل نام های سراسری ماژول است، می روند. برای انتساب "
"مجدد متغیرهایی که خارج از داخلی ترین حوزه یافت می شوند، می توان از عبارت :"
"keyword:`nonlocal` استفاده کرد؛ اگر به صورت nonlocal اعلام نشده باشند، آن "
"متغیرها فقط قابل خواندن خواهند بود (تلاش برای نوشتن به چنین متغیری به سادگی "
"یک متغیر محلی *new* را در داخلی ترین حوزه ایجاد می کند و متغیر هم نام بیرونی "
"را بدون تغییر باقی می گذارد)."

#: ../../tutorial/classes.rst:133
msgid ""
"Usually, the local scope references the local names of the (textually) "
"current function.  Outside functions, the local scope references the same "
"namespace as the global scope: the module's namespace. Class definitions "
"place yet another namespace in the local scope."
msgstr ""
"معمولاً، حوزه محلی به نام های محلی تابع (متنی) جاری اشاره می کند. خارج از "
"توابع، حوزه محلی به همان فضای نامی که حوزه سراسری را تشکیل می دهد اشاره می "
"کند: فضای نام ماژول. تعریف های کلاس، فضای نام دیگری را در حوزه محلی قرار می "
"دهند."

#: ../../tutorial/classes.rst:138
msgid ""
"It is important to realize that scopes are determined textually: the global "
"scope of a function defined in a module is that module's namespace, no "
"matter from where or by what alias the function is called.  On the other "
"hand, the actual search for names is done dynamically, at run time --- "
"however, the language definition is evolving towards static name resolution, "
"at \"compile\" time, so don't rely on dynamic name resolution!  (In fact, "
"local variables are already determined statically.)"
msgstr ""
"مهم است که متوجه شویم حوزه ها به صورت متنی تعیین می شوند: حوزه ی سراسری یک "
"تابع که در یک ماژول تعریف شده است، فضای نام آن ماژول است، بدون توجه به اینکه "
"از کجا یا با چه نام مستعاری آن تابع فراخوانی می شود. از طرف دیگر، جستجوی "
"واقعی برای نام ها به صورت پویا و در زمان اجرا انجام می شود --- با این حال، "
"تعریف زبان در حال حرکت به سمت حل نام ها به صورت ایستا، در زمان \"کامپایل\" "
"است، بنابراین به حل نام به صورت پویا اتکا نکنید! (در واقع، متغیرهای محلی از "
"قبل به صورت ایستا تعیین می شوند.)"

#: ../../tutorial/classes.rst:146
msgid ""
"A special quirk of Python is that -- if no :keyword:`global` or :keyword:"
"`nonlocal` statement is in effect -- assignments to names always go into the "
"innermost scope. Assignments do not copy data --- they just bind names to "
"objects.  The same is true for deletions: the statement ``del x`` removes "
"the binding of ``x`` from the namespace referenced by the local scope.  In "
"fact, all operations that introduce new names use the local scope: in "
"particular, :keyword:`import` statements and function definitions bind the "
"module or function name in the local scope."
msgstr ""
"یکی از ویژگی های خاص پایتون این است که اگر هیچ بیانیه :keyword:`global` یا :"
"keyword:`nonlocal` در حال اجرا نباشد، اختصاص نام ها همیشه در حیطه داخلی ترین "
"صورت می گیرد. اختصاص نام ها داده ها را کپی نمی کند، بلکه فقط نام ها را به "
"اشیاء متصل می کند. این موضوع در مورد حذف نیز صدق می کند: بیانیه ``del x`` "
"اتصال ``x`` را از فضای نام ارجاع شده توسط حیطه محلی حذف می کند. در واقع، "
"تمام عملیات هایی که نام های جدیدی معرفی می کنند از حیطه محلی استفاده می "
"کنند: به خصوص، بیانیه های :keyword:`import` و تعریف تابع نام ماژول یا تابع "
"را در حیطه محلی متصل می کنند."

#: ../../tutorial/classes.rst:154
msgid ""
"The :keyword:`global` statement can be used to indicate that particular "
"variables live in the global scope and should be rebound there; the :keyword:"
"`nonlocal` statement indicates that particular variables live in an "
"enclosing scope and should be rebound there."
msgstr ""
"بیانیه :keyword:`global` می تواند برای نشان دادن اینکه متغیرهای خاصی در حوزه "
"جهانی هستند و باید در آنجا بازبسته شوند، استفاده شود؛ بیانیه :keyword:"
"`nonlocal` نشان می دهد که متغیرهای خاصی در یک حوزه محاط کننده قرار دارند و "
"باید در آنجا بازبسته شوند."

#: ../../tutorial/classes.rst:162
msgid "Scopes and Namespaces Example"
msgstr "مثال محدوده ها و فضاهای نام"

#: ../../tutorial/classes.rst:164
msgid ""
"This is an example demonstrating how to reference the different scopes and "
"namespaces, and how :keyword:`global` and :keyword:`nonlocal` affect "
"variable binding::"
msgstr ""
"این یک مثال است که نشان می دهد چگونه به حوزه ها و نام فضاهای مختلف ارجاع "
"دهید، و چگونه :keyword:`global` و :keyword:`nonlocal` بر بایندینگ متغیر "
"تأثیر می گذارند::"

#: ../../tutorial/classes.rst:168
msgid ""
"def scope_test():\n"
"    def do_local():\n"
"        spam = \"local spam\"\n"
"\n"
"    def do_nonlocal():\n"
"        nonlocal spam\n"
"        spam = \"nonlocal spam\"\n"
"\n"
"    def do_global():\n"
"        global spam\n"
"        spam = \"global spam\"\n"
"\n"
"    spam = \"test spam\"\n"
"    do_local()\n"
"    print(\"After local assignment:\", spam)\n"
"    do_nonlocal()\n"
"    print(\"After nonlocal assignment:\", spam)\n"
"    do_global()\n"
"    print(\"After global assignment:\", spam)\n"
"\n"
"scope_test()\n"
"print(\"In global scope:\", spam)"
msgstr ""
"def scope_test():\n"
"    def do_local():\n"
"        spam = \"local spam\"\n"
"\n"
"    def do_nonlocal():\n"
"        nonlocal spam\n"
"        spam = \"nonlocal spam\"\n"
"\n"
"    def do_global():\n"
"        global spam\n"
"        spam = \"global spam\"\n"
"\n"
"    spam = \"test spam\"\n"
"    do_local()\n"
"    print(\"After local assignment:\", spam)\n"
"    do_nonlocal()\n"
"    print(\"After nonlocal assignment:\", spam)\n"
"    do_global()\n"
"    print(\"After global assignment:\", spam)\n"
"\n"
"scope_test()\n"
"print(\"In global scope:\", spam)"

#: ../../tutorial/classes.rst:191
msgid "The output of the example code is:"
msgstr "خروجی کد مثال به صورت زیر است:"

#: ../../tutorial/classes.rst:193
msgid ""
"After local assignment: test spam\n"
"After nonlocal assignment: nonlocal spam\n"
"After global assignment: nonlocal spam\n"
"In global scope: global spam"
msgstr ""
"بعد از تخصیص محلی: test spam\n"
"بعد از تخصیص nonlocal: nonlocal spam\n"
"بعد از تخصیص global: nonlocal spam\n"
"در فضای سراسری: global spam"

#: ../../tutorial/classes.rst:200
msgid ""
"Note how the *local* assignment (which is default) didn't change "
"*scope_test*\\'s binding of *spam*.  The :keyword:`nonlocal` assignment "
"changed *scope_test*\\'s binding of *spam*, and the :keyword:`global` "
"assignment changed the module-level binding."
msgstr ""
"توجه کنید که انتساب *local* (که به صورت پیش فرض است) تغییر در ارتباط "
"*scope_test* با *spam* ایجاد نکرد. انتساب :keyword:`nonlocal` ارتباط "
"*scope_test* با *spam* را تغییر داد و انتساب :keyword:`global` ارتباط در سطح "
"ماژول را تغییر داد."

#: ../../tutorial/classes.rst:205
msgid ""
"You can also see that there was no previous binding for *spam* before the :"
"keyword:`global` assignment."
msgstr ""
"همچنین می توانید ببینید که هیچ اتصال قبلی برای *spam* قبل از انتساب :keyword:"
"`global` وجود نداشت."

#: ../../tutorial/classes.rst:212
msgid "A First Look at Classes"
msgstr "در نگاه اول به کلاس ها"

#: ../../tutorial/classes.rst:214
msgid ""
"Classes introduce a little bit of new syntax, three new object types, and "
"some new semantics."
msgstr ""
"کلاس ها اندکی سینتکس جدید، سه نوع شئ جدید و برخی مفاهیم معنایی جدید معرفی می "
"کنند."

#: ../../tutorial/classes.rst:221
msgid "Class Definition Syntax"
msgstr "قواعد تعریف کلاس"

#: ../../tutorial/classes.rst:223
msgid "The simplest form of class definition looks like this::"
msgstr "ساده ترین شکل تعریف کلاس به این صورت است:"

#: ../../tutorial/classes.rst:225
msgid ""
"class ClassName:\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"
msgstr ""
"class ClassName:\n"
"1\n"
".\n"
".\n"
".\n"
"2\n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
" \n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"

#: ../../tutorial/classes.rst:232
msgid ""
"Class definitions, like function definitions (:keyword:`def` statements) "
"must be executed before they have any effect.  (You could conceivably place "
"a class definition in a branch of an :keyword:`if` statement, or inside a "
"function.)"
msgstr ""
"تعاریف کلاس، مانند تعاریف تابع (:keyword:`def` statements)، باید قبل از "
"اینکه تأثیری داشته باشند اجرا شوند. (می توانید تعریف یک کلاس را به طور قابل "
"تصوری در یکی از شاخه های یک :keyword:`if` statement یا داخل یک تابع قرار "
"دهید.)"

#: ../../tutorial/classes.rst:236
msgid ""
"In practice, the statements inside a class definition will usually be "
"function definitions, but other statements are allowed, and sometimes useful "
"--- we'll come back to this later.  The function definitions inside a class "
"normally have a peculiar form of argument list, dictated by the calling "
"conventions for methods --- again, this is explained later."
msgstr ""
"در عمل، دستورات داخل تعریف یک کلاس معمولاً شامل تعریف توابع خواهد بود، اما "
"استفاده از دستورات دیگر مجاز است و گاهی اوقات مفید است — بعدها به این موضوع "
"باز خواهیم گشت. تعریف توابع داخل یک کلاس معمولاً شکل خاصی از لیست آرگومان ها "
"دارد که توسط قراردادهای فراخوانی برای متدها تعیین می شود — باز هم، این موضوع "
"بعداً توضیح داده خواهد شد."

#: ../../tutorial/classes.rst:242
msgid ""
"When a class definition is entered, a new namespace is created, and used as "
"the local scope --- thus, all assignments to local variables go into this "
"new namespace.  In particular, function definitions bind the name of the new "
"function here."
msgstr ""
"هنگامی که یک تعریف کلاس وارد می شود، یک فضای نام جدید ایجاد می شود و به "
"عنوان محدوده محلی استفاده می شود --- بنابراین، تمامی انتساب ها به متغیر های "
"محلی وارد این فضای نام جدید می شوند. به طور خاص، تعاریف تابع، نام تابع جدید "
"را در اینجا متصل می کنند."

#: ../../tutorial/classes.rst:247
msgid ""
"When a class definition is left normally (via the end), a *class object* is "
"created.  This is basically a wrapper around the contents of the namespace "
"created by the class definition; we'll learn more about class objects in the "
"next section.  The original local scope (the one in effect just before the "
"class definition was entered) is reinstated, and the class object is bound "
"here to the class name given in the class definition header (:class:`!"
"ClassName` in the example)."
msgstr ""
"هنگامی که تعریف یک کلاس به صورت طبیعی (از طریق پایان) به پایان می رسد، یک "
"*class object* ایجاد می شود. این در واقع یک پوشش است بر محتوای فضای نامی که "
"توسط تعریف کلاس ایجاد شده است؛ در بخش بعدی بیشتر درباره اشیاء کلاس یاد "
"خواهیم گرفت. حوزه محلی اولیه (همان که قبل از ورود به تعریف کلاس وجود داشت) "
"دوباره فعال می شود و شیء کلاس به نامی که در سربرگ تعریف کلاس داده شده است (:"
"class:`!ClassName` در مثال) متصل می شود."

#: ../../tutorial/classes.rst:259
msgid "Class Objects"
msgstr "اشیاء کلاس"

#: ../../tutorial/classes.rst:261
msgid ""
"Class objects support two kinds of operations: attribute references and "
"instantiation."
msgstr ""
"شیءهای کلاس از دو نوع عملیات پشتیبانی می کنند: ارجاع به ویژگی ها و نمونه "
"سازی."

#: ../../tutorial/classes.rst:264
msgid ""
"*Attribute references* use the standard syntax used for all attribute "
"references in Python: ``obj.name``.  Valid attribute names are all the names "
"that were in the class's namespace when the class object was created.  So, "
"if the class definition looked like this::"
msgstr ""
"برای استفاده از *Attribute references* از نحو استانداردی استفاده کنید که "
"برای تمامی مرجع های ویژگی در پایتون به کار می رود: ``obj.name``. نام های "
"ویژگی معتبر شامل تمامی نام هایی هستند که در فضای نام کلاس در هنگام ایجاد شیء "
"کلاس بودند. بنابراین، اگر تعریف کلاس به این صورت باشد:"

#: ../../tutorial/classes.rst:269
msgid ""
"class MyClass:\n"
"    \"\"\"A simple example class\"\"\"\n"
"    i = 12345\n"
"\n"
"    def f(self):\n"
"        return 'hello world'"
msgstr ""
"class MyClass:\n"
"    \"\"\"A simple example class\"\"\"\n"
"    i = 12345\n"
"\n"
"    def f(self):\n"
"        return 'hello world'"

#: ../../tutorial/classes.rst:276
msgid ""
"then ``MyClass.i`` and ``MyClass.f`` are valid attribute references, "
"returning an integer and a function object, respectively. Class attributes "
"can also be assigned to, so you can change the value of ``MyClass.i`` by "
"assignment. :attr:`~type.__doc__` is also a valid attribute, returning the "
"docstring belonging to the class: ``\"A simple example class\"``."
msgstr ""
"سپس ``MyClass.i`` و ``MyClass.f`` به عنوان ارجاعات معتبر به ویژگی قابل "
"استفاده هستند که به ترتیب یک عدد صحیح و یک شیء تابع را ارائه می دهند. ویژگی "
"های کلاس نیز می توانند مقداردهی شوند، بنابراین می توانید مقدار ``MyClass.i`` "
"را با تخصیص تغییر دهید. :attr:`~type.__doc__` نیز یک ویژگی معتبر است که داک "
"استرینگ مربوط به کلاس را برمی گرداند: ``\"A simple example class\"``."

#: ../../tutorial/classes.rst:282
msgid ""
"Class *instantiation* uses function notation.  Just pretend that the class "
"object is a parameterless function that returns a new instance of the class. "
"For example (assuming the above class)::"
msgstr ""
"کلاس *instantiation* از نماد تابعی استفاده می کند. فقط فرض کنید که شیء کلاس "
"یک تابع بدون پارامتر است که نمونه جدیدی از کلاس را برمی گرداند. برای مثال "
"(با فرض وجود کلاس فوق):"

#: ../../tutorial/classes.rst:286 ../../tutorial/classes.rst:303
msgid "x = MyClass()"
msgstr "x = MyClass()"

#: ../../tutorial/classes.rst:288
msgid ""
"creates a new *instance* of the class and assigns this object to the local "
"variable ``x``."
msgstr ""
"شیء جدیدی از کلاس *instance* ایجاد کرده و این شیء را به متغیر محلی ``x`` "
"اختصاص می دهد."

#: ../../tutorial/classes.rst:291
msgid ""
"The instantiation operation (\"calling\" a class object) creates an empty "
"object. Many classes like to create objects with instances customized to a "
"specific initial state. Therefore a class may define a special method named :"
"meth:`~object.__init__`, like this::"
msgstr ""
"عملیات نمونه سازی (برای مثال \"صدا زدن\" یک شیء کلاس) یک شیء خالی ایجاد می "
"کند. بسیاری از کلاس ها تمایل دارند اشیائی با نمونه های شخصی سازی شده به یک "
"حالت اولیه خاص ایجاد کنند. به همین دلیل یک کلاس ممکن است یک متد ویژه به نام :"
"meth:`~object.__init__` تعریف کند، مانند این:"

#: ../../tutorial/classes.rst:296
msgid ""
"def __init__(self):\n"
"    self.data = []"
msgstr ""
"def __init__(self):\n"
"    self.data = []"

#: ../../tutorial/classes.rst:299
msgid ""
"When a class defines an :meth:`~object.__init__` method, class instantiation "
"automatically invokes :meth:`!__init__` for the newly created class "
"instance.  So in this example, a new, initialized instance can be obtained "
"by::"
msgstr ""
"وقتی یک کلاس متدی با نام :meth:`~object.__init__` را تعریف می کند، ایجاد یک "
"نمونه از کلاس به صورت خودکار :meth:`!__init__` را برای نمونه تازه ساخته شده "
"فراخوانی می کند. بنابراین، در این مثال، یک نمونه جدید و مقداردهی اولیه شده "
"را می توان به این صورت به دست آورد:"

#: ../../tutorial/classes.rst:305
msgid ""
"Of course, the :meth:`~object.__init__` method may have arguments for "
"greater flexibility.  In that case, arguments given to the class "
"instantiation operator are passed on to :meth:`!__init__`.  For example, ::"
msgstr ""
"البته، متد :meth:`~object.__init__` می تواند برای انعطاف پذیری بیشتر دارای "
"آرگومان باشد. در این صورت، آرگومان هایی که به عملگر ایجاد کلاس داده می شوند "
"به :meth:`!__init__` منتقل می شوند. برای مثال: :"

#: ../../tutorial/classes.rst:309
msgid ""
">>> class Complex:\n"
"...     def __init__(self, realpart, imagpart):\n"
"...         self.r = realpart\n"
"...         self.i = imagpart\n"
"...\n"
">>> x = Complex(3.0, -4.5)\n"
">>> x.r, x.i\n"
"(3.0, -4.5)"
msgstr ""
">>> class Complex:\n"
"...     def __init__(self, realpart, imagpart):\n"
"...         self.r = realpart\n"
"...         self.i = imagpart\n"
"...\n"
">>> x = Complex(3.0, -4.5)\n"
">>> x.r, x.i\n"
"(3.0, -4.5)"

#: ../../tutorial/classes.rst:322
msgid "Instance Objects"
msgstr "شیء های نمونه"

#: ../../tutorial/classes.rst:324
msgid ""
"Now what can we do with instance objects?  The only operations understood by "
"instance objects are attribute references.  There are two kinds of valid "
"attribute names: data attributes and methods."
msgstr ""
"اکنون با اشیاء نمونه چه کاری می توانیم انجام دهیم؟ تنها عملیاتی که توسط "
"اشیاء نمونه قابل درک است، ارجاع به ویژگی ها است. دو نوع نام ویژگی معتبر وجود "
"دارد: ویژگی های داده و متدها."

#: ../../tutorial/classes.rst:328
msgid ""
"*Data attributes* correspond to \"instance variables\" in Smalltalk, and to "
"\"data members\" in C++.  Data attributes need not be declared; like local "
"variables, they spring into existence when they are first assigned to.  For "
"example, if ``x`` is the instance of :class:`!MyClass` created above, the "
"following piece of code will print the value ``16``, without leaving a "
"trace::"
msgstr ""

#: ../../tutorial/classes.rst:334
msgid ""
"x.counter = 1\n"
"while x.counter < 10:\n"
"    x.counter = x.counter * 2\n"
"print(x.counter)\n"
"del x.counter"
msgstr ""
"x.counter = 1\n"
"while x.counter < 10:\n"
"    x.counter = x.counter * 2\n"
"print(x.counter)\n"
"del x.counter"

#: ../../tutorial/classes.rst:340
msgid ""
"The other kind of instance attribute reference is a *method*. A method is a "
"function that \"belongs to\" an object."
msgstr ""
"نوع دیگر ارجاع به ویژگی نمونه، *method* است. یک متد، تابعی است که \"متعلق "
"به\" یک آبجکت است."

#: ../../tutorial/classes.rst:345
msgid ""
"Valid method names of an instance object depend on its class.  By "
"definition, all attributes of a class that are function  objects define "
"corresponding methods of its instances.  So in our example, ``x.f`` is a "
"valid method reference, since ``MyClass.f`` is a function, but ``x.i`` is "
"not, since ``MyClass.i`` is not.  But ``x.f`` is not the same thing as "
"``MyClass.f`` --- it is a *method object*, not a function object."
msgstr ""
"نام های معتبر برای متدهای یک شیء نمونه به کلاس آن بستگی دارد. به طور تعریف "
"شده، تمام ویژگی های یک کلاس که اشیاء تابع باشند، متدهای متناظر نمونه های آن "
"کلاس را تعریف می کنند. بنابراین در مثال ما، ``x.f`` یک مرجع متد معتبر است، "
"چون ``MyClass.f`` یک تابع است، اما ``x.i`` نیست، چون ``MyClass.i`` نیست. با "
"این حال، ``x.f`` معادل ``MyClass.f`` نیست --- این یک *method object* است، نه "
"یک شیء تابع."

#: ../../tutorial/classes.rst:356
msgid "Method Objects"
msgstr "اشیای متد"

#: ../../tutorial/classes.rst:358
msgid "Usually, a method is called right after it is bound::"
msgstr "معمولاً یک متد بلافاصله بعد از اینکه مرتبط شد فراخوانی می شود::"

#: ../../tutorial/classes.rst:360
msgid "x.f()"
msgstr "x.f()"

#: ../../tutorial/classes.rst:362
msgid ""
"In the :class:`!MyClass` example, this will return the string ``'hello "
"world'``. However, it is not necessary to call a method right away: ``x.f`` "
"is a method object, and can be stored away and called at a later time.  For "
"example::"
msgstr ""
"در مثال :class:`!MyClass` این رشته را برمی گرداند ``'hello world'``. با این "
"حال، لازم نیست که بلافاصله یک متد را فراخوانی کنید: ``x.f`` یک شیء متد است و "
"می تواند ذخیره شود و در زمان دیگری فراخوانی شود. به عنوان مثال::"

#: ../../tutorial/classes.rst:366
msgid ""
"xf = x.f\n"
"while True:\n"
"    print(xf())"
msgstr ""
"xf = x.f\n"
"while True:\n"
"    print(xf())"

#: ../../tutorial/classes.rst:370
msgid "will continue to print ``hello world`` until the end of time."
msgstr "تا پایان زمان به چاپ ``hello world`` ادامه خواهد داد."

#: ../../tutorial/classes.rst:372
msgid ""
"What exactly happens when a method is called?  You may have noticed that ``x."
"f()`` was called without an argument above, even though the function "
"definition for :meth:`!f` specified an argument.  What happened to the "
"argument? Surely Python raises an exception when a function that requires an "
"argument is called without any --- even if the argument isn't actually "
"used..."
msgstr ""
"دقیقاً چه اتفاقی می افتد وقتی که یک متد فراخوانی می شود؟ شاید متوجه شده باشید "
"که ``x.f()`` بدون آرگومان فراخوانی شد، حتی با این که تعریف تابع برای :meth:`!"
"f` یک آرگومان مشخص کرده است. چه بر سر آرگومان آمد؟ به احتمال زیاد پایتون یک "
"استثناء مطرح می کند وقتی که تابعی که نیازمند یک آرگومان است، بدون هیچ "
"آرگومانی فراخوانی شود --- حتی اگر آرگومان به طور واقعی مورد استفاده قرار "
"نگیرد..."

#: ../../tutorial/classes.rst:378
msgid ""
"Actually, you may have guessed the answer: the special thing about methods "
"is that the instance object is passed as the first argument of the "
"function.  In our example, the call ``x.f()`` is exactly equivalent to "
"``MyClass.f(x)``.  In general, calling a method with a list of *n* arguments "
"is equivalent to calling the corresponding function with an argument list "
"that is created by inserting the method's instance object before the first "
"argument."
msgstr ""
"در واقع، شاید پاسخ را حدس زده باشید: ویژگی خاص متدها این است که شیء نمونه به "
"عنوان اولین آرگومان به تابع ارسال می شود. در مثال ما، فراخوانی ``x.f()`` "
"دقیقا معادل ``MyClass.f(x)`` است. به طور کلی، فراخوانی یک متد با لیستی از "
"آرگومان ها *n* معادل فراخوانی تابع متناظر با یک لیست آرگومان است که با وارد "
"کردن شیء نمونه متد قبل از اولین آرگومان ایجاد می شود."

#: ../../tutorial/classes.rst:385
msgid ""
"In general, methods work as follows.  When a non-data attribute of an "
"instance is referenced, the instance's class is searched. If the name "
"denotes a valid class attribute that is a function object, references to "
"both the instance object and the function object are packed into a method "
"object.  When the method object is called with an argument list, a new "
"argument list is constructed from the instance object and the argument list, "
"and the function object is called with this new argument list."
msgstr ""
"به طور کلی، متدها به صورت زیر عمل می کنند. وقتی یک ویژگی غیر داده ای از یک "
"نمونه ارجاع داده می شود، کلاس نمونه جستجو می شود. اگر نام نشان دهنده یک "
"ویژگی معتبر کلاس باشد که یک شیء تابع است، ارجاعات به هر دو شیء نمونه و شیء "
"تابع در یک شیء متد بسته بندی می شوند. هنگامی که شیء متد با یک فهرست آرگومان "
"فراخوانی می شود، یک فهرست آرگومان جدید از شیء نمونه و فهرست آرگومان ساخته می "
"شود، و شیء تابع با این فهرست آرگومان جدید فراخوانی می شود."

#: ../../tutorial/classes.rst:398
msgid "Class and Instance Variables"
msgstr "کلاس و متغیرهای نمونه"

#: ../../tutorial/classes.rst:400
msgid ""
"Generally speaking, instance variables are for data unique to each instance "
"and class variables are for attributes and methods shared by all instances "
"of the class::"
msgstr ""
"به طور کلی، متغیر های نمونه برای داده های منحصر به فرد هر نمونه و متغیر های "
"کلاسی برای خصوصیات و روش هایی استفاده می شوند که توسط تمام نمونه های کلاس به "
"اشتراک گذاشته می شوند::"

#: ../../tutorial/classes.rst:404
msgid ""
"class Dog:\n"
"\n"
"    kind = 'canine'         # class variable shared by all instances\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name    # instance variable unique to each instance\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.kind                  # shared by all dogs\n"
"'canine'\n"
">>> e.kind                  # shared by all dogs\n"
"'canine'\n"
">>> d.name                  # unique to d\n"
"'Fido'\n"
">>> e.name                  # unique to e\n"
"'Buddy'"
msgstr ""
"class Dog:\n"
"\n"
"    kind = 'canine'         # class variable shared by all instances\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name    # instance variable unique to each instance\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.kind                  # shared by all dogs\n"
"'canine'\n"
">>> e.kind                  # shared by all dogs\n"
"'canine'\n"
">>> d.name                  # unique to d\n"
"'Fido'\n"
">>> e.name                  # unique to e\n"
"'Buddy'"

#: ../../tutorial/classes.rst:422
msgid ""
"As discussed in :ref:`tut-object`, shared data can have possibly surprising "
"effects with involving :term:`mutable` objects such as lists and "
"dictionaries. For example, the *tricks* list in the following code should "
"not be used as a class variable because just a single list would be shared "
"by all *Dog* instances::"
msgstr ""
"همانطور که در :ref:`tut-object` بحث شد، داده های مشترک می توانند تأثیرات "
"شگفت آوری در گیر کردن اشیاء :term:`mutable` مانند لیست ها و دیکشنری ها داشته "
"باشند. به عنوان مثال، لیست *tricks* در کد زیر نباید به عنوان یک متغیر کلاس "
"استفاده شود زیرا تنها یک لیست توسط تمام نمونه های *Dog* به اشتراک گذاشته می "
"شود::"

#: ../../tutorial/classes.rst:428
msgid ""
"class Dog:\n"
"\n"
"    tricks = []             # mistaken use of a class variable\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"\n"
"    def add_trick(self, trick):\n"
"        self.tricks.append(trick)\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.add_trick('roll over')\n"
">>> e.add_trick('play dead')\n"
">>> d.tricks                # unexpectedly shared by all dogs\n"
"['roll over', 'play dead']"
msgstr ""
"class Dog:\n"
"\n"
"    tricks = []             # mistaken use of a class variable\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"\n"
"    def add_trick(self, trick):\n"
"        self.tricks.append(trick)\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.add_trick('roll over')\n"
">>> e.add_trick('play dead')\n"
">>> d.tricks                # unexpectedly shared by all dogs\n"
"['roll over', 'play dead']"

#: ../../tutorial/classes.rst:445
msgid "Correct design of the class should use an instance variable instead::"
msgstr "طراحی صحیح کلاس باید به جای آن از یک متغیر نمونه استفاده کند::"

#: ../../tutorial/classes.rst:447
msgid ""
"class Dog:\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"        self.tricks = []    # creates a new empty list for each dog\n"
"\n"
"    def add_trick(self, trick):\n"
"        self.tricks.append(trick)\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.add_trick('roll over')\n"
">>> e.add_trick('play dead')\n"
">>> d.tricks\n"
"['roll over']\n"
">>> e.tricks\n"
"['play dead']"
msgstr ""
"class Dog:\n"
"\n"
"    def __init__(self, name):\n"
"        self.name = name\n"
"        self.tricks = []    # creates a new empty list for each dog\n"
"\n"
"    def add_trick(self, trick):\n"
"        self.tricks.append(trick)\n"
"\n"
">>> d = Dog('Fido')\n"
">>> e = Dog('Buddy')\n"
">>> d.add_trick('roll over')\n"
">>> e.add_trick('play dead')\n"
">>> d.tricks\n"
"['roll over']\n"
">>> e.tricks\n"
"['play dead']"

#: ../../tutorial/classes.rst:469
msgid "Random Remarks"
msgstr "نکات تصادفی"

#: ../../tutorial/classes.rst:473
msgid ""
"If the same attribute name occurs in both an instance and in a class, then "
"attribute lookup prioritizes the instance::"
msgstr ""
"اگر یک نام ویژگی هم در یک نمونه و هم در یک کلاس وجود داشته باشد، جستجوی "
"ویژگی به نمونه اولویت می دهد::"

#: ../../tutorial/classes.rst:476
msgid ""
">>> class Warehouse:\n"
"...    purpose = 'storage'\n"
"...    region = 'west'\n"
"...\n"
">>> w1 = Warehouse()\n"
">>> print(w1.purpose, w1.region)\n"
"storage west\n"
">>> w2 = Warehouse()\n"
">>> w2.region = 'east'\n"
">>> print(w2.purpose, w2.region)\n"
"storage east"
msgstr ""
">>> class Warehouse:\n"
"...    purpose = 'انبار داری'\n"
"...    region = 'غرب'\n"
"...\n"
">>> w1 = Warehouse()\n"
">>> print(w1.purpose, w1.region)\n"
"storage west\n"
">>> w2 = Warehouse()\n"
">>> w2.region = 'شرق'\n"
">>> print(w2.purpose, w2.region)\n"
"storage east"

#: ../../tutorial/classes.rst:488
msgid ""
"Data attributes may be referenced by methods as well as by ordinary users "
"(\"clients\") of an object.  In other words, classes are not usable to "
"implement pure abstract data types.  In fact, nothing in Python makes it "
"possible to enforce data hiding --- it is all based upon convention.  (On "
"the other hand, the Python implementation, written in C, can completely hide "
"implementation details and control access to an object if necessary; this "
"can be used by extensions to Python written in C.)"
msgstr ""
"ویژگی های داده ها ممکن است هم توسط متدها و هم توسط کاربران عادی "
"(\"مشتریان\") یک شیء مورد استفاده قرار گیرند. به عبارت دیگر، کلاس ها برای "
"پیاده سازی انواع داده های انتزاعی ناب قابل استفاده نیستند. در واقع، هیچ چیزی "
"در پایتون امکان پنهان سازی داده ها را به طور کامل فراهم نمی کند --- همه چیز "
"بر اساس قرارداد انجام می شود. (از طرف دیگر، پیاده سازی پایتون که به زبان C "
"نوشته شده است، می تواند جزئیات پیاده سازی را به طور کامل پنهان کند و در صورت "
"نیاز دسترسی به یک شیء را کنترل نماید؛ این قابلیت می تواند توسط افزونه های "
"نوشته شده به زبان C برای پایتون استفاده شود.)"

#: ../../tutorial/classes.rst:496
msgid ""
"Clients should use data attributes with care --- clients may mess up "
"invariants maintained by the methods by stamping on their data attributes.  "
"Note that clients may add data attributes of their own to an instance object "
"without affecting the validity of the methods, as long as name conflicts are "
"avoided --- again, a naming convention can save a lot of headaches here."
msgstr ""
"مشتریان باید با دقت از ویژگی های داده استفاده کنند --- ممکن است مشتریان با "
"تداخل در ویژگی های داده خود، ناپایداری هایی که توسط متدها حفظ می شود را به "
"هم بزنند. توجه داشته باشید که مشتریان ممکن است ویژگی های داده خود را بدون "
"تأثیر بر اعتبار متدها به یک شیء مثال اضافه کنند، به شرط اینکه از تداخل نام "
"ها جلوگیری شود --- مجدد، یک کنوانسیون نام گذاری می تواند بسیاری از مشکلات را "
"در اینجا حل کند."

#: ../../tutorial/classes.rst:502
msgid ""
"There is no shorthand for referencing data attributes (or other methods!) "
"from within methods.  I find that this actually increases the readability of "
"methods: there is no chance of confusing local variables and instance "
"variables when glancing through a method."
msgstr ""
"هیچ روش کوتاهی برای ارجاع به ویژگی های داده (یا روش های دیگر!) از درون متدها "
"وجود ندارد. من معتقدم که این در واقع خوانایی متدها را افزایش می دهد: هیچ "
"احتمالی برای اشتباه گرفتن متغیرهای محلی و متغیرهای نمونه در هنگام مرور سریع "
"یک متد وجود ندارد."

#: ../../tutorial/classes.rst:507
msgid ""
"Often, the first argument of a method is called ``self``.  This is nothing "
"more than a convention: the name ``self`` has absolutely no special meaning "
"to Python.  Note, however, that by not following the convention your code "
"may be less readable to other Python programmers, and it is also conceivable "
"that a *class browser* program might be written that relies upon such a "
"convention."
msgstr ""
"اغلباً، اولین آرگومان یک متد ``self`` نامیده می شود. این تنها یک قرارداد است: "
"نام ``self`` هیچ معنای خاصی برای پایتون ندارد. اما توجه داشته باشید که با "
"رعایت نکردن این قرارداد، امکان دارد کد شما برای دیگر برنامه نویسان پایتون "
"کمتر قابل خواندن باشد و همچنین ممکن است یک برنامه *class browser* نوشته شود "
"که به چنین قراردادی وابسته باشد."

#: ../../tutorial/classes.rst:513
msgid ""
"Any function object that is a class attribute defines a method for instances "
"of that class.  It is not necessary that the function definition is "
"textually enclosed in the class definition: assigning a function object to a "
"local variable in the class is also ok.  For example::"
msgstr ""
"هر شیء تابع ای که یک ویژگی کلاس باشد، یک متد برای نمونه های آن کلاس تعریف می "
"کند. ضروری نیست که تعریف تابع به طور متنی در تعریف کلاس قرار بگیرد: تخصیص یک "
"شیء تابع به یک متغیر محلی در کلاس نیز قابل قبول است. برای مثال:"

#: ../../tutorial/classes.rst:518
msgid ""
"# Function defined outside the class\n"
"def f1(self, x, y):\n"
"    return min(x, x+y)\n"
"\n"
"class C:\n"
"    f = f1\n"
"\n"
"    def g(self):\n"
"        return 'hello world'\n"
"\n"
"    h = g"
msgstr ""
"# Function defined outside the class\n"
"def f1(self, x, y):\n"
"    return min(x, x+y)\n"
"\n"
"class C:\n"
"    f = f1\n"
"\n"
"    def g(self):\n"
"        return 'hello world'\n"
"\n"
"    h = g"

#: ../../tutorial/classes.rst:530
msgid ""
"Now ``f``, ``g`` and ``h`` are all attributes of class :class:`!C` that "
"refer to function objects, and consequently they are all methods of "
"instances of :class:`!C` --- ``h`` being exactly equivalent to ``g``.  Note "
"that this practice usually only serves to confuse the reader of a program."
msgstr ""
"اکنون ``f``، ``g`` و ``h`` همگی خصوصیاتی از کلاس :class:`!C` هستند که به "
"اشیاء تابع اشاره دارند و به تبع آن، همگی متدهای نمونه های :class:`!C` هستند "
"--- ``h`` دقیقاً معادل ``g`` است. توجه داشته باشید که این رویکرد معمولاً تنها "
"باعث سردرگمی خواننده یک برنامه می شود."

#: ../../tutorial/classes.rst:535
msgid ""
"Methods may call other methods by using method attributes of the ``self`` "
"argument::"
msgstr ""
"متدها می توانند با استفاده از ویژگی های متد آرگومان ``self``، متدهای دیگر را "
"فراخوانی کنند:"

#: ../../tutorial/classes.rst:538
msgid ""
"class Bag:\n"
"    def __init__(self):\n"
"        self.data = []\n"
"\n"
"    def add(self, x):\n"
"        self.data.append(x)\n"
"\n"
"    def addtwice(self, x):\n"
"        self.add(x)\n"
"        self.add(x)"
msgstr ""
"class Bag:\n"
"    def __init__(self):\n"
"        self.data = []\n"
"\n"
"    def add(self, x):\n"
"        self.data.append(x)\n"
"\n"
"    def addtwice(self, x):\n"
"        self.add(x)\n"
"        self.add(x)"

#: ../../tutorial/classes.rst:549
msgid ""
"Methods may reference global names in the same way as ordinary functions.  "
"The global scope associated with a method is the module containing its "
"definition.  (A class is never used as a global scope.)  While one rarely "
"encounters a good reason for using global data in a method, there are many "
"legitimate uses of the global scope: for one thing, functions and modules "
"imported into the global scope can be used by methods, as well as functions "
"and classes defined in it.  Usually, the class containing the method is "
"itself defined in this global scope, and in the next section we'll find some "
"good reasons why a method would want to reference its own class."
msgstr ""
"متدها می توانند به همان شکلی که توابع عادی به نام های عمومی ارجاع می دهند، "
"به نام های عمومی دسترسی داشته باشند. دامنه عمومی مرتبط با یک متد، ماژولی است "
"که تعریف آن را در بر می گیرد. (یک کلاس هرگز به عنوان یک دامنه عمومی استفاده "
"نمی شود.) در حالی که به ندرت دلایل خوبی برای استفاده از داده های عمومی در یک "
"متد دیده می شود، استفاده زیادی از دامنه عمومی وجود دارد: برای مثال، توابع و "
"ماژول هایی که به دامنه عمومی وارد شده اند، می توانند توسط متدها و همچنین "
"توابع و کلاس هایی که در آن تعریف شده اند، استفاده شوند. به طور معمول، کلاسی "
"که حاوی متد است، به خودی خود در این دامنه عمومی تعریف می شود و در بخش بعدی "
"به دلایل خوبی خواهیم پرداخت که چرا یک متد ممکن است بخواهد به کلاس خودش ارجاع "
"دهد."

#: ../../tutorial/classes.rst:559
msgid ""
"Each value is an object, and therefore has a *class* (also called its "
"*type*). It is stored as ``object.__class__``."
msgstr ""
"هر مقدار یک شیء است، و بنابراین دارای *class* (که همچنین به عنوان *type* "
"نامیده می شود) است. این به صورت ``object.__class__`` ذخیره می شود."

#: ../../tutorial/classes.rst:566
msgid "Inheritance"
msgstr "وراثت"

#: ../../tutorial/classes.rst:568
msgid ""
"Of course, a language feature would not be worthy of the name \"class\" "
"without supporting inheritance.  The syntax for a derived class definition "
"looks like this::"
msgstr ""
"البته، یک ویژگی زبانی بدون پشتیبانی از ارث بری شایسته ی نام \"کلاس\" نخواهد "
"بود.  نحو تعریف یک کلاس مشتق به این شکل است::"

#: ../../tutorial/classes.rst:572
msgid ""
"class DerivedClassName(BaseClassName):\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"
msgstr ""
"کلاس DerivedClassName(BaseClassName):\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"

#: ../../tutorial/classes.rst:579
msgid ""
"The name :class:`!BaseClassName` must be defined in a namespace accessible "
"from the scope containing the derived class definition.  In place of a base "
"class name, other arbitrary expressions are also allowed.  This can be "
"useful, for example, when the base class is defined in another module::"
msgstr ""
"نام :class:`!BaseClassName` باید در یک فضای نام که از حوزه ای که تعریف کلاس "
"مشتق شده است قابل دسترسی باشد، تعریف شود. به جای نام یک کلاس پایه، تعابیر "
"دلخواه دیگر نیز مجاز هستند. این ویژگی می تواند برای مثال، زمانی که کلاس پایه "
"در یک ماژول دیگر تعریف شده است، مفید باشد:"

#: ../../tutorial/classes.rst:585
msgid "class DerivedClassName(modname.BaseClassName):"
msgstr "کلاس DerivedClassName(modname.BaseClassName):"

#: ../../tutorial/classes.rst:587
msgid ""
"Execution of a derived class definition proceeds the same as for a base "
"class. When the class object is constructed, the base class is remembered.  "
"This is used for resolving attribute references: if a requested attribute is "
"not found in the class, the search proceeds to look in the base class.  This "
"rule is applied recursively if the base class itself is derived from some "
"other class."
msgstr ""
"اجرای تعریف یک کلاس مشتق شده به همان صورتی که برای یک کلاس پایه انجام می "
"شود، پیش می رود. وقتی شیء کلاس ساخته می شود، کلاس پایه به خاطر سپرده می شود. "
"این برای حل مرجع های ویژگی استفاده می شود: اگر یک ویژگی درخواست شده در کلاس "
"پیدا نشود، جستجو به کلاس پایه ادامه می یابد. این قاعده به صورت بازگشتی اعمال "
"می شود اگر کلاس پایه خود از کلاس دیگری مشتق شده باشد."

#: ../../tutorial/classes.rst:593
msgid ""
"There's nothing special about instantiation of derived classes: "
"``DerivedClassName()`` creates a new instance of the class.  Method "
"references are resolved as follows: the corresponding class attribute is "
"searched, descending down the chain of base classes if necessary, and the "
"method reference is valid if this yields a function object."
msgstr ""
"چیزی خاصی درباره ایجاد نمونه از کلاس های مشتق شده وجود ندارد: "
"``DerivedClassName()`` یک نمونه جدید از کلاس را ایجاد می کند. به روش های "
"ارجاع به این صورت پرداخته می شود: ویژگی کلاس متناظر جستجو می شود، و در صورت "
"لزوم به سمت پایین زنجیره کلاس های پایه حرکت کرده و اگر این جستجو یک شیء تابع "
"را برگرداند، ارجاع به روش معتبر است."

#: ../../tutorial/classes.rst:599
msgid ""
"Derived classes may override methods of their base classes.  Because methods "
"have no special privileges when calling other methods of the same object, a "
"method of a base class that calls another method defined in the same base "
"class may end up calling a method of a derived class that overrides it.  "
"(For C++ programmers: all methods in Python are effectively ``virtual``.)"
msgstr ""
"کلاس های مشتق شده ممکن است متدهای کلاس های پایه خود را بازنویسی کنند. از "
"آنجایی که متدها هنگام فراخوانی سایر متدهای همان شیء هیچ امتیاز ویژه ای "
"ندارند، یک متد از کلاس پایه که متد دیگری را که در همان کلاس پایه تعریف شده "
"فراخوانی می کند ممکن است در نهایت متدی از یک کلاس مشتق شده را که آن را "
"بازنویسی کرده است، فراخوانی کند. (برای برنامه نویسان C++: تمام متدها در "
"پایتون به طور مؤثر ``virtual`` هستند.)"

#: ../../tutorial/classes.rst:605
msgid ""
"An overriding method in a derived class may in fact want to extend rather "
"than simply replace the base class method of the same name. There is a "
"simple way to call the base class method directly: just call ``BaseClassName."
"methodname(self, arguments)``.  This is occasionally useful to clients as "
"well.  (Note that this only works if the base class is accessible as "
"``BaseClassName`` in the global scope.)"
msgstr ""
"در یک کلاس مشتق شده، یک متد جایگزین می تواند بخواهد به جای اینکه صرفاً متد "
"کلاس پایه با همان نام را جایگزین کند، آن را گسترش دهد. یک راه ساده برای "
"فراخوانی مستقیم متد کلاس پایه وجود دارد: فقط ``BaseClassName."
"methodname(self, arguments)`` را فراخوانی کنید. این روش گاهی برای کاربران "
"نیز مفید است. (توجه داشته باشید که این تنها زمانی کار می کند که کلاس پایه به "
"عنوان ``BaseClassName`` در حوزهٔ جهانی در دسترس باشد.)"

#: ../../tutorial/classes.rst:612
msgid "Python has two built-in functions that work with inheritance:"
msgstr "پایتون دو تابع داخلی دارد که با ارث بری کار می کنند:"

#: ../../tutorial/classes.rst:614
msgid ""
"Use :func:`isinstance` to check an instance's type: ``isinstance(obj, int)`` "
"will be ``True`` only if ``obj.__class__`` is :class:`int` or some class "
"derived from :class:`int`."
msgstr ""
"از :func:`isinstance` برای بررسی نوع یک نمونه استفاده کنید: "
"``isinstance(obj, int)`` فقط زمانی ``True`` خواهد بود که ``obj.__class__`` "
"برابر با :class:`int` یا کلاسی که از :class:`int` مشتق شده است باشد."

#: ../../tutorial/classes.rst:618
msgid ""
"Use :func:`issubclass` to check class inheritance: ``issubclass(bool, int)`` "
"is ``True`` since :class:`bool` is a subclass of :class:`int`.  However, "
"``issubclass(float, int)`` is ``False`` since :class:`float` is not a "
"subclass of :class:`int`."
msgstr ""
"از :func:`issubclass` برای بررسی وراثت کلاس ها استفاده کنید: "
"``issubclass(bool, int)`` از ``True`` است چونکه :class:`bool` یک زیرکلاس از :"
"class:`int` است. با این حال، ``issubclass(float, int)`` از ``False`` نیست "
"چونکه :class:`float` یک زیرکلاس از :class:`int` نیست."

#: ../../tutorial/classes.rst:628
msgid "Multiple Inheritance"
msgstr "وراثت چندگانه"

#: ../../tutorial/classes.rst:630
msgid ""
"Python supports a form of multiple inheritance as well.  A class definition "
"with multiple base classes looks like this::"
msgstr ""
"پایتون از نوعی از وراثت چندگانه نیز پشتیبانی می کند. تعریف یک کلاس با چندین "
"کلاس پایه به این شکل است::"

#: ../../tutorial/classes.rst:633
msgid ""
"class DerivedClassName(Base1, Base2, Base3):\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"
msgstr ""
"کلاس DerivedClassName(Base1, Base2, Base3):\n"
"    <statement-1>\n"
"    .\n"
"    .\n"
"    .\n"
"    <statement-N>"

#: ../../tutorial/classes.rst:640
msgid ""
"For most purposes, in the simplest cases, you can think of the search for "
"attributes inherited from a parent class as depth-first, left-to-right, not "
"searching twice in the same class where there is an overlap in the "
"hierarchy. Thus, if an attribute is not found in :class:`!DerivedClassName`, "
"it is searched for in :class:`!Base1`, then (recursively) in the base "
"classes of :class:`!Base1`, and if it was not found there, it was searched "
"for in :class:`!Base2`, and so on."
msgstr ""
"برای بیشتر مقاصد، در ساده ترین موارد، می توانید جستجوی ویژگی های به ارث برده "
"شده از یک کلاس والد را به صورت عمق اول، از چپ به راست در نظر بگیرید، به طوری "
"که در جایی که در سلسله مراتب هم پوشانی وجود دارد، در یک کلاس دوبار جستجو "
"نشود. بنابراین، اگر یک ویژگی در :class:`!DerivedClassName` پیدا نشد، در :"
"class:`!Base1` جستجو می شود، سپس (به صورت بازگشتی) در کلاس های پایه :class:`!"
"Base1` جستجو می شود، و اگر در آنجا یافت نشد، در :class:`!Base2` جستجو می "
"شود، و به همین ترتیب ادامه دارد."

#: ../../tutorial/classes.rst:647
msgid ""
"In fact, it is slightly more complex than that; the method resolution order "
"changes dynamically to support cooperative calls to :func:`super`.  This "
"approach is known in some other multiple-inheritance languages as call-next-"
"method and is more powerful than the super call found in single-inheritance "
"languages."
msgstr ""
"در واقع، این کمی پیچیده تر از آن است؛ ترتیب حل روش به صورت دینامیکی تغییر می "
"کند تا از فراخوانی های تعاونی برای :func:`super` پشتیبانی کند. این رویکرد در "
"برخی زبان های چند-ارث بری دیگر به عنوان call-next-method شناخته می شود و "
"قدرتمندتر از فراخوانی super که در زبان های ارث بری منفرد یافت می شود، است."

#: ../../tutorial/classes.rst:653
msgid ""
"Dynamic ordering is necessary because all cases of multiple inheritance "
"exhibit one or more diamond relationships (where at least one of the parent "
"classes can be accessed through multiple paths from the bottommost class).  "
"For example, all classes inherit from :class:`object`, so any case of "
"multiple inheritance provides more than one path to reach :class:`object`.  "
"To keep the base classes from being accessed more than once, the dynamic "
"algorithm linearizes the search order in a way that preserves the left-to-"
"right ordering specified in each class, that calls each parent only once, "
"and that is monotonic (meaning that a class can be subclassed without "
"affecting the precedence order of its parents). Taken together, these "
"properties make it possible to design reliable and extensible classes with "
"multiple inheritance.  For more detail, see :ref:`python_2.3_mro`."
msgstr ""
"ترتیب دهی پویا لازم است زیرا در تمامی موارد وراثت چندگانه، یک یا چند رابطه "
"الماسی وجود دارد (که در آن حداقل یکی از کلاس های والد می تواند از طریق "
"مسیرهای مختلف از کلاس پایینی دسترسی پیدا کند). برای مثال، همه کلاس ها از :"
"class:`object` مشتق می شوند، بنابراین هر مورد از وراثت چندگانه مسیرهای "
"متعددی برای رسیدن به :class:`object` ارائه می دهد. برای جلوگیری از دسترسی به "
"کلاس های پایه بیش از یک بار، الگوریتم پویا ترتیب جستجو را به شکل خطی درآورده "
"که ترتیب چپ به راست مشخص شده در هر کلاس را حفظ می کند، هر والد را فقط یک بار "
"فراخوانی می کند، و یکنواخت است (به این معنا که یک کلاس می تواند زیرکلاس شود، "
"بدون اینکه ترتیب اولویت والدین آن تحت تأثیر قرار گیرد). این ویژگی ها به طور "
"کلی امکان طراحی کلاس های قابل اعتماد و قابل توسعه با وراثت چندگانه را فراهم "
"می کند. برای جزئیات بیشتر، به :ref:`python_2.3_mro` مراجعه کنید."

#: ../../tutorial/classes.rst:670
msgid "Private Variables"
msgstr "متغیرهای خصوصی"

#: ../../tutorial/classes.rst:672
msgid ""
"\"Private\" instance variables that cannot be accessed except from inside an "
"object don't exist in Python.  However, there is a convention that is "
"followed by most Python code: a name prefixed with an underscore (e.g. "
"``_spam``) should be treated as a non-public part of the API (whether it is "
"a function, a method or a data member).  It should be considered an "
"implementation detail and subject to change without notice."
msgstr ""
"متغیرهای نمونه \"خصوصی\" که نمی توان به جز از داخل یک شیء به آن ها دسترسی "
"داشت در پایتون وجود ندارند. با این حال، یک قرارداد وجود دارد که توسط بیشتر "
"کدهای پایتون رعایت می شود: یک نام که با یک آندرلاین پیشوند شده است (برای "
"مثال ``_spam``) باید به عنوان بخشی غیرعمومی از API در نظر گرفته شود (چه "
"کاربرد یک تابع، یک روش یا یک عضو داده باشد). باید به عنوان یک جزئیات پیاده "
"سازی تلقی شود و ممکن است بدون هشدار قبلی تغییر کند."

#: ../../tutorial/classes.rst:682
msgid ""
"Since there is a valid use-case for class-private members (namely to avoid "
"name clashes of names with names defined by subclasses), there is limited "
"support for such a mechanism, called :dfn:`name mangling`.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with leading underscore(s) "
"stripped.  This mangling is done without regard to the syntactic position of "
"the identifier, as long as it occurs within the definition of a class."
msgstr ""
"از آنجا که استفاده موجه ای برای اعضای خصوصی کلاس وجود دارد (یعنی به منظور "
"جلوگیری از تداخل نام ها با نام هایی که توسط زیرکلاس ها تعریف شده اند)، "
"پشتیبانی محدودی برای چنین مکانیزمی به نام :dfn:`تغییر نام` وجود دارد. هر "
"شناسه ای به فرم ``__spam`` (حداقل با دو زیرخط ابتدایی و حداکثر یک زیرخط "
"انتهایی) به صورت متنی با ``_classname__spam`` جایگزین می شود، که در آن "
"``classname`` نام کلاس جاری است با حذف زیرخط های اولیه. این تغییر نام بدون "
"توجه به موقعیت نحوی شناسه انجام می شود، تا زمانی که در تعریف یک کلاس رخ دهد."

#: ../../tutorial/classes.rst:693
msgid ""
"The :ref:`private name mangling specifications <private-name-mangling>` for "
"details and special cases."
msgstr ""
":ref:`private name mangling specifications <private-name-mangling>` برای "
"جزئیات و موارد خاص."

#: ../../tutorial/classes.rst:696
msgid ""
"Name mangling is helpful for letting subclasses override methods without "
"breaking intraclass method calls.  For example::"
msgstr ""
"نام گذاری مخفی برای اجازه دادن به زیربخش ها برای نادیده گرفتن روش ها بدون "
"شکستن فراخوانی های روش درون کلاسی مفید است. به عنوان مثال:"

#: ../../tutorial/classes.rst:699
msgid ""
"class Mapping:\n"
"    def __init__(self, iterable):\n"
"        self.items_list = []\n"
"        self.__update(iterable)\n"
"\n"
"    def update(self, iterable):\n"
"        for item in iterable:\n"
"            self.items_list.append(item)\n"
"\n"
"    __update = update   # private copy of original update() method\n"
"\n"
"class MappingSubclass(Mapping):\n"
"\n"
"    def update(self, keys, values):\n"
"        # provides new signature for update()\n"
"        # but does not break __init__()\n"
"        for item in zip(keys, values):\n"
"            self.items_list.append(item)"
msgstr ""
"class Mapping:\n"
"    def __init__(self, iterable):\n"
"        self.items_list = []\n"
"        self.__update(iterable)\n"
"\n"
"    def update(self, iterable):\n"
"        for item in iterable:\n"
"            self.items_list.append(item)\n"
"\n"
"    __update = update   # private copy of original update() method\n"
"\n"
"class MappingSubclass(Mapping):\n"
"\n"
"    def update(self, keys, values):\n"
"        # provides new signature for update()\n"
"        # but does not break __init__()\n"
"        for item in zip(keys, values):\n"
"            self.items_list.append(item)"

#: ../../tutorial/classes.rst:718
msgid ""
"The above example would work even if ``MappingSubclass`` were to introduce a "
"``__update`` identifier since it is replaced with ``_Mapping__update`` in "
"the ``Mapping`` class  and ``_MappingSubclass__update`` in the "
"``MappingSubclass`` class respectively."
msgstr ""
"مثال بالا حتی اگر ``MappingSubclass`` یک شناسه ``__update`` معرفی کند نیز "
"کار خواهد کرد زیرا در کلاس ``Mapping`` با ``_Mapping__update`` و در کلاس "
"``MappingSubclass`` با ``_MappingSubclass__update`` جایگزین می شود."

#: ../../tutorial/classes.rst:723
msgid ""
"Note that the mangling rules are designed mostly to avoid accidents; it "
"still is possible to access or modify a variable that is considered "
"private.  This can even be useful in special circumstances, such as in the "
"debugger."
msgstr ""
"توجه داشته باشید که قوانین مبهم سازی عمدتاً برای جلوگیری از تصادفات طراحی شده "
"اند؛ همچنان ممکن است به یک متغیر که خصوصی محسوب می شود دسترسی پیدا کرده یا "
"آن را تغییر دهید. این امر حتی می تواند در شرایط خاص، مانند درون دیباگر مفید "
"باشد."

#: ../../tutorial/classes.rst:727
msgid ""
"Notice that code passed to ``exec()`` or ``eval()`` does not consider the "
"classname of the invoking class to be the current class; this is similar to "
"the effect of the ``global`` statement, the effect of which is likewise "
"restricted to code that is byte-compiled together.  The same restriction "
"applies to ``getattr()``, ``setattr()`` and ``delattr()``, as well as when "
"referencing ``__dict__`` directly."
msgstr ""
"توجه داشته باشید که کدی که به ``exec()`` یا ``eval()`` ارسال می شود، "
"classname کلاس فراخوانی شده را به عنوان کلاس فعلی در نظر نمی گیرد؛ این مشابه "
"تأثیر جمله ``global`` است که اثر آن نیز به کدی محدود می شود که با هم byte-"
"compiled شده اند. همین محدودیت برای ``getattr()``، ``setattr()`` و "
"``delattr()`` نیز اعمال می شود، همچنین زمانی که به طور مستقیم به "
"``__dict__`` ارجاع داده می شود."

#: ../../tutorial/classes.rst:738
msgid "Odds and Ends"
msgstr "Odds and Ends"

#: ../../tutorial/classes.rst:740
msgid ""
"Sometimes it is useful to have a data type similar to the Pascal \"record\" "
"or C \"struct\", bundling together a few named data items. The idiomatic "
"approach is to use :mod:`dataclasses` for this purpose::"
msgstr ""
"گاهی اوقات داشتن یک نوع داده مشابه به \"record\" در زبان Pascal یا "
"\"struct\" در زبان C، که چند آیتم داده ای با نام های مشخص را با هم جمع می "
"کند، مفید است. روش ایدیوماتیک برای این منظور استفاده از :mod:`dataclasses` "
"است::"

#: ../../tutorial/classes.rst:744
msgid ""
"from dataclasses import dataclass\n"
"\n"
"@dataclass\n"
"class Employee:\n"
"    name: str\n"
"    dept: str\n"
"    salary: int"
msgstr ""
"from dataclasses import dataclass\n"
"\n"
"@dataclass\n"
"class Employee:\n"
"    name: str\n"
"    dept: str\n"
"    salary: int"

#: ../../tutorial/classes.rst:754
msgid ""
">>> john = Employee('john', 'computer lab', 1000)\n"
">>> john.dept\n"
"'computer lab'\n"
">>> john.salary\n"
"1000"
msgstr ""
">>> john = Employee('john', 'computer lab', 1000)\n"
">>> john.dept\n"
"'computer lab'\n"
">>> john.salary\n"
"1000"

#: ../../tutorial/classes.rst:760
msgid ""
"A piece of Python code that expects a particular abstract data type can "
"often be passed a class that emulates the methods of that data type "
"instead.  For instance, if you have a function that formats some data from a "
"file object, you can define a class with methods :meth:`~io.TextIOBase.read` "
"and :meth:`~io.TextIOBase.readline` that get the data from a string buffer "
"instead, and pass it as an argument."
msgstr ""
"وقتی که یک قطعه کد Python نیاز به یک نوع داده انتزاعی خاص دارد، اغلب می توان "
"بجای آن یک کلاسی که روش های آن نوع داده را شبیه سازی می کند، پاس کرد. به "
"عنوان مثال، اگر تابعی دارید که داده هایی را از یک شیء فایل فرمت می کند، می "
"توانید کلاسی با روش های :meth:`~io.TextIOBase.read` و :meth:`~io.TextIOBase."
"readline` تعریف کنید که داده ها را از یک بافر رشته ای دریافت کند و آن را به "
"عنوان یک آرگومان پاس کنید."

#: ../../tutorial/classes.rst:772
msgid ""
":ref:`Instance method objects <instance-methods>` have attributes, too: :"
"attr:`m.__self__ <method.__self__>` is the instance object with the method :"
"meth:`!m`, and :attr:`m.__func__ <method.__func__>` is the :ref:`function "
"object <user-defined-funcs>` corresponding to the method."
msgstr ""
":ref:`Instance method objects <instance-methods>` نیز ویژگی هایی دارند: :"
"attr:`m.__self__ <method.__self__>` شیء نمونه با متد :meth:`!m` است و :attr:"
"`m.__func__ <method.__func__>` همان :ref:`function object <user-defined-"
"funcs>` مربوط به متد است."

#: ../../tutorial/classes.rst:782
msgid "Iterators"
msgstr "ترتیب دهنده ها"

#: ../../tutorial/classes.rst:784
msgid ""
"By now you have probably noticed that most container objects can be looped "
"over using a :keyword:`for` statement::"
msgstr ""
"احتمالاً تا حالا متوجه شده اید که اکثر اشیاء ظرفی می توانند با استفاده از یک "
"عبارت :keyword:`for` حلقه زده شوند::"

#: ../../tutorial/classes.rst:787
msgid ""
"for element in [1, 2, 3]:\n"
"    print(element)\n"
"for element in (1, 2, 3):\n"
"    print(element)\n"
"for key in {'one':1, 'two':2}:\n"
"    print(key)\n"
"for char in \"123\":\n"
"    print(char)\n"
"for line in open(\"myfile.txt\"):\n"
"    print(line, end='')"
msgstr ""
"for element in [1, 2, 3]:\n"
"    print(element)\n"
"for element in (1, 2, 3):\n"
"    print(element)\n"
"for key in {'one':1, 'two':2}:\n"
"    print(key)\n"
"for char in \"123\":\n"
"    print(char)\n"
"for line in open(\"myfile.txt\"):\n"
"    print(line, end='')"

#: ../../tutorial/classes.rst:798
msgid ""
"This style of access is clear, concise, and convenient.  The use of "
"iterators pervades and unifies Python.  Behind the scenes, the :keyword:"
"`for` statement calls :func:`iter` on the container object.  The function "
"returns an iterator object that defines the method :meth:`~iterator."
"__next__` which accesses elements in the container one at a time.  When "
"there are no more elements, :meth:`~iterator.__next__` raises a :exc:"
"`StopIteration` exception which tells the :keyword:`!for` loop to "
"terminate.  You can call the :meth:`~iterator.__next__` method using the :"
"func:`next` built-in function; this example shows how it all works::"
msgstr ""
"این سبک دسترسی واضح، مختصر و راحت است. استفاده از پیمانه ها در سراسر Python "
"گسترده و یگانه است. در پشت صحنه، عبارت :keyword:`for` تابع :func:`iter` را "
"بر روی شیء ظرف فراخوانی می کند. این تابع شیء پیمانه ای را برمی گرداند که "
"متد :meth:`~iterator.__next__` را تعریف می کند که عناصر را در ظرف یکی یکی "
"دسترسی می دهد. زمانی که دیگر هیچ عنصری باقی نیست، :meth:`~iterator.__next__` "
"یک استثنای :exc:`StopIteration` را برمی انگیزد که به حلقه ی :keyword:`!for` "
"می گوید که متوقف شود. شما می توانید متد :meth:`~iterator.__next__` را با "
"استفاده از تابع داخلی :func:`next` فراخوانی کنید؛ این مثال نشان می دهد که "
"همه این کارها چگونه انجام می شود:"

#: ../../tutorial/classes.rst:807
msgid ""
">>> s = 'abc'\n"
">>> it = iter(s)\n"
">>> it\n"
"<str_iterator object at 0x10c90e650>\n"
">>> next(it)\n"
"'a'\n"
">>> next(it)\n"
"'b'\n"
">>> next(it)\n"
"'c'\n"
">>> next(it)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"    next(it)\n"
"StopIteration"
msgstr ""
">>> s = 'abc'\n"
">>> it = iter(s)\n"
">>> it\n"
"<str_iterator object at 0x10c90e650>\n"
">>> next(it)\n"
"'a'\n"
">>> next(it)\n"
"'b'\n"
">>> next(it)\n"
"'c'\n"
">>> next(it)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"    next(it)\n"
"StopIteration"

#: ../../tutorial/classes.rst:823
msgid ""
"Having seen the mechanics behind the iterator protocol, it is easy to add "
"iterator behavior to your classes.  Define an :meth:`~container.__iter__` "
"method which returns an object with a :meth:`~iterator.__next__` method.  If "
"the class defines :meth:`!__next__`, then :meth:`!__iter__` can just return "
"``self``::"
msgstr ""
"با مشاهده مکانیزم های پشت پروتکل تکرارگر، افزودن رفتار تکرارگر به کلاس "
"هایتان آسان است. یک متد :meth:`~container.__iter__` تعریف کنید که یک شیء با "
"متد :meth:`~iterator.__next__` را بازگشت دهد. اگر کلاس :meth:`!__next__` را "
"تعریف کند، آنگاه :meth:`!__iter__` می تواند فقط ``self`` را بازگرداند::"

#: ../../tutorial/classes.rst:828
msgid ""
"class Reverse:\n"
"    \"\"\"Iterator for looping over a sequence backwards.\"\"\"\n"
"    def __init__(self, data):\n"
"        self.data = data\n"
"        self.index = len(data)\n"
"\n"
"    def __iter__(self):\n"
"        return self\n"
"\n"
"    def __next__(self):\n"
"        if self.index == 0:\n"
"            raise StopIteration\n"
"        self.index = self.index - 1\n"
"        return self.data[self.index]"
msgstr ""
"class Reverse:\n"
"    \"\"\"Iterator for looping over a sequence backwards.\"\"\"\n"
"    def __init__(self, data):\n"
"        self.data = data\n"
"        self.index = len(data)\n"
"\n"
"    def __iter__(self):\n"
"        return self\n"
"\n"
"    def __next__(self):\n"
"        if self.index == 0:\n"
"            raise StopIteration\n"
"        self.index = self.index - 1\n"
"        return self.data[self.index]"

#: ../../tutorial/classes.rst:845
msgid ""
">>> rev = Reverse('spam')\n"
">>> iter(rev)\n"
"<__main__.Reverse object at 0x00A1DB50>\n"
">>> for char in rev:\n"
"...     print(char)\n"
"...\n"
"m\n"
"a\n"
"p\n"
"s"
msgstr ""
">>> rev = Reverse('spam')\n"
">>> iter(rev)\n"
"<__main__.Reverse object at 0x00A1DB50>\n"
">>> for char in rev:\n"
"...     print(char)\n"
"...\n"
"m\n"
"a\n"
"p\n"
"s"

#: ../../tutorial/classes.rst:860
msgid "Generators"
msgstr "تولیدکننده ها"

#: ../../tutorial/classes.rst:862
msgid ""
":term:`Generators <generator>` are a simple and powerful tool for creating "
"iterators.  They are written like regular functions but use the :keyword:"
"`yield` statement whenever they want to return data.  Each time :func:`next` "
"is called on it, the generator resumes where it left off (it remembers all "
"the data values and which statement was last executed).  An example shows "
"that generators can be trivially easy to create::"
msgstr ""
":term:`Generators <generator>` یک ابزار ساده و قدرتمند برای ایجاد "
"اینتراتورها هستند. آنها مانند توابع عادی نوشته می شوند اما هر زمان که می "
"خواهند داده ای را بازگردانند از دستور :keyword:`yield` استفاده می کنند. هر "
"بار که :func:`next` بر روی آن فراخوانی می شود، مولد از جایی که متوقف شده "
"ادامه می یابد (تمام مقادیر داده ها و اینکه آخرین دستور اجرا شده چه بوده را "
"به خاطر می آورد). یک مثال نشان می دهد که ایجاد مولدها می تواند به طرز "
"باورنکردنی ساده باشد::"

#: ../../tutorial/classes.rst:869
msgid ""
"def reverse(data):\n"
"    for index in range(len(data)-1, -1, -1):\n"
"        yield data[index]"
msgstr ""
"def reverse(data):\n"
"    for index in range(len(data)-1, -1, -1):\n"
"        yield data[index]"

#: ../../tutorial/classes.rst:875
msgid ""
">>> for char in reverse('golf'):\n"
"...     print(char)\n"
"...\n"
"f\n"
"l\n"
"o\n"
"g"
msgstr ""
">>> for char in reverse('golf'):\n"
"...     print(char)\n"
"...\n"
"f\n"
"l\n"
"o\n"
"g"

#: ../../tutorial/classes.rst:883
msgid ""
"Anything that can be done with generators can also be done with class-based "
"iterators as described in the previous section.  What makes generators so "
"compact is that the :meth:`~iterator.__iter__` and :meth:`~generator."
"__next__` methods are created automatically."
msgstr ""
"هر چیزی که با تولیدکننده ها (generators) قابل انجام است، می تواند با استفاده "
"از تکرارگرهای مبتنی بر کلاس نیز انجام شود، همانطور که در بخش قبلی توضیح داده "
"شد. آنچه تولیدکننده ها را فشرده می کند، این است که روش های :meth:`~iterator."
"__iter__` و :meth:`~generator.__next__` به طور خودکار ایجاد می شوند."

#: ../../tutorial/classes.rst:888
msgid ""
"Another key feature is that the local variables and execution state are "
"automatically saved between calls.  This made the function easier to write "
"and much more clear than an approach using instance variables like ``self."
"index`` and ``self.data``."
msgstr ""
"یکی دیگر از ویژگی های کلیدی این است که متغیرهای محلی و وضعیت اجرا به طور "
"خودکار بین فراخوانی ها ذخیره می شوند. این امر نوشتن تابع را آسان تر و خیلی "
"واضح تر از رویکردی که از متغیرهای نمونه ای مانند ``self.index`` و ``self."
"data`` استفاده می کند، کرده است."

#: ../../tutorial/classes.rst:893
msgid ""
"In addition to automatic method creation and saving program state, when "
"generators terminate, they automatically raise :exc:`StopIteration`. In "
"combination, these features make it easy to create iterators with no more "
"effort than writing a regular function."
msgstr ""
"علاوه بر ایجاد خودکار متدها و ذخیره سازی وضعیت برنامه، زمانی که جنراتورها "
"خاتمه می یابند، به طور خودکار :exc:`StopIteration` را ایجاد می کنند. این "
"ویژگی ها به صورت ترکیبی، ساختن تکرارگرها را به همان سادگی نوشتن یک تابع عادی "
"امکان پذیر می سازند."

#: ../../tutorial/classes.rst:902
msgid "Generator Expressions"
msgstr ""
"Generator Expressions\n"
"\n"
"تعبیرات مولد شبیه به لیست  comprehensions هستند ولی به جای تولید یک لیست "
"کامل، یک مولد ایجاد می کنند که مقادیر را به تدریج تولید می کند. این می تواند "
"باعث بهینه سازی حافظه شود و برای پردازش داده های بزرگ مفید باشد. تعبیرات "
"مولد به کمک پرانتز دور نتیجه نوشته می شوند، در حالی که لیست  comprehensions "
"از براکت ها استفاده می کنند."

#: ../../tutorial/classes.rst:904
msgid ""
"Some simple generators can be coded succinctly as expressions using a syntax "
"similar to list comprehensions but with parentheses instead of square "
"brackets. These expressions are designed for situations where the generator "
"is used right away by an enclosing function.  Generator expressions are more "
"compact but less versatile than full generator definitions and tend to be "
"more memory friendly than equivalent list comprehensions."
msgstr ""
"برخی از مولدهای ساده را می توان به صورت مختصر به عنوان عباراتی با استفاده از "
"یک نحو مشابه با درک لیست ها اما با پرانتز به جای کروشه کد کرد. این عبارات "
"برای موقعیت هایی طراحی شده اند که در آن مولد بلافاصله توسط یک تابع فراگیر "
"استفاده می شود. عبارات مولد فشرده تر اما کمتر انعطاف پذیر از تعاریف کامل "
"مولد هستند و به طور معمول نسبت به درک لیست های معادل، حافظه بیشتری را صرفه "
"جویی می کنند."

#: ../../tutorial/classes.rst:911
msgid "Examples::"
msgstr "مثال ها::"

#: ../../tutorial/classes.rst:913
msgid ""
">>> sum(i*i for i in range(10))                 # sum of squares\n"
"285\n"
"\n"
">>> xvec = [10, 20, 30]\n"
">>> yvec = [7, 5, 3]\n"
">>> sum(x*y for x,y in zip(xvec, yvec))         # dot product\n"
"260\n"
"\n"
">>> unique_words = set(word for line in page  for word in line.split())\n"
"\n"
">>> valedictorian = max((student.gpa, student.name) for student in "
"graduates)\n"
"\n"
">>> data = 'golf'\n"
">>> list(data[i] for i in range(len(data)-1, -1, -1))\n"
"['f', 'l', 'o', 'g']"
msgstr ""
">>> sum(i*i for i in range(10))                 # sum of squares\n"
"285\n"
"\n"
">>> xvec = [10, 20, 30]\n"
">>> yvec = [7, 5, 3]\n"
">>> sum(x*y for x,y in zip(xvec, yvec))         # dot product\n"
"260\n"
"\n"
">>> unique_words = set(word for line in page  for word in line.split())\n"
"\n"
">>> valedictorian = max((student.gpa, student.name) for student in "
"graduates)\n"
"\n"
">>> data = 'golf'\n"
">>> list(data[i] for i in range(len(data)-1, -1, -1))\n"
"['f', 'l', 'o', 'g']"

#: ../../tutorial/classes.rst:932
msgid "Footnotes"
msgstr "پاورقی ها"

#: ../../tutorial/classes.rst:933
msgid ""
"Except for one thing.  Module objects have a secret read-only attribute "
"called :attr:`~object.__dict__` which returns the dictionary used to "
"implement the module's namespace; the name ``__dict__`` is an attribute but "
"not a global name. Obviously, using this violates the abstraction of "
"namespace implementation, and should be restricted to things like post-"
"mortem debuggers."
msgstr ""
"با یک استثنا. اشیای ماژول دارای یک ویژگی مخفی و فقط خواندنی به نام :attr:"
"`~object.__dict__` هستند که دیکشنری مورد استفاده برای پیاده سازی فضای نام "
"ماژول را برمی گرداند؛ نام ``__dict__`` یک ویژگی است اما یک نام جهانی نیست. "
"بدیهی است که استفاده از این ویژگی نقض انتزاع پیاده سازی فضای نام است و باید "
"محدود به مواردی مانند دیباگرهای پس از مرگ برنامه باشد."

#: ../../tutorial/classes.rst:343
msgid "object"
msgstr "شیء"

#: ../../tutorial/classes.rst:343
msgid "method"
msgstr "متد"

#: ../../tutorial/classes.rst:679
msgid "name"
msgstr "نام"

#: ../../tutorial/classes.rst:679
msgid "mangling"
msgstr "مخفی سازی نام"
