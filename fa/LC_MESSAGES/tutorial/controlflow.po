# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-07 14:14+0000\n"
"PO-Revision-Date: 2025-08-02 17:35+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Persian (https://app.transifex.com/python-doc/teams/5390/"
"fa/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fa\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../tutorial/controlflow.rst:5
msgid "More Control Flow Tools"
msgstr "ابزارهای کنترل جریان بیشتر"

#: ../../tutorial/controlflow.rst:7
msgid ""
"As well as the :keyword:`while` statement just introduced, Python uses a few "
"more that we will encounter in this chapter."
msgstr ""
"همچنین به علاوه دستور :keyword:`while` که به تازگی معرفی شد، پایتون از چند "
"دستور دیگر نیز استفاده می کند که در این فصل با آن ها مواجه خواهیم شد."

#: ../../tutorial/controlflow.rst:14
msgid ":keyword:`!if` Statements"
msgstr "عبارات :keyword:`!if`"

#: ../../tutorial/controlflow.rst:16
msgid ""
"Perhaps the most well-known statement type is the :keyword:`if` statement.  "
"For example::"
msgstr "شاید شناخته شده ترین نوع دستور، دستور :keyword:`if` باشد. برای مثال:"

#: ../../tutorial/controlflow.rst:19
msgid ""
">>> x = int(input(\"Please enter an integer: \"))\n"
"Please enter an integer: 42\n"
">>> if x < 0:\n"
"...     x = 0\n"
"...     print('Negative changed to zero')\n"
"... elif x == 0:\n"
"...     print('Zero')\n"
"... elif x == 1:\n"
"...     print('Single')\n"
"... else:\n"
"...     print('More')\n"
"...\n"
"More"
msgstr ""
">>> x = int(input(\"لطفاً یک عدد صحیح وارد کنید: \"))\n"
"لطفاً یک عدد صحیح وارد کنید: 42\n"
">>> if x < 0:\n"
"...     x = 0\n"
"...     print('منفی به صفر تغییر یافت')\n"
"... elif x == 0:\n"
"...     print('صفر')\n"
"... elif x == 1:\n"
"...     print('تک')\n"
"... else:\n"
"...     print('بیشتر')\n"
"...\n"
"بیشتر"

#: ../../tutorial/controlflow.rst:33
msgid ""
"There can be zero or more :keyword:`elif` parts, and the :keyword:`else` "
"part is optional.  The keyword ':keyword:`!elif`' is short for 'else if', "
"and is useful to avoid excessive indentation.  An  :keyword:`!if` ... :"
"keyword:`!elif` ... :keyword:`!elif` ... sequence is a substitute for the "
"``switch`` or ``case`` statements found in other languages."
msgstr ""
"می تواند صفر یا بیشتر از بخش های :keyword:`elif` وجود داشته باشد، و بخش :"
"keyword:`else` اختیاری است. کلمه کلیدی ':keyword:`!elif`' به عنوان کوتاه شده "
"'else if' استفاده می شود و برای جلوگیری از تو رفتگی بیش از حد مفید است. "
"دنباله ای :keyword:`!if` ... :keyword:`!elif` ... :keyword:`!elif` ... به "
"عنوان جایگزینی برای عبارات ``switch`` یا ``case`` که در دیگر زبان ها یافت می "
"شود، به کار می رود."

#: ../../tutorial/controlflow.rst:39
msgid ""
"If you're comparing the same value to several constants, or checking for "
"specific types or attributes, you may also find the :keyword:`!match` "
"statement useful. For more details see :ref:`tut-match`."
msgstr ""
"اگر در حال مقایسه یک مقدار با چندین ثابت هستید، یا بررسی نوع های خاص یا "
"ویژگی ها را انجام می دهید، ممکن است دستور :keyword:`!match` برای شما مفید "
"باشد. برای جزئیات بیشتر به :ref:`tut-match` مراجعه کنید."

#: ../../tutorial/controlflow.rst:46
msgid ":keyword:`!for` Statements"
msgstr ":keyword:`!for` اظهارات"

#: ../../tutorial/controlflow.rst:51
msgid ""
"The :keyword:`for` statement in Python differs a bit from what you may be "
"used to in C or Pascal.  Rather than always iterating over an arithmetic "
"progression of numbers (like in Pascal), or giving the user the ability to "
"define both the iteration step and halting condition (as C), Python's :"
"keyword:`!for` statement iterates over the items of any sequence (a list or "
"a string), in the order that they appear in the sequence.  For example (no "
"pun intended):"
msgstr ""
"بیانیه :keyword:`for` در پایتون کمی با آنچه که ممکن است در C یا Pascal به آن "
"عادت داشته باشید تفاوت دارد. به جای تکرار همیشگی از یک دنباله حسابی از اعداد "
"(مانند Pascal)، یا اجازه دادن به کاربر برای تعریف گام تکرار و شرط توقف "
"(مانند C)، بیانیه :keyword:`!for` در پایتون بر روی آیتم های هر دنباله ای "
"(لیست یا رشته) به ترتیب ظاهر شدن آنها در دنباله، تکرار می کند. برای مثال:"

#: ../../tutorial/controlflow.rst:63
msgid ""
">>> # Measure some strings:\n"
">>> words = ['cat', 'window', 'defenestrate']\n"
">>> for w in words:\n"
"...     print(w, len(w))\n"
"...\n"
"cat 3\n"
"window 6\n"
"defenestrate 12"
msgstr ""
">>> # چند رشته را اندازه گیری کنید:\n"
">>> words = ['cat', 'window', 'defenestrate']\n"
">>> for w in words:\n"
"...     print(w, len(w))\n"
"...\n"
"cat 3\n"
"window 6\n"
"defenestrate 12"

#: ../../tutorial/controlflow.rst:72
msgid ""
"Code that modifies a collection while iterating over that same collection "
"can be tricky to get right.  Instead, it is usually more straight-forward to "
"loop over a copy of the collection or to create a new collection::"
msgstr ""
"زمانی که کدی مجموعه ای را در حین پیمایش آن مجموعه تغییر می دهد، ممکن است "
"خطاهایی رخ دهد. به جای این روش، معمولاً ساده تر این است که یا بر روی یک نسخه "
"کپی از مجموعه حلقه بزنید یا یک مجموعه جدید ایجاد کنید::"

#: ../../tutorial/controlflow.rst:76
msgid ""
"# Create a sample collection\n"
"users = {'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active'}\n"
"\n"
"# Strategy:  Iterate over a copy\n"
"for user, status in users.copy().items():\n"
"    if status == 'inactive':\n"
"        del users[user]\n"
"\n"
"# Strategy:  Create a new collection\n"
"active_users = {}\n"
"for user, status in users.items():\n"
"    if status == 'active':\n"
"        active_users[user] = status"
msgstr ""
"# ایجاد یک مجموعه نمونه\n"
"users = {'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active'}\n"
"\n"
"# استراتژی: تکرار روی یک کپی\n"
"for user, status in users.copy().items():\n"
"    if status == 'inactive':\n"
"        del users[user]\n"
"\n"
"# استراتژی: ایجاد یک مجموعه جدید\n"
"active_users = {}\n"
"for user, status in users.items():\n"
"    if status == 'active':\n"
"        active_users[user] = status"

#: ../../tutorial/controlflow.rst:94
msgid "The :func:`range` Function"
msgstr "تابع :func:`range`"

#: ../../tutorial/controlflow.rst:96
msgid ""
"If you do need to iterate over a sequence of numbers, the built-in function :"
"func:`range` comes in handy.  It generates arithmetic progressions::"
msgstr ""
"اگر نیاز دارید بر روی دنباله ای از اعداد تکرار کنید، تابع داخلی :func:"
"`range` کارآمد است. این تابع، پیشرفت های حسابی تولید می کند::"

#: ../../tutorial/controlflow.rst:99
msgid ""
">>> for i in range(5):\n"
"...     print(i)\n"
"...\n"
"0\n"
"1\n"
"2\n"
"3\n"
"4"
msgstr ""
">>> for i in range(5):\n"
"...     print(i)\n"
"...\n"
"0\n"
"1\n"
"2\n"
"3\n"
"4"

#: ../../tutorial/controlflow.rst:108
msgid ""
"The given end point is never part of the generated sequence; ``range(10)`` "
"generates 10 values, the legal indices for items of a sequence of length "
"10.  It is possible to let the range start at another number, or to specify "
"a different increment (even negative; sometimes this is called the 'step')::"
msgstr ""
"نقطه پایانی که داده شده است هیچ وقت بخشی از دنباله تولید شده نیست؛ "
"``range(10)`` تعداد 10 مقدار تولید می کند، شاخص های قانونی برای اعضای یک "
"دنباله با طول 10. امکان شروع بازه از عدد دیگری وجود دارد یا می توان یک "
"افزایش دهنده (حتی منفی؛ گاهی اوقات این را 'گام' می نامند) متفاوت را مشخص کرد:"

#: ../../tutorial/controlflow.rst:113
msgid ""
">>> list(range(5, 10))\n"
"[5, 6, 7, 8, 9]\n"
"\n"
">>> list(range(0, 10, 3))\n"
"[0, 3, 6, 9]\n"
"\n"
">>> list(range(-10, -100, -30))\n"
"[-10, -40, -70]"
msgstr ""
">>> list(range(5, 10))\n"
"[5, 6, 7, 8, 9]\n"
"\n"
">>> list(range(0, 10, 3))\n"
"[0, 3, 6, 9]\n"
"\n"
">>> list(range(-10, -100, -30))\n"
"[-10, -40, -70]"

#: ../../tutorial/controlflow.rst:122
msgid ""
"To iterate over the indices of a sequence, you can combine :func:`range` "
"and :func:`len` as follows::"
msgstr ""
"برای پیمایش بر روی شاخص های یک دنباله، می توانید :func:`range` و :func:`len` "
"را به صورت زیر ترکیب کنید::"

#: ../../tutorial/controlflow.rst:125
msgid ""
">>> a = ['Mary', 'had', 'a', 'little', 'lamb']\n"
">>> for i in range(len(a)):\n"
"...     print(i, a[i])\n"
"...\n"
"0 Mary\n"
"1 had\n"
"2 a\n"
"3 little\n"
"4 lamb"
msgstr ""
">>> a = ['Mary', 'had', 'a', 'little', 'lamb']\n"
">>> for i in range(len(a)):\n"
"...     print(i, a[i])\n"
"...\n"
"0 Mary\n"
"1 had\n"
"2 a\n"
"3 little\n"
"4 lamb"

#: ../../tutorial/controlflow.rst:135
msgid ""
"In most such cases, however, it is convenient to use the :func:`enumerate` "
"function, see :ref:`tut-loopidioms`."
msgstr ""
"در بسیاری از این موارد، با این حال، استفاده از تابع :func:`enumerate` راحت "
"است، رجوع کنید به :ref:`tut-loopidioms`."

#: ../../tutorial/controlflow.rst:138
msgid "A strange thing happens if you just print a range::"
msgstr "اگر شما فقط یک range را چاپ کنید، اتفاق عجیبی رخ می دهد:"

#: ../../tutorial/controlflow.rst:140
msgid ""
">>> range(10)\n"
"range(0, 10)"
msgstr ""
">>> range(10)\n"
"range(0, 10)"

#: ../../tutorial/controlflow.rst:143
msgid ""
"In many ways the object returned by :func:`range` behaves as if it is a "
"list, but in fact it isn't. It is an object which returns the successive "
"items of the desired sequence when you iterate over it, but it doesn't "
"really make the list, thus saving space."
msgstr ""
"به بسیاری از جهات، شیء بازگشتی توسط :func:`range` رفتار می کند انگار که یک "
"لیست است، اما در واقع این طور نیست. این یک شیء است که آیتم های متوالی از "
"دنباله ی مورد نظر را زمانی که بر روی آن تکرار می کنید، بازمی گرداند، اما در "
"حقیقت لیست را نمی سازد و بدین ترتیب فضای ذخیره سازی را حفظ می کند."

#: ../../tutorial/controlflow.rst:148
msgid ""
"We say such an object is :term:`iterable`, that is, suitable as a target for "
"functions and constructs that expect something from which they can obtain "
"successive items until the supply is exhausted.  We have seen that the :"
"keyword:`for` statement is such a construct, while an example of a function "
"that takes an iterable is :func:`sum`::"
msgstr ""
"ما به چنین شیء :term:`iterable` می گوییم، به این معنی که برای استفاده در "
"توابع و ساختارهایی مناسب است که انتظار دارند چیزی داشته باشند که بتوانند از "
"آن به ترتیب آیتم هایی را دریافت کنند تا وقتی که منابع به پایان برسد.  ما "
"دیده ایم که عبارت :keyword:`for` ساختاری از این قبیل است، در حالی که مثالی "
"از یک تابع که یک iterable می گیرد :func:`sum` است::"

#: ../../tutorial/controlflow.rst:154
msgid ""
">>> sum(range(4))  # 0 + 1 + 2 + 3\n"
"6"
msgstr ""
">>> sum(range(4))  # 0 + 1 + 2 + 3\n"
"6"

#: ../../tutorial/controlflow.rst:157
msgid ""
"Later we will see more functions that return iterables and take iterables as "
"arguments.  In chapter :ref:`tut-structures`, we will discuss in more detail "
"about :func:`list`."
msgstr ""
"در ادامه، توابع بیشتری را خواهیم دید که تکرارشونده ها را برمی گردانند و "
"تکرارشونده ها را به عنوان آرگومان می پذیرند. در فصل :ref:`tut-structures`، "
"درباره :func:`list` به تفصیل بیشتری صحبت خواهیم کرد."

#: ../../tutorial/controlflow.rst:164
msgid ":keyword:`!break` and :keyword:`!continue` Statements"
msgstr ":keyword:`!break` و :keyword:`!continue` گزاره ها"

#: ../../tutorial/controlflow.rst:166
msgid ""
"The :keyword:`break` statement breaks out of the innermost enclosing :"
"keyword:`for` or :keyword:`while` loop::"
msgstr ""
"دستور :keyword:`break` از درونی ترین حلقه های :keyword:`for` یا :keyword:"
"`while` خارج می شود::"

#: ../../tutorial/controlflow.rst:169
msgid ""
">>> for n in range(2, 10):\n"
"...     for x in range(2, n):\n"
"...         if n % x == 0:\n"
"...             print(f\"{n} equals {x} * {n//x}\")\n"
"...             break\n"
"...\n"
"4 equals 2 * 2\n"
"6 equals 2 * 3\n"
"8 equals 2 * 4\n"
"9 equals 3 * 3"
msgstr ""
">>> برای n در range(2, 10):\n"
"...     برای x در range(2, n):\n"
"...         اگر n % x == 0:\n"
"...             print(f\"{n} برابر است با {x} ضربدر {n//x}\")\n"
"...             break\n"
"...     else:\n"
"...         print(f\"{n} یک عدد اول است\")"

#: ../../tutorial/controlflow.rst:180
msgid ""
"The :keyword:`continue` statement continues with the next iteration of the "
"loop::"
msgstr "بیانیه :keyword:`continue` با تکرار بعدی حلقه ادامه می یابد."

#: ../../tutorial/controlflow.rst:183
msgid ""
">>> for num in range(2, 10):\n"
"...     if num % 2 == 0:\n"
"...         print(f\"Found an even number {num}\")\n"
"...         continue\n"
"...     print(f\"Found an odd number {num}\")\n"
"...\n"
"Found an even number 2\n"
"Found an odd number 3\n"
"Found an even number 4\n"
"Found an odd number 5\n"
"Found an even number 6\n"
"Found an odd number 7\n"
"Found an even number 8\n"
"Found an odd number 9"
msgstr ""
"برای num در بازه ی 2 تا 10:\n"
"    اگر num % 2 == 0:\n"
"        چاپ کن(f\"عدد زوج پیدا شد {num}\")\n"
"        ادامه بده\n"
"    چاپ کن(f\"عدد فرد پیدا شد {num}\")\n"
"\n"
"عدد زوج پیدا شد 2\n"
"عدد فرد پیدا شد 3\n"
"عدد زوج پیدا شد 4\n"
"عدد فرد پیدا شد 5\n"
"عدد زوج پیدا شد 6\n"
"عدد فرد پیدا شد 7\n"
"عدد زوج پیدا شد 8\n"
"عدد فرد پیدا شد 9"

#: ../../tutorial/controlflow.rst:202
msgid ":keyword:`!else` Clauses on Loops"
msgstr ":keyword:`!else` بندهایی درباره حلقه ها"

#: ../../tutorial/controlflow.rst:204
msgid ""
"In a :keyword:`!for` or :keyword:`!while` loop the :keyword:`!break` "
"statement may be paired with an :keyword:`!else` clause.  If the loop "
"finishes without executing the :keyword:`!break`, the :keyword:`!else` "
"clause executes."
msgstr ""
"در یک حلقه :keyword:`!for` یا :keyword:`!while`، دستور :keyword:`!break` "
"ممکن است با یک شرط :keyword:`!else` جفت شود. اگر حلقه بدون اجرای :keyword:`!"
"break` به پایان برسد، شرط :keyword:`!else` اجرا می شود."

#: ../../tutorial/controlflow.rst:208
msgid ""
"In a :keyword:`for` loop, the :keyword:`!else` clause is executed after the "
"loop finishes its final iteration, that is, if no break occurred."
msgstr ""
"در یک حلقه :keyword:`for`، عبارت :keyword:`!else` پس از پایان یافتن آخرین "
"تکرار حلقه اجرا می شود، یعنی اگر هیچ توقفی رخ نداده باشد."

#: ../../tutorial/controlflow.rst:211
msgid ""
"In a :keyword:`while` loop, it's executed after the loop's condition becomes "
"false."
msgstr ""
"در یک حلقه :keyword:`while`، این پس از آن اجرا می شود که شرط حلقه نادرست می "
"شود."

#: ../../tutorial/controlflow.rst:213
msgid ""
"In either kind of loop, the :keyword:`!else` clause is **not** executed if "
"the loop was terminated by a :keyword:`break`.  Of course, other ways of "
"ending the loop early, such as a :keyword:`return` or a raised exception, "
"will also skip execution of the :keyword:`else` clause."
msgstr ""
"در هر دو نوع حلقه، بخش :keyword:`!else` تنها زمانی **not** اجرا می شود که "
"حلقه توسط یک :keyword:`break` خاتمه یافته باشد. البته، روش های دیگری برای "
"پایان دادن به حلقه به صورت زودهنگام، مانند یک :keyword:`return` یا ایجاد "
"استثنا، نیز باعث می شوند که اجرای بخش :keyword:`else` نادیده گرفته شود."

#: ../../tutorial/controlflow.rst:218
msgid ""
"This is exemplified in the following :keyword:`!for` loop, which searches "
"for prime numbers::"
msgstr ""
"این در حلقه :keyword:`!for` زیر که به دنبال اعداد اول می گردد، نشان داده شده "
"است::"

#: ../../tutorial/controlflow.rst:221
msgid ""
">>> for n in range(2, 10):\n"
"...     for x in range(2, n):\n"
"...         if n % x == 0:\n"
"...             print(n, 'equals', x, '*', n//x)\n"
"...             break\n"
"...     else:\n"
"...         # loop fell through without finding a factor\n"
"...         print(n, 'is a prime number')\n"
"...\n"
"2 is a prime number\n"
"3 is a prime number\n"
"4 equals 2 * 2\n"
"5 is a prime number\n"
"6 equals 2 * 3\n"
"7 is a prime number\n"
"8 equals 2 * 4\n"
"9 equals 3 * 3"
msgstr ""
">>> برای n در بازه(2, 10):\n"
"...     برای x در بازه(2, n):\n"
"...         اگر n % x == 0:\n"
"...             print(n, 'equals', x, '*', n//x)\n"
"...             break\n"
"...     else:\n"
"...         # loop fell through without finding a factor\n"
"...         print(n, 'is a prime number')\n"
"...\n"
"2 is a prime number\n"
"3 is a prime number\n"
"4 equals 2 * 2\n"
"5 یک عدد اول است\n"
"6 برابر است با 2 * 3\n"
"7 is a prime number\n"
"8 equals 2 * 4\n"
"9 برابر است با 3 * 3"

#: ../../tutorial/controlflow.rst:239
msgid ""
"(Yes, this is the correct code.  Look closely: the ``else`` clause belongs "
"to the ``for`` loop, **not** the ``if`` statement.)"
msgstr ""
"(بله، این کد درست است. با دقت نگاه کنید: قید ``else`` به حلقه ``for`` تعلق "
"دارد، **not** به عبارت ``if``.)"

#: ../../tutorial/controlflow.rst:242
msgid ""
"One way to think of the else clause is to imagine it paired with the ``if`` "
"inside the loop.  As the loop executes, it will run a sequence like if/if/if/"
"else. The ``if`` is inside the loop, encountered a number of times. If the "
"condition is ever true, a ``break`` will happen. If the condition is never "
"true, the ``else`` clause outside the loop will execute."
msgstr ""
"یک راه برای فکر کردن به گزاره else این است که آن را با ``if`` داخل حلقه تصور "
"کنید. هنگامی که حلقه اجرا می شود، اجرا به صورت if/if/if/else خواهد بود. "
"``if`` داخل حلقه، چندین بار برخورد می شود. اگر شرطی صحیح باشد، یک ``break`` "
"اتفاق خواهد افتاد. اگر هیچ گاه شرطی صحیح نباشد، گزاره ``else`` خارج از حلقه "
"اجرا خواهد شد."

#: ../../tutorial/controlflow.rst:248
msgid ""
"When used with a loop, the ``else`` clause has more in common with the "
"``else`` clause of a :keyword:`try` statement than it does with that of "
"``if`` statements: a ``try`` statement's ``else`` clause runs when no "
"exception occurs, and a loop's ``else`` clause runs when no ``break`` "
"occurs. For more on the ``try`` statement and exceptions, see :ref:`tut-"
"handling`."
msgstr ""
"هنگامی که با یک حلقه استفاده می شود، عبارت ``else`` بیشتر با عبارت ``else`` "
"در یک دستور :keyword:`try` شباهت دارد تا با عبارت دستورهای ``if``: عبارت "
"``else`` در یک دستور ``try`` زمانی اجرا می شود که استثنایی رخ ندهد، و عبارت "
"``else`` در یک حلقه زمانی اجرا می شود که ``break`` رخ ندهد. برای اطلاعات "
"بیشتر درباره دستور ``try`` و استثناها، به :ref:`tut-handling` مراجعه کنید."

#: ../../tutorial/controlflow.rst:257
msgid ":keyword:`!pass` Statements"
msgstr ":keyword:`!pass` دستورات"

#: ../../tutorial/controlflow.rst:259
msgid ""
"The :keyword:`pass` statement does nothing. It can be used when a statement "
"is required syntactically but the program requires no action. For example::"
msgstr ""
"عبارت :keyword:`pass` هیچ کاری انجام نمی دهد. این عبارت می تواند زمانی "
"استفاده شود که به صورت نحوی یک عبارت لازم است اما برنامه به هیچ عملی نیازی "
"ندارد. برای مثال::"

#: ../../tutorial/controlflow.rst:262
msgid ""
">>> while True:\n"
"...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)\n"
"..."
msgstr ""
">>> while True:\n"
"...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)\n"
"..."

#: ../../tutorial/controlflow.rst:266
msgid "This is commonly used for creating minimal classes::"
msgstr "این معمولاً برای ایجاد کلاس های حداقلی استفاده می شود::"

#: ../../tutorial/controlflow.rst:268
msgid ""
">>> class MyEmptyClass:\n"
"...     pass\n"
"..."
msgstr ""
">>> class MyEmptyClass:\n"
"...     pass\n"
"..."

#: ../../tutorial/controlflow.rst:272
msgid ""
"Another place :keyword:`pass` can be used is as a place-holder for a "
"function or conditional body when you are working on new code, allowing you "
"to keep thinking at a more abstract level.  The :keyword:`!pass` is silently "
"ignored::"
msgstr ""
"جای دیگری که :keyword:`pass` می تواند استفاده شود به عنوان یک جای نگه دار "
"برای بدنه یک تابع یا شرطی زمانی است که شما در حال کار روی کد جدیدی هستید، که "
"به شما اجازه می دهد تا به تفکر در سطحی انتزاعی تر ادامه دهید. :keyword:`!"
"pass` به صورت خاموش نادیده گرفته می شود::"

#: ../../tutorial/controlflow.rst:276
msgid ""
">>> def initlog(*args):\n"
"...     pass   # Remember to implement this!\n"
"..."
msgstr ""
">>> def initlog(*args):\n"
"...     pass   # Remember to implement this!\n"
"..."

#: ../../tutorial/controlflow.rst:284
msgid ":keyword:`!match` Statements"
msgstr ":keyword:`!match` دستورات"

#: ../../tutorial/controlflow.rst:286
msgid ""
"A :keyword:`match` statement takes an expression and compares its value to "
"successive patterns given as one or more case blocks.  This is superficially "
"similar to a switch statement in C, Java or JavaScript (and many other "
"languages), but it's more similar to pattern matching in languages like Rust "
"or Haskell. Only the first pattern that matches gets executed and it can "
"also extract components (sequence elements or object attributes) from the "
"value into variables. If no case matches, none of the branches is executed."
msgstr ""

#: ../../tutorial/controlflow.rst:295
msgid ""
"The simplest form compares a subject value against one or more literals::"
msgstr ""
"ساده ترین شکل، یک مقدار موضوع را با یک یا چند مقدار ثابت مقایسه می کند::"

#: ../../tutorial/controlflow.rst:297
msgid ""
"def http_error(status):\n"
"    match status:\n"
"        case 400:\n"
"            return \"Bad request\"\n"
"        case 404:\n"
"            return \"Not found\"\n"
"        case 418:\n"
"            return \"I'm a teapot\"\n"
"        case _:\n"
"            return \"Something's wrong with the internet\""
msgstr ""
"def http_error(status):\n"
"    match status:\n"
"        case 400:\n"
"            return \"Bad request\"\n"
"        case 404:\n"
"            return \"Not found\"\n"
"        case 418:\n"
"            return \"I'm a teapot\"\n"
"        case _:\n"
"            return \"Something's wrong with the internet\""

#: ../../tutorial/controlflow.rst:308
msgid ""
"Note the last block: the \"variable name\" ``_`` acts as a *wildcard* and "
"never fails to match."
msgstr ""

#: ../../tutorial/controlflow.rst:311
msgid ""
"You can combine several literals in a single pattern using ``|`` (\"or\")::"
msgstr ""
"شما می توانید چندین مقدار مشخص را در یک الگو با استفاده از ``|`` (\"یا\") "
"ترکیب کنید::"

#: ../../tutorial/controlflow.rst:313
msgid ""
"case 401 | 403 | 404:\n"
"    return \"Not allowed\""
msgstr ""
"مورد ۴۰۱ | ۴۰۳ | ۴۰۴:\n"
"    return \"اجازه داده نمی شود\""

#: ../../tutorial/controlflow.rst:316
msgid ""
"Patterns can look like unpacking assignments, and can be used to bind "
"variables::"
msgstr ""
"الگوها می توانند شبیه به تخصیص های باز کردن باشند و می توانند برای بستن "
"متغیرها استفاده شوند::"

#: ../../tutorial/controlflow.rst:319
msgid ""
"# point is an (x, y) tuple\n"
"match point:\n"
"    case (0, 0):\n"
"        print(\"Origin\")\n"
"    case (0, y):\n"
"        print(f\"Y={y}\")\n"
"    case (x, 0):\n"
"        print(f\"X={x}\")\n"
"    case (x, y):\n"
"        print(f\"X={x}, Y={y}\")\n"
"    case _:\n"
"        raise ValueError(\"Not a point\")"
msgstr ""
"# point is an (x, y) tuple\n"
"match point:\n"
"    case (0, 0):\n"
"        print(\"Origin\")\n"
"    case (0, y):\n"
"        print(f\"Y={y}\")\n"
"    case (x, 0):\n"
"        print(f\"X={x}\")\n"
"    case (x, y):\n"
"        print(f\"X={x}, Y={y}\")\n"
"    case _:\n"
"        raise ValueError(\"Not a point\")"

#: ../../tutorial/controlflow.rst:332
msgid ""
"Study that one carefully!  The first pattern has two literals, and can be "
"thought of as an extension of the literal pattern shown above.  But the next "
"two patterns combine a literal and a variable, and the variable *binds* a "
"value from the subject (``point``).  The fourth pattern captures two values, "
"which makes it conceptually similar to the unpacking assignment ``(x, y) = "
"point``."
msgstr ""
"به دقت این را مطالعه کنید! الگوی اول دو مقدار ثابت دارد و می توان آن را به "
"عنوان یک گسترش از الگوی مقدار ثابت نشان داده شده در بالا در نظر گرفت. اما، "
"دو الگوی بعدی یک مقدار ثابت و یک متغیر را ترکیب می کنند و متغیر *binds* یک "
"مقدار از موضوع (``point``) را می گیرد. الگوی چهارم دو مقدار را ضبط می کند که "
"این باعث می شود از نظر مفهومی به تخصیص بازکردن ``(x, y) = point`` شبیه باشد."

#: ../../tutorial/controlflow.rst:339
msgid ""
"If you are using classes to structure your data you can use the class name "
"followed by an argument list resembling a constructor, but with the ability "
"to capture attributes into variables::"
msgstr ""
"اگر از کلاس ها برای ساختاردهی داده ها استفاده می کنید، می توانید از نام کلاس "
"به همراه یک لیست از آرگومان ها استفاده کنید که شبیه به یک سازنده عمل می کند، "
"اما با این قابلیت که ویژگی ها را در متغیرها ذخیره کنید::"

#: ../../tutorial/controlflow.rst:343
msgid ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x = x\n"
"        self.y = y\n"
"\n"
"def where_is(point):\n"
"    match point:\n"
"        case Point(x=0, y=0):\n"
"            print(\"Origin\")\n"
"        case Point(x=0, y=y):\n"
"            print(f\"Y={y}\")\n"
"        case Point(x=x, y=0):\n"
"            print(f\"X={x}\")\n"
"        case Point():\n"
"            print(\"Somewhere else\")\n"
"        case _:\n"
"            print(\"Not a point\")"
msgstr ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x = x\n"
"        self.y = y\n"
"\n"
"def where_is(point):\n"
"    match point:\n"
"        case Point(x=0, y=0):\n"
"            print(\"Origin\")\n"
"        case Point(x=0, y=y):\n"
"            print(f\"Y={y}\")\n"
"        case Point(x=x, y=0):\n"
"            print(f\"X={x}\")\n"
"        case Point():\n"
"            print(\"Somewhere else\")\n"
"        case _:\n"
"            print(\"Not a point\")"

#: ../../tutorial/controlflow.rst:361
msgid ""
"You can use positional parameters with some builtin classes that provide an "
"ordering for their attributes (e.g. dataclasses). You can also define a "
"specific position for attributes in patterns by setting the "
"``__match_args__`` special attribute in your classes. If it's set to (\"x\", "
"\"y\"), the following patterns are all equivalent (and all bind the ``y`` "
"attribute to the ``var`` variable)::"
msgstr ""
"شما می توانید از پارامترهای موقعیتی با برخی کلاس های داخلی که یک ترتیب دهی "
"برای ویژگی هایشان ارائه می دهند (مانند dataclasses) استفاده کنید. شما همچنین "
"می توانید موقعیت خاصی را برای ویژگی ها در الگوها با تنظیم ویژگی خاص "
"``__match_args__`` در کلاس های خود تعریف کنید. اگر روی (\"x\", \"y\") تنظیم "
"شود، الگوهای زیر همگی معادل هستند (و همگی ویژگی ``y`` را به متغیر ``var`` "
"متصل می کنند):"

#: ../../tutorial/controlflow.rst:367
msgid ""
"Point(1, var)\n"
"Point(1, y=var)\n"
"Point(x=1, y=var)\n"
"Point(y=var, x=1)"
msgstr ""
"Point(1, var)\n"
"Point(1, y=var)\n"
"Point(x=1, y=var)\n"
"Point(y=var, x=1)"

#: ../../tutorial/controlflow.rst:372
msgid ""
"A recommended way to read patterns is to look at them as an extended form of "
"what you would put on the left of an assignment, to understand which "
"variables would be set to what. Only the standalone names (like ``var`` "
"above) are assigned to by a match statement. Dotted names (like ``foo."
"bar``), attribute names (the ``x=`` and ``y=`` above) or class names "
"(recognized by the \"(...)\" next to them like ``Point`` above) are never "
"assigned to."
msgstr ""
"روش توصیه شده برای خواندن الگوها این است که به آنها به عنوان شکلی گسترش "
"یافته از چیزی که در سمت چپ یک تخصیص قرار می دهید نگاه کنید، تا بفهمید کدام "
"متغیرها به چه چیزی تنظیم می شوند. تنها نام های مستقل (مثل ``var`` بالا) توسط "
"یک عبارت match تخصیص داده می شوند. نام های نقطه دار (مثل ``foo.bar``)، نام "
"های ویژگی (``x=`` و ``y=`` بالا) یا نام های کلاس (که با \"(...)\" کنارشان "
"شناخته می شوند مثل ``Point`` بالا) هرگز تخصیص داده نمی شوند."

#: ../../tutorial/controlflow.rst:379
msgid ""
"Patterns can be arbitrarily nested.  For example, if we have a short list of "
"Points, with ``__match_args__`` added, we could match it like this::"
msgstr ""
"الگوها می توانند به صورت دلخواه تو در تو قرار گیرند. به عنوان مثال، اگر یک "
"لیست کوتاه از Points داشته باشیم که ``__match_args__`` به آن اضافه شده باشد، "
"می توانیم به این صورت آن را تطبیق دهیم::"

#: ../../tutorial/controlflow.rst:382
msgid ""
"class Point:\n"
"    __match_args__ = ('x', 'y')\n"
"    def __init__(self, x, y):\n"
"        self.x = x\n"
"        self.y = y\n"
"\n"
"match points:\n"
"    case []:\n"
"        print(\"No points\")\n"
"    case [Point(0, 0)]:\n"
"        print(\"The origin\")\n"
"    case [Point(x, y)]:\n"
"        print(f\"Single point {x}, {y}\")\n"
"    case [Point(0, y1), Point(0, y2)]:\n"
"        print(f\"Two on the Y axis at {y1}, {y2}\")\n"
"    case _:\n"
"        print(\"Something else\")"
msgstr ""
"class Point:\n"
"    __match_args__ = ('x', 'y')\n"
"    def __init__(self, x, y):\n"
"        self.x = x\n"
"        self.y = y\n"
"\n"
"match points:\n"
"    case []:\n"
"        print(\"No points\")\n"
"    case [Point(0, 0)]:\n"
"        print(\"The origin\")\n"
"    case [Point(x, y)]:\n"
"        print(f\"Single point {x}, {y}\")\n"
"    case [Point(0, y1), Point(0, y2)]:\n"
"        print(f\"Two on the Y axis at {y1}, {y2}\")\n"
"    case _:\n"
"        print(\"Something else\")"

#: ../../tutorial/controlflow.rst:400
msgid ""
"We can add an ``if`` clause to a pattern, known as a \"guard\".  If the "
"guard is false, ``match`` goes on to try the next case block.  Note that "
"value capture happens before the guard is evaluated::"
msgstr ""
"ما می توانیم یک بند ``if`` به یک الگو اضافه کنیم، که به عنوان \"محافظ\" "
"شناخته می شود. اگر محافظ نادرست باشد، ``match`` به بلوک بعدی می رود. توجه "
"داشته باشید که جذب مقدار قبل از ارزیابی محافظ رخ می دهد::"

#: ../../tutorial/controlflow.rst:404
msgid ""
"match point:\n"
"    case Point(x, y) if x == y:\n"
"        print(f\"Y=X at {x}\")\n"
"    case Point(x, y):\n"
"        print(f\"Not on the diagonal\")"
msgstr ""
"match point:\n"
"    case Point(x, y) if x == y:\n"
"        print(f\"Y=X at {x}\")\n"
"    case Point(x, y):\n"
"        print(f\"Not on the diagonal\")"

#: ../../tutorial/controlflow.rst:410
msgid "Several other key features of this statement:"
msgstr "چند ویژگی  کلیدی دیگر این عبارت:"

#: ../../tutorial/controlflow.rst:412
msgid ""
"Like unpacking assignments, tuple and list patterns have exactly the same "
"meaning and actually match arbitrary sequences.  An important exception is "
"that they don't match iterators or strings."
msgstr ""
"مانند تخصیص های بازکردن بسته، الگوهای تاپل و لیست دقیقا همان معنا را دارند و "
"در واقع با توالی های دلخواه تطابق دارند. یک استثنای مهم این است که آنها با "
"iteratorها یا رشته ها مطابقت ندارند."

#: ../../tutorial/controlflow.rst:416
msgid ""
"Sequence patterns support extended unpacking: ``[x, y, *rest]`` and ``(x, y, "
"*rest)`` work similar to unpacking assignments.  The name after ``*`` may "
"also be ``_``, so ``(x, y, *_)`` matches a sequence of at least two items "
"without binding the remaining items."
msgstr ""
"الگوهای دنباله ای از باز کردن توسعه یافته پشتیبانی می کنند: ``[x, y, "
"*rest]`` و ``(x, y, *rest)`` به صورت مشابه با اختصاص باز کردن کار می کنند. "
"نام بعد از ``*`` ممکن است ``_`` باشد، بنابراین ``(x, y, *_)`` با دنباله ای "
"از حداقل دو آیتم مطابقت دارد بدون اینکه آیتم ها ی باقی مانده را متصل کند."

#: ../../tutorial/controlflow.rst:421
msgid ""
"Mapping patterns: ``{\"bandwidth\": b, \"latency\": l}`` captures the "
"``\"bandwidth\"`` and ``\"latency\"`` values from a dictionary.  Unlike "
"sequence patterns, extra keys are ignored.  An unpacking like ``**rest`` is "
"also supported.  (But ``**_`` would be redundant, so it is not allowed.)"
msgstr ""
"الگوهای نگاشت: ``{\"bandwidth\": b, \"latency\": l}`` مقادیر "
"``\"bandwidth\"`` و ``\"latency\"`` را از یک دیکشنری استخراج می کند. بر خلاف "
"الگوهای دنباله ای، کلیدهای اضافی نادیده گرفته می شوند. مشابه ``**rest`` نیز "
"پشتیبانی می شود. (اما ``**_`` زائد خواهد بود، بنابراین مجاز نیست.)"

#: ../../tutorial/controlflow.rst:426
msgid "Subpatterns may be captured using the ``as`` keyword::"
msgstr "می توان الگوهای جزئی را با استفاده از کلیدواژه ``as`` ضبط کرد::"

#: ../../tutorial/controlflow.rst:428
msgid "case (Point(x1, y1), Point(x2, y2) as p2): ..."
msgstr "case (Point(x1, y1), Point(x2, y2) as p2): ..."

#: ../../tutorial/controlflow.rst:430
msgid ""
"will capture the second element of the input as ``p2`` (as long as the input "
"is a sequence of two points)"
msgstr ""
"عنصر دوم ورودی را به عنوان ``p2`` در نظر می گیرد (تا زمانی که ورودی یک "
"دنباله از دو نقطه باشد)"

#: ../../tutorial/controlflow.rst:433
msgid ""
"Most literals are compared by equality, however the singletons ``True``, "
"``False`` and ``None`` are compared by identity."
msgstr ""
"بیشتر لیترال ها بر اساس برابری مقایسه می شوند، اما تک تایی ها ``True``، "
"``False`` و ``None`` بر اساس هویت مقایسه می شوند."

#: ../../tutorial/controlflow.rst:436
msgid ""
"Patterns may use named constants.  These must be dotted names to prevent "
"them from being interpreted as capture variable::"
msgstr ""
"الگوها ممکن است از ثابت های نام گذاری شده استفاده کنند. این ها باید به صورت "
"نام های نقطه دار باشند تا از تفسیر آن ها به عنوان متغیر قابل ضبط جلوگیری "
"شود::"

#: ../../tutorial/controlflow.rst:439
msgid ""
"from enum import Enum\n"
"class Color(Enum):\n"
"    RED = 'red'\n"
"    GREEN = 'green'\n"
"    BLUE = 'blue'\n"
"\n"
"color = Color(input(\"Enter your choice of 'red', 'blue' or 'green': \"))\n"
"\n"
"match color:\n"
"    case Color.RED:\n"
"        print(\"I see red!\")\n"
"    case Color.GREEN:\n"
"        print(\"Grass is green\")\n"
"    case Color.BLUE:\n"
"        print(\"I'm feeling the blues :(\")"
msgstr ""
"from enum import Enum\n"
"class Color(Enum):\n"
"    RED = 'red'\n"
"    GREEN = 'green'\n"
"    BLUE = 'blue'\n"
"\n"
"color = Color(input(\"Enter your choice of 'red', 'blue' or 'green': \"))\n"
"\n"
"match color:\n"
"    case Color.RED:\n"
"        print(\"I see red!\")\n"
"    case Color.GREEN:\n"
"        print(\"Grass is green\")\n"
"    case Color.BLUE:\n"
"        print(\"I'm feeling the blues :(\")"

#: ../../tutorial/controlflow.rst:455
msgid ""
"For a more detailed explanation and additional examples, you can look into :"
"pep:`636` which is written in a tutorial format."
msgstr ""
"برای توضیح بیشتر و مثال های اضافی، می توانید به :pep:`636` که به صورت یک "
"آموزش نوشته شده است، مراجعه کنید."

#: ../../tutorial/controlflow.rst:461
msgid "Defining Functions"
msgstr "تعریف توابع"

#: ../../tutorial/controlflow.rst:463
msgid ""
"We can create a function that writes the Fibonacci series to an arbitrary "
"boundary::"
msgstr ""
"ما می توانیم یک تابع ایجاد کنیم که سری فیبوناچی را تا یک مرز دلخواه بنویسد::"

#: ../../tutorial/controlflow.rst:466
msgid ""
">>> def fib(n):    # write Fibonacci series less than n\n"
"...     \"\"\"Print a Fibonacci series less than n.\"\"\"\n"
"...     a, b = 0, 1\n"
"...     while a < n:\n"
"...         print(a, end=' ')\n"
"...         a, b = b, a+b\n"
"...     print()\n"
"...\n"
">>> # Now call the function we just defined:\n"
">>> fib(2000)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597"
msgstr ""
">>> def fib(n):    # نوشتن سری فیبوناچی کمتر از n\n"
"...     \"\"\"سری فیبوناچی کمتر از n را چاپ کنید.\"\"\"\n"
"...     a, b = 0, 1\n"
"...     while a < n:\n"
"...         print(a, end=' ')\n"
"...         a, b = b, a+b\n"
"...     print()\n"
"...\n"
">>> # اکنون تابعی که تعریف کردیم را فراخوانی کنید:\n"
">>> fib(2000)\n"
"0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597"

#: ../../tutorial/controlflow.rst:483
msgid ""
"The keyword :keyword:`def` introduces a function *definition*.  It must be "
"followed by the function name and the parenthesized list of formal "
"parameters. The statements that form the body of the function start at the "
"next line, and must be indented."
msgstr ""
"کلمه کلیدی :keyword:`def` یک تابع *definition* را معرفی می کند. این کلمه "
"باید با نام تابع و لیست پرانتزی پارامترهای رسمی بیاید. دستوراتی که بدنه تابع "
"را تشکیل می دهند باید در خط بعد شروع شوند و تورفتگی داشته باشند."

#: ../../tutorial/controlflow.rst:488
msgid ""
"The first statement of the function body can optionally be a string literal; "
"this string literal is the function's documentation string, or :dfn:"
"`docstring`. (More about docstrings can be found in the section :ref:`tut-"
"docstrings`.) There are tools which use docstrings to automatically produce "
"online or printed documentation, or to let the user interactively browse "
"through code; it's good practice to include docstrings in code that you "
"write, so make a habit of it."
msgstr ""
"اولین عبارت از بدنه تابع می تواند به صورت اختیاری یک رشته متنی باشد؛ این "
"رشته متنی، رشته مستندات تابع یا :dfn:`docstring` نامیده می شود. (اطلاعات "
"بیشتر درباره docstrings را می توانید در بخش :ref:`tut-docstrings` پیدا "
"کنید.) ابزارهایی وجود دارند که از docstrings استفاده می کنند تا به صورت "
"خودکار مستندات آنلاین یا چاپی تولید کنند یا به کاربر اجازه دهند تا به صورت "
"تعاملی بین کد بگردد؛ بنابراین قراردادن docstrings در کدی که می نویسید، تمرین "
"خوبی است و این کار را به صورت عادت انجام دهید."

#: ../../tutorial/controlflow.rst:495
msgid ""
"The *execution* of a function introduces a new symbol table used for the "
"local variables of the function.  More precisely, all variable assignments "
"in a function store the value in the local symbol table; whereas variable "
"references first look in the local symbol table, then in the local symbol "
"tables of enclosing functions, then in the global symbol table, and finally "
"in the table of built-in names. Thus, global variables and variables of "
"enclosing functions cannot be directly assigned a value within a function "
"(unless, for global variables, named in a :keyword:`global` statement, or, "
"for variables of enclosing functions, named in a :keyword:`nonlocal` "
"statement), although they may be referenced."
msgstr ""
"*execution* یک تابع یک جدول نماد جدید معرفی می کند که برای متغیرهای محلی "
"تابع استفاده می شود. به طور دقیق تر، تمام انتساب های متغیر در یک تابع، مقدار "
"را در جدول نماد محلی ذخیره می کنند؛ در حالی که مراجع متغیر ابتدا در جدول "
"نماد محلی جستجو می شوند، سپس در جداول نماد محلی توابع محصورکننده، سپس در "
"جدول نمادهای جهانی، و در نهایت در جدول نام های توکار. بنابراین، به متغیرهای "
"جهانی و متغیرهای توابع محصورکننده نمی توان به طور مستقیم یک مقدار درون تابع "
"اختصاص داد (مگر این که برای متغیرهای جهانی، در یک عبارت :keyword:`global` "
"نام گذاری شوند، یا برای متغیرهای توابع محصورکننده، در یک عبارت :keyword:"
"`nonlocal` نام گذاری شوند)، هرچند ممکن است به آن ها اشاره شود."

#: ../../tutorial/controlflow.rst:506
msgid ""
"The actual parameters (arguments) to a function call are introduced in the "
"local symbol table of the called function when it is called; thus, arguments "
"are passed using *call by value* (where the *value* is always an object "
"*reference*, not the value of the object). [#]_ When a function calls "
"another function, or calls itself recursively, a new local symbol table is "
"created for that call."
msgstr ""
"پارامترهای واقعی (آرگومان ها) در یک فراخوانی تابع هنگام فراخوانی به جدول "
"نماد محلی تابع فراخوانده شده معرفی می شوند؛ بنابراین، آرگومان ها با استفاده "
"از *call by value* منتقل می شوند (که در آن *value* همیشه یک شیء *reference* "
"است، نه مقدار شیء). [#]_ هنگامی که یک تابع، تابع دیگری را فرا می خواند یا "
"خودش را به صورت بازگشتی فراخوانی می کند، یک جدول نماد محلی جدید برای آن "
"فراخوانی ایجاد می شود."

#: ../../tutorial/controlflow.rst:513
msgid ""
"A function definition associates the function name with the function object "
"in the current symbol table.  The interpreter recognizes the object pointed "
"to by that name as a user-defined function.  Other names can also point to "
"that same function object and can also be used to access the function::"
msgstr ""
"تعریف تابع، نام تابع را با شیء تابع در جدول نماد جاری مرتبط می کند. مفسر، "
"شیء اشاره شده توسط آن نام را به عنوان یک تابع تعریف شده توسط کاربر شناسایی "
"می کند. نام های دیگر نیز می توانند به همان شیء تابع اشاره کنند و می توانند "
"برای دسترسی به تابع استفاده شوند:"

#: ../../tutorial/controlflow.rst:518
msgid ""
">>> fib\n"
"<function fib at 10042ed0>\n"
">>> f = fib\n"
">>> f(100)\n"
"0 1 1 2 3 5 8 13 21 34 55 89"
msgstr ""
">>> fib\n"
"<function fib at 10042ed0>\n"
">>> f = fib\n"
">>> f(100)\n"
"0 1 1 2 3 5 8 13 21 34 55 89"

#: ../../tutorial/controlflow.rst:524
msgid ""
"Coming from other languages, you might object that ``fib`` is not a function "
"but a procedure since it doesn't return a value.  In fact, even functions "
"without a :keyword:`return` statement do return a value, albeit a rather "
"boring one.  This value is called ``None`` (it's a built-in name).  Writing "
"the value ``None`` is normally suppressed by the interpreter if it would be "
"the only value written. You can see it if you really want to using :func:"
"`print`::"
msgstr ""
"هنگام انتقال از زبان های دیگر، ممکن است با این موضوع مخالفت کنید که ``fib`` "
"یک تابع نیست بلکه یک رویه است زیرا مقداری بر نمی گرداند. در واقع، حتی توابعی "
"که هیچ عبارت :keyword:`return` ندارند نیز مقداری بر می گردانند، اگرچه مقداری "
"نسبتاً کسل کننده است. این مقدار ``None`` نامیده می شود (این یک نام داخلی "
"است). نوشتن مقدار ``None`` معمولاً توسط مفسر زمانی که تنها مقدار نوشته شده "
"باشد، نادیده گرفته می شود. اگر واقعاً بخواهید، می توانید با استفاده از :func:"
"`print` آن را ببینید."

#: ../../tutorial/controlflow.rst:531
msgid ""
">>> fib(0)\n"
">>> print(fib(0))\n"
"None"
msgstr ""
">>> fib(0)\n"
">>> print(fib(0))\n"
"None"

#: ../../tutorial/controlflow.rst:535
msgid ""
"It is simple to write a function that returns a list of the numbers of the "
"Fibonacci series, instead of printing it::"
msgstr ""
"نوشتن یک تابع که به جای چاپ کردن، فهرستی از اعداد سری فیبوناچی را برمی "
"گرداند، ساده است::"

#: ../../tutorial/controlflow.rst:538
msgid ""
">>> def fib2(n):  # return Fibonacci series up to n\n"
"...     \"\"\"Return a list containing the Fibonacci series up to n.\"\"\"\n"
"...     result = []\n"
"...     a, b = 0, 1\n"
"...     while a < n:\n"
"...         result.append(a)    # see below\n"
"...         a, b = b, a+b\n"
"...     return result\n"
"...\n"
">>> f100 = fib2(100)    # call it\n"
">>> f100                # write the result\n"
"[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]"
msgstr ""
">>> def fib2(n):  # return Fibonacci series up to n\n"
"...     \"\"\"Return a list containing the Fibonacci series up to n.\"\"\"\n"
"...     result = []\n"
"...     a, b = 0, 1\n"
"...     while a < n:\n"
"...         result.append(a)    # see below\n"
"...         a, b = b, a+b\n"
"...     return result\n"
"...\n"
">>> f100 = fib2(100)    # call it\n"
">>> f100                # write the result\n"
"[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]"

#: ../../tutorial/controlflow.rst:551
msgid "This example, as usual, demonstrates some new Python features:"
msgstr "این مثال، طبق معمول، برخی ویژگی های جدید Python را نمایش می دهد:"

#: ../../tutorial/controlflow.rst:553
msgid ""
"The :keyword:`return` statement returns with a value from a function. :"
"keyword:`!return` without an expression argument returns ``None``. Falling "
"off the end of a function also returns ``None``."
msgstr ""
"دستور :keyword:`return` یک مقدار از یک تابع برمی گرداند. :keyword:`!return` "
"بدون یک آرگومان عبارت، ``None`` را برمی گرداند. یعنی خروج از انتهای تابع نیز "
"``None`` را برمی گرداند."

#: ../../tutorial/controlflow.rst:557
msgid ""
"The statement ``result.append(a)`` calls a *method* of the list object "
"``result``.  A method is a function that 'belongs' to an object and is named "
"``obj.methodname``, where ``obj`` is some object (this may be an "
"expression), and ``methodname`` is the name of a method that is defined by "
"the object's type. Different types define different methods.  Methods of "
"different types may have the same name without causing ambiguity.  (It is "
"possible to define your own object types and methods, using *classes*, see :"
"ref:`tut-classes`) The method :meth:`~list.append` shown in the example is "
"defined for list objects; it adds a new element at the end of the list.  In "
"this example it is equivalent to ``result = result + [a]``, but more "
"efficient."
msgstr ""

#: ../../tutorial/controlflow.rst:572
msgid "More on Defining Functions"
msgstr "بیشتر درباره تعریف توابع"

#: ../../tutorial/controlflow.rst:574
msgid ""
"It is also possible to define functions with a variable number of arguments. "
"There are three forms, which can be combined."
msgstr ""
"همچنین امکان تعریف توابع با تعداد متغیری از آرگومان ها وجود دارد. سه فرم "
"وجود دارد که می توانند با هم ترکیب شوند."

#: ../../tutorial/controlflow.rst:581
msgid "Default Argument Values"
msgstr "مقادیر پیش فرض آرگومان ها"

#: ../../tutorial/controlflow.rst:583
msgid ""
"The most useful form is to specify a default value for one or more "
"arguments. This creates a function that can be called with fewer arguments "
"than it is defined to allow.  For example::"
msgstr ""
"مفیدترین حالت، مشخص کردن یک مقدار پیش فرض برای یک یا چند آرگومان است. این "
"کار تابعی ایجاد می کند که می توان آن را با تعداد آرگومان های کمتری نسبت به "
"آنچه که تعریف شده فراخوانی کرد. به عنوان مثال:"

#: ../../tutorial/controlflow.rst:587
msgid ""
"def ask_ok(prompt, retries=4, reminder='Please try again!'):\n"
"    while True:\n"
"        reply = input(prompt)\n"
"        if reply in {'y', 'ye', 'yes'}:\n"
"            return True\n"
"        if reply in {'n', 'no', 'nop', 'nope'}:\n"
"            return False\n"
"        retries = retries - 1\n"
"        if retries < 0:\n"
"            raise ValueError('invalid user response')\n"
"        print(reminder)"
msgstr ""
"def ask_ok(prompt, retries=4, reminder='Please try again!'):\n"
"    while True:\n"
"        reply = input(prompt)\n"
"        if reply in {'y', 'ye', 'yes'}:\n"
"            return True\n"
"        if reply in {'n', 'no', 'nop', 'nope'}:\n"
"            return False\n"
"        retries = retries - 1\n"
"        if retries < 0:\n"
"            raise ValueError('invalid user response')\n"
"        print(reminder)"

#: ../../tutorial/controlflow.rst:599
msgid "This function can be called in several ways:"
msgstr "این تابع می تواند به روش های مختلفی فراخوانی شود:"

#: ../../tutorial/controlflow.rst:601
msgid ""
"giving only the mandatory argument: ``ask_ok('Do you really want to quit?')``"
msgstr "فقط آرگومان اجباری را دادن: ``ask_ok('Do you really want to quit?')``"

#: ../../tutorial/controlflow.rst:603
msgid ""
"giving one of the optional arguments: ``ask_ok('OK to overwrite the file?', "
"2)``"
msgstr ""
"با ارائه یکی از آرگومان های اختیاری: ``ask_ok('OK to overwrite the file?', "
"2)``"

#: ../../tutorial/controlflow.rst:605
msgid ""
"or even giving all arguments: ``ask_ok('OK to overwrite the file?', 2, 'Come "
"on, only yes or no!')``"
msgstr ""
"یا حتی با دادن تمام آرگومان ها: ``ask_ok('OK to overwrite the file?', 2, "
"'Come on, only yes or no!')``"

#: ../../tutorial/controlflow.rst:608
msgid ""
"This example also introduces the :keyword:`in` keyword. This tests whether "
"or not a sequence contains a certain value."
msgstr ""
"این مثال همچنین کلمه کلیدی :keyword:`in` را معرفی می کند. این مورد بررسی می "
"کند که آیا یک دنباله شامل یک مقدار خاص است یا خیر."

#: ../../tutorial/controlflow.rst:611
msgid ""
"The default values are evaluated at the point of function definition in the "
"*defining* scope, so that ::"
msgstr ""
"مقادیر پیش فرض در نقطه تعریف تابع در دامنه *defining* ارزیابی می شوند، به "
"طوری که ::"

#: ../../tutorial/controlflow.rst:614
msgid ""
"i = 5\n"
"\n"
"def f(arg=i):\n"
"    print(arg)\n"
"\n"
"i = 6\n"
"f()"
msgstr ""
"i = 5\n"
"\n"
"def f(arg=i):\n"
"    print(arg)\n"
"\n"
"i = 6\n"
"f()"

#: ../../tutorial/controlflow.rst:622
msgid "will print ``5``."
msgstr "عبارت ``5`` را چاپ خواهد کرد."

#: ../../tutorial/controlflow.rst:624
msgid ""
"**Important warning:**  The default value is evaluated only once. This makes "
"a difference when the default is a mutable object such as a list, "
"dictionary, or instances of most classes.  For example, the following "
"function accumulates the arguments passed to it on subsequent calls::"
msgstr ""
"**Important warning:**  مقدار پیش فرض تنها یک بار ارزیابی می شود. این موضوع "
"زمانی اهمیت پیدا می کند که مقدار پیش فرض یک شیء قابل تغییر مانند یک فهرست، "
"فرهنگ، یا نمونه هایی از بیشتر کلاس ها باشد. برای مثال، تابع زیر، آرگومان "
"هایی که در فراخوانی های بعدی به آن ارسال می شوند را جمع آوری می کند::"

#: ../../tutorial/controlflow.rst:629
msgid ""
"def f(a, L=[]):\n"
"    L.append(a)\n"
"    return L\n"
"\n"
"print(f(1))\n"
"print(f(2))\n"
"print(f(3))"
msgstr ""
"def f(a, L=[]):\n"
"    L.append(a)\n"
"    return L\n"
"\n"
"print(f(1))\n"
"print(f(2))\n"
"print(f(3))"

#: ../../tutorial/controlflow.rst:637
msgid "This will print ::"
msgstr "این چاپ خواهد شد ::"

#: ../../tutorial/controlflow.rst:639
msgid ""
"[1]\n"
"[1, 2]\n"
"[1, 2, 3]"
msgstr ""
"[1]\n"
"[1, 2]\n"
"[1, 2, 3]"

#: ../../tutorial/controlflow.rst:643
msgid ""
"If you don't want the default to be shared between subsequent calls, you can "
"write the function like this instead::"
msgstr ""
"اگر نمی خواهید مقدار پیش فرض بین فراخوانی های بعدی به اشتراک گذاشته شود، می "
"توانید تابع را به این صورت بنویسید::"

#: ../../tutorial/controlflow.rst:646
msgid ""
"def f(a, L=None):\n"
"    if L is None:\n"
"        L = []\n"
"    L.append(a)\n"
"    return L"
msgstr ""
"def f(a, L=None):\n"
"    if L is None:\n"
"        L = []\n"
"    L.append(a)\n"
"    return L"

#: ../../tutorial/controlflow.rst:656
msgid "Keyword Arguments"
msgstr "آرگومان های کلیدواژه ای"

#: ../../tutorial/controlflow.rst:658
msgid ""
"Functions can also be called using :term:`keyword arguments <keyword "
"argument>` of the form ``kwarg=value``.  For instance, the following "
"function::"
msgstr ""
"تابع ها همچنین می توانند با استفاده از :term:`keyword arguments <keyword "
"argument>` به فرم ``kwarg=value`` فراخوانی شوند. برای مثال، تابع زیر::"

#: ../../tutorial/controlflow.rst:661
msgid ""
"def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):\n"
"    print(\"-- This parrot wouldn't\", action, end=' ')\n"
"    print(\"if you put\", voltage, \"volts through it.\")\n"
"    print(\"-- Lovely plumage, the\", type)\n"
"    print(\"-- It's\", state, \"!\")"
msgstr ""
"def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):\n"
"    print(\"-- This parrot wouldn't\", action, end=' ')\n"
"    print(\"if you put\", voltage, \"volts through it.\")\n"
"    print(\"-- Lovely plumage, the\", type)\n"
"    print(\"-- It's\", state, \"!\")"

#: ../../tutorial/controlflow.rst:667
msgid ""
"accepts one required argument (``voltage``) and three optional arguments "
"(``state``, ``action``, and ``type``).  This function can be called in any "
"of the following ways::"
msgstr ""
"یک آرگومان اجباری (``voltage``) و سه آرگومان اختیاری (``state``، ``action`` "
"و ``type``) را می پذیرد. این تابع می تواند به یکی از روش های زیر فراخوانی "
"شود::"

#: ../../tutorial/controlflow.rst:671
msgid ""
"parrot(1000)                                          # 1 positional "
"argument\n"
"parrot(voltage=1000)                                  # 1 keyword argument\n"
"parrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments\n"
"parrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments\n"
"parrot('a million', 'bereft of life', 'jump')         # 3 positional "
"arguments\n"
"parrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 "
"keyword"
msgstr ""
"parrot(1000)                                          # 1 positional "
"argument\n"
"parrot(voltage=1000)                                  # 1 keyword argument\n"
"parrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments\n"
"parrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments\n"
"parrot('a million', 'bereft of life', 'jump')         # 3 positional "
"arguments\n"
"parrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 "
"keyword"

#: ../../tutorial/controlflow.rst:678
msgid "but all the following calls would be invalid::"
msgstr "اما تمامی فراخوانی های زیر نامعتبر خواهند بود::"

#: ../../tutorial/controlflow.rst:680
msgid ""
"parrot()                     # required argument missing\n"
"parrot(voltage=5.0, 'dead')  # non-keyword argument after a keyword "
"argument\n"
"parrot(110, voltage=220)     # duplicate value for the same argument\n"
"parrot(actor='John Cleese')  # unknown keyword argument"
msgstr ""
"parrot()                     # آرگومان ضروری وجود ندارد\n"
"parrot(voltage=5.0, 'dead')  # آرگومان غیر کلیدی بعد از آرگومان کلیدی\n"
"parrot(110, voltage=220)     # مقدار تکراری برای همان آرگومان\n"
"parrot(actor='John Cleese')  # آرگومان کلیدی ناشناخته"

#: ../../tutorial/controlflow.rst:685
msgid ""
"In a function call, keyword arguments must follow positional arguments. All "
"the keyword arguments passed must match one of the arguments accepted by the "
"function (e.g. ``actor`` is not a valid argument for the ``parrot`` "
"function), and their order is not important.  This also includes non-"
"optional arguments (e.g. ``parrot(voltage=1000)`` is valid too). No argument "
"may receive a value more than once. Here's an example that fails due to this "
"restriction::"
msgstr ""
"در یک فراخوانی تابع، آرگومان های کلیدی باید پس از آرگومان های موقعیتی "
"بیایند. تمام آرگومان های کلیدی که ارسال می شوند باید با یکی از آرگومان هایی "
"که تابع قبول می کند، مطابقت داشته باشند (به عنوان مثال ``actor`` آرگومان "
"معتبری برای تابع ``parrot`` نیست)، و ترتیب آنها مهم نیست. این مورد شامل "
"آرگومان های غیر اختیاری نیز می شود (به عنوان مثال ``parrot(voltage=1000)`` "
"نیز معتبر است). هیچ آرگومانی نمی تواند بیش از یک بار مقدار بگیرد. در اینجا "
"یک مثال آورده شده که به دلیل این محدودیت شکست می خورد:"

#: ../../tutorial/controlflow.rst:693
msgid ""
">>> def function(a):\n"
"...     pass\n"
"...\n"
">>> function(0, a=0)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: function() got multiple values for argument 'a'"
msgstr ""
">>> def function(a):\n"
"...     pass\n"
"...\n"
">>> function(0, a=0)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: function() got multiple values for argument 'a'"

#: ../../tutorial/controlflow.rst:701
msgid ""
"When a final formal parameter of the form ``**name`` is present, it receives "
"a dictionary (see :ref:`typesmapping`) containing all keyword arguments "
"except for those corresponding to a formal parameter.  This may be combined "
"with a formal parameter of the form ``*name`` (described in the next "
"subsection) which receives a :ref:`tuple <tut-tuples>` containing the "
"positional arguments beyond the formal parameter list.  (``*name`` must "
"occur before ``**name``.) For example, if we define a function like this::"
msgstr ""
"هنگامی که یک پارامتر رسمی نهایی به صورت ``**name`` وجود دارد، یک دیکشنری "
"(به :ref:`typesmapping` مراجعه کنید) دریافت می کند که شامل تمام آرگومان های "
"کلیدواژه ای به جز آن هایی که با یک پارامتر رسمی مطابقت دارند، می باشد. این "
"می تواند با یک پارامتر رسمی به شکل ``*name`` (که در زیر بخش بعدی توصیف شده "
"است) که شامل یک :ref:`tuple <tut-tuples>` است که آرگومان های موقعیتی فراتر "
"از لیست پارامترهای رسمی را دریافت می کند، ترکیب شود. (``*name`` باید قبل از "
"``**name`` ظاهر شود.) به عنوان مثال، اگر ما تابعی به این صورت تعریف کنیم:"

#: ../../tutorial/controlflow.rst:709
msgid ""
"def cheeseshop(kind, *arguments, **keywords):\n"
"    print(\"-- Do you have any\", kind, \"?\")\n"
"    print(\"-- I'm sorry, we're all out of\", kind)\n"
"    for arg in arguments:\n"
"        print(arg)\n"
"    print(\"-\" * 40)\n"
"    for kw in keywords:\n"
"        print(kw, \":\", keywords[kw])"
msgstr ""
"def cheeseshop(kind, *arguments, **keywords):\n"
"    print(\"-- Do you have any\", kind, \"?\")\n"
"    print(\"-- I'm sorry, we're all out of\", kind)\n"
"    for arg in arguments:\n"
"        print(arg)\n"
"    print(\"-\" * 40)\n"
"    for kw in keywords:\n"
"        print(kw, \":\", keywords[kw])"

#: ../../tutorial/controlflow.rst:718
msgid "It could be called like this::"
msgstr "می تواند به این صورت فراخوانی شود::"

#: ../../tutorial/controlflow.rst:720
msgid ""
"cheeseshop(\"Limburger\", \"It's very runny, sir.\",\n"
"           \"It's really very, VERY runny, sir.\",\n"
"           shopkeeper=\"Michael Palin\",\n"
"           client=\"John Cleese\",\n"
"           sketch=\"Cheese Shop Sketch\")"
msgstr ""
"cheeseshop(\"Limburger\", \"It's very runny, sir.\",\n"
"           \"It's really very, VERY runny, sir.\",\n"
"           shopkeeper=\"Michael Palin\",\n"
"           client=\"John Cleese\",\n"
"           sketch=\"Cheese Shop Sketch\")"

#: ../../tutorial/controlflow.rst:726
msgid "and of course it would print:"
msgstr "و البته چاپ خواهد کرد:"

#: ../../tutorial/controlflow.rst:728
msgid ""
"-- Do you have any Limburger ?\n"
"-- I'm sorry, we're all out of Limburger\n"
"It's very runny, sir.\n"
"It's really very, VERY runny, sir.\n"
"----------------------------------------\n"
"shopkeeper : Michael Palin\n"
"client : John Cleese\n"
"sketch : Cheese Shop Sketch"
msgstr ""
"-- آیا پنیر لیـمبـرگر دارین؟\n"
"-- متأسفم، لیک همه لیـمبـرگر ما تمام شده\n"
"خیلی نرم هست، آقا.\n"
"واقعاً خیلی، خیلی نرم هست، آقا.\n"
"----------------------------------------\n"
"مغازه دار: مایکل پَلین\n"
"مشتری: جان کـلیز\n"
"اسکچ: طرح پنیر فروشی"

#: ../../tutorial/controlflow.rst:739
msgid ""
"Note that the order in which the keyword arguments are printed is guaranteed "
"to match the order in which they were provided in the function call."
msgstr ""
"توجه داشته باشید که ترتیب نمایش آرگومان های کلیدی، مطابق با ترتیبی که در "
"فراخوانی تابع ارائه شده اند، تضمین می شود."

#: ../../tutorial/controlflow.rst:743
msgid "Special parameters"
msgstr "پارامترهای ویژه"

#: ../../tutorial/controlflow.rst:745
msgid ""
"By default, arguments may be passed to a Python function either by position "
"or explicitly by keyword. For readability and performance, it makes sense to "
"restrict the way arguments can be passed so that a developer need only look "
"at the function definition to determine if items are passed by position, by "
"position or keyword, or by keyword."
msgstr ""
"به طور پیش فرض، آرگومان ها می توانند به یک تابع پایتون به صورت موقعیتی یا به "
"صورت صریح با استفاده از کلیدواژه ها ارسال شوند. برای افزایش خوانایی و "
"کارایی، منطقی است که روش ارسال آرگومان ها را محدود کنیم تا یک توسعه دهنده "
"فقط با نگاه کردن به تعریف تابع بتواند تشخیص دهد که آیتم ها به صورت موقعیتی، "
"یا به صورت موقعیتی و کلیدواژه، یا به صورت کلیدواژه ارسال می شوند."

#: ../../tutorial/controlflow.rst:751
msgid "A function definition may look like:"
msgstr "تعریف یک تابع ممکن است به صورت زیر باشد:"

#: ../../tutorial/controlflow.rst:753
msgid ""
"def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):\n"
"      -----------    ----------     ----------\n"
"        |             |                  |\n"
"        |        Positional or keyword   |\n"
"        |                                - Keyword only\n"
"         -- Positional only"
msgstr ""
"تعریف f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):\n"
"      -----------    ----------     ----------\n"
"        |             |                  |\n"
"        |        مکانی یا کلیدواژه ای   |\n"
"        |                                - فقط کلیدواژه ای\n"
"         -- فقط مکانی"

#: ../../tutorial/controlflow.rst:762
msgid ""
"where ``/`` and ``*`` are optional. If used, these symbols indicate the kind "
"of parameter by how the arguments may be passed to the function: positional-"
"only, positional-or-keyword, and keyword-only. Keyword parameters are also "
"referred to as named parameters."
msgstr ""
"که ``/`` و ``*`` اختیاری هستند. اگر استفاده شوند، این نمادها نوع پارامتر را "
"با نحوه ای که آرگومان ها ممکن است به تابع منتقل شوند، نشان می دهند: فقط "
"موقعیتی، موقعیتی یا کلیدواژه ای، و فقط کلیدواژه ای. پارامترهای کلیدواژه ای "
"همچنین به عنوان پارامترهای نام گذاری شده شناخته می شوند."

#: ../../tutorial/controlflow.rst:769
msgid "Positional-or-Keyword Arguments"
msgstr "آرگومان های موقعیتی-یا-کلیدواژه ای"

#: ../../tutorial/controlflow.rst:771
msgid ""
"If ``/`` and ``*`` are not present in the function definition, arguments may "
"be passed to a function by position or by keyword."
msgstr ""
"اگر ``/`` و ``*`` در تعریف تابع حضور نداشته باشند، آرگومان ها ممکن است به "
"صورت مکانی یا با استفاده از کلیدواژه به تابع ارسال شوند."

#: ../../tutorial/controlflow.rst:776
msgid "Positional-Only Parameters"
msgstr "پارامترهای فقط موقعیتی"

#: ../../tutorial/controlflow.rst:778
msgid ""
"Looking at this in a bit more detail, it is possible to mark certain "
"parameters as *positional-only*. If *positional-only*, the parameters' order "
"matters, and the parameters cannot be passed by keyword. Positional-only "
"parameters are placed before a ``/`` (forward-slash). The ``/`` is used to "
"logically separate the positional-only parameters from the rest of the "
"parameters. If there is no ``/`` in the function definition, there are no "
"positional-only parameters."
msgstr ""
"با بررسی دقیق تر این موضوع، می توان برخی از پارامترها را به عنوان "
"*positional-only* علامت گذاری کرد. اگر *positional-only*، ترتیب پارامترها "
"اهمیت دارد و پارامترها نمی توانند با استفاده از کلمات کلیدی ارسال شوند. "
"پارامترهای فقط مکانی قبل از ``/`` (اسلش رو به جلو) قرار می گیرند. ``/`` برای "
"جدا کردن منطقی پارامترهای فقط مکانی از بقیه پارامترها استفاده می شود. اگر در "
"تعریف تابع ``/`` وجود نداشته باشد، پارامترهای فقط مکانی وجود نخواهند داشت."

#: ../../tutorial/controlflow.rst:786
msgid ""
"Parameters following the ``/`` may be *positional-or-keyword* or *keyword-"
"only*."
msgstr ""
"پارامترهایی که پس از ``/`` می آیند می توانند *positional-or-keyword* یا "
"*keyword-only* باشند."

#: ../../tutorial/controlflow.rst:790
msgid "Keyword-Only Arguments"
msgstr ""
"استدلال های فقط کلیدواژه ای\n"
"\n"
"در پایتون، می توانید به توابع خود استدلال هایی اضافه کنید که تنها از طریق "
"کلیدواژه ها قابل ارائه باشند. برای این کار، از علامت شناور * در تعریف تابع "
"استفاده می شود. استدلال هایی که بعد از * می آیند، باید به عنوان استدلال های "
"کلیدواژه ای ارائه شوند. \n"
"\n"
"این ویژگی می تواند خوانایی کد را افزایش داده و جلوگیری از اشتباه را تسهیل "
"کند."

#: ../../tutorial/controlflow.rst:792
msgid ""
"To mark parameters as *keyword-only*, indicating the parameters must be "
"passed by keyword argument, place an ``*`` in the arguments list just before "
"the first *keyword-only* parameter."
msgstr ""
"برای علامت گذاری پارامترها به عنوان *keyword-only*، که نشان دهنده ی این است "
"که پارامترها باید با آرگومان کلیدواژه ای ارسال شوند، یک ``*`` را در لیست "
"آرگومان ها درست قبل از اولین پارامتر *keyword-only* قرار دهید."

#: ../../tutorial/controlflow.rst:798
msgid "Function Examples"
msgstr "نمونه های تابع"

#: ../../tutorial/controlflow.rst:800
msgid ""
"Consider the following example function definitions paying close attention "
"to the markers ``/`` and ``*``::"
msgstr ""
"مثال های زیر را که شامل تعریف توابع هستند بررسی کنید و به علامت های ``/`` و "
"``*`` دقت کنید::"

#: ../../tutorial/controlflow.rst:803
msgid ""
">>> def standard_arg(arg):\n"
"...     print(arg)\n"
"...\n"
">>> def pos_only_arg(arg, /):\n"
"...     print(arg)\n"
"...\n"
">>> def kwd_only_arg(*, arg):\n"
"...     print(arg)\n"
"...\n"
">>> def combined_example(pos_only, /, standard, *, kwd_only):\n"
"...     print(pos_only, standard, kwd_only)"
msgstr ""
">>> def standard_arg(arg):\n"
"...     print(arg)\n"
"...\n"
">>> def pos_only_arg(arg, /):\n"
"...     print(arg)\n"
"...\n"
">>> def kwd_only_arg(*, arg):\n"
"...     print(arg)\n"
"...\n"
">>> def combined_example(pos_only, /, standard, *, kwd_only):\n"
"...     print(pos_only, standard, kwd_only)"

#: ../../tutorial/controlflow.rst:816
msgid ""
"The first function definition, ``standard_arg``, the most familiar form, "
"places no restrictions on the calling convention and arguments may be passed "
"by position or keyword::"
msgstr ""
"تعریف اولین تابع، ``standard_arg``، که آشناترین فرم است، هیچ محدودیتی بر روی "
"نحوه فراخوانی ندارد و آرگومان ها می توانند به صورت موقعیت یا کلیدواژه ای "
"ارسال شوند:"

#: ../../tutorial/controlflow.rst:820
msgid ""
">>> standard_arg(2)\n"
"2\n"
"\n"
">>> standard_arg(arg=2)\n"
"2"
msgstr ""
">>> standard_arg(2)\n"
"2\n"
"\n"
">>> standard_arg(arg=2)\n"
"2"

#: ../../tutorial/controlflow.rst:826
msgid ""
"The second function ``pos_only_arg`` is restricted to only use positional "
"parameters as there is a ``/`` in the function definition::"
msgstr ""
"تابع دوم ``pos_only_arg`` محدود به استفاده تنها از پارامترهای موقعیتی است "
"زیرا یک ``/`` در تعریف تابع قرار دارد::"

#: ../../tutorial/controlflow.rst:829
msgid ""
">>> pos_only_arg(1)\n"
"1\n"
"\n"
">>> pos_only_arg(arg=1)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: pos_only_arg() got some positional-only arguments passed as "
"keyword arguments: 'arg'"
msgstr ""
">>> pos_only_arg(1)\n"
"1\n"
"\n"
">>> pos_only_arg(arg=1)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: pos_only_arg() got some positional-only arguments passed as "
"keyword arguments: 'arg'"

#: ../../tutorial/controlflow.rst:837
msgid ""
"The third function ``kwd_only_arg`` only allows keyword arguments as "
"indicated by a ``*`` in the function definition::"
msgstr ""
"تابع سوم ``kwd_only_arg`` تنها آرگومان های کلیدواژه ای را می پذیرد، همان طور "
"که با یک ``*`` در تعریف تابع نشان داده شده است::"

#: ../../tutorial/controlflow.rst:840
msgid ""
">>> kwd_only_arg(3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: kwd_only_arg() takes 0 positional arguments but 1 was given\n"
"\n"
">>> kwd_only_arg(arg=3)\n"
"3"
msgstr ""
">>> kwd_only_arg(3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: kwd_only_arg() takes 0 positional arguments but 1 was given\n"
"\n"
">>> kwd_only_arg(arg=3)\n"
"3"

#: ../../tutorial/controlflow.rst:848
msgid ""
"And the last uses all three calling conventions in the same function "
"definition::"
msgstr ""
"و در آخر، هر سه قرارداد فراخوانی را در همان تعریف تابع استفاده می کند::"

#: ../../tutorial/controlflow.rst:851
msgid ""
">>> combined_example(1, 2, 3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: combined_example() takes 2 positional arguments but 3 were given\n"
"\n"
">>> combined_example(1, 2, kwd_only=3)\n"
"1 2 3\n"
"\n"
">>> combined_example(1, standard=2, kwd_only=3)\n"
"1 2 3\n"
"\n"
">>> combined_example(pos_only=1, standard=2, kwd_only=3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: combined_example() got some positional-only arguments passed as "
"keyword arguments: 'pos_only'"
msgstr ""
">>> combined_example(1, 2, 3)\n"
"دنباله خطا (آخرین تماس اخیر):\n"
"  پرونده \"<stdin>\", خط 1، در <module>\n"
"TypeError: combined_example() تعداد 2 آرگومان مکانی لازم دارد ولی 3 داده شده "
"اند\n"
"\n"
">>> combined_example(1, 2, kwd_only=3)\n"
"1 2 3\n"
"\n"
">>> combined_example(1, standard=2, kwd_only=3)\n"
"1 2 3\n"
"\n"
">>> combined_example(pos_only=1, standard=2, kwd_only=3)\n"
"دنباله خطا (آخرین تماس اخیر):\n"
"  پرونده \"<stdin>\", خط 1، در <module>\n"
"TypeError: combined_example() برخی از آرگومان های فقط مکان دریافت کرده است "
"که به صورت آرگومان های کلمه کلیدی ارسال شده اند: 'pos_only'"

#: ../../tutorial/controlflow.rst:868
msgid ""
"Finally, consider this function definition which has a potential collision "
"between the positional argument ``name``  and ``**kwds`` which has ``name`` "
"as a key::"
msgstr ""
"در نهایت، به این تعریف تابع توجه کنید که دارای یک برخورد احتمالی بین آرگومان "
"موقعیتی ``name`` و ``**kwds`` است که ``name`` را به عنوان یک کلید دارد::"

#: ../../tutorial/controlflow.rst:870
msgid ""
"def foo(name, **kwds):\n"
"    return 'name' in kwds"
msgstr ""
"def foo(name, **kwds):\n"
"    return 'name' in kwds"

#: ../../tutorial/controlflow.rst:873
msgid ""
"There is no possible call that will make it return ``True`` as the keyword "
"``'name'`` will always bind to the first parameter. For example::"
msgstr ""
"هیچ فراخوانی ممکن نیست که باعث شود ``True`` برگردد زیرا کلیدواژه ``'name'`` "
"همیشه به اولین پارامتر متصل می شود. برای مثال::"

#: ../../tutorial/controlflow.rst:876
msgid ""
">>> foo(1, **{'name': 2})\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: foo() got multiple values for argument 'name'\n"
">>>"
msgstr ""
">>> foo(1, **{'name': 2})\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: foo() got multiple values for argument 'name'\n"
">>>"

#: ../../tutorial/controlflow.rst:882
msgid ""
"But using ``/`` (positional only arguments), it is possible since it allows "
"``name`` as a positional argument and ``'name'`` as a key in the keyword "
"arguments::"
msgstr ""
"اما با استفاده از ``/`` (آرگومان های فقط مکانی)، این امکان وجود دارد زیرا به "
"``name`` به عنوان یک آرگومان مکانی و ``'name'`` به عنوان یک کلید در آرگومان "
"های کلیدواژه ای اجازه می دهد::"

#: ../../tutorial/controlflow.rst:884
msgid ""
">>> def foo(name, /, **kwds):\n"
"...     return 'name' in kwds\n"
"...\n"
">>> foo(1, **{'name': 2})\n"
"True"
msgstr ""
">>> def foo(name, /, **kwds):\n"
"...     return 'name' in kwds\n"
"...\n"
">>> foo(1, **{'name': 2})\n"
"True"

#: ../../tutorial/controlflow.rst:890
msgid ""
"In other words, the names of positional-only parameters can be used in "
"``**kwds`` without ambiguity."
msgstr ""
"به عبارت دیگر، نام پارامترهای فقط-موضعی می تواند در ``**kwds`` بدون ابهام "
"استفاده شود."

#: ../../tutorial/controlflow.rst:895
msgid "Recap"
msgstr "خلاصه"

#: ../../tutorial/controlflow.rst:897
msgid ""
"The use case will determine which parameters to use in the function "
"definition::"
msgstr ""
"موارد استفاده تعیین می کنند که از کدام پارامترها در تعریف تابع استفاده شود:"

#: ../../tutorial/controlflow.rst:899
msgid "def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):"
msgstr "def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):"

#: ../../tutorial/controlflow.rst:901
msgid "As guidance:"
msgstr "به عنوان راهنمایی:"

#: ../../tutorial/controlflow.rst:903
msgid ""
"Use positional-only if you want the name of the parameters to not be "
"available to the user. This is useful when parameter names have no real "
"meaning, if you want to enforce the order of the arguments when the function "
"is called or if you need to take some positional parameters and arbitrary "
"keywords."
msgstr ""
"از پارامترهای فقط-مکانی استفاده کنید اگر می خواهید نام پارامترها برای کاربر "
"در دسترس نباشد. این مورد زمانی مفید است که نام پارامتر معنی خاصی ندارد، اگر "
"می خواهید ترتیب آرگومان ها به هنگام فراخوانی تابع رعایت شود یا اگر نیاز "
"دارید تعدادی پارامتر مکانی و کلیدواژه های دلخواه را بپذیرید."

#: ../../tutorial/controlflow.rst:908
msgid ""
"Use keyword-only when names have meaning and the function definition is more "
"understandable by being explicit with names or you want to prevent users "
"relying on the position of the argument being passed."
msgstr ""
"از کلیدواژه فقط زمانی استفاده کنید که نام ها دارای معنا هستند و تعریف تابع "
"با واضح کردن نام ها قابل فهم تر می شود یا می خواهید از وابستگی کاربران به "
"موقعیت استدلالی که ارجاع می شود جلوگیری کنید."

#: ../../tutorial/controlflow.rst:911
msgid ""
"For an API, use positional-only to prevent breaking API changes if the "
"parameter's name is modified in the future."
msgstr ""
"برای یک API، از فقط موقعیتی استفاده کنید تا از ایجاد تغییرات شکستی در API "
"جلوگیری کنید اگر نام پارامتر در آینده تغییر کند."

#: ../../tutorial/controlflow.rst:917
msgid "Arbitrary Argument Lists"
msgstr "لیست های آرگومان دلخواه"

#: ../../tutorial/controlflow.rst:922
msgid ""
"Finally, the least frequently used option is to specify that a function can "
"be called with an arbitrary number of arguments.  These arguments will be "
"wrapped up in a tuple (see :ref:`tut-tuples`).  Before the variable number "
"of arguments, zero or more normal arguments may occur. ::"
msgstr ""
"در نهایت، کمترین گزینه مورد استفاده این است که مشخص کنید یک تابع می تواند با "
"تعداد نامشخصی از آرگومان ها فراخوانی شود. این آرگومان ها در یک تاپل قرار "
"خواهند گرفت (به :ref:`tut-tuples` مراجعه کنید). قبل از آرگومان های با تعداد "
"متغیر، ممکن است هیچ یا چند آرگومان عادی نیز وجود داشته باشد."

#: ../../tutorial/controlflow.rst:927
msgid ""
"def write_multiple_items(file, separator, *args):\n"
"    file.write(separator.join(args))"
msgstr ""
"def write_multiple_items(file, separator, *args):\n"
"    file.write(separator.join(args))"

#: ../../tutorial/controlflow.rst:931
msgid ""
"Normally, these *variadic* arguments will be last in the list of formal "
"parameters, because they scoop up all remaining input arguments that are "
"passed to the function. Any formal parameters which occur after the "
"``*args`` parameter are 'keyword-only' arguments, meaning that they can only "
"be used as keywords rather than positional arguments. ::"
msgstr ""
"معمولاً، این آرگومان های *variadic* در انتهای لیست پارامترهای رسمی قرار می "
"گیرند، زیرا همه آرگومان های ورودی باقیمانده که به تابع ارسال می شوند را در "
"بر می گیرند. هر پارامتر رسمی که بعد از پارامتر ``*args`` قرار گیرد، آرگومان "
"«فقط کلیدی» شناخته می شود، که به این معنی است که آن ها فقط می توانند به صورت "
"کلیدواژه ها استفاده شوند و نه به عنوان آرگومان موقعیتی. ::"

#: ../../tutorial/controlflow.rst:937
msgid ""
">>> def concat(*args, sep=\"/\"):\n"
"...     return sep.join(args)\n"
"...\n"
">>> concat(\"earth\", \"mars\", \"venus\")\n"
"'earth/mars/venus'\n"
">>> concat(\"earth\", \"mars\", \"venus\", sep=\".\")\n"
"'earth.mars.venus'"
msgstr ""
">>> def concat(*args, sep=\"/\"):\n"
"...     return sep.join(args)\n"
"...\n"
">>> concat(\"earth\", \"mars\", \"venus\")\n"
"'earth/mars/venus'\n"
">>> concat(\"earth\", \"mars\", \"venus\", sep=\".\")\n"
"'earth.mars.venus'"

#: ../../tutorial/controlflow.rst:948
msgid "Unpacking Argument Lists"
msgstr "باز کردن لیست آرگومان ها"

#: ../../tutorial/controlflow.rst:950
msgid ""
"The reverse situation occurs when the arguments are already in a list or "
"tuple but need to be unpacked for a function call requiring separate "
"positional arguments.  For instance, the built-in :func:`range` function "
"expects separate *start* and *stop* arguments.  If they are not available "
"separately, write the function call with the  ``*``\\ -operator to unpack "
"the arguments out of a list or tuple::"
msgstr ""
"وضعیت معکوس زمانی اتفاق می افتد که آرگومان ها در یک لیست یا تاپل هستند اما "
"نیاز به جداسازی برای یک فراخوانی تابع که به آرگومان های موقعیتی جداگانه نیاز "
"دارد، دارند. به عنوان مثال، تابع ساخته شده :func:`range` انتظار آرگومان های "
"*start* و *stop* جداگانه را دارد. اگر آنها به صورت جداگانه در دسترس نباشند، "
"فراخوانی تابع را با استفاده از عملگر ``*``\\ بنویسید تا آرگومان ها از یک "
"لیست یا تاپل جدا شوند:"

#: ../../tutorial/controlflow.rst:957
msgid ""
">>> list(range(3, 6))            # normal call with separate arguments\n"
"[3, 4, 5]\n"
">>> args = [3, 6]\n"
">>> list(range(*args))            # call with arguments unpacked from a "
"list\n"
"[3, 4, 5]"
msgstr ""
">>> list(range(3, 6))            # فراخوانی عادی با آرگومان های جداگانه\n"
"[3, 4, 5]\n"
">>> args = [3, 6]\n"
">>> list(range(*args))            # فراخوانی با باز کردن آرگومان ها از یک "
"لیست\n"
"[3, 4, 5]"

#: ../../tutorial/controlflow.rst:966
msgid ""
"In the same fashion, dictionaries can deliver keyword arguments with the "
"``**``\\ -operator::"
msgstr ""
"به همان شکل، دیکشنری ها می توانند آرگومان های کلیدواژه ای را با عملگر "
"``**``\\ ارائه دهند::"

#: ../../tutorial/controlflow.rst:969
msgid ""
">>> def parrot(voltage, state='a stiff', action='voom'):\n"
"...     print(\"-- This parrot wouldn't\", action, end=' ')\n"
"...     print(\"if you put\", voltage, \"volts through it.\", end=' ')\n"
"...     print(\"E's\", state, \"!\")\n"
"...\n"
">>> d = {\"voltage\": \"four million\", \"state\": \"bleedin' demised\", "
"\"action\": \"VOOM\"}\n"
">>> parrot(**d)\n"
"-- This parrot wouldn't VOOM if you put four million volts through it. E's "
"bleedin' demised !"
msgstr ""
">>> def parrot(voltage, state='a stiff', action='voom'):\n"
"...     print(\"-- این طوطی\", action, end=' ')\n"
"...     print(\"نخواهد کرد اگر\", voltage, \"ولت از آن عبور دهید.\", end=' "
"')\n"
"...     print(\"او\", state, \"است!\")\n"
"...\n"
">>> d = {\"voltage\": \"چهار میلیون\", \"state\": \"کاملاً مرده\", "
"\"action\": \"حرکت\"}\n"
">>> parrot(**d)\n"
"-- این طوطی حرکت نخواهد کرد اگر چهار میلیون ولت از آن عبور دهید. او کاملاً "
"مرده است!"

#: ../../tutorial/controlflow.rst:982
msgid "Lambda Expressions"
msgstr "عبارات لامبدا"

#: ../../tutorial/controlflow.rst:984
msgid ""
"Small anonymous functions can be created with the :keyword:`lambda` keyword. "
"This function returns the sum of its two arguments: ``lambda a, b: a+b``. "
"Lambda functions can be used wherever function objects are required.  They "
"are syntactically restricted to a single expression.  Semantically, they are "
"just syntactic sugar for a normal function definition.  Like nested function "
"definitions, lambda functions can reference variables from the containing "
"scope::"
msgstr ""
"توابع کوچک ناشناس را می توان با استفاده از کلمه کلیدی :keyword:`lambda` "
"ایجاد کرد. این تابع مجموع دو آرگومان خود را برمی گرداند: ``lambda a, b: "
"a+b``. توابع لامبدا هر جا که اشیاء تابع مورد نیاز باشند، می توانند استفاده "
"شوند. این توابع به لحاظ نحوی به یک عبارت واحد محدود می شوند. به لحاظ معنایی، "
"آن ها تنها به عنوان یک میانبر نحوی برای تعریف تابع عادی عمل می کنند. مانند "
"تعریف توابع تو در تو، توابع لامبدا می توانند به متغیرهای موجود در حوزه "
"شاملشان ارجاع دهند::"

#: ../../tutorial/controlflow.rst:992
msgid ""
">>> def make_incrementor(n):\n"
"...     return lambda x: x + n\n"
"...\n"
">>> f = make_incrementor(42)\n"
">>> f(0)\n"
"42\n"
">>> f(1)\n"
"43"
msgstr ""
">>> def make_incrementor(n):\n"
"...     return lambda x: x + n\n"
"...\n"
">>> f = make_incrementor(42)\n"
">>> f(0)\n"
"42\n"
">>> f(1)\n"
"43"

#: ../../tutorial/controlflow.rst:1001
msgid ""
"The above example uses a lambda expression to return a function.  Another "
"use is to pass a small function as an argument.  For instance, :meth:`list."
"sort` takes a sorting key function *key* which can be a lambda function::"
msgstr ""

#: ../../tutorial/controlflow.rst:1005
msgid ""
">>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]\n"
">>> pairs.sort(key=lambda pair: pair[1])\n"
">>> pairs\n"
"[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]"
msgstr ""
">>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]\n"
">>> pairs.sort(key=lambda pair: pair[1])\n"
">>> pairs\n"
"[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]"

#: ../../tutorial/controlflow.rst:1014
msgid "Documentation Strings"
msgstr "رشته های مستندات"

#: ../../tutorial/controlflow.rst:1021
msgid ""
"Here are some conventions about the content and formatting of documentation "
"strings."
msgstr ""
"در اینجا برخی از قراردادها درباره محتوا و قالب بندی رشته های مستندات آورده "
"شده است."

#: ../../tutorial/controlflow.rst:1024
msgid ""
"The first line should always be a short, concise summary of the object's "
"purpose.  For brevity, it should not explicitly state the object's name or "
"type, since these are available by other means (except if the name happens "
"to be a verb describing a function's operation).  This line should begin "
"with a capital letter and end with a period."
msgstr ""
"اولین خط باید همیشه یک خلاصه کوتاه و واضح از هدف شیء باشد. برای اختصار، "
"نباید به طور صریح نام یا نوع شیء را بیان کند، زیرا این اطلاعات به روش های "
"دیگر در دسترس است (مگر اینکه نام، یک فعل توصیفی از عملکرد تابع باشد). این خط "
"باید با حرف بزرگ شروع شده و با نقطه پایان یابد."

#: ../../tutorial/controlflow.rst:1030
msgid ""
"If there are more lines in the documentation string, the second line should "
"be blank, visually separating the summary from the rest of the description.  "
"The following lines should be one or more paragraphs describing the object's "
"calling conventions, its side effects, etc."
msgstr ""
"اگر تعداد خطوط در رشته مستندات بیشتر باشد، باید خط دوم خالی باشد و به صورت "
"بصری خلاصه را از بقیه توضیحات جدا کند.\n"
"\n"
"خطوط بعدی باید یک یا چند پاراگراف باشند که کنوانسیون های فراخوانی شی، اثرات "
"جانبی آن و غیره را توضیح می دهند."

#: ../../tutorial/controlflow.rst:1035
msgid ""
"The Python parser does not strip indentation from multi-line string literals "
"in Python, so tools that process documentation have to strip indentation if "
"desired.  This is done using the following convention. The first non-blank "
"line *after* the first line of the string determines the amount of "
"indentation for the entire documentation string.  (We can't use the first "
"line since it is generally adjacent to the string's opening quotes so its "
"indentation is not apparent in the string literal.)  Whitespace "
"\"equivalent\" to this indentation is then stripped from the start of all "
"lines of the string.  Lines that are indented less should not occur, but if "
"they occur all their leading whitespace should be stripped.  Equivalence of "
"whitespace should be tested after expansion of tabs (to 8 spaces, normally)."
msgstr ""
"تجزیه کننده ی پایتون فرورفتگی را از رشته های چندخطی در پایتون حذف نمی کند، "
"بنابراین ابزارهایی که مستندات را پردازش می کنند، باید در صورت نیاز فرورفتگی "
"را حذف کنند. این کار با استفاده از استاندارد زیر انجام می شود. اولین خط غیر "
"خالی *after* اولین خط رشته، مقدار فرورفتگی برای کل رشته ی مستندات را تعیین "
"می کند. (ما نمی توانیم از خط اول استفاده کنیم زیرا به طور کلی مجاور به نقل "
"قول های ابتدایی رشته است، بنابراین فرورفتگی آن در رشته ی ظاهری مشخص نیست.) "
"فاصله ی \"معادل\" با این فرورفتگی سپس از ابتدای تمام خطوط رشته حذف می شود. "
"خطوطی که فرورفتگی کمتری دارند نباید اتفاق بیافتد، اما اگر اتفاق افتاد، باید "
"تمامی فاصله های پیشرو آن ها حذف شود. معادل بودن فاصله ها باید بعد از تعویض "
"تب ها (به ۸ فاصله، معمولاً) بررسی شود."

#: ../../tutorial/controlflow.rst:1047
msgid "Here is an example of a multi-line docstring::"
msgstr "در اینجا یک مثال از یک رشته توضیح چند خطی ارائه شده است:"

#: ../../tutorial/controlflow.rst:1049
msgid ""
">>> def my_function():\n"
"...     \"\"\"Do nothing, but document it.\n"
"...\n"
"...     No, really, it doesn't do anything.\n"
"...     \"\"\"\n"
"...     pass\n"
"...\n"
">>> print(my_function.__doc__)\n"
"Do nothing, but document it.\n"
"\n"
"No, really, it doesn't do anything."
msgstr ""

#: ../../tutorial/controlflow.rst:1065
msgid "Function Annotations"
msgstr "حاشیه نویسی توابع"

#: ../../tutorial/controlflow.rst:1073
msgid ""
":ref:`Function annotations <function>` are completely optional metadata "
"information about the types used by user-defined functions (see :pep:`3107` "
"and :pep:`484` for more information)."
msgstr ""
":ref:`Function annotations <function>` اطلاعات متادیتای کاملاً اختیاری درباره "
"انواع استفاده شده توسط توابع تعریف شده توسط کاربر است (برای اطلاعات بیشتر "
"به :pep:`3107` و :pep:`484` مراجعه کنید)."

#: ../../tutorial/controlflow.rst:1077
msgid ""
":term:`Annotations <function annotation>` are stored in the :attr:`!"
"__annotations__` attribute of the function as a dictionary and have no "
"effect on any other part of the function.  Parameter annotations are defined "
"by a colon after the parameter name, followed by an expression evaluating to "
"the value of the annotation.  Return annotations are defined by a literal ``-"
">``, followed by an expression, between the parameter list and the colon "
"denoting the end of the :keyword:`def` statement.  The following example has "
"a required argument, an optional argument, and the return value annotated::"
msgstr ""
":term:`Annotations <function annotation>` در ویژگی :attr:`!__annotations__` "
"تابع به صورت یک دیکشنری ذخیره می شوند و هیچ تأثیری بر سایر قسمت های تابع "
"ندارند. حاشیه نویسی پارامترها با یک دو نقطه پس از نام پارامتر، به دنبال آن "
"یک عبارت که به مقدار حاشیه نویسی ارزیابی می شود، تعریف می شود. حاشیه نویسی "
"بازگشتی با یک ``->`` لیتری، به دنبال آن یک عبارت، بین لیست پارامترها و دو "
"نقطه که پایان بیانیه :keyword:`def` را نشان می دهد، تعریف می شود. مثال زیر "
"یک آرگومان ضروری، یک آرگومان اختیاری و مقدار بازگشتی را حاشیه نویسی کرده است:"

#: ../../tutorial/controlflow.rst:1086
msgid ""
">>> def f(ham: str, eggs: str = 'eggs') -> str:\n"
"...     print(\"Annotations:\", f.__annotations__)\n"
"...     print(\"Arguments:\", ham, eggs)\n"
"...     return ham + ' and ' + eggs\n"
"...\n"
">>> f('spam')\n"
"Annotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class "
"'str'>}\n"
"Arguments: spam eggs\n"
"'spam and eggs'"
msgstr ""
">>> def f(ham: str, eggs: str = 'eggs') -> str:\n"
"...     print(\"Annotations:\", f.__annotations__)\n"
"...     print(\"Arguments:\", ham, eggs)\n"
"...     return ham + ' and ' + eggs\n"
"...\n"
">>> f('spam')\n"
"Annotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class "
"'str'>}\n"
"Arguments: spam eggs\n"
"'spam and eggs'"

#: ../../tutorial/controlflow.rst:1099
msgid "Intermezzo: Coding Style"
msgstr "میان پرده: سبک کدنویسی"

#: ../../tutorial/controlflow.rst:1104
msgid ""
"Now that you are about to write longer, more complex pieces of Python, it is "
"a good time to talk about *coding style*.  Most languages can be written (or "
"more concise, *formatted*) in different styles; some are more readable than "
"others. Making it easy for others to read your code is always a good idea, "
"and adopting a nice coding style helps tremendously for that."
msgstr ""
"اکنون که قصد دارید کدهای پیچیده تر و طولانی تری از پایتون بنویسید، زمان "
"مناسبی است که درباره ی *coding style* صحبت کنیم. اکثر زبان ها می توانند به "
"سبک های مختلف نوشته شوند (یا به بیان دقیق تر، *formatted*)؛ برخی از آنها "
"خواناتر از بقیه هستند. این که کار دیگران برای خواندن کد شما آسان باشد همیشه "
"ایده خوبی است و پیروی از یک سبک کدنویسی مناسب در این زمینه بسیار کمک می کند."

#: ../../tutorial/controlflow.rst:1110
msgid ""
"For Python, :pep:`8` has emerged as the style guide that most projects "
"adhere to; it promotes a very readable and eye-pleasing coding style.  Every "
"Python developer should read it at some point; here are the most important "
"points extracted for you:"
msgstr ""
"برای پایتون، :pep:`8` به عنوان راهنمای سبکی به وجود آمده است که بیشتر پروژه "
"ها از آن پیروی می کنند؛ این راهنما یک سبک کدنویسی بسیار خوانا و جذاب را "
"ترویج می کند. هر برنامه نویس پایتون باید در مقطعی آن را مطالعه کند؛ در اینجا "
"مهم ترین نکات استخراج  شده برای شما آورده شده است:"

#: ../../tutorial/controlflow.rst:1115
msgid "Use 4-space indentation, and no tabs."
msgstr ""
"متغیرها در پایتون به صورت خودکار تایپ بندی می شوند. وقتی یک مقدار به یک "
"متغیر اختصاص داده می شود، پایتون به صورت خودکار نوع داده های آن متغیر را "
"تعیین می کند. به عنوان مثال، اگر یک عدد صحیح به متغیری داده شود، پایتون به "
"صورت خودکار آن متغیر را از نوع \"int\" در نظر می گیرد.\n"
"\n"
"بخشی از کد که متغیرها را مقداردهی می کند به صورت زیر است:\n"
"\n"
"    x = 5\n"
"    y = \"Hello, World!\"\n"
"\n"
"اینجا 'x' یک متغیر از نوع عدد صحیح و 'y' یک متغیر از نوع رشته است. اگر می "
"خواهید متغیرها را با نوع داده ای مشخص ایجاد کنید، می توانید از تبدیل نوع "
"استفاده کنید:\n"
"\n"
"    x = int(5)\n"
"    y = str(\"Hello, World!\")"

#: ../../tutorial/controlflow.rst:1117
msgid ""
"4 spaces are a good compromise between small indentation (allows greater "
"nesting depth) and large indentation (easier to read).  Tabs introduce "
"confusion, and are best left out."
msgstr ""
"۴ فاصله، هم زمان تعادلی مناسب بین تورفتگی کم (که عمق لایه بندی بیشتری را "
"ممکن می سازد) و تورفتگی زیاد (که خواندن را ساده تر می سازد) ایجاد می کند. "
"استفاده از تب ها می تواند گیج کننده باشد و بهتر است از آنها اجتناب شود."

#: ../../tutorial/controlflow.rst:1121
msgid "Wrap lines so that they don't exceed 79 characters."
msgstr ""
"به منظور دستیابی به حداکثر قابلیت استفاده و سازگاری با دیگر سیستم های \n"
"برنامه نویسی، معمولاً توصیه می شود از متدهای مشخصی تبعیت کنید. برای \n"
"مثال، همیشه از خطوط فضا (space) به جای تب (tab) استفاده کنید تا مطمئن \n"
"شوید که کد شما در تمامی محیط های توسعه دیده می شود. همچنین به صورت \n"
"استاندارد عبارات و نام گذاری که شامل ترکیبی از حروف بزرگ و کوچک است \n"
"را رعایت کنید، مانند این که از camelCase برای نام گذاری متغیرها و \n"
"از PascalCase برای نام گذاری کلاس ها استفاده کنید.\""

#: ../../tutorial/controlflow.rst:1123
msgid ""
"This helps users with small displays and makes it possible to have several "
"code files side-by-side on larger displays."
msgstr ""
"این به کاربران با نمایشگرهای کوچک کمک می کند و امکان قرار دادن چندین فایل کد "
"به صورت کنار هم روی نمایشگرهای بزرگ تر را فراهم می سازد."

#: ../../tutorial/controlflow.rst:1126
msgid ""
"Use blank lines to separate functions and classes, and larger blocks of code "
"inside functions."
msgstr ""
"متغیرها در پایتون محلی (locally) یا سراسری (globally) هستند. اگر یک متغیر "
"درون یک تابع تعریف شود، آن متغیر محلی به نظر می رسد. اگر خارج از تابع تعریف "
"شده باشد، سراسری است.\n"
"\n"
"متغیرهای محلی فقط درون تابعی که تعریف شده اند قابل دسترسی هستند، در حالی که "
"متغیرهای سراسری می توانند از هر جایی در برنامه در هر تابعی مورد استفاده قرار "
"گیرند.\n"
"\n"
"CODE_BLOCK_01\n"
"\n"
"در این مثال، x یک متغیر سراسری است، در حالی که y یک متغیر محلی است. می "
"توانید از دستور global درون یک تابع استفاده کنید تا به طور صریح به متغیری به "
"عنوان سراسری اشاره کنید، این به شما اجازه می دهد تا مقدار یک متغیر سراسری را "
"در داخل یک تابع تغییر دهید.\n"
"\n"
"مثال استفاده از کلمه کلیدی global:\n"
"\n"
"CODE_BLOCK_02\n"
"\n"
"به خاطر داشته باشید، اگر سعی کنید مقداری را به یک متغیر قبل از تعریف صریح آن "
"داخل تابع تخصیص دهید، ممکن است با خطای UnboundLocalError مواجه شوید."

#: ../../tutorial/controlflow.rst:1129
msgid "When possible, put comments on a line of their own."
msgstr "هنگامی که ممکن است، نظرات را در یک خط جداگانه قرار دهید."

#: ../../tutorial/controlflow.rst:1131
msgid "Use docstrings."
msgstr "از docstring ها استفاده کنید."

#: ../../tutorial/controlflow.rst:1133
msgid ""
"Use spaces around operators and after commas, but not directly inside "
"bracketing constructs: ``a = f(1, 2) + g(3, 4)``."
msgstr ""
"از فاصله ها در اطراف عملگر ها و بعد از کاماها استفاده کنید، اما نه مستقیماً "
"درون ساختار های براکت دار: ``a = f(1, 2) + g(3, 4)``."

#: ../../tutorial/controlflow.rst:1136
msgid ""
"Name your classes and functions consistently; the convention is to use "
"``UpperCamelCase`` for classes and ``lowercase_with_underscores`` for "
"functions and methods.  Always use ``self`` as the name for the first method "
"argument (see :ref:`tut-firstclasses` for more on classes and methods)."
msgstr ""
"نام گذاری کلاس ها و توابع خود را به صورت منظم انجام دهید؛ کنوانسیون این است "
"که از ``UpperCamelCase`` برای کلاس ها و از ``lowercase_with_underscores`` "
"برای توابع و متدها استفاده کنید. همیشه از ``self`` به عنوان نام اولین "
"آرگومان متد استفاده کنید (برای اطلاعات بیشتر در مورد کلاس ها و متدها به :ref:"
"`tut-firstclasses` مراجعه کنید)."

#: ../../tutorial/controlflow.rst:1141
msgid ""
"Don't use fancy encodings if your code is meant to be used in international "
"environments.  Python's default, UTF-8, or even plain ASCII work best in any "
"case."
msgstr ""
"از رمزگذاری های خاص استفاده نکنید اگر کد شما برای استفاده در محیط های بین "
"المللی طراحی شده است. پیش فرض پایتون، یعنی UTF-8، و حتی ASCII ساده به بهترین "
"شکل در هر شرایطی کار می کنند."

#: ../../tutorial/controlflow.rst:1145
msgid ""
"Likewise, don't use non-ASCII characters in identifiers if there is only the "
"slightest chance people speaking a different language will read or maintain "
"the code."
msgstr ""
"به همین ترتیب، اگر حتی کوچکترین احتمالی وجود داشته باشد که افرادی که به "
"زبانی متفاوت صحبت می کنند، کد را بخوانند یا نگهداری کنند، از کاراکترهای "
"غیرASCII در شناسه ها استفاده نکنید."

#: ../../tutorial/controlflow.rst:1151
msgid "Footnotes"
msgstr "پانویس ها"

#: ../../tutorial/controlflow.rst:1152
msgid ""
"Actually, *call by object reference* would be a better description, since if "
"a mutable object is passed, the caller will see any changes the callee makes "
"to it (items inserted into a list)."
msgstr ""
"در واقع، *call by object reference* توصیف بهتری خواهد بود، زیرا اگر یک شیء "
"قابل تغییر ارسال شود، هرگونه تغییری که توسط تابع فراخوانی شده بر روی آن "
"انجام گیرد (مواردی که در یک لیست درج می شوند)، توسط فردی که آن را فراخوانی "
"می کند مشاهده خواهد شد."

#: ../../tutorial/controlflow.rst:48
msgid "statement"
msgstr "بیانیه"

#: ../../tutorial/controlflow.rst:48
msgid "for"
msgstr "برای"

#: ../../tutorial/controlflow.rst:478 ../../tutorial/controlflow.rst:1016
msgid "documentation strings"
msgstr ""
"رشته های مستندات (documentation strings)، که به سادگی داک استرینگ "
"(docstring) نیز نامیده می شوند، راهی برای استفاده از قابلیت های یادداشت "
"گذاری در پایتون هستند. رشته های مستندات به طور مستقیم پس از تعریف ماژول، "
"کلاس یا تابع قرار می گیرند. اگر رشته مستنداتی وجود داشته باشد، مشخصات در "
"زمان اجرا قابل دستیابی هستند. به عنوان مثال:\n"
"```python\n"
"def kol_hajm_zekhira(tedad, andaze):\n"
"    \"\"\"\n"
"    محاسبه حجم کل.\n"
"\n"
"    پارامترها:\n"
"    tedad -- تعداد اقلام\n"
"    andaze -- اندازه هر قلم\n"
"    \"\"\"\n"
"    return tedad * andaze\n"
"```\n"
"در اینجا، داک استرینگ تابع kol_hajm_zekhira توضیحی مختصر از هدف تابع ارائه "
"می دهد و اطلاعاتی درباره پارامترهای آن درج می کند."

#: ../../tutorial/controlflow.rst:478 ../../tutorial/controlflow.rst:1016
msgid "docstrings"
msgstr "رشته های مستندات"

#: ../../tutorial/controlflow.rst:478 ../../tutorial/controlflow.rst:1016
msgid "strings, documentation"
msgstr "رشته ها، مستندات"

#: ../../tutorial/controlflow.rst:919
msgid "* (asterisk)"
msgstr "* (ستاره)"

#: ../../tutorial/controlflow.rst:919 ../../tutorial/controlflow.rst:963
msgid "in function calls"
msgstr "در فراخوانی توابع"

#: ../../tutorial/controlflow.rst:963
msgid "**"
msgstr "**"

#: ../../tutorial/controlflow.rst:1068
msgid "function"
msgstr "تابع"

#: ../../tutorial/controlflow.rst:1068
msgid "annotations"
msgstr "حاشیه نویسی ها"

#: ../../tutorial/controlflow.rst:1068
msgid "->"
msgstr ""
"ماژول `math` یک منبع ثابت از توابع ریاضی در پایتون است. این ماژول شامل "
"توابعی برای انجام محاسبات علمی و مهندسی مانند سینوس، کسینوس و لگاریتم است.\n"
"\n"
"متد 'ceil' یک عدد را به سمت بالا گرد می کند و نزدیک ترین عدد صحیح بزرگ تر از "
"یا برابر با شماره داده شده را برمی گرداند.\n"
"\n"
"توابع دیگری مانند 'sqrt' برای پیدا کردن ریشه دوم یک عدد و 'factorial' برای "
"محاسبه فاکتوریل یک عدد وجود دارند. برای استفاده از این ماژول، ابتدا باید آن "
"را وارد برنامه خود کنید: \n"
"\n"
"```\n"
"import math\n"
"```"

#: ../../tutorial/controlflow.rst:1068
msgid "function annotations"
msgstr "توضیحات توابع"

#: ../../tutorial/controlflow.rst:1068
msgid ": (colon)"
msgstr ": (کولون)"

#: ../../tutorial/controlflow.rst:1102
msgid "coding"
msgstr "کدگذاری"

#: ../../tutorial/controlflow.rst:1102
msgid "style"
msgstr "استایل"
