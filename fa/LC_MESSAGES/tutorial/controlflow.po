# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2026, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-01-05 16:37+0000\n"
"PO-Revision-Date: 2025-09-22 16:51+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Persian (https://app.transifex.com/python-doc/teams/5390/"
"fa/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fa\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../tutorial/controlflow.rst:5
msgid "More Control Flow Tools"
msgstr "ابزارهای کنترل جریان بیشتر"

#: ../../tutorial/controlflow.rst:7
msgid ""
"As well as the :keyword:`while` statement just introduced, Python uses a few "
"more that we will encounter in this chapter."
msgstr ""
"همچنین به علاوه دستور :keyword:`while` که به تازگی معرفی شد، پایتون از چند "
"دستور دیگر نیز استفاده می کند که در این فصل با آن ها مواجه خواهیم شد."

#: ../../tutorial/controlflow.rst:14
msgid ":keyword:`!if` Statements"
msgstr "عبارات :keyword:`!if`"

#: ../../tutorial/controlflow.rst:16
msgid ""
"Perhaps the most well-known statement type is the :keyword:`if` statement.  "
"For example::"
msgstr "شاید شناخته شده ترین نوع دستور، دستور :keyword:`if` باشد. برای مثال:"

#: ../../tutorial/controlflow.rst:33
msgid ""
"There can be zero or more :keyword:`elif` parts, and the :keyword:`else` "
"part is optional.  The keyword ':keyword:`!elif`' is short for 'else if', "
"and is useful to avoid excessive indentation.  An  :keyword:`!if` ... :"
"keyword:`!elif` ... :keyword:`!elif` ... sequence is a substitute for the "
"``switch`` or ``case`` statements found in other languages."
msgstr ""
"می تواند صفر یا بیشتر از بخش های :keyword:`elif` وجود داشته باشد، و بخش :"
"keyword:`else` اختیاری است. کلمه کلیدی ':keyword:`!elif`' به عنوان کوتاه شده "
"'else if' استفاده می شود و برای جلوگیری از تو رفتگی بیش از حد مفید است. "
"دنباله ای :keyword:`!if` ... :keyword:`!elif` ... :keyword:`!elif` ... به "
"عنوان جایگزینی برای عبارات ``switch`` یا ``case`` که در دیگر زبان ها یافت می "
"شود، به کار می رود."

#: ../../tutorial/controlflow.rst:39
msgid ""
"If you're comparing the same value to several constants, or checking for "
"specific types or attributes, you may also find the :keyword:`!match` "
"statement useful. For more details see :ref:`tut-match`."
msgstr ""
"اگر در حال مقایسه یک مقدار با چندین ثابت هستید، یا بررسی نوع های خاص یا "
"ویژگی ها را انجام می دهید، ممکن است دستور :keyword:`!match` برای شما مفید "
"باشد. برای جزئیات بیشتر به :ref:`tut-match` مراجعه کنید."

#: ../../tutorial/controlflow.rst:46
msgid ":keyword:`!for` Statements"
msgstr ":keyword:`!for` اظهارات"

#: ../../tutorial/controlflow.rst:51
msgid ""
"The :keyword:`for` statement in Python differs a bit from what you may be "
"used to in C or Pascal.  Rather than always iterating over an arithmetic "
"progression of numbers (like in Pascal), or giving the user the ability to "
"define both the iteration step and halting condition (as C), Python's :"
"keyword:`!for` statement iterates over the items of any sequence (a list or "
"a string), in the order that they appear in the sequence.  For example (no "
"pun intended):"
msgstr ""
"بیانیه :keyword:`for` در پایتون کمی با آنچه که ممکن است در C یا Pascal به آن "
"عادت داشته باشید تفاوت دارد. به جای تکرار همیشگی از یک دنباله حسابی از اعداد "
"(مانند Pascal)، یا اجازه دادن به کاربر برای تعریف گام تکرار و شرط توقف "
"(مانند C)، بیانیه :keyword:`!for` در پایتون بر روی آیتم های هر دنباله ای "
"(لیست یا رشته) به ترتیب ظاهر شدن آنها در دنباله، تکرار می کند. برای مثال:"

#: ../../tutorial/controlflow.rst:72
msgid ""
"Code that modifies a collection while iterating over that same collection "
"can be tricky to get right.  Instead, it is usually more straight-forward to "
"loop over a copy of the collection or to create a new collection::"
msgstr ""
"زمانی که کدی مجموعه ای را در حین پیمایش آن مجموعه تغییر می دهد، ممکن است "
"خطاهایی رخ دهد. به جای این روش، معمولاً ساده تر این است که یا بر روی یک نسخه "
"کپی از مجموعه حلقه بزنید یا یک مجموعه جدید ایجاد کنید::"

#: ../../tutorial/controlflow.rst:94
msgid "The :func:`range` Function"
msgstr "تابع :func:`range`"

#: ../../tutorial/controlflow.rst:96
msgid ""
"If you do need to iterate over a sequence of numbers, the built-in function :"
"func:`range` comes in handy.  It generates arithmetic progressions::"
msgstr ""
"اگر نیاز دارید بر روی دنباله ای از اعداد تکرار کنید، تابع داخلی :func:"
"`range` کارآمد است. این تابع، پیشرفت های حسابی تولید می کند::"

#: ../../tutorial/controlflow.rst:108
msgid ""
"The given end point is never part of the generated sequence; ``range(10)`` "
"generates 10 values, the legal indices for items of a sequence of length "
"10.  It is possible to let the range start at another number, or to specify "
"a different increment (even negative; sometimes this is called the 'step')::"
msgstr ""
"نقطه پایانی که داده شده است هیچ وقت بخشی از دنباله تولید شده نیست؛ "
"``range(10)`` تعداد 10 مقدار تولید می کند، شاخص های قانونی برای اعضای یک "
"دنباله با طول 10. امکان شروع بازه از عدد دیگری وجود دارد یا می توان یک "
"افزایش دهنده (حتی منفی؛ گاهی اوقات این را 'گام' می نامند) متفاوت را مشخص کرد:"

#: ../../tutorial/controlflow.rst:122
msgid ""
"To iterate over the indices of a sequence, you can combine :func:`range` "
"and :func:`len` as follows::"
msgstr ""
"برای پیمایش بر روی شاخص های یک دنباله، می توانید :func:`range` و :func:`len` "
"را به صورت زیر ترکیب کنید::"

#: ../../tutorial/controlflow.rst:135
msgid ""
"In most such cases, however, it is convenient to use the :func:`enumerate` "
"function, see :ref:`tut-loopidioms`."
msgstr ""
"در بسیاری از این موارد، با این حال، استفاده از تابع :func:`enumerate` راحت "
"است، رجوع کنید به :ref:`tut-loopidioms`."

#: ../../tutorial/controlflow.rst:138
msgid "A strange thing happens if you just print a range::"
msgstr "اگر شما فقط یک range را چاپ کنید، اتفاق عجیبی رخ می دهد:"

#: ../../tutorial/controlflow.rst:143
msgid ""
"In many ways the object returned by :func:`range` behaves as if it is a "
"list, but in fact it isn't. It is an object which returns the successive "
"items of the desired sequence when you iterate over it, but it doesn't "
"really make the list, thus saving space."
msgstr ""
"به بسیاری از جهات، شیء بازگشتی توسط :func:`range` رفتار می کند انگار که یک "
"لیست است، اما در واقع این طور نیست. این یک شیء است که آیتم های متوالی از "
"دنباله ی مورد نظر را زمانی که بر روی آن تکرار می کنید، بازمی گرداند، اما در "
"حقیقت لیست را نمی سازد و بدین ترتیب فضای ذخیره سازی را حفظ می کند."

#: ../../tutorial/controlflow.rst:148
msgid ""
"We say such an object is :term:`iterable`, that is, suitable as a target for "
"functions and constructs that expect something from which they can obtain "
"successive items until the supply is exhausted.  We have seen that the :"
"keyword:`for` statement is such a construct, while an example of a function "
"that takes an iterable is :func:`sum`::"
msgstr ""
"ما به چنین شیء :term:`iterable` می گوییم، به این معنی که برای استفاده در "
"توابع و ساختارهایی مناسب است که انتظار دارند چیزی داشته باشند که بتوانند از "
"آن به ترتیب آیتم هایی را دریافت کنند تا وقتی که منابع به پایان برسد.  ما "
"دیده ایم که عبارت :keyword:`for` ساختاری از این قبیل است، در حالی که مثالی "
"از یک تابع که یک iterable می گیرد :func:`sum` است::"

#: ../../tutorial/controlflow.rst:157
msgid ""
"Later we will see more functions that return iterables and take iterables as "
"arguments.  In chapter :ref:`tut-structures`, we will discuss in more detail "
"about :func:`list`."
msgstr ""
"در ادامه، توابع بیشتری را خواهیم دید که تکرارشونده ها را برمی گردانند و "
"تکرارشونده ها را به عنوان آرگومان می پذیرند. در فصل :ref:`tut-structures`، "
"درباره :func:`list` به تفصیل بیشتری صحبت خواهیم کرد."

#: ../../tutorial/controlflow.rst:164
msgid ""
":keyword:`!break` and :keyword:`!continue` Statements, and :keyword:`!else` "
"Clauses on Loops"
msgstr ""

#: ../../tutorial/controlflow.rst:166
msgid ""
"The :keyword:`break` statement breaks out of the innermost enclosing :"
"keyword:`for` or :keyword:`while` loop."
msgstr ""

#: ../../tutorial/controlflow.rst:169
msgid ""
"A :keyword:`!for` or :keyword:`!while` loop can include an :keyword:`!else` "
"clause."
msgstr ""

#: ../../tutorial/controlflow.rst:171
msgid ""
"In a :keyword:`for` loop, the :keyword:`!else` clause is executed after the "
"loop reaches its final iteration."
msgstr ""

#: ../../tutorial/controlflow.rst:174
msgid ""
"In a :keyword:`while` loop, it's executed after the loop's condition becomes "
"false."
msgstr ""
"در یک حلقه :keyword:`while`، این پس از آن اجرا می شود که شرط حلقه نادرست می "
"شود."

#: ../../tutorial/controlflow.rst:176
msgid ""
"In either kind of loop, the :keyword:`!else` clause is **not** executed if "
"the loop was terminated by a :keyword:`break`."
msgstr ""

#: ../../tutorial/controlflow.rst:179
msgid ""
"This is exemplified in the following :keyword:`!for` loop, which searches "
"for prime numbers::"
msgstr ""
"این در حلقه :keyword:`!for` زیر که به دنبال اعداد اول می گردد، نشان داده شده "
"است::"

#: ../../tutorial/controlflow.rst:200
msgid ""
"(Yes, this is the correct code.  Look closely: the ``else`` clause belongs "
"to the :keyword:`for` loop, **not** the :keyword:`if` statement.)"
msgstr ""

#: ../../tutorial/controlflow.rst:203
msgid ""
"When used with a loop, the ``else`` clause has more in common with the "
"``else`` clause of a :keyword:`try` statement than it does with that of :"
"keyword:`if` statements: a :keyword:`try` statement's ``else`` clause runs "
"when no exception occurs, and a loop's ``else`` clause runs when no "
"``break`` occurs. For more on the :keyword:`!try` statement and exceptions, "
"see :ref:`tut-handling`."
msgstr ""

#: ../../tutorial/controlflow.rst:210
msgid ""
"The :keyword:`continue` statement, also borrowed from C, continues with the "
"next iteration of the loop::"
msgstr ""

#: ../../tutorial/controlflow.rst:231
msgid ":keyword:`!pass` Statements"
msgstr ":keyword:`!pass` دستورات"

#: ../../tutorial/controlflow.rst:233
msgid ""
"The :keyword:`pass` statement does nothing. It can be used when a statement "
"is required syntactically but the program requires no action. For example::"
msgstr ""
"عبارت :keyword:`pass` هیچ کاری انجام نمی دهد. این عبارت می تواند زمانی "
"استفاده شود که به صورت نحوی یک عبارت لازم است اما برنامه به هیچ عملی نیازی "
"ندارد. برای مثال::"

#: ../../tutorial/controlflow.rst:240
msgid "This is commonly used for creating minimal classes::"
msgstr "این معمولاً برای ایجاد کلاس های حداقلی استفاده می شود::"

#: ../../tutorial/controlflow.rst:246
msgid ""
"Another place :keyword:`pass` can be used is as a place-holder for a "
"function or conditional body when you are working on new code, allowing you "
"to keep thinking at a more abstract level.  The :keyword:`!pass` is silently "
"ignored::"
msgstr ""
"جای دیگری که :keyword:`pass` می تواند استفاده شود به عنوان یک جای نگه دار "
"برای بدنه یک تابع یا شرطی زمانی است که شما در حال کار روی کد جدیدی هستید، که "
"به شما اجازه می دهد تا به تفکر در سطحی انتزاعی تر ادامه دهید. :keyword:`!"
"pass` به صورت خاموش نادیده گرفته می شود::"

#: ../../tutorial/controlflow.rst:258
msgid ":keyword:`!match` Statements"
msgstr ":keyword:`!match` دستورات"

#: ../../tutorial/controlflow.rst:260
msgid ""
"A :keyword:`match` statement takes an expression and compares its value to "
"successive patterns given as one or more case blocks.  This is superficially "
"similar to a switch statement in C, Java or JavaScript (and many other "
"languages), but it's more similar to pattern matching in languages like Rust "
"or Haskell. Only the first pattern that matches gets executed and it can "
"also extract components (sequence elements or object attributes) from the "
"value into variables."
msgstr ""
"یک دستور :keyword:`match` یک عبارت را می گیرد و مقدار آن را با الگوهای "
"متوالی مقایسه می کند که به صورت یک یا چند بلوک case ارائه شده اند. این به "
"طور سطحی شبیه به یک دستور switch در زبان های C، Java یا JavaScript (و بسیاری "
"زبان های دیگر) است، اما بیشتر شبیه به تطابق الگو در زبان هایی مانند Rust یا "
"Haskell است. فقط اولین الگویی که مطابقت دارد اجرا می شود و همچنین می تواند "
"اجزا (عناصر دنباله یا ویژگی های شیء) را از مقدار درون متغیرها استخراج کند."

#: ../../tutorial/controlflow.rst:268
msgid ""
"The simplest form compares a subject value against one or more literals::"
msgstr ""
"ساده ترین شکل، یک مقدار موضوع را با یک یا چند مقدار ثابت مقایسه می کند::"

#: ../../tutorial/controlflow.rst:281
msgid ""
"Note the last block: the \"variable name\" ``_`` acts as a *wildcard* and "
"never fails to match. If no case matches, none of the branches is executed."
msgstr ""
"توجه داشته باشید که در آخرین بلوک: \"نام متغیر\" ``_`` به عنوان یک "
"*wildcard* عمل می کند و هرگز در تطابق شکست نمی خورد. اگر هیچ موردی مطابقت "
"نداشته باشد، هیچ کدام از شاخه ها اجرا نمی شوند."

#: ../../tutorial/controlflow.rst:284
msgid ""
"You can combine several literals in a single pattern using ``|`` (\"or\")::"
msgstr ""
"با استفاده از ``|`` (\"یا\") می توانید چندین کلمه را در یک الگو ترکیب کنید:"

#: ../../tutorial/controlflow.rst:289
msgid ""
"Patterns can look like unpacking assignments, and can be used to bind "
"variables::"
msgstr ""
"الگوها می توانند شبیه به تخصیص های باز کردن باشند و می توانند برای بستن "
"متغیرها استفاده شوند::"

#: ../../tutorial/controlflow.rst:305
msgid ""
"Study that one carefully!  The first pattern has two literals, and can be "
"thought of as an extension of the literal pattern shown above.  But the next "
"two patterns combine a literal and a variable, and the variable *binds* a "
"value from the subject (``point``).  The fourth pattern captures two values, "
"which makes it conceptually similar to the unpacking assignment ``(x, y) = "
"point``."
msgstr ""
"به دقت این را مطالعه کنید! الگوی اول دو مقدار ثابت دارد و می توان آن را به "
"عنوان یک گسترش از الگوی مقدار ثابت نشان داده شده در بالا در نظر گرفت. اما، "
"دو الگوی بعدی یک مقدار ثابت و یک متغیر را ترکیب می کنند و متغیر *binds* یک "
"مقدار از موضوع (``point``) را می گیرد. الگوی چهارم دو مقدار را ضبط می کند که "
"این باعث می شود از نظر مفهومی به تخصیص بازکردن ``(x, y) = point`` شبیه باشد."

#: ../../tutorial/controlflow.rst:312
msgid ""
"If you are using classes to structure your data you can use the class name "
"followed by an argument list resembling a constructor, but with the ability "
"to capture attributes into variables::"
msgstr ""
"اگر از کلاس ها برای ساختاردهی داده ها استفاده می کنید، می توانید از نام کلاس "
"به همراه یک لیست از آرگومان ها استفاده کنید که شبیه به یک سازنده عمل می کند، "
"اما با این قابلیت که ویژگی ها را در متغیرها ذخیره کنید::"

#: ../../tutorial/controlflow.rst:334
msgid ""
"You can use positional parameters with some builtin classes that provide an "
"ordering for their attributes (e.g. dataclasses). You can also define a "
"specific position for attributes in patterns by setting the "
"``__match_args__`` special attribute in your classes. If it's set to (\"x\", "
"\"y\"), the following patterns are all equivalent (and all bind the ``y`` "
"attribute to the ``var`` variable)::"
msgstr ""
"می‌توانید از پارامترهای موقعیتی با برخی کلاس‌های داخلی استفاده کنید که ترتیبی "
"برای ویژگی‌های آن‌ها ارائه می‌کنند (مانند کلاس‌های داده). همچنین می توانید با "
"تنظیم ویژگی خاص ``__match_args__`` در کلاس های خود، یک موقعیت خاص برای ویژگی "
"ها در الگوها تعریف کنید. اگر روی (\"x\", \"y\" تنظیم شده باشد), الگوهای زیر "
"همگی معادل هستند (و همه ویژگی ``y`` را به متغیر ``var`` متصل می کنند):"

#: ../../tutorial/controlflow.rst:345
msgid ""
"A recommended way to read patterns is to look at them as an extended form of "
"what you would put on the left of an assignment, to understand which "
"variables would be set to what. Only the standalone names (like ``var`` "
"above) are assigned to by a match statement. Dotted names (like ``foo."
"bar``), attribute names (the ``x=`` and ``y=`` above) or class names "
"(recognized by the \"(...)\" next to them like ``Point`` above) are never "
"assigned to."
msgstr ""
"روش توصیه شده برای خواندن الگوها این است که به آنها به عنوان شکلی گسترش "
"یافته از چیزی که در سمت چپ یک تخصیص قرار می دهید نگاه کنید، تا بفهمید کدام "
"متغیرها به چه چیزی تنظیم می شوند. تنها نام های مستقل (مثل ``var`` بالا) توسط "
"یک عبارت match تخصیص داده می شوند. نام های نقطه دار (مثل ``foo.bar``)، نام "
"های ویژگی (``x=`` و ``y=`` بالا) یا نام های کلاس (که با \"(...)\" کنارشان "
"شناخته می شوند مثل ``Point`` بالا) هرگز تخصیص داده نمی شوند."

#: ../../tutorial/controlflow.rst:352
msgid ""
"Patterns can be arbitrarily nested.  For example, if we have a short list of "
"Points, with ``__match_args__`` added, we could match it like this::"
msgstr ""
"الگوها می توانند به صورت دلخواه تو در تو قرار گیرند. به عنوان مثال، اگر یک "
"لیست کوتاه از Points داشته باشیم که ``__match_args__`` به آن اضافه شده باشد، "
"می توانیم به این صورت آن را تطبیق دهیم::"

#: ../../tutorial/controlflow.rst:373
msgid ""
"We can add an ``if`` clause to a pattern, known as a \"guard\".  If the "
"guard is false, ``match`` goes on to try the next case block.  Note that "
"value capture happens before the guard is evaluated::"
msgstr ""
"ما می توانیم یک بند ``if`` به یک الگو اضافه کنیم که به عنوان \"گارد\" شناخته "
"می شود.  اگر گارد نادرست باشد، ``match`` بلاک کیس بعدی را امتحان می کند.  "
"توجه داشته باشید که گرفتن ارزش قبل از ارزیابی گارد اتفاق می افتد:"

#: ../../tutorial/controlflow.rst:383
msgid "Several other key features of this statement:"
msgstr "چند ویژگی  کلیدی دیگر این عبارت:"

#: ../../tutorial/controlflow.rst:385
msgid ""
"Like unpacking assignments, tuple and list patterns have exactly the same "
"meaning and actually match arbitrary sequences.  An important exception is "
"that they don't match iterators or strings."
msgstr ""
"مانند تخصیص های بازکردن بسته، الگوهای تاپل و لیست دقیقا همان معنا را دارند و "
"در واقع با توالی های دلخواه تطابق دارند. یک استثنای مهم این است که آنها با "
"iteratorها یا رشته ها مطابقت ندارند."

#: ../../tutorial/controlflow.rst:389
msgid ""
"Sequence patterns support extended unpacking: ``[x, y, *rest]`` and ``(x, y, "
"*rest)`` work similar to unpacking assignments.  The name after ``*`` may "
"also be ``_``, so ``(x, y, *_)`` matches a sequence of at least two items "
"without binding the remaining items."
msgstr ""
"الگوهای دنباله ای از باز کردن توسعه یافته پشتیبانی می کنند: ``[x, y, "
"*rest]`` و ``(x, y, *rest)`` به صورت مشابه با اختصاص باز کردن کار می کنند. "
"نام بعد از ``*`` ممکن است ``_`` باشد، بنابراین ``(x, y, *_)`` با دنباله ای "
"از حداقل دو آیتم مطابقت دارد بدون اینکه آیتم ها ی باقی مانده را متصل کند."

#: ../../tutorial/controlflow.rst:394
msgid ""
"Mapping patterns: ``{\"bandwidth\": b, \"latency\": l}`` captures the "
"``\"bandwidth\"`` and ``\"latency\"`` values from a dictionary.  Unlike "
"sequence patterns, extra keys are ignored.  An unpacking like ``**rest`` is "
"also supported.  (But ``**_`` would be redundant, so it is not allowed.)"
msgstr ""
"الگوهای نگاشت: ``{\"bandwidth\": b, \"latency\": l}`` مقادیر "
"``\"bandwidth\"`` و ``\"latency\"`` را از یک دیکشنری استخراج می کند. بر خلاف "
"الگوهای دنباله ای، کلیدهای اضافی نادیده گرفته می شوند. مشابه ``**rest`` نیز "
"پشتیبانی می شود. (اما ``**_`` زائد خواهد بود، بنابراین مجاز نیست.)"

#: ../../tutorial/controlflow.rst:399
msgid "Subpatterns may be captured using the ``as`` keyword::"
msgstr "الگوهای فرعی ممکن است با استفاده از کلمه کلیدی ``as`` ثبت شوند:"

#: ../../tutorial/controlflow.rst:403
msgid ""
"will capture the second element of the input as ``p2`` (as long as the input "
"is a sequence of two points)"
msgstr ""
"عنصر دوم ورودی را به عنوان ``p2`` در نظر می گیرد (تا زمانی که ورودی یک "
"دنباله از دو نقطه باشد)"

#: ../../tutorial/controlflow.rst:406
msgid ""
"Most literals are compared by equality, however the singletons ``True``, "
"``False`` and ``None`` are compared by identity."
msgstr ""
"بیشتر لیترال ها بر اساس برابری مقایسه می شوند، اما تک تایی ها ``True``، "
"``False`` و ``None`` بر اساس هویت مقایسه می شوند."

#: ../../tutorial/controlflow.rst:409
msgid ""
"Patterns may use named constants.  These must be dotted names to prevent "
"them from being interpreted as capture variable::"
msgstr ""
"الگوها ممکن است از ثابت های نام گذاری شده استفاده کنند. این ها باید به صورت "
"نام های نقطه دار باشند تا از تفسیر آن ها به عنوان متغیر قابل ضبط جلوگیری "
"شود::"

#: ../../tutorial/controlflow.rst:428
msgid ""
"For a more detailed explanation and additional examples, you can look into :"
"pep:`636` which is written in a tutorial format."
msgstr ""
"برای توضیح بیشتر و مثال های اضافی، می توانید به :pep:`636` که به صورت یک "
"آموزش نوشته شده است، مراجعه کنید."

#: ../../tutorial/controlflow.rst:434
msgid "Defining Functions"
msgstr "تعریف توابع"

#: ../../tutorial/controlflow.rst:436
msgid ""
"We can create a function that writes the Fibonacci series to an arbitrary "
"boundary::"
msgstr ""
"ما می توانیم یک تابع ایجاد کنیم که سری فیبوناچی را تا یک مرز دلخواه بنویسد::"

#: ../../tutorial/controlflow.rst:456
msgid ""
"The keyword :keyword:`def` introduces a function *definition*.  It must be "
"followed by the function name and the parenthesized list of formal "
"parameters. The statements that form the body of the function start at the "
"next line, and must be indented."
msgstr ""
"کلمه کلیدی :keyword:`def` یک تابع *definition* را معرفی می کند. این کلمه "
"باید با نام تابع و لیست پرانتزی پارامترهای رسمی بیاید. دستوراتی که بدنه تابع "
"را تشکیل می دهند باید در خط بعد شروع شوند و تورفتگی داشته باشند."

#: ../../tutorial/controlflow.rst:461
msgid ""
"The first statement of the function body can optionally be a string literal; "
"this string literal is the function's documentation string, or :dfn:"
"`docstring`. (More about docstrings can be found in the section :ref:`tut-"
"docstrings`.) There are tools which use docstrings to automatically produce "
"online or printed documentation, or to let the user interactively browse "
"through code; it's good practice to include docstrings in code that you "
"write, so make a habit of it."
msgstr ""
"اولین عبارت از بدنه تابع می تواند به صورت اختیاری یک رشته متنی باشد؛ این "
"رشته متنی، رشته مستندات تابع یا :dfn:`docstring` نامیده می شود. (اطلاعات "
"بیشتر درباره docstrings را می توانید در بخش :ref:`tut-docstrings` پیدا "
"کنید.) ابزارهایی وجود دارند که از docstrings استفاده می کنند تا به صورت "
"خودکار مستندات آنلاین یا چاپی تولید کنند یا به کاربر اجازه دهند تا به صورت "
"تعاملی بین کد بگردد؛ بنابراین قراردادن docstrings در کدی که می نویسید، تمرین "
"خوبی است و این کار را به صورت عادت انجام دهید."

#: ../../tutorial/controlflow.rst:468
msgid ""
"The *execution* of a function introduces a new symbol table used for the "
"local variables of the function.  More precisely, all variable assignments "
"in a function store the value in the local symbol table; whereas variable "
"references first look in the local symbol table, then in the local symbol "
"tables of enclosing functions, then in the global symbol table, and finally "
"in the table of built-in names. Thus, global variables and variables of "
"enclosing functions cannot be directly assigned a value within a function "
"(unless, for global variables, named in a :keyword:`global` statement, or, "
"for variables of enclosing functions, named in a :keyword:`nonlocal` "
"statement), although they may be referenced."
msgstr ""
"*execution* یک تابع یک جدول نماد جدید معرفی می کند که برای متغیرهای محلی "
"تابع استفاده می شود. به طور دقیق تر، تمام انتساب های متغیر در یک تابع، مقدار "
"را در جدول نماد محلی ذخیره می کنند؛ در حالی که مراجع متغیر ابتدا در جدول "
"نماد محلی جستجو می شوند، سپس در جداول نماد محلی توابع محصورکننده، سپس در "
"جدول نمادهای جهانی، و در نهایت در جدول نام های توکار. بنابراین، به متغیرهای "
"جهانی و متغیرهای توابع محصورکننده نمی توان به طور مستقیم یک مقدار درون تابع "
"اختصاص داد (مگر این که برای متغیرهای جهانی، در یک عبارت :keyword:`global` "
"نام گذاری شوند، یا برای متغیرهای توابع محصورکننده، در یک عبارت :keyword:"
"`nonlocal` نام گذاری شوند)، هرچند ممکن است به آن ها اشاره شود."

#: ../../tutorial/controlflow.rst:479
msgid ""
"The actual parameters (arguments) to a function call are introduced in the "
"local symbol table of the called function when it is called; thus, arguments "
"are passed using *call by value* (where the *value* is always an object "
"*reference*, not the value of the object). [#]_ When a function calls "
"another function, or calls itself recursively, a new local symbol table is "
"created for that call."
msgstr ""
"پارامترهای واقعی (آرگومان ها) در یک فراخوانی تابع هنگام فراخوانی به جدول "
"نماد محلی تابع فراخوانده شده معرفی می شوند؛ بنابراین، آرگومان ها با استفاده "
"از *call by value* منتقل می شوند (که در آن *value* همیشه یک شیء *reference* "
"است، نه مقدار شیء). [#]_ هنگامی که یک تابع، تابع دیگری را فرا می خواند یا "
"خودش را به صورت بازگشتی فراخوانی می کند، یک جدول نماد محلی جدید برای آن "
"فراخوانی ایجاد می شود."

#: ../../tutorial/controlflow.rst:486
msgid ""
"A function definition associates the function name with the function object "
"in the current symbol table.  The interpreter recognizes the object pointed "
"to by that name as a user-defined function.  Other names can also point to "
"that same function object and can also be used to access the function::"
msgstr ""
"تعریف تابع، نام تابع را با شیء تابع در جدول نماد جاری مرتبط می کند. مفسر، "
"شیء اشاره شده توسط آن نام را به عنوان یک تابع تعریف شده توسط کاربر شناسایی "
"می کند. نام های دیگر نیز می توانند به همان شیء تابع اشاره کنند و می توانند "
"برای دسترسی به تابع استفاده شوند:"

#: ../../tutorial/controlflow.rst:497
msgid ""
"Coming from other languages, you might object that ``fib`` is not a function "
"but a procedure since it doesn't return a value.  In fact, even functions "
"without a :keyword:`return` statement do return a value, albeit a rather "
"boring one.  This value is called ``None`` (it's a built-in name).  Writing "
"the value ``None`` is normally suppressed by the interpreter if it would be "
"the only value written. You can see it if you really want to using :func:"
"`print`::"
msgstr ""
"هنگام انتقال از زبان های دیگر، ممکن است با این موضوع مخالفت کنید که ``fib`` "
"یک تابع نیست بلکه یک رویه است زیرا مقداری بر نمی گرداند. در واقع، حتی توابعی "
"که هیچ عبارت :keyword:`return` ندارند نیز مقداری بر می گردانند، اگرچه مقداری "
"نسبتاً کسل کننده است. این مقدار ``None`` نامیده می شود (این یک نام داخلی "
"است). نوشتن مقدار ``None`` معمولاً توسط مفسر زمانی که تنها مقدار نوشته شده "
"باشد، نادیده گرفته می شود. اگر واقعاً بخواهید، می توانید با استفاده از :func:"
"`print` آن را ببینید."

#: ../../tutorial/controlflow.rst:508
msgid ""
"It is simple to write a function that returns a list of the numbers of the "
"Fibonacci series, instead of printing it::"
msgstr ""
"نوشتن یک تابع که به جای چاپ کردن، فهرستی از اعداد سری فیبوناچی را برمی "
"گرداند، ساده است::"

#: ../../tutorial/controlflow.rst:524
msgid "This example, as usual, demonstrates some new Python features:"
msgstr "این مثال، طبق معمول، برخی ویژگی های جدید Python را نمایش می دهد:"

#: ../../tutorial/controlflow.rst:526
msgid ""
"The :keyword:`return` statement returns with a value from a function. :"
"keyword:`!return` without an expression argument returns ``None``. Falling "
"off the end of a function also returns ``None``."
msgstr ""
"دستور :keyword:`return` یک مقدار از یک تابع برمی گرداند. :keyword:`!return` "
"بدون یک آرگومان عبارت، ``None`` را برمی گرداند. یعنی خروج از انتهای تابع نیز "
"``None`` را برمی گرداند."

#: ../../tutorial/controlflow.rst:530
msgid ""
"The statement ``result.append(a)`` calls a *method* of the list object "
"``result``.  A method is a function that 'belongs' to an object and is named "
"``obj.methodname``, where ``obj`` is some object (this may be an "
"expression), and ``methodname`` is the name of a method that is defined by "
"the object's type. Different types define different methods.  Methods of "
"different types may have the same name without causing ambiguity.  (It is "
"possible to define your own object types and methods, using *classes*, see :"
"ref:`tut-classes`) The method :meth:`!append` shown in the example is "
"defined for list objects; it adds a new element at the end of the list.  In "
"this example it is equivalent to ``result = result + [a]``, but more "
"efficient."
msgstr ""
"عبارت ``result.append(a)`` یک *method* از شیء لیست ``result`` را فراخوانی می "
"کند. متد یک تابع است که به یک شیء \"تعلق دارد\" و به نام ``obj.methodname`` "
"نامیده می شود، که در آن ``obj`` برخی اشیاء هستند (که ممکن است یک عبارت باشد) "
"و ``methodname`` نام یک متد است که توسط نوع شیء تعریف می شود. انواع مختلف "
"متدهای متفاوتی تعریف می کنند. متدهای انواع مختلف ممکن است نام مشابهی داشته "
"باشند بدون اینکه باعث ابهام شوند. (این امکان وجود دارد که انواع اشیاء و "
"متدهای خود را با استفاده از *classes* تعریف کنید، به :ref:`tut-classes` "
"مراجعه کنید) متد :meth:`!append` که در مثال نشان داده شده است برای اشیاء "
"لیست تعریف شده است؛ این متد یک عنصر جدید در انتهای لیست اضافه می کند. در این "
"مثال معادل ``result = result + [a]`` است، اما کارآمدتر."

#: ../../tutorial/controlflow.rst:545
msgid "More on Defining Functions"
msgstr "بیشتر درباره تعریف توابع"

#: ../../tutorial/controlflow.rst:547
msgid ""
"It is also possible to define functions with a variable number of arguments. "
"There are three forms, which can be combined."
msgstr ""
"همچنین امکان تعریف توابع با تعداد متغیری از آرگومان ها وجود دارد. سه فرم "
"وجود دارد که می توانند با هم ترکیب شوند."

#: ../../tutorial/controlflow.rst:554
msgid "Default Argument Values"
msgstr "مقادیر پیش فرض آرگومان ها"

#: ../../tutorial/controlflow.rst:556
msgid ""
"The most useful form is to specify a default value for one or more "
"arguments. This creates a function that can be called with fewer arguments "
"than it is defined to allow.  For example::"
msgstr ""
"مفیدترین حالت، مشخص کردن یک مقدار پیش فرض برای یک یا چند آرگومان است. این "
"کار تابعی ایجاد می کند که می توان آن را با تعداد آرگومان های کمتری نسبت به "
"آنچه که تعریف شده فراخوانی کرد. به عنوان مثال:"

#: ../../tutorial/controlflow.rst:572
msgid "This function can be called in several ways:"
msgstr "این تابع می تواند به روش های مختلفی فراخوانی شود:"

#: ../../tutorial/controlflow.rst:574
msgid ""
"giving only the mandatory argument: ``ask_ok('Do you really want to quit?')``"
msgstr "فقط آرگومان اجباری را دادن: ``ask_ok('Do you really want to quit?')``"

#: ../../tutorial/controlflow.rst:576
msgid ""
"giving one of the optional arguments: ``ask_ok('OK to overwrite the file?', "
"2)``"
msgstr ""
"با ارائه یکی از آرگومان های اختیاری: ``ask_ok('OK to overwrite the file?', "
"2)``"

#: ../../tutorial/controlflow.rst:578
msgid ""
"or even giving all arguments: ``ask_ok('OK to overwrite the file?', 2, 'Come "
"on, only yes or no!')``"
msgstr ""
"یا حتی با دادن تمام آرگومان ها: ``ask_ok('OK to overwrite the file?', 2, "
"'Come on, only yes or no!')``"

#: ../../tutorial/controlflow.rst:581
msgid ""
"This example also introduces the :keyword:`in` keyword. This tests whether "
"or not a sequence contains a certain value."
msgstr ""
"این مثال همچنین کلمه کلیدی :keyword:`in` را معرفی می کند. این مورد بررسی می "
"کند که آیا یک دنباله شامل یک مقدار خاص است یا خیر."

#: ../../tutorial/controlflow.rst:584
msgid ""
"The default values are evaluated at the point of function definition in the "
"*defining* scope, so that ::"
msgstr ""
"مقادیر پیش فرض در نقطه تعریف تابع در دامنه *defining* ارزیابی می شوند، به "
"طوری که ::"

#: ../../tutorial/controlflow.rst:595
msgid "will print ``5``."
msgstr "عبارت ``5`` را چاپ خواهد کرد."

#: ../../tutorial/controlflow.rst:597
msgid ""
"**Important warning:**  The default value is evaluated only once. This makes "
"a difference when the default is a mutable object such as a list, "
"dictionary, or instances of most classes.  For example, the following "
"function accumulates the arguments passed to it on subsequent calls::"
msgstr ""
"**Important warning:**  مقدار پیش فرض تنها یک بار ارزیابی می شود. این موضوع "
"زمانی اهمیت پیدا می کند که مقدار پیش فرض یک شیء قابل تغییر مانند یک فهرست، "
"فرهنگ، یا نمونه هایی از بیشتر کلاس ها باشد. برای مثال، تابع زیر، آرگومان "
"هایی که در فراخوانی های بعدی به آن ارسال می شوند را جمع آوری می کند::"

#: ../../tutorial/controlflow.rst:610
msgid "This will print ::"
msgstr "این چاپ خواهد شد ::"

#: ../../tutorial/controlflow.rst:616
msgid ""
"If you don't want the default to be shared between subsequent calls, you can "
"write the function like this instead::"
msgstr ""
"اگر نمی خواهید مقدار پیش فرض بین فراخوانی های بعدی به اشتراک گذاشته شود، می "
"توانید تابع را به این صورت بنویسید::"

#: ../../tutorial/controlflow.rst:629
msgid "Keyword Arguments"
msgstr "آرگومان های کلیدواژه ای"

#: ../../tutorial/controlflow.rst:631
msgid ""
"Functions can also be called using :term:`keyword arguments <keyword "
"argument>` of the form ``kwarg=value``.  For instance, the following "
"function::"
msgstr ""
"تابع ها همچنین می توانند با استفاده از :term:`keyword arguments <keyword "
"argument>` به فرم ``kwarg=value`` فراخوانی شوند. برای مثال، تابع زیر::"

#: ../../tutorial/controlflow.rst:640
msgid ""
"accepts one required argument (``voltage``) and three optional arguments "
"(``state``, ``action``, and ``type``).  This function can be called in any "
"of the following ways::"
msgstr ""
"یک آرگومان اجباری (``voltage``) و سه آرگومان اختیاری (``state``، ``action`` "
"و ``type``) را می پذیرد. این تابع می تواند به یکی از روش های زیر فراخوانی "
"شود::"

#: ../../tutorial/controlflow.rst:651
msgid "but all the following calls would be invalid::"
msgstr "اما تمامی فراخوانی های زیر نامعتبر خواهند بود::"

#: ../../tutorial/controlflow.rst:658
msgid ""
"In a function call, keyword arguments must follow positional arguments. All "
"the keyword arguments passed must match one of the arguments accepted by the "
"function (e.g. ``actor`` is not a valid argument for the ``parrot`` "
"function), and their order is not important.  This also includes non-"
"optional arguments (e.g. ``parrot(voltage=1000)`` is valid too). No argument "
"may receive a value more than once. Here's an example that fails due to this "
"restriction::"
msgstr ""
"در یک فراخوانی تابع، آرگومان های کلیدی باید پس از آرگومان های موقعیتی "
"بیایند. تمام آرگومان های کلیدی که ارسال می شوند باید با یکی از آرگومان هایی "
"که تابع قبول می کند، مطابقت داشته باشند (به عنوان مثال ``actor`` آرگومان "
"معتبری برای تابع ``parrot`` نیست)، و ترتیب آنها مهم نیست. این مورد شامل "
"آرگومان های غیر اختیاری نیز می شود (به عنوان مثال ``parrot(voltage=1000)`` "
"نیز معتبر است). هیچ آرگومانی نمی تواند بیش از یک بار مقدار بگیرد. در اینجا "
"یک مثال آورده شده که به دلیل این محدودیت شکست می خورد:"

#: ../../tutorial/controlflow.rst:674
msgid ""
"When a final formal parameter of the form ``**name`` is present, it receives "
"a dictionary (see :ref:`typesmapping`) containing all keyword arguments "
"except for those corresponding to a formal parameter.  This may be combined "
"with a formal parameter of the form ``*name`` (described in the next "
"subsection) which receives a :ref:`tuple <tut-tuples>` containing the "
"positional arguments beyond the formal parameter list.  (``*name`` must "
"occur before ``**name``.) For example, if we define a function like this::"
msgstr ""
"هنگامی که یک پارامتر رسمی نهایی به صورت ``**name`` وجود دارد، یک دیکشنری "
"(به :ref:`typesmapping` مراجعه کنید) دریافت می کند که شامل تمام آرگومان های "
"کلیدواژه ای به جز آن هایی که با یک پارامتر رسمی مطابقت دارند، می باشد. این "
"می تواند با یک پارامتر رسمی به شکل ``*name`` (که در زیر بخش بعدی توصیف شده "
"است) که شامل یک :ref:`tuple <tut-tuples>` است که آرگومان های موقعیتی فراتر "
"از لیست پارامترهای رسمی را دریافت می کند، ترکیب شود. (``*name`` باید قبل از "
"``**name`` ظاهر شود.) به عنوان مثال، اگر ما تابعی به این صورت تعریف کنیم:"

#: ../../tutorial/controlflow.rst:691
msgid "It could be called like this::"
msgstr "می تواند به این صورت فراخوانی شود::"

#: ../../tutorial/controlflow.rst:699
msgid "and of course it would print:"
msgstr "و البته چاپ خواهد کرد:"

#: ../../tutorial/controlflow.rst:712
msgid ""
"Note that the order in which the keyword arguments are printed is guaranteed "
"to match the order in which they were provided in the function call."
msgstr ""
"توجه داشته باشید که ترتیب نمایش آرگومان های کلیدی، مطابق با ترتیبی که در "
"فراخوانی تابع ارائه شده اند، تضمین می شود."

#: ../../tutorial/controlflow.rst:716
msgid "Special parameters"
msgstr "پارامترهای ویژه"

#: ../../tutorial/controlflow.rst:718
msgid ""
"By default, arguments may be passed to a Python function either by position "
"or explicitly by keyword. For readability and performance, it makes sense to "
"restrict the way arguments can be passed so that a developer need only look "
"at the function definition to determine if items are passed by position, by "
"position or keyword, or by keyword."
msgstr ""
"به طور پیش فرض، آرگومان ها می توانند به یک تابع پایتون به صورت موقعیتی یا به "
"صورت صریح با استفاده از کلیدواژه ها ارسال شوند. برای افزایش خوانایی و "
"کارایی، منطقی است که روش ارسال آرگومان ها را محدود کنیم تا یک توسعه دهنده "
"فقط با نگاه کردن به تعریف تابع بتواند تشخیص دهد که آیتم ها به صورت موقعیتی، "
"یا به صورت موقعیتی و کلیدواژه، یا به صورت کلیدواژه ارسال می شوند."

#: ../../tutorial/controlflow.rst:724
msgid "A function definition may look like:"
msgstr "تعریف یک تابع ممکن است به صورت زیر باشد:"

#: ../../tutorial/controlflow.rst:735
msgid ""
"where ``/`` and ``*`` are optional. If used, these symbols indicate the kind "
"of parameter by how the arguments may be passed to the function: positional-"
"only, positional-or-keyword, and keyword-only. Keyword parameters are also "
"referred to as named parameters."
msgstr ""
"که ``/`` و ``*`` اختیاری هستند. اگر استفاده شوند، این نمادها نوع پارامتر را "
"با نحوه ای که آرگومان ها ممکن است به تابع منتقل شوند، نشان می دهند: فقط "
"موقعیتی، موقعیتی یا کلیدواژه ای، و فقط کلیدواژه ای. پارامترهای کلیدواژه ای "
"همچنین به عنوان پارامترهای نام گذاری شده شناخته می شوند."

#: ../../tutorial/controlflow.rst:742
msgid "Positional-or-Keyword Arguments"
msgstr "آرگومان های موقعیتی-یا-کلیدواژه ای"

#: ../../tutorial/controlflow.rst:744
msgid ""
"If ``/`` and ``*`` are not present in the function definition, arguments may "
"be passed to a function by position or by keyword."
msgstr ""
"اگر ``/`` و ``*`` در تعریف تابع حضور نداشته باشند، آرگومان ها ممکن است به "
"صورت مکانی یا با استفاده از کلیدواژه به تابع ارسال شوند."

#: ../../tutorial/controlflow.rst:749
msgid "Positional-Only Parameters"
msgstr "پارامترهای فقط موقعیتی"

#: ../../tutorial/controlflow.rst:751
msgid ""
"Looking at this in a bit more detail, it is possible to mark certain "
"parameters as *positional-only*. If *positional-only*, the parameters' order "
"matters, and the parameters cannot be passed by keyword. Positional-only "
"parameters are placed before a ``/`` (forward-slash). The ``/`` is used to "
"logically separate the positional-only parameters from the rest of the "
"parameters. If there is no ``/`` in the function definition, there are no "
"positional-only parameters."
msgstr ""
"با بررسی دقیق تر این موضوع، می توان برخی از پارامترها را به عنوان "
"*positional-only* علامت گذاری کرد. اگر *positional-only*، ترتیب پارامترها "
"اهمیت دارد و پارامترها نمی توانند با استفاده از کلمات کلیدی ارسال شوند. "
"پارامترهای فقط مکانی قبل از ``/`` (اسلش رو به جلو) قرار می گیرند. ``/`` برای "
"جدا کردن منطقی پارامترهای فقط مکانی از بقیه پارامترها استفاده می شود. اگر در "
"تعریف تابع ``/`` وجود نداشته باشد، پارامترهای فقط مکانی وجود نخواهند داشت."

#: ../../tutorial/controlflow.rst:759
msgid ""
"Parameters following the ``/`` may be *positional-or-keyword* or *keyword-"
"only*."
msgstr ""
"پارامترهایی که پس از ``/`` می آیند می توانند *positional-or-keyword* یا "
"*keyword-only* باشند."

#: ../../tutorial/controlflow.rst:763
msgid "Keyword-Only Arguments"
msgstr ""
"استدلال های فقط کلیدواژه ای\n"
"\n"
"در پایتون، می توانید به توابع خود استدلال هایی اضافه کنید که تنها از طریق "
"کلیدواژه ها قابل ارائه باشند. برای این کار، از علامت شناور * در تعریف تابع "
"استفاده می شود. استدلال هایی که بعد از * می آیند، باید به عنوان استدلال های "
"کلیدواژه ای ارائه شوند. \n"
"\n"
"این ویژگی می تواند خوانایی کد را افزایش داده و جلوگیری از اشتباه را تسهیل "
"کند."

#: ../../tutorial/controlflow.rst:765
msgid ""
"To mark parameters as *keyword-only*, indicating the parameters must be "
"passed by keyword argument, place an ``*`` in the arguments list just before "
"the first *keyword-only* parameter."
msgstr ""
"برای علامت گذاری پارامترها به عنوان *keyword-only*، که نشان دهنده ی این است "
"که پارامترها باید با آرگومان کلیدواژه ای ارسال شوند، یک ``*`` را در لیست "
"آرگومان ها درست قبل از اولین پارامتر *keyword-only* قرار دهید."

#: ../../tutorial/controlflow.rst:771
msgid "Function Examples"
msgstr "نمونه های تابع"

#: ../../tutorial/controlflow.rst:773
msgid ""
"Consider the following example function definitions paying close attention "
"to the markers ``/`` and ``*``::"
msgstr ""
"مثال های زیر را که شامل تعریف توابع هستند بررسی کنید و به علامت های ``/`` و "
"``*`` دقت کنید::"

#: ../../tutorial/controlflow.rst:789
msgid ""
"The first function definition, ``standard_arg``, the most familiar form, "
"places no restrictions on the calling convention and arguments may be passed "
"by position or keyword::"
msgstr ""
"تعریف اولین تابع، ``standard_arg``، که آشناترین فرم است، هیچ محدودیتی بر روی "
"نحوه فراخوانی ندارد و آرگومان ها می توانند به صورت موقعیت یا کلیدواژه ای "
"ارسال شوند:"

#: ../../tutorial/controlflow.rst:799
msgid ""
"The second function ``pos_only_arg`` is restricted to only use positional "
"parameters as there is a ``/`` in the function definition::"
msgstr ""
"تابع دوم ``pos_only_arg`` محدود به استفاده تنها از پارامترهای موقعیتی است "
"زیرا یک ``/`` در تعریف تابع قرار دارد::"

#: ../../tutorial/controlflow.rst:810
msgid ""
"The third function ``kwd_only_args`` only allows keyword arguments as "
"indicated by a ``*`` in the function definition::"
msgstr ""

#: ../../tutorial/controlflow.rst:821
msgid ""
"And the last uses all three calling conventions in the same function "
"definition::"
msgstr ""
"و در آخر، هر سه قرارداد فراخوانی را در همان تعریف تابع استفاده می کند::"

#: ../../tutorial/controlflow.rst:841
msgid ""
"Finally, consider this function definition which has a potential collision "
"between the positional argument ``name``  and ``**kwds`` which has ``name`` "
"as a key::"
msgstr ""
"در نهایت، به این تعریف تابع توجه کنید که دارای یک برخورد احتمالی بین آرگومان "
"موقعیتی ``name`` و ``**kwds`` است که ``name`` را به عنوان یک کلید دارد::"

#: ../../tutorial/controlflow.rst:846
msgid ""
"There is no possible call that will make it return ``True`` as the keyword "
"``'name'`` will always bind to the first parameter. For example::"
msgstr ""
"هیچ فراخوانی ممکن نیست که باعث شود ``True`` برگردد زیرا کلیدواژه ``'name'`` "
"همیشه به اولین پارامتر متصل می شود. برای مثال::"

#: ../../tutorial/controlflow.rst:855
msgid ""
"But using ``/`` (positional only arguments), it is possible since it allows "
"``name`` as a positional argument and ``'name'`` as a key in the keyword "
"arguments::"
msgstr ""
"اما با استفاده از ``/`` (آرگومان های فقط مکانی)، این امکان وجود دارد زیرا به "
"``name`` به عنوان یک آرگومان مکانی و ``'name'`` به عنوان یک کلید در آرگومان "
"های کلیدواژه ای اجازه می دهد::"

#: ../../tutorial/controlflow.rst:863
msgid ""
"In other words, the names of positional-only parameters can be used in "
"``**kwds`` without ambiguity."
msgstr ""
"به عبارت دیگر، نام پارامترهای فقط-موضعی می تواند در ``**kwds`` بدون ابهام "
"استفاده شود."

#: ../../tutorial/controlflow.rst:868
msgid "Recap"
msgstr "خلاصه"

#: ../../tutorial/controlflow.rst:870
msgid ""
"The use case will determine which parameters to use in the function "
"definition::"
msgstr ""
"موارد استفاده تعیین می کنند که از کدام پارامترها در تعریف تابع استفاده شود:"

#: ../../tutorial/controlflow.rst:874
msgid "As guidance:"
msgstr "به عنوان راهنمایی:"

#: ../../tutorial/controlflow.rst:876
msgid ""
"Use positional-only if you want the name of the parameters to not be "
"available to the user. This is useful when parameter names have no real "
"meaning, if you want to enforce the order of the arguments when the function "
"is called or if you need to take some positional parameters and arbitrary "
"keywords."
msgstr ""
"از پارامترهای فقط-مکانی استفاده کنید اگر می خواهید نام پارامترها برای کاربر "
"در دسترس نباشد. این مورد زمانی مفید است که نام پارامتر معنی خاصی ندارد، اگر "
"می خواهید ترتیب آرگومان ها به هنگام فراخوانی تابع رعایت شود یا اگر نیاز "
"دارید تعدادی پارامتر مکانی و کلیدواژه های دلخواه را بپذیرید."

#: ../../tutorial/controlflow.rst:881
msgid ""
"Use keyword-only when names have meaning and the function definition is more "
"understandable by being explicit with names or you want to prevent users "
"relying on the position of the argument being passed."
msgstr ""
"از کلیدواژه فقط زمانی استفاده کنید که نام ها دارای معنا هستند و تعریف تابع "
"با واضح کردن نام ها قابل فهم تر می شود یا می خواهید از وابستگی کاربران به "
"موقعیت استدلالی که ارجاع می شود جلوگیری کنید."

#: ../../tutorial/controlflow.rst:884
msgid ""
"For an API, use positional-only to prevent breaking API changes if the "
"parameter's name is modified in the future."
msgstr ""
"برای یک API، از فقط موقعیتی استفاده کنید تا از ایجاد تغییرات شکستی در API "
"جلوگیری کنید اگر نام پارامتر در آینده تغییر کند."

#: ../../tutorial/controlflow.rst:890
msgid "Arbitrary Argument Lists"
msgstr "لیست های آرگومان دلخواه"

#: ../../tutorial/controlflow.rst:895
msgid ""
"Finally, the least frequently used option is to specify that a function can "
"be called with an arbitrary number of arguments.  These arguments will be "
"wrapped up in a tuple (see :ref:`tut-tuples`).  Before the variable number "
"of arguments, zero or more normal arguments may occur. ::"
msgstr ""
"در نهایت، کمترین گزینه مورد استفاده این است که مشخص کنید یک تابع می تواند با "
"تعداد نامشخصی از آرگومان ها فراخوانی شود. این آرگومان ها در یک تاپل قرار "
"خواهند گرفت (به :ref:`tut-tuples` مراجعه کنید). قبل از آرگومان های با تعداد "
"متغیر، ممکن است هیچ یا چند آرگومان عادی نیز وجود داشته باشد."

#: ../../tutorial/controlflow.rst:904
msgid ""
"Normally, these *variadic* arguments will be last in the list of formal "
"parameters, because they scoop up all remaining input arguments that are "
"passed to the function. Any formal parameters which occur after the "
"``*args`` parameter are 'keyword-only' arguments, meaning that they can only "
"be used as keywords rather than positional arguments. ::"
msgstr ""
"معمولاً، این آرگومان های *variadic* در انتهای لیست پارامترهای رسمی قرار می "
"گیرند، زیرا همه آرگومان های ورودی باقیمانده که به تابع ارسال می شوند را در "
"بر می گیرند. هر پارامتر رسمی که بعد از پارامتر ``*args`` قرار گیرد، آرگومان "
"«فقط کلیدی» شناخته می شود، که به این معنی است که آن ها فقط می توانند به صورت "
"کلیدواژه ها استفاده شوند و نه به عنوان آرگومان موقعیتی. ::"

#: ../../tutorial/controlflow.rst:921
msgid "Unpacking Argument Lists"
msgstr "باز کردن لیست آرگومان ها"

#: ../../tutorial/controlflow.rst:923
msgid ""
"The reverse situation occurs when the arguments are already in a list or "
"tuple but need to be unpacked for a function call requiring separate "
"positional arguments.  For instance, the built-in :func:`range` function "
"expects separate *start* and *stop* arguments.  If they are not available "
"separately, write the function call with the  ``*``\\ -operator to unpack "
"the arguments out of a list or tuple::"
msgstr ""
"وضعیت معکوس زمانی اتفاق می افتد که آرگومان ها در یک لیست یا تاپل هستند اما "
"نیاز به جداسازی برای یک فراخوانی تابع که به آرگومان های موقعیتی جداگانه نیاز "
"دارد، دارند. به عنوان مثال، تابع ساخته شده :func:`range` انتظار آرگومان های "
"*start* و *stop* جداگانه را دارد. اگر آنها به صورت جداگانه در دسترس نباشند، "
"فراخوانی تابع را با استفاده از عملگر ``*``\\ بنویسید تا آرگومان ها از یک "
"لیست یا تاپل جدا شوند:"

#: ../../tutorial/controlflow.rst:939
msgid ""
"In the same fashion, dictionaries can deliver keyword arguments with the "
"``**``\\ -operator::"
msgstr ""
"به همان شکل، دیکشنری ها می توانند آرگومان های کلیدواژه ای را با عملگر "
"``**``\\ ارائه دهند::"

#: ../../tutorial/controlflow.rst:955
msgid "Lambda Expressions"
msgstr "عبارات لامبدا"

#: ../../tutorial/controlflow.rst:957
msgid ""
"Small anonymous functions can be created with the :keyword:`lambda` keyword. "
"This function returns the sum of its two arguments: ``lambda a, b: a+b``. "
"Lambda functions can be used wherever function objects are required.  They "
"are syntactically restricted to a single expression.  Semantically, they are "
"just syntactic sugar for a normal function definition.  Like nested function "
"definitions, lambda functions can reference variables from the containing "
"scope::"
msgstr ""
"توابع کوچک ناشناس را می توان با استفاده از کلمه کلیدی :keyword:`lambda` "
"ایجاد کرد. این تابع مجموع دو آرگومان خود را برمی گرداند: ``lambda a, b: "
"a+b``. توابع لامبدا هر جا که اشیاء تابع مورد نیاز باشند، می توانند استفاده "
"شوند. این توابع به لحاظ نحوی به یک عبارت واحد محدود می شوند. به لحاظ معنایی، "
"آن ها تنها به عنوان یک میانبر نحوی برای تعریف تابع عادی عمل می کنند. مانند "
"تعریف توابع تو در تو، توابع لامبدا می توانند به متغیرهای موجود در حوزه "
"شاملشان ارجاع دهند::"

#: ../../tutorial/controlflow.rst:974
msgid ""
"The above example uses a lambda expression to return a function.  Another "
"use is to pass a small function as an argument::"
msgstr ""
"مثال بالا از یک عبارت lambda برای بازگرداندن یک تابع استفاده می کند. استفاده "
"دیگری این است که یک تابع کوچک را به عنوان یک آرگومان پاس دهید::"

#: ../../tutorial/controlflow.rst:986
msgid "Documentation Strings"
msgstr "رشته های مستندات"

#: ../../tutorial/controlflow.rst:993
msgid ""
"Here are some conventions about the content and formatting of documentation "
"strings."
msgstr ""
"در اینجا برخی از قراردادها درباره محتوا و قالب بندی رشته های مستندات آورده "
"شده است."

#: ../../tutorial/controlflow.rst:996
msgid ""
"The first line should always be a short, concise summary of the object's "
"purpose.  For brevity, it should not explicitly state the object's name or "
"type, since these are available by other means (except if the name happens "
"to be a verb describing a function's operation).  This line should begin "
"with a capital letter and end with a period."
msgstr ""
"اولین خط باید همیشه یک خلاصه کوتاه و واضح از هدف شیء باشد. برای اختصار، "
"نباید به طور صریح نام یا نوع شیء را بیان کند، زیرا این اطلاعات به روش های "
"دیگر در دسترس است (مگر اینکه نام، یک فعل توصیفی از عملکرد تابع باشد). این خط "
"باید با حرف بزرگ شروع شده و با نقطه پایان یابد."

#: ../../tutorial/controlflow.rst:1002
msgid ""
"If there are more lines in the documentation string, the second line should "
"be blank, visually separating the summary from the rest of the description.  "
"The following lines should be one or more paragraphs describing the object's "
"calling conventions, its side effects, etc."
msgstr ""
"اگر تعداد خطوط در رشته مستندات بیشتر باشد، باید خط دوم خالی باشد و به صورت "
"بصری خلاصه را از بقیه توضیحات جدا کند.\n"
"\n"
"خطوط بعدی باید یک یا چند پاراگراف باشند که کنوانسیون های فراخوانی شی، اثرات "
"جانبی آن و غیره را توضیح می دهند."

#: ../../tutorial/controlflow.rst:1007
msgid ""
"The Python parser does not strip indentation from multi-line string literals "
"in Python, so tools that process documentation have to strip indentation if "
"desired.  This is done using the following convention. The first non-blank "
"line *after* the first line of the string determines the amount of "
"indentation for the entire documentation string.  (We can't use the first "
"line since it is generally adjacent to the string's opening quotes so its "
"indentation is not apparent in the string literal.)  Whitespace "
"\"equivalent\" to this indentation is then stripped from the start of all "
"lines of the string.  Lines that are indented less should not occur, but if "
"they occur all their leading whitespace should be stripped.  Equivalence of "
"whitespace should be tested after expansion of tabs (to 8 spaces, normally)."
msgstr ""
"تجزیه کننده ی پایتون فرورفتگی را از رشته های چندخطی در پایتون حذف نمی کند، "
"بنابراین ابزارهایی که مستندات را پردازش می کنند، باید در صورت نیاز فرورفتگی "
"را حذف کنند. این کار با استفاده از استاندارد زیر انجام می شود. اولین خط غیر "
"خالی *after* اولین خط رشته، مقدار فرورفتگی برای کل رشته ی مستندات را تعیین "
"می کند. (ما نمی توانیم از خط اول استفاده کنیم زیرا به طور کلی مجاور به نقل "
"قول های ابتدایی رشته است، بنابراین فرورفتگی آن در رشته ی ظاهری مشخص نیست.) "
"فاصله ی \"معادل\" با این فرورفتگی سپس از ابتدای تمام خطوط رشته حذف می شود. "
"خطوطی که فرورفتگی کمتری دارند نباید اتفاق بیافتد، اما اگر اتفاق افتاد، باید "
"تمامی فاصله های پیشرو آن ها حذف شود. معادل بودن فاصله ها باید بعد از تعویض "
"تب ها (به ۸ فاصله، معمولاً) بررسی شود."

#: ../../tutorial/controlflow.rst:1019
msgid "Here is an example of a multi-line docstring::"
msgstr "در اینجا یک مثال از یک رشته توضیح چند خطی ارائه شده است:"

#: ../../tutorial/controlflow.rst:1037
msgid "Function Annotations"
msgstr "حاشیه نویسی توابع"

#: ../../tutorial/controlflow.rst:1045
msgid ""
":ref:`Function annotations <function>` are completely optional metadata "
"information about the types used by user-defined functions (see :pep:`3107` "
"and :pep:`484` for more information)."
msgstr ""
":ref:`Function annotations <function>` اطلاعات متادیتای کاملاً اختیاری درباره "
"انواع استفاده شده توسط توابع تعریف شده توسط کاربر است (برای اطلاعات بیشتر "
"به :pep:`3107` و :pep:`484` مراجعه کنید)."

#: ../../tutorial/controlflow.rst:1049
msgid ""
":term:`Annotations <function annotation>` are stored in the :attr:`!"
"__annotations__` attribute of the function as a dictionary and have no "
"effect on any other part of the function.  Parameter annotations are defined "
"by a colon after the parameter name, followed by an expression evaluating to "
"the value of the annotation.  Return annotations are defined by a literal ``-"
">``, followed by an expression, between the parameter list and the colon "
"denoting the end of the :keyword:`def` statement.  The following example has "
"a required argument, an optional argument, and the return value annotated::"
msgstr ""
":term:`Annotations <function annotation>` در ویژگی :attr:`!__annotations__` "
"تابع به صورت یک دیکشنری ذخیره می شوند و هیچ تأثیری بر سایر قسمت های تابع "
"ندارند. حاشیه نویسی پارامترها با یک دو نقطه پس از نام پارامتر، به دنبال آن "
"یک عبارت که به مقدار حاشیه نویسی ارزیابی می شود، تعریف می شود. حاشیه نویسی "
"بازگشتی با یک ``->`` لیتری، به دنبال آن یک عبارت، بین لیست پارامترها و دو "
"نقطه که پایان بیانیه :keyword:`def` را نشان می دهد، تعریف می شود. مثال زیر "
"یک آرگومان ضروری، یک آرگومان اختیاری و مقدار بازگشتی را حاشیه نویسی کرده است:"

#: ../../tutorial/controlflow.rst:1071
msgid "Intermezzo: Coding Style"
msgstr "میان پرده: سبک کدنویسی"

#: ../../tutorial/controlflow.rst:1076
msgid ""
"Now that you are about to write longer, more complex pieces of Python, it is "
"a good time to talk about *coding style*.  Most languages can be written (or "
"more concise, *formatted*) in different styles; some are more readable than "
"others. Making it easy for others to read your code is always a good idea, "
"and adopting a nice coding style helps tremendously for that."
msgstr ""
"اکنون که قصد دارید کدهای پیچیده تر و طولانی تری از پایتون بنویسید، زمان "
"مناسبی است که درباره ی *coding style* صحبت کنیم. اکثر زبان ها می توانند به "
"سبک های مختلف نوشته شوند (یا به بیان دقیق تر، *formatted*)؛ برخی از آنها "
"خواناتر از بقیه هستند. این که کار دیگران برای خواندن کد شما آسان باشد همیشه "
"ایده خوبی است و پیروی از یک سبک کدنویسی مناسب در این زمینه بسیار کمک می کند."

#: ../../tutorial/controlflow.rst:1082
msgid ""
"For Python, :pep:`8` has emerged as the style guide that most projects "
"adhere to; it promotes a very readable and eye-pleasing coding style.  Every "
"Python developer should read it at some point; here are the most important "
"points extracted for you:"
msgstr ""
"برای پایتون، :pep:`8` به عنوان راهنمای سبکی به وجود آمده است که بیشتر پروژه "
"ها از آن پیروی می کنند؛ این راهنما یک سبک کدنویسی بسیار خوانا و جذاب را "
"ترویج می کند. هر برنامه نویس پایتون باید در مقطعی آن را مطالعه کند؛ در اینجا "
"مهم ترین نکات استخراج  شده برای شما آورده شده است:"

#: ../../tutorial/controlflow.rst:1087
msgid "Use 4-space indentation, and no tabs."
msgstr ""
"متغیرها در پایتون به صورت خودکار تایپ بندی می شوند. وقتی یک مقدار به یک "
"متغیر اختصاص داده می شود، پایتون به صورت خودکار نوع داده های آن متغیر را "
"تعیین می کند. به عنوان مثال، اگر یک عدد صحیح به متغیری داده شود، پایتون به "
"صورت خودکار آن متغیر را از نوع \"int\" در نظر می گیرد.\n"
"\n"
"بخشی از کد که متغیرها را مقداردهی می کند به صورت زیر است:\n"
"\n"
"    x = 5\n"
"    y = \"Hello, World!\"\n"
"\n"
"اینجا 'x' یک متغیر از نوع عدد صحیح و 'y' یک متغیر از نوع رشته است. اگر می "
"خواهید متغیرها را با نوع داده ای مشخص ایجاد کنید، می توانید از تبدیل نوع "
"استفاده کنید:\n"
"\n"
"    x = int(5)\n"
"    y = str(\"Hello, World!\")"

#: ../../tutorial/controlflow.rst:1089
msgid ""
"4 spaces are a good compromise between small indentation (allows greater "
"nesting depth) and large indentation (easier to read).  Tabs introduce "
"confusion, and are best left out."
msgstr ""
"۴ فاصله، هم زمان تعادلی مناسب بین تورفتگی کم (که عمق لایه بندی بیشتری را "
"ممکن می سازد) و تورفتگی زیاد (که خواندن را ساده تر می سازد) ایجاد می کند. "
"استفاده از تب ها می تواند گیج کننده باشد و بهتر است از آنها اجتناب شود."

#: ../../tutorial/controlflow.rst:1093
msgid "Wrap lines so that they don't exceed 79 characters."
msgstr ""
"به منظور دستیابی به حداکثر قابلیت استفاده و سازگاری با دیگر سیستم های \n"
"برنامه نویسی، معمولاً توصیه می شود از متدهای مشخصی تبعیت کنید. برای \n"
"مثال، همیشه از خطوط فضا (space) به جای تب (tab) استفاده کنید تا مطمئن \n"
"شوید که کد شما در تمامی محیط های توسعه دیده می شود. همچنین به صورت \n"
"استاندارد عبارات و نام گذاری که شامل ترکیبی از حروف بزرگ و کوچک است \n"
"را رعایت کنید، مانند این که از camelCase برای نام گذاری متغیرها و \n"
"از PascalCase برای نام گذاری کلاس ها استفاده کنید.\""

#: ../../tutorial/controlflow.rst:1095
msgid ""
"This helps users with small displays and makes it possible to have several "
"code files side-by-side on larger displays."
msgstr ""
"این به کاربران با نمایشگرهای کوچک کمک می کند و امکان قرار دادن چندین فایل کد "
"به صورت کنار هم روی نمایشگرهای بزرگ تر را فراهم می سازد."

#: ../../tutorial/controlflow.rst:1098
msgid ""
"Use blank lines to separate functions and classes, and larger blocks of code "
"inside functions."
msgstr ""
"متغیرها در پایتون محلی (locally) یا سراسری (globally) هستند. اگر یک متغیر "
"درون یک تابع تعریف شود، آن متغیر محلی به نظر می رسد. اگر خارج از تابع تعریف "
"شده باشد، سراسری است.\n"
"\n"
"متغیرهای محلی فقط درون تابعی که تعریف شده اند قابل دسترسی هستند، در حالی که "
"متغیرهای سراسری می توانند از هر جایی در برنامه در هر تابعی مورد استفاده قرار "
"گیرند.\n"
"\n"
"CODE_BLOCK_01\n"
"\n"
"در این مثال، x یک متغیر سراسری است، در حالی که y یک متغیر محلی است. می "
"توانید از دستور global درون یک تابع استفاده کنید تا به طور صریح به متغیری به "
"عنوان سراسری اشاره کنید، این به شما اجازه می دهد تا مقدار یک متغیر سراسری را "
"در داخل یک تابع تغییر دهید.\n"
"\n"
"مثال استفاده از کلمه کلیدی global:\n"
"\n"
"CODE_BLOCK_02\n"
"\n"
"به خاطر داشته باشید، اگر سعی کنید مقداری را به یک متغیر قبل از تعریف صریح آن "
"داخل تابع تخصیص دهید، ممکن است با خطای UnboundLocalError مواجه شوید."

#: ../../tutorial/controlflow.rst:1101
msgid "When possible, put comments on a line of their own."
msgstr "هنگامی که ممکن است، نظرات را در یک خط جداگانه قرار دهید."

#: ../../tutorial/controlflow.rst:1103
msgid "Use docstrings."
msgstr "از docstring ها استفاده کنید."

#: ../../tutorial/controlflow.rst:1105
msgid ""
"Use spaces around operators and after commas, but not directly inside "
"bracketing constructs: ``a = f(1, 2) + g(3, 4)``."
msgstr ""
"از فاصله ها در اطراف عملگر ها و بعد از کاماها استفاده کنید، اما نه مستقیماً "
"درون ساختار های براکت دار: ``a = f(1, 2) + g(3, 4)``."

#: ../../tutorial/controlflow.rst:1108
msgid ""
"Name your classes and functions consistently; the convention is to use "
"``UpperCamelCase`` for classes and ``lowercase_with_underscores`` for "
"functions and methods.  Always use ``self`` as the name for the first method "
"argument (see :ref:`tut-firstclasses` for more on classes and methods)."
msgstr ""
"نام گذاری کلاس ها و توابع خود را به صورت منظم انجام دهید؛ کنوانسیون این است "
"که از ``UpperCamelCase`` برای کلاس ها و از ``lowercase_with_underscores`` "
"برای توابع و متدها استفاده کنید. همیشه از ``self`` به عنوان نام اولین "
"آرگومان متد استفاده کنید (برای اطلاعات بیشتر در مورد کلاس ها و متدها به :ref:"
"`tut-firstclasses` مراجعه کنید)."

#: ../../tutorial/controlflow.rst:1113
msgid ""
"Don't use fancy encodings if your code is meant to be used in international "
"environments.  Python's default, UTF-8, or even plain ASCII work best in any "
"case."
msgstr ""
"از رمزگذاری های خاص استفاده نکنید اگر کد شما برای استفاده در محیط های بین "
"المللی طراحی شده است. پیش فرض پایتون، یعنی UTF-8، و حتی ASCII ساده به بهترین "
"شکل در هر شرایطی کار می کنند."

#: ../../tutorial/controlflow.rst:1117
msgid ""
"Likewise, don't use non-ASCII characters in identifiers if there is only the "
"slightest chance people speaking a different language will read or maintain "
"the code."
msgstr ""
"به همین ترتیب، اگر حتی کوچکترین احتمالی وجود داشته باشد که افرادی که به "
"زبانی متفاوت صحبت می کنند، کد را بخوانند یا نگهداری کنند، از کاراکترهای "
"غیرASCII در شناسه ها استفاده نکنید."

#: ../../tutorial/controlflow.rst:1123
msgid "Footnotes"
msgstr "پاورقی ها"

#: ../../tutorial/controlflow.rst:1124
msgid ""
"Actually, *call by object reference* would be a better description, since if "
"a mutable object is passed, the caller will see any changes the callee makes "
"to it (items inserted into a list)."
msgstr ""
"در واقع، *call by object reference* توصیف بهتری خواهد بود، زیرا اگر یک شیء "
"قابل تغییر ارسال شود، هرگونه تغییری که توسط تابع فراخوانی شده بر روی آن "
"انجام گیرد (مواردی که در یک لیست درج می شوند)، توسط فردی که آن را فراخوانی "
"می کند مشاهده خواهد شد."

#: ../../tutorial/controlflow.rst:48
msgid "statement"
msgstr "بیانیه"

#: ../../tutorial/controlflow.rst:48
msgid "for"
msgstr "برای"

#: ../../tutorial/controlflow.rst:451 ../../tutorial/controlflow.rst:988
msgid "documentation strings"
msgstr ""
"رشته های مستندات (documentation strings)، که به سادگی داک استرینگ "
"(docstring) نیز نامیده می شوند، راهی برای استفاده از قابلیت های یادداشت "
"گذاری در پایتون هستند. رشته های مستندات به طور مستقیم پس از تعریف ماژول، "
"کلاس یا تابع قرار می گیرند. اگر رشته مستنداتی وجود داشته باشد، مشخصات در "
"زمان اجرا قابل دستیابی هستند. به عنوان مثال:\n"
"```python\n"
"def kol_hajm_zekhira(tedad, andaze):\n"
"    \"\"\"\n"
"    محاسبه حجم کل.\n"
"\n"
"    پارامترها:\n"
"    tedad -- تعداد اقلام\n"
"    andaze -- اندازه هر قلم\n"
"    \"\"\"\n"
"    return tedad * andaze\n"
"```\n"
"در اینجا، داک استرینگ تابع kol_hajm_zekhira توضیحی مختصر از هدف تابع ارائه "
"می دهد و اطلاعاتی درباره پارامترهای آن درج می کند."

#: ../../tutorial/controlflow.rst:451 ../../tutorial/controlflow.rst:988
msgid "docstrings"
msgstr "رشته های مستندات"

#: ../../tutorial/controlflow.rst:451 ../../tutorial/controlflow.rst:988
msgid "strings, documentation"
msgstr "رشته ها، مستندات"

#: ../../tutorial/controlflow.rst:892
msgid "* (asterisk)"
msgstr "* (ستاره)"

#: ../../tutorial/controlflow.rst:892 ../../tutorial/controlflow.rst:936
msgid "in function calls"
msgstr "در فراخوانی توابع"

#: ../../tutorial/controlflow.rst:936
msgid "**"
msgstr "**"

#: ../../tutorial/controlflow.rst:1040
msgid "function"
msgstr "تابع"

#: ../../tutorial/controlflow.rst:1040
msgid "annotations"
msgstr "حاشیه نویسی ها"

#: ../../tutorial/controlflow.rst:1040
msgid "->"
msgstr ""
"ماژول `math` یک منبع ثابت از توابع ریاضی در پایتون است. این ماژول شامل "
"توابعی برای انجام محاسبات علمی و مهندسی مانند سینوس، کسینوس و لگاریتم است.\n"
"\n"
"متد 'ceil' یک عدد را به سمت بالا گرد می کند و نزدیک ترین عدد صحیح بزرگ تر از "
"یا برابر با شماره داده شده را برمی گرداند.\n"
"\n"
"توابع دیگری مانند 'sqrt' برای پیدا کردن ریشه دوم یک عدد و 'factorial' برای "
"محاسبه فاکتوریل یک عدد وجود دارند. برای استفاده از این ماژول، ابتدا باید آن "
"را وارد برنامه خود کنید: \n"
"\n"
"```\n"
"import math\n"
"```"

#: ../../tutorial/controlflow.rst:1040
msgid "function annotations"
msgstr "توضیحات توابع"

#: ../../tutorial/controlflow.rst:1040
msgid ": (colon)"
msgstr ": (کولون)"

#: ../../tutorial/controlflow.rst:1074
msgid "coding"
msgstr "کدگذاری"

#: ../../tutorial/controlflow.rst:1074
msgid "style"
msgstr "استایل"
