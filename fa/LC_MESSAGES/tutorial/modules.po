# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-04 16:17+0000\n"
"PO-Revision-Date: 2022-11-05 17:23+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Persian (https://app.transifex.com/python-doc/teams/5390/"
"fa/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fa\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../tutorial/modules.rst:5
msgid "Modules"
msgstr "ماژول ها"

#: ../../tutorial/modules.rst:7
msgid ""
"If you quit from the Python interpreter and enter it again, the definitions "
"you have made (functions and variables) are lost. Therefore, if you want to "
"write a somewhat longer program, you are better off using a text editor to "
"prepare the input for the interpreter and running it with that file as input "
"instead.  This is known as creating a *script*.  As your program gets "
"longer, you may want to split it into several files for easier maintenance.  "
"You may also want to use a handy function that you've written in several "
"programs without copying its definition into each program."
msgstr ""
"اگر از مفسر پایتون خارج شوید و دوباره وارد آن شوید، تعاریفی که انجام داده "
"اید (توابع و متغیرها) از دست می روند. بنابراین، اگر می خواهید یک برنامه "
"نسبتاً طولانی بنویسید، بهتر است از یک ویرایشگر متنی برای تهیه ورودی برای مفسر "
"استفاده کنید و آن را با استفاده از آن فایل به عنوان ورودی اجرا کنید. این به "
"عنوان ایجاد یک *script* شناخته می شود. همان طور که برنامه شما طولانی تر می "
"شود، ممکن است بخواهید آن را به چندین فایل برای نگهداری آسان تر تقسیم کنید. "
"همچنین ممکن است بخواهید از یک تابع کاربردی که در چندین برنامه نوشته اید "
"استفاده کنید بدون اینکه تعریف آن را در هر برنامه کپی کنید."

#: ../../tutorial/modules.rst:16
msgid ""
"To support this, Python has a way to put definitions in a file and use them "
"in a script or in an interactive instance of the interpreter. Such a file is "
"called a *module*; definitions from a module can be *imported* into other "
"modules or into the *main* module (the collection of variables that you have "
"access to in a script executed at the top level and in calculator mode)."
msgstr ""
"برای پشتیبانی از این موضوع، پایتون روشی برای قرار دادن تعاریف در یک فایل و "
"استفاده از آن ها در یک اسکریپت یا در یک نمونه تعاملی از مفسر دارد. چنین "
"فایلی به نام یک *module* شناخته می شود؛ تعاریف از یک ماژول می توانند در سایر "
"ماژول ها یا در ماژول *main* بارگذاری شوند (مجموعه ای از متغیرهایی که در یک "
"اسکریپت که در سطح بالا اجرا می شود و در حالت ماشین حساب به آن ها دسترسی "
"دارید)."

#: ../../tutorial/modules.rst:22
msgid ""
"A module is a file containing Python definitions and statements.  The file "
"name is the module name with the suffix :file:`.py` appended.  Within a "
"module, the module's name (as a string) is available as the value of the "
"global variable ``__name__``.  For instance, use your favorite text editor "
"to create a file called :file:`fibo.py` in the current directory with the "
"following contents::"
msgstr ""
"ماژول یک فایل حاوی تعریف ها و دستورات پایتون است. نام فایل همان نام ماژول با "
"پسوند :file:`.py` اضافه شده در انتهای آن است. درون ماژول، نام ماژول (به صورت "
"رشته) به عنوان مقدار متغیر سراسری ``__name__`` در دسترس است. برای مثال، از "
"ویرایشگر متن دلخواه خود استفاده کنید تا فایلی به نام :file:`fibo.py` در "
"دایرکتوری جاری با محتوای زیر ایجاد کنید::"

#: ../../tutorial/modules.rst:45
msgid ""
"Now enter the Python interpreter and import this module with the following "
"command::"
msgstr "حال وارد مفسر پایتون شوید و این ماژول را با فرمان زیر وارد کنید::"

#: ../../tutorial/modules.rst:50
msgid ""
"This does not add the names of the functions defined in ``fibo``  directly "
"to the current :term:`namespace` (see :ref:`tut-scopes` for more details); "
"it only adds the module name ``fibo`` there. Using the module name you can "
"access the functions::"
msgstr ""
"این به طور مستقیم نام توابع تعریف شده در ``fibo`` را به :term:`namespace` "
"فعلی اضافه نمی کند (برای جزئیات بیشتر به :ref:`tut-scopes` مراجعه کنید)؛ فقط "
"نام ماژول ``fibo`` را در آنجا اضافه می کند. با استفاده از نام ماژول می "
"توانید به توابع دسترسی پیدا کنید::"

#: ../../tutorial/modules.rst:62
msgid ""
"If you intend to use a function often you can assign it to a local name::"
msgstr ""
"اگر قصد دارید از یک تابع به طور مکرر استفاده کنید، می توانید آن را به یک نام "
"محلی اختصاص دهید::"

#: ../../tutorial/modules.rst:72
msgid "More on Modules"
msgstr "بیشتر در مورد ماژول ها"

#: ../../tutorial/modules.rst:74
msgid ""
"A module can contain executable statements as well as function definitions. "
"These statements are intended to initialize the module. They are executed "
"only the *first* time the module name is encountered in an import statement. "
"[#]_ (They are also run if the file is executed as a script.)"
msgstr ""
"یک ماژول می تواند شامل بیانیه های اجرایی و همچنین تعریف توابع باشد. این "
"بیانیه ها به منظور مقداردهی اولیه ماژول هستند. آن ها تنها در اولین باری که "
"نام ماژول در یک دستور `import` قرار می گیرد، اجرا می شوند. [#]_ (آن ها "
"همچنین اگر فایل به صورت یک اسکریپت اجرا شود, نیز اجرا خواهند شد.)"

#: ../../tutorial/modules.rst:79
msgid ""
"Each module has its own private namespace, which is used as the global "
"namespace by all functions defined in the module. Thus, the author of a "
"module can use global variables in the module without worrying about "
"accidental clashes with a user's global variables. On the other hand, if you "
"know what you are doing you can touch a module's global variables with the "
"same notation used to refer to its functions, ``modname.itemname``."
msgstr ""
"هر ماژول دارای فضای نام خصوصی خود است که به عنوان فضای نام سراسری توسط تمام "
"توابع تعریف شده در ماژول استفاده می شود. بنابراین، نویسنده یک ماژول می تواند "
"از متغیرهای سراسری در ماژول استفاده کند بدون نگرانی از تداخل تصادفی با "
"متغیرهای سراسری کاربر. از سوی دیگر، اگر بدانید که چه کار می کنید، می توانید "
"با استفاده از همان نشانه گذاری که برای اشاره به توابع آن استفاده می شود، به "
"متغیرهای سراسری یک ماژول دسترسی پیدا کنید."

#: ../../tutorial/modules.rst:86
msgid ""
"Modules can import other modules.  It is customary but not required to place "
"all :keyword:`import` statements at the beginning of a module (or script, "
"for that matter).  The imported module names, if placed at the top level of "
"a module (outside any functions or classes), are added to the module's "
"global namespace."
msgstr ""
"ماژول ها می توانند ماژول های دیگر را وارد کنند. به طور معمول (ولی الزامی "
"نیست), تمام عبارات :keyword:`import` در ابتدای یک ماژول (یا اسکریپت, در این "
"صورت) قرار می گیرند. نام های ماژول وارد شده، در صورتی که در سطح بالای ماژول "
"(خارج از توابع یا کلاس ها) قرار گیرند، به فضای نام عمومی ماژول اضافه می شوند."

#: ../../tutorial/modules.rst:91
msgid ""
"There is a variant of the :keyword:`import` statement that imports names "
"from a module directly into the importing module's namespace.  For example::"
msgstr ""
"نوعی از دستور :keyword:`import` وجود دارد که نام ها را مستقیماً از یک ماژول "
"به فضای نام ماژول واردکننده وارد می کند. برای مثال::"

#: ../../tutorial/modules.rst:98
msgid ""
"This does not introduce the module name from which the imports are taken in "
"the local namespace (so in the example, ``fibo`` is not defined)."
msgstr ""
"این کار نام ماژولی که واردات از آن انجام شده را به فضای نام محلی معرفی نمی "
"کند (بنابراین در مثال, ``fibo`` تعریف نشده است)."

#: ../../tutorial/modules.rst:101
msgid "There is even a variant to import all names that a module defines::"
msgstr ""
"حتی یک نوع خاص برای وارد کردن تمامی اسامی که یک ماژول تعریف می کند وجود "
"دارد::"

#: ../../tutorial/modules.rst:107
msgid ""
"This imports all names except those beginning with an underscore (``_``). In "
"most cases Python programmers do not use this facility since it introduces "
"an unknown set of names into the interpreter, possibly hiding some things "
"you have already defined."
msgstr ""
"این تمام نام ها را به جز آن هایی که با یک آندرلاین (_) شروع می شوند، وارد می "
"کند. در بیشتر موارد، برنامه نویسان پایتون از این قابلیت استفاده نمی کنند "
"زیرا مجموعه ای ناشناخته از نام ها را وارد مفسر می کند که ممکن است باعث پنهان "
"شدن بعضی از چیزهایی شود که شما قبلاً تعریف کرده اید."

#: ../../tutorial/modules.rst:112
msgid ""
"Note that in general the practice of importing ``*`` from a module or "
"package is frowned upon, since it often causes poorly readable code. "
"However, it is okay to use it to save typing in interactive sessions."
msgstr ""
"توجه داشته باشید که به طور کلی، انجام عمل وارد کردن ``*`` از یک ماژول یا "
"بسته، مورد انتقاد قرار می گیرد، زیرا معمولاً منجر به کدی می شود که خوانایی "
"ضعیفی دارد. با این حال، استفاده از آن برای کاهش تایپ در جلسات تعاملی اشکالی "
"ندارد."

#: ../../tutorial/modules.rst:116
msgid ""
"If the module name is followed by :keyword:`!as`, then the name following :"
"keyword:`!as` is bound directly to the imported module."
msgstr ""
"اگر نام ماژول با :keyword:`!as` دنبال شود، سپس نامی که با :keyword:`!as` "
"دنبال می شود به طور مستقیم به ماژول وارد شده متصل می شود."

#: ../../tutorial/modules.rst:125
msgid ""
"This is effectively importing the module in the same way that ``import "
"fibo`` will do, with the only difference of it being available as ``fib``."
msgstr ""
"این به طور مؤثر ماژول را به همان روشی که ``import fibo`` انجام می دهد، وارد "
"می کند، با تنها تفاوت آن که به عنوان ``fib`` در دسترس است."

#: ../../tutorial/modules.rst:128
msgid ""
"It can also be used when utilising :keyword:`from` with similar effects::"
msgstr ""
"همچنین می تواند هنگام استفاده از :keyword:`from` با تأثیرات مشابه مورد "
"استفاده قرار گیرد::"

#: ../../tutorial/modules.rst:137
msgid ""
"For efficiency reasons, each module is only imported once per interpreter "
"session.  Therefore, if you change your modules, you must restart the "
"interpreter -- or, if it's just one module you want to test interactively, "
"use :func:`importlib.reload`, e.g. ``import importlib; importlib."
"reload(modulename)``."
msgstr ""
"به دلایل کارایی، هر ماژول تنها یک بار در هر جلسه مفسر وارد می شود. بنابراین، "
"اگر ماژول های خود را تغییر دهید، باید مفسر را دوباره راه اندازی کنید -- یا "
"اگر فقط یک ماژول است که می خواهید به صورت تعاملی آزمایش کنید، از :func:"
"`importlib.reload` استفاده کنید، مثلاً ``import importlib; importlib."
"reload(modulename)``."

#: ../../tutorial/modules.rst:147
msgid "Executing modules as scripts"
msgstr "اجرای ماژول ها به صورت اسکریپت"

#: ../../tutorial/modules.rst:149
msgid "When you run a Python module with ::"
msgstr "وقتی یک ماژول پایتون را اجرا می کنید با ::"

#: ../../tutorial/modules.rst:153
msgid ""
"the code in the module will be executed, just as if you imported it, but "
"with the ``__name__`` set to ``\"__main__\"``.  That means that by adding "
"this code at the end of your module::"
msgstr ""
"کد در ماژول اجرا خواهد شد، همان طور که اگر آن را وارد کرده بودید، اما با "
"تنظیم ``__name__`` به ``\"__main__\"``. این بدان معناست که با افزودن این کد "
"در انتهای ماژول خود::"

#: ../../tutorial/modules.rst:161
msgid ""
"you can make the file usable as a script as well as an importable module, "
"because the code that parses the command line only runs if the module is "
"executed as the \"main\" file:"
msgstr ""
"شما می توانید فایل را به گونه ای ایجاد کنید که هم به عنوان یک اسکریپت قابل "
"استفاده باشد و هم به عنوان یک ماژول واردشدنی، زیرا کدی که دستورات خط فرمان "
"را تحلیل می کند، تنها زمانی اجرا می شود که ماژول به عنوان فایل \"main\" اجرا "
"شود:"

#: ../../tutorial/modules.rst:170
msgid "If the module is imported, the code is not run::"
msgstr "اگر ماژول ایمپورت شده باشد، کد اجرا نمی شود::"

#: ../../tutorial/modules.rst:175
msgid ""
"This is often used either to provide a convenient user interface to a "
"module, or for testing purposes (running the module as a script executes a "
"test suite)."
msgstr ""
"این اغلب برای ارائه یک رابط کاربری راحت به یک ماژول یا برای اهداف آزمایش "
"(اجرای ماژول به عنوان یک اسکریپت یک مجموعه تست را اجرا می کند) استفاده می "
"شود."

#: ../../tutorial/modules.rst:182
msgid "The Module Search Path"
msgstr "مسیر جستجوی ماژول"

#: ../../tutorial/modules.rst:186
msgid ""
"When a module named :mod:`spam` is imported, the interpreter first searches "
"for a built-in module with that name. These module names are listed in :data:"
"`sys.builtin_module_names`. If not found, it then searches for a file named :"
"file:`spam.py` in a list of directories given by the variable :data:`sys."
"path`.  :data:`sys.path` is initialized from these locations:"
msgstr ""

#: ../../tutorial/modules.rst:192
msgid ""
"The directory containing the input script (or the current directory when no "
"file is specified)."
msgstr ""
"دایرکتوری که شامل اسکریپت ورودی است (یا دایرکتوری فعلی هنگامی که هیچ فایلی "
"مشخص نشده است)."

#: ../../tutorial/modules.rst:194
msgid ""
":envvar:`PYTHONPATH` (a list of directory names, with the same syntax as the "
"shell variable :envvar:`PATH`)."
msgstr ""
":envvar:`PYTHONPATH` (یک لیست از نام دایرکتوری ها, با همان نحوه نگارش متغیر "
"شِل :envvar:`PATH`)."

#: ../../tutorial/modules.rst:196
msgid ""
"The installation-dependent default (by convention including a ``site-"
"packages`` directory, handled by the :mod:`site` module)."
msgstr ""
"پیش فرض وابسته به نصب (به طور مرسوم شامل یک دایرکتوری ``site-packages`` که "
"توسط ماژول :mod:`site` مدیریت می شود)."

#: ../../tutorial/modules.rst:200
msgid ""
"On file systems which support symlinks, the directory containing the input "
"script is calculated after the symlink is followed. In other words the "
"directory containing the symlink is **not** added to the module search path."
msgstr ""
"در سیستم فایل هایی که از سیملینک ها پشتیبانی می کنند، دایرکتوری حاوی اسکریپت "
"ورودی پس از دنبال کردن سیملینک محاسبه می شود. به عبارت دیگر، دایرکتوری حاوی "
"سیملینک به مسیر جستجوی ماژول اضافه می شود."

#: ../../tutorial/modules.rst:204
msgid ""
"After initialization, Python programs can modify :data:`sys.path`.  The "
"directory containing the script being run is placed at the beginning of the "
"search path, ahead of the standard library path. This means that scripts in "
"that directory will be loaded instead of modules of the same name in the "
"library directory. This is an error unless the replacement is intended.  See "
"section :ref:`tut-standardmodules` for more information."
msgstr ""
"پس از مقداردهی اولیه، برنامه های پایتون می توانند :data:`sys.path` را تغییر "
"دهند. دایرکتوری حاوی اسکریپتی که اجرا می شود، در ابتدای مسیر جستجو قرار می "
"گیرد، پیش از مسیر کتابخانه استاندارد. این بدین معناست که اسکریپت های موجود "
"در آن دایرکتوری به جای ماژول های هم نام در دایرکتوری کتابخانه بارگذاری می "
"شوند. این یک خطا است مگر اینکه جایگزینی مورد نظر باشد. برای اطلاعات بیشتر به "
"بخش :ref:`tut-standardmodules` مراجعه کنید."

#: ../../tutorial/modules.rst:215
msgid "\"Compiled\" Python files"
msgstr "فایل های پایتون \"کامپایل شده\""

#: ../../tutorial/modules.rst:217
msgid ""
"To speed up loading modules, Python caches the compiled version of each "
"module in the ``__pycache__`` directory under the name :file:`module."
"{version}.pyc`, where the version encodes the format of the compiled file; "
"it generally contains the Python version number.  For example, in CPython "
"release 3.3 the compiled version of spam.py would be cached as ``__pycache__/"
"spam.cpython-33.pyc``.  This naming convention allows compiled modules from "
"different releases and different versions of Python to coexist."
msgstr ""
"برای سرعت بخشیدن به بارگذاری ماژول ها، پایتون نسخه کامپایل شده هر ماژول را "
"در دایرکتوری ``__pycache__``، با نام :file:`module.{version}.pyc` ذخیره می "
"کند که نسخه آن فرمت فایل کامپایل شده را رمزگذاری می کند؛ به طور کلی شامل "
"شماره نسخه پایتون است. به عنوان مثال، در نسخه 3.3 CPython، نسخه کامپایل شده "
"spam.py به صورت ``__pycache__/spam.cpython-33.pyc`` ذخیره می شود. این "
"نامگذاری به ماژول های کامپایل شده از نسخه ها و شماره های مختلف پایتون اجازه "
"می دهد که در کنار هم وجود داشته باشند."

#: ../../tutorial/modules.rst:225
msgid ""
"Python checks the modification date of the source against the compiled "
"version to see if it's out of date and needs to be recompiled.  This is a "
"completely automatic process.  Also, the compiled modules are platform-"
"independent, so the same library can be shared among systems with different "
"architectures."
msgstr ""
"پایتون تاریخ تغییر منبع را در مقابل نسخه کامپایل شده بررسی می کند تا ببیند "
"آیا قدیمی است و نیاز به بازکامپایل شدن دارد یا خیر. این یک فرآیند کاملاً "
"خودکار است. همچنین، ماژول های کامپایل شده مستقل از پلتفرم هستند، بنابراین "
"همان کتابخانه می تواند بین سیستم هایی با معماری های متفاوت به اشتراک گذاشته "
"شود."

#: ../../tutorial/modules.rst:230
msgid ""
"Python does not check the cache in two circumstances.  First, it always "
"recompiles and does not store the result for the module that's loaded "
"directly from the command line.  Second, it does not check the cache if "
"there is no source module.  To support a non-source (compiled only) "
"distribution, the compiled module must be in the source directory, and there "
"must not be a source module."
msgstr ""
"پایتون در دو حالت حافظه پنهان را بررسی نمی کند. اول، همیشه دوباره کامپایل "
"کرده و نتیجه را برای ماژولی که به طور مستقیم از خط فرمان بارگذاری می شود، "
"ذخیره نمی کند. دوم، اگر ماژول منبعی وجود نداشته باشد، حافظه پنهان را بررسی "
"نمی کند. برای پشتیبانی از توزیع بدون منبع (فقط کامپایل شده), ماژول کامپایل "
"شده باید در دایرکتوری منبع باشد و نباید ماژول منبعی وجود داشته باشد."

#: ../../tutorial/modules.rst:237
msgid "Some tips for experts:"
msgstr "نکاتی برای متخصصان:"

#: ../../tutorial/modules.rst:239
msgid ""
"You can use the :option:`-O` or :option:`-OO` switches on the Python command "
"to reduce the size of a compiled module.  The ``-O`` switch removes assert "
"statements, the ``-OO`` switch removes both assert statements and __doc__ "
"strings.  Since some programs may rely on having these available, you should "
"only use this option if you know what you're doing.  \"Optimized\" modules "
"have an ``opt-`` tag and are usually smaller.  Future releases may change "
"the effects of optimization."
msgstr ""
"شما می توانید از سوئیچ های :option:`-O` یا :option:`-OO` در دستور Python "
"استفاده کنید تا حجم یک ماژول کامپایل شده را کاهش دهید. سوئیچ ``-O`` عبارات "
"assert را حذف می کند، سوئیچ ``-OO`` هم عبارات assert و هم رشته های __doc__ "
"را حذف می کند. از آنجایی که برخی برنامه ها ممکن است بر دسترسی به این ها تکیه "
"داشته باشند، باید تنها در صورتی که دقیقاً می دانید چه کاری انجام می دهید از "
"این گزینه استفاده کنید. ماژول های \"بهینه سازی شده\" دارای یک برچسب ``opt-`` "
"هستند و معمولاً حجم کمتری دارند. نسخه های آینده ممکن است اثرات بهینه سازی را "
"تغییر دهند."

#: ../../tutorial/modules.rst:247
msgid ""
"A program doesn't run any faster when it is read from a ``.pyc`` file than "
"when it is read from a ``.py`` file; the only thing that's faster about ``."
"pyc`` files is the speed with which they are loaded."
msgstr ""
"اجرای یک برنامه زمانی که از فایل ``.pyc`` خوانده می شود، سریع تر از زمانی که "
"از فایل ``.py`` خوانده می شود نیست؛ تنها نکته ای که در مورد فایل های ``."
"pyc`` سریع تر است، سرعت بارگذاری آنهاست."

#: ../../tutorial/modules.rst:251
msgid ""
"The module :mod:`compileall` can create .pyc files for all modules in a "
"directory."
msgstr ""
"ماژول :mod:`compileall` می تواند فایل های .pyc را برای همه ماژول ها در یک "
"دایرکتوری ایجاد کند."

#: ../../tutorial/modules.rst:254
msgid ""
"There is more detail on this process, including a flow chart of the "
"decisions, in :pep:`3147`."
msgstr ""
"جزئیات بیشتری در مورد این فرآیند، از جمله یک نمودار جریان از تصمیمات، در :"
"pep:`3147` وجود دارد."

#: ../../tutorial/modules.rst:261
msgid "Standard Modules"
msgstr "ماژول های استاندارد"

#: ../../tutorial/modules.rst:265
msgid ""
"Python comes with a library of standard modules, described in a separate "
"document, the Python Library Reference (\"Library Reference\" hereafter).  "
"Some modules are built into the interpreter; these provide access to "
"operations that are not part of the core of the language but are "
"nevertheless built in, either for efficiency or to provide access to "
"operating system primitives such as system calls.  The set of such modules "
"is a configuration option which also depends on the underlying platform.  "
"For example, the :mod:`winreg` module is only provided on Windows systems. "
"One particular module deserves some attention: :mod:`sys`, which is built "
"into every Python interpreter.  The variables ``sys.ps1`` and ``sys.ps2`` "
"define the strings used as primary and secondary prompts::"
msgstr ""
"پایتون با یک کتابخانه از ماژول های استاندارد ارائه می شود که در یک سند "
"جداگانه به نام مرجع کتابخانه پایتون (\"مرجع کتابخانه\" از این پس) توصیف شده "
"است. برخی از ماژول ها در مفسر ساخته شده اند؛ این ماژول ها امکان دسترسی به "
"عملیاتی را فراهم می کنند که بخشی از هسته زبان نیستند، اما به هر حال به دلایل "
"کارایی یا جهت دسترسی به ابزارهای اولیه سیستم عامل مانند فراخوانی های سیستمی "
"ساخته شده اند. مجموعه این ماژول ها یک گزینه پیکربندی است که همچنین به پلت "
"فرم زیربنایی بستگی دارد. برای مثال، ماژول :mod:`winreg` تنها در سیستم های "
"ویندوز ارائه می شود. یک ماژول خاص نیاز به توجه دارد: :mod:`sys`، که در هر "
"مفسر پایتون ساخته شده است. متغیرهای ``sys.ps1`` و ``sys.ps2`` رشته هایی که "
"به عنوان پرامپت اولیه و ثانویه مورد استفاده قرار می گیرند را تعریف می کنند::"

#: ../../tutorial/modules.rst:288
msgid ""
"These two variables are only defined if the interpreter is in interactive "
"mode."
msgstr "این دو متغیر تنها زمانی تعریف می شوند که مفسر در حالت تعاملی باشد."

#: ../../tutorial/modules.rst:290
msgid ""
"The variable ``sys.path`` is a list of strings that determines the "
"interpreter's search path for modules. It is initialized to a default path "
"taken from the environment variable :envvar:`PYTHONPATH`, or from a built-in "
"default if :envvar:`PYTHONPATH` is not set.  You can modify it using "
"standard list operations::"
msgstr ""
"متغیر ``sys.path`` یک لیستی از رشته ها است که مسیر جستجوی مفسر برای ماژول ها "
"را تعیین می کند. این متغیر به یک مسیر پیش فرض که از متغیر محیطی :envvar:"
"`PYTHONPATH` گرفته شده است، یا اگر :envvar:`PYTHONPATH` تنظیم نشده باشد، از "
"یک مقدار پیش فرض داخلی، مقداردهی اولیه می شود. شما می توانید با استفاده از "
"عملیات استاندارد لیست آن را تغییر دهید::"

#: ../../tutorial/modules.rst:303
msgid "The :func:`dir` Function"
msgstr "تابع :func:`dir`"

#: ../../tutorial/modules.rst:305
msgid ""
"The built-in function :func:`dir` is used to find out which names a module "
"defines.  It returns a sorted list of strings::"
msgstr ""
"تابع داخلی :func:`dir` برای پیدا کردن نام هایی که یک ماژول تعریف می کند "
"استفاده می شود. این تابع یک لیست مرتب شده از رشته ها را برمی گرداند::"

#: ../../tutorial/modules.rst:334
msgid ""
"Without arguments, :func:`dir` lists the names you have defined currently::"
msgstr ""
"بدون آرگومان، :func:`dir` نام هایی را که در حال حاضر تعریف کرده اید لیست می "
"کند::"

#: ../../tutorial/modules.rst:342
msgid ""
"Note that it lists all types of names: variables, modules, functions, etc."
msgstr ""
"توجه داشته باشید که شامل همه انواع نام ها می شود: متغیرها، ماژول ها، توابع، "
"و غیره."

#: ../../tutorial/modules.rst:346
msgid ""
":func:`dir` does not list the names of built-in functions and variables.  If "
"you want a list of those, they are defined in the standard module :mod:"
"`builtins`::"
msgstr ""
":func:`dir` نام توابع و متغیرهای داخلی را فهرست نمی کند. اگر به دنبال فهرستی "
"از آن ها هستید، آن ها در ماژول استاندارد :mod:`builtins` تعریف شده اند::"

#: ../../tutorial/modules.rst:385
msgid "Packages"
msgstr "بسته ها"

#: ../../tutorial/modules.rst:387
msgid ""
"Packages are a way of structuring Python's module namespace by using "
"\"dotted module names\".  For example, the module name :mod:`A.B` designates "
"a submodule named ``B`` in a package named ``A``.  Just like the use of "
"modules saves the authors of different modules from having to worry about "
"each other's global variable names, the use of dotted module names saves the "
"authors of multi-module packages like NumPy or Pillow from having to worry "
"about each other's module names."
msgstr ""

#: ../../tutorial/modules.rst:395
msgid ""
"Suppose you want to design a collection of modules (a \"package\") for the "
"uniform handling of sound files and sound data.  There are many different "
"sound file formats (usually recognized by their extension, for example: :"
"file:`.wav`, :file:`.aiff`, :file:`.au`), so you may need to create and "
"maintain a growing collection of modules for the conversion between the "
"various file formats. There are also many different operations you might "
"want to perform on sound data (such as mixing, adding echo, applying an "
"equalizer function, creating an artificial stereo effect), so in addition "
"you will be writing a never-ending stream of modules to perform these "
"operations.  Here's a possible structure for your package (expressed in "
"terms of a hierarchical filesystem):"
msgstr ""
"فرض کنید می خواهید مجموعه ای از ماژول ها (یک \"پکیج\") برای مدیریت یکپارچه "
"فایل های صوتی و داده های صوتی طراحی کنید. انواع مختلفی از فرمت های فایل صوتی "
"وجود دارد (که معمولاً با پسوندشان شناخته می شوند, برای مثال: :file:`.wav`, :"
"file:`.aiff`, :file:`.au`), بنابراین ممکن است نیاز داشته باشید مجموعه ای رو "
"به رشد از ماژول ها برای تبدیل بین فرمت های مختلف فایل ها ایجاد و نگهداری "
"کنید. همچنین عملیات متنوعی وجود دارد که ممکن است بخواهید بر روی داده های "
"صوتی انجام دهید (مانند میکس, افزوده های اکو, اعمال یک تابع اکولایزر, ایجاد "
"یک افکت استریو مصنوعی), بنابراین علاوه بر این، شما در حال نوشتن جریان پایان "
"ناپذیری از ماژول ها برای انجام این عملیات خواهید بود. اینجا ساختاری ممکن "
"برای پکیج شما آورده شده است (که بر اساس یک سیستم فایل سلسله مراتبی بیان شده "
"است):"

#: ../../tutorial/modules.rst:432
msgid ""
"When importing the package, Python searches through the directories on ``sys."
"path`` looking for the package subdirectory."
msgstr ""
"زمانی که بسته وارد می شود، پایتون در دایرکتوری های موجود در ``sys.path`` "
"جستجو می کند تا زیردایرکتوری بسته را پیدا کند."

#: ../../tutorial/modules.rst:435
msgid ""
"The :file:`__init__.py` files are required to make Python treat directories "
"containing the file as packages.  This prevents directories with a common "
"name, such as ``string``, from unintentionally hiding valid modules that "
"occur later on the module search path. In the simplest case, :file:`__init__."
"py` can just be an empty file, but it can also execute initialization code "
"for the package or set the ``__all__`` variable, described later."
msgstr ""

#: ../../tutorial/modules.rst:442
msgid ""
"Users of the package can import individual modules from the package, for "
"example::"
msgstr ""
"کاربران بسته می توانند به صورت جداگانه ماژول های مختلف را از بسته وارد کنند، "
"به عنوان مثال::"

#: ../../tutorial/modules.rst:447
msgid ""
"This loads the submodule :mod:`sound.effects.echo`.  It must be referenced "
"with its full name. ::"
msgstr ""

#: ../../tutorial/modules.rst:452
msgid "An alternative way of importing the submodule is::"
msgstr "راه دیگری برای وارد کردن زیرماژول وجود دارد::"

#: ../../tutorial/modules.rst:456
msgid ""
"This also loads the submodule :mod:`echo`, and makes it available without "
"its package prefix, so it can be used as follows::"
msgstr ""

#: ../../tutorial/modules.rst:461
msgid ""
"Yet another variation is to import the desired function or variable "
"directly::"
msgstr ""
"یک تغییر دیگر این است که تابع یا متغیر مورد نظر را به طور مستقیم وارد کنید::"

#: ../../tutorial/modules.rst:465
msgid ""
"Again, this loads the submodule :mod:`echo`, but this makes its function :"
"func:`echofilter` directly available::"
msgstr ""

#: ../../tutorial/modules.rst:470
msgid ""
"Note that when using ``from package import item``, the item can be either a "
"submodule (or subpackage) of the package, or some  other name defined in the "
"package, like a function, class or variable.  The ``import`` statement first "
"tests whether the item is defined in the package; if not, it assumes it is a "
"module and attempts to load it.  If it fails to find it, an :exc:"
"`ImportError` exception is raised."
msgstr ""
"توجه داشته باشید که هنگام استفاده از ``from package import item``، آیتم می "
"تواند یا یک زیرماژول (یا زیرپکیج) از پکیج باشد یا یک نام دیگر تعریف شده در "
"پکیج، مانند یک تابع، کلاس یا متغیر. دستور ``import`` ابتدا بررسی می کند که "
"آیا آیتم در پکیج تعریف شده است یا خیر؛ اگر نه، فرض می کند که یک ماژول است و "
"تلاش می کند آن را بارگیری کند. اگر موفق به پیدا کردن آن نشود، یک استثنای :"
"exc:`ImportError` ایجاد می شود."

#: ../../tutorial/modules.rst:477
msgid ""
"Contrarily, when using syntax like ``import item.subitem.subsubitem``, each "
"item except for the last must be a package; the last item can be a module or "
"a package but can't be a class or function or variable defined in the "
"previous item."
msgstr ""
"برعکس، زمانی که از سینتاکسی مانند ``import item.subitem.subsubitem`` استفاده "
"می کنید، هر آیتم به جز آخری باید یک پکیج باشد؛ آیتم آخر می تواند ماژول یا "
"پکیج باشد اما نمی تواند یک کلاس یا تابع یا متغیر تعریف شده در آیتم قبلی باشد."

#: ../../tutorial/modules.rst:486
msgid "Importing \\* From a Package"
msgstr "وارد کردن \\* از یک بسته"

#: ../../tutorial/modules.rst:490
msgid ""
"Now what happens when the user writes ``from sound.effects import *``?  "
"Ideally, one would hope that this somehow goes out to the filesystem, finds "
"which submodules are present in the package, and imports them all.  This "
"could take a long time and importing sub-modules might have unwanted side-"
"effects that should only happen when the sub-module is explicitly imported."
msgstr ""
"حال وقتی کاربر ``from sound.effects import *`` را می نویسد، چه اتفاقی می "
"افتد؟ به طور ایده آل، انتظار می رود که این دستور به نوعی به سیستم فایل برود، "
"زیرماژول های موجود در بسته را پیدا کند و همه آن ها را وارد کند. این فرآیند "
"ممکن است مدت زیادی طول بکشد و وارد کردن زیرماژول ها می تواند اثرات جانبی "
"ناخواسته ای داشته باشد که تنها باید زمانی که زیرماژول به طور مشخص وارد شده "
"است، رخ دهند."

#: ../../tutorial/modules.rst:496
msgid ""
"The only solution is for the package author to provide an explicit index of "
"the package.  The :keyword:`import` statement uses the following convention: "
"if a package's :file:`__init__.py` code defines a list named ``__all__``, it "
"is taken to be the list of module names that should be imported when ``from "
"package import *`` is encountered.  It is up to the package author to keep "
"this list up-to-date when a new version of the package is released.  Package "
"authors may also decide not to support it, if they don't see a use for "
"importing \\* from their package.  For example, the file :file:`sound/"
"effects/__init__.py` could contain the following code::"
msgstr ""
"تنها راه حل این است که نویسنده بسته، یک فهرست صریح از بسته ارائه دهد. دستور :"
"keyword:`import` از این قرارداد استفاده می کند: اگر کد :file:`__init__.py` "
"یک بسته، لیستی به نام ``__all__`` تعریف کند، فرض بر این است که این لیست شامل "
"نام ماژول هایی است که باید هنگام مواجه شدن با ``from package import *`` وارد "
"شوند. بر عهده نویسنده بسته است که این لیست را به روز نگه دارد وقتی یک نسخه "
"جدید از بسته منتشر می شود. نویسندگان بسته ممکن است تصمیم بگیرند که از این "
"قابلیت پشتیبانی نکنند، اگر نیازی به وارد کردن \\* از بسته خودشان نبینند. به "
"عنوان مثال، فایل :file:`sound/effects/__init__.py` می تواند کد زیر را شامل "
"شود::"

#: ../../tutorial/modules.rst:508
msgid ""
"This would mean that ``from sound.effects import *`` would import the three "
"named submodules of the :mod:`sound.effects` package."
msgstr ""

#: ../../tutorial/modules.rst:511
msgid ""
"If ``__all__`` is not defined, the statement ``from sound.effects import *`` "
"does *not* import all submodules from the package :mod:`sound.effects` into "
"the current namespace; it only ensures that the package :mod:`sound.effects` "
"has been imported (possibly running any initialization code in :file:"
"`__init__.py`) and then imports whatever names are defined in the package.  "
"This includes any names defined (and submodules explicitly loaded) by :file:"
"`__init__.py`.  It also includes any submodules of the package that were "
"explicitly loaded by previous :keyword:`import` statements.  Consider this "
"code::"
msgstr ""

#: ../../tutorial/modules.rst:524
msgid ""
"In this example, the :mod:`echo` and :mod:`surround` modules are imported in "
"the current namespace because they are defined in the :mod:`sound.effects` "
"package when the ``from...import`` statement is executed.  (This also works "
"when ``__all__`` is defined.)"
msgstr ""

#: ../../tutorial/modules.rst:529
msgid ""
"Although certain modules are designed to export only names that follow "
"certain patterns when you use ``import *``, it is still considered bad "
"practice in production code."
msgstr ""
"اگرچه بعضی از ماژول ها طراحی شده اند تا فقط نام هایی را که از الگوهای خاصی "
"پیروی می کنند وقتی که از ``import *`` استفاده می کنید صادر کنند، اما استفاده "
"از این روش در کد تولیدی همچنان به عنوان یک عمل نامناسب در نظر گرفته می شود."

#: ../../tutorial/modules.rst:533
msgid ""
"Remember, there is nothing wrong with using ``from package import "
"specific_submodule``!  In fact, this is the recommended notation unless the "
"importing module needs to use submodules with the same name from different "
"packages."
msgstr ""
"به خاطر داشته باشید که استفاده از ``from package import specific_submodule`` "
"هیچ ایرادی ندارد! در واقع، این نشانه گذاری توصیه می شود مگر اینکه ماژول "
"وارداتی نیاز به استفاده از زیرماژول هایی با همان نام از بسته های مختلف داشته "
"باشد."

#: ../../tutorial/modules.rst:542
msgid "Intra-package References"
msgstr "ارجاعات درون بسته ای"

#: ../../tutorial/modules.rst:544
msgid ""
"When packages are structured into subpackages (as with the :mod:`sound` "
"package in the example), you can use absolute imports to refer to submodules "
"of siblings packages.  For example, if the module :mod:`sound.filters."
"vocoder` needs to use the :mod:`echo` module in the :mod:`sound.effects` "
"package, it can use ``from sound.effects import echo``."
msgstr ""

#: ../../tutorial/modules.rst:550
msgid ""
"You can also write relative imports, with the ``from module import name`` "
"form of import statement.  These imports use leading dots to indicate the "
"current and parent packages involved in the relative import.  From the :mod:"
"`surround` module for example, you might use::"
msgstr ""

#: ../../tutorial/modules.rst:559
msgid ""
"Note that relative imports are based on the name of the current module.  "
"Since the name of the main module is always ``\"__main__\"``, modules "
"intended for use as the main module of a Python application must always use "
"absolute imports."
msgstr ""
"توجه داشته باشید که واردات نسبی بر اساس نام ماژول فعلی است. از آنجا که نام "
"ماژول اصلی همیشه ``\"__main__\"`` است، ماژول هایی که برای استفاده به عنوان "
"ماژول اصلی یک برنامه کاربردی Python در نظر گرفته شده اند، باید همیشه از "
"واردات مطلق استفاده کنند."

#: ../../tutorial/modules.rst:565
msgid "Packages in Multiple Directories"
msgstr "پکیج ها در چندین دایرکتوری"

#: ../../tutorial/modules.rst:567
msgid ""
"Packages support one more special attribute, :attr:`__path__`.  This is "
"initialized to be a list containing the name of the directory holding the "
"package's :file:`__init__.py` before the code in that file is executed.  "
"This variable can be modified; doing so affects future searches for modules "
"and subpackages contained in the package."
msgstr ""

#: ../../tutorial/modules.rst:573
msgid ""
"While this feature is not often needed, it can be used to extend the set of "
"modules found in a package."
msgstr ""
"در حالی که این ویژگی اغلب مورد نیاز نیست، می تواند برای گسترش مجموعه ماژول "
"های موجود در یک پکیج استفاده شود."

#: ../../tutorial/modules.rst:578
msgid "Footnotes"
msgstr "پاورقی ها"

#: ../../tutorial/modules.rst:579
msgid ""
"In fact function definitions are also 'statements' that are 'executed'; the "
"execution of a module-level function definition adds the function name to "
"the module's global namespace."
msgstr ""
"در واقع، تعریف توابع نیز 'بیانیه هایی' هستند که 'اجرا' می شوند؛ اجرای تعریف "
"یک تابع در سطح ماژول، نام تابع را به فضای نام سراسری ماژول اضافه می کند."
