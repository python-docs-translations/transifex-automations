# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-03-21 14:55+0000\n"
"PO-Revision-Date: 2024-05-11 00:34+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Persian (https://app.transifex.com/python-doc/teams/5390/"
"fa/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fa\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../tutorial/stdlib2.rst:5
msgid "Brief Tour of the Standard Library --- Part II"
msgstr "گشتی سریع در کتابخانه استاندارد --- بخش دوم"

#: ../../tutorial/stdlib2.rst:7
msgid ""
"This second tour covers more advanced modules that support professional "
"programming needs.  These modules rarely occur in small scripts."
msgstr ""
"تور دوم به بررسی ماژول های پیشرفته تری می پردازد که از نیازهای برنامه نویسی "
"حرفه ای پشتیبانی می کنند. این ماژول ها به ندرت در اسکریپت های کوچک ظاهر می "
"شوند."

#: ../../tutorial/stdlib2.rst:14
msgid "Output Formatting"
msgstr "فرمت دهی خروجی"

#: ../../tutorial/stdlib2.rst:16
msgid ""
"The :mod:`reprlib` module provides a version of :func:`repr` customized for "
"abbreviated displays of large or deeply nested containers::"
msgstr ""
"ماژول :mod:`reprlib` نسخه ای از :func:`repr` را فراهم می کند که برای نمایش "
"مختصر محتوای بزرگ یا به شدت تودرتو سفارشی شده است::"

#: ../../tutorial/stdlib2.rst:19
msgid ""
">>> import reprlib\n"
">>> reprlib.repr(set('supercalifragilisticexpialidocious'))\n"
"\"{'a', 'c', 'd', 'e', 'f', 'g', ...}\""
msgstr ""
">>> import reprlib\n"
">>> reprlib.repr(set('supercalifragilisticexpialidocious'))\n"
"\"{'a', 'c', 'd', 'e', 'f', 'g', ...}\""

#: ../../tutorial/stdlib2.rst:23
msgid ""
"The :mod:`pprint` module offers more sophisticated control over printing "
"both built-in and user defined objects in a way that is readable by the "
"interpreter. When the result is longer than one line, the \"pretty printer\" "
"adds line breaks and indentation to more clearly reveal data structure::"
msgstr ""
"ماژول :mod:`pprint` کنترل پیچیده تری بر چاپ اشیاء داخلی و تعریف شده توسط "
"کاربر به نحوی که توسط مفسر قابل خواندن باشد، ارائه می دهد. زمانی که نتیجه "
"بیش از یک خط باشد، \"چاپگر زیبا\" برش خط و تورفتگی هایی اضافه می کند تا "
"ساختار داده به وضوح بیشتری نمایش داده شود::"

#: ../../tutorial/stdlib2.rst:28
msgid ""
">>> import pprint\n"
">>> t = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta',\n"
"...     'yellow'], 'blue']]]\n"
"...\n"
">>> pprint.pprint(t, width=30)\n"
"[[[['black', 'cyan'],\n"
"   'white',\n"
"   ['green', 'red']],\n"
"  [['magenta', 'yellow'],\n"
"   'blue']]]"
msgstr ""
">>> import pprint\n"
">>> t = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta',\n"
"...     'yellow'], 'blue']]]\n"
"...\n"
">>> pprint.pprint(t, width=30)\n"
"[[[['black', 'cyan'],\n"
"   'white',\n"
"   ['green', 'red']],\n"
"  [['magenta', 'yellow'],\n"
"   'blue']]]"

#: ../../tutorial/stdlib2.rst:39
msgid ""
"The :mod:`textwrap` module formats paragraphs of text to fit a given screen "
"width::"
msgstr ""
"ماژول :mod:`textwrap` پاراگراف های متن را فرمت می کند تا در عرض صفحه مشخصی "
"جا بگیرند::"

#: ../../tutorial/stdlib2.rst:42
msgid ""
">>> import textwrap\n"
">>> doc = \"\"\"The wrap() method is just like fill() except that it "
"returns\n"
"... a list of strings instead of one big string with newlines to separate\n"
"... the wrapped lines.\"\"\"\n"
"...\n"
">>> print(textwrap.fill(doc, width=40))\n"
"The wrap() method is just like fill()\n"
"except that it returns a list of strings\n"
"instead of one big string with newlines\n"
"to separate the wrapped lines."
msgstr ""
">>> import textwrap\n"
">>> doc = \"\"\"متد wrap() دقیقاً مانند fill() است با این تفاوت که به جای یک "
"رشته بزرگ که خطوط پیچیده شده را با خطوط جدید جدا می کند, لیستی از رشته ها را "
"برمی گرداند.\"\"\"\n"
"...\n"
">>> print(textwrap.fill(doc, width=40))\n"
"متد wrap() دقیقاً مانند fill() است با این\n"
"تفاوت که به جای یک رشته بزرگ که خطوط\n"
"پیچیده شده را با خطوط جدید جدا می کند،\n"
"لیستی از رشته ها را برمی گرداند."

#: ../../tutorial/stdlib2.rst:53
msgid ""
"The :mod:`locale` module accesses a database of culture specific data "
"formats. The grouping attribute of locale's format function provides a "
"direct way of formatting numbers with group separators::"
msgstr ""
"ماژول :mod:`locale` به یک پایگاه داده از قالب های داده مخصوص فرهنگ ها دسترسی "
"دارد. ویژگی grouping تابع format در locale یک روش مستقیم برای قالب بندی "
"اعداد با جداکننده های گروه ارائه می دهد::"

#: ../../tutorial/stdlib2.rst:57
msgid ""
">>> import locale\n"
">>> locale.setlocale(locale.LC_ALL, 'English_United States.1252')\n"
"'English_United States.1252'\n"
">>> conv = locale.localeconv()          # get a mapping of conventions\n"
">>> x = 1234567.8\n"
">>> locale.format_string(\"%d\", x, grouping=True)\n"
"'1,234,567'\n"
">>> locale.format_string(\"%s%.*f\", (conv['currency_symbol'],\n"
"...                      conv['frac_digits'], x), grouping=True)\n"
"'$1,234,567.80'"
msgstr ""
">>> import locale\n"
">>> locale.setlocale(locale.LC_ALL, 'English_United States.1252')\n"
"'English_United States.1252'\n"
">>> conv = locale.localeconv()          # get a mapping of conventions\n"
">>> x = 1234567.8\n"
">>> locale.format_string(\"%d\", x, grouping=True)\n"
"'1,234,567'\n"
">>> locale.format_string(\"%s%.*f\", (conv['currency_symbol'],\n"
"...                      conv['frac_digits'], x), grouping=True)\n"
"'$1,234,567.80'"

#: ../../tutorial/stdlib2.rst:72
msgid "Templating"
msgstr "الگوگذاری"

#: ../../tutorial/stdlib2.rst:74
msgid ""
"The :mod:`string` module includes a versatile :class:`~string.Template` "
"class with a simplified syntax suitable for editing by end-users.  This "
"allows users to customize their applications without having to alter the "
"application."
msgstr ""
"ماژول :mod:`string` شامل یک کلاس چندمنظوره :class:`~string.Template` است که "
"دارای یک نحو ساده  شده مناسب برای ویرایش توسط کاربران نهایی می باشد. این "
"امکان را به کاربران می دهد تا برنامه های خود را بدون نیاز به تغییر خود "
"برنامه سفارشی کنند."

#: ../../tutorial/stdlib2.rst:78
msgid ""
"The format uses placeholder names formed by ``$`` with valid Python "
"identifiers (alphanumeric characters and underscores).  Surrounding the "
"placeholder with braces allows it to be followed by more alphanumeric "
"letters with no intervening spaces.  Writing ``$$`` creates a single escaped "
"``$``::"
msgstr ""
"فرمت از نام های جایگزین ساخته شده توسط ``$`` استفاده می کند که شامل شناسه "
"های معتبر پایتون (کاراکترهای الفبایی عددی و زیرخط) می باشد. قرار دادن "
"جایگزین در داخل براکت ها این امکان را می دهد که با حروف الفبایی عددی بیشتری "
"بدون فاصله های میانی دنبال شود. نوشتن ``$$``، یک ``$`` فرار یافته ایجاد می "
"کند::"

#: ../../tutorial/stdlib2.rst:83
msgid ""
">>> from string import Template\n"
">>> t = Template('${village}folk send $$10 to $cause.')\n"
">>> t.substitute(village='Nottingham', cause='the ditch fund')\n"
"'Nottinghamfolk send $10 to the ditch fund.'"
msgstr ""
">>> from string import Template\n"
">>> t = Template('${village}folk send $$10 to $cause.')\n"
">>> t.substitute(village='Nottingham', cause='the ditch fund')\n"
"'Nottinghamfolk send $10 to the ditch fund.'"

#: ../../tutorial/stdlib2.rst:88
msgid ""
"The :meth:`~string.Template.substitute` method raises a :exc:`KeyError` when "
"a placeholder is not supplied in a dictionary or a keyword argument.  For "
"mail-merge style applications, user supplied data may be incomplete and the :"
"meth:`~string.Template.safe_substitute` method may be more appropriate --- "
"it will leave placeholders unchanged if data is missing::"
msgstr ""
"متد :meth:`~string.Template.substitute` یک :exc:`KeyError` را زمانی برمی "
"گرداند که یک جایگزین در یک دیکشنری یا یک آرگومان کلیدواژه ارائه نشده باشد. "
"برای برنامه های کاربردی به سبک ترکیب پیام ها، داده هایی که توسط کاربر ارائه "
"می شوند ممکن است ناقص باشند و متد :meth:`~string.Template.safe_substitute` "
"ممکن است مناسب تر باشد --- این متد، جایگزین ها را بدون تغییر باقی می گذارد "
"اگر داده ها ناقص باشند::"

#: ../../tutorial/stdlib2.rst:94
msgid ""
">>> t = Template('Return the $item to $owner.')\n"
">>> d = dict(item='unladen swallow')\n"
">>> t.substitute(d)\n"
"Traceback (most recent call last):\n"
"  ...\n"
"KeyError: 'owner'\n"
">>> t.safe_substitute(d)\n"
"'Return the unladen swallow to $owner.'"
msgstr ""
">>> t = Template('بازگرداندن $item به $owner.')\n"
">>> d = dict(item='unladen swallow')\n"
">>> t.substitute(d)\n"
"Traceback (most recent call last):\n"
"  ...\n"
"KeyError: 'owner'\n"
">>> t.safe_substitute(d)\n"
"'بازگرداندن unladen swallow به $owner.'"

#: ../../tutorial/stdlib2.rst:103
msgid ""
"Template subclasses can specify a custom delimiter.  For example, a batch "
"renaming utility for a photo browser may elect to use percent signs for "
"placeholders such as the current date, image sequence number, or file "
"format::"
msgstr ""
"کلاس های زیرمجموعه Template می توانند یک جداکننده سفارشی مشخص کنند. برای "
"مثال، یک ابزار تغییر نام دسته ای برای مرورگر عکس ممکن است انتخاب کند از "
"علامت درصد به عنوان جایگزین برای مواردی مثل تاریخ جاری، شماره ترتیب تصویر، "
"یا فرمت فایل استفاده کند::"

#: ../../tutorial/stdlib2.rst:107
msgid ""
">>> import time, os.path\n"
">>> photofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']\n"
">>> class BatchRename(Template):\n"
"...     delimiter = '%'\n"
"...\n"
">>> fmt = input('Enter rename style (%d-date %n-seqnum %f-format):  ')\n"
"Enter rename style (%d-date %n-seqnum %f-format):  Ashley_%n%f\n"
"\n"
">>> t = BatchRename(fmt)\n"
">>> date = time.strftime('%d%b%y')\n"
">>> for i, filename in enumerate(photofiles):\n"
"...     base, ext = os.path.splitext(filename)\n"
"...     newname = t.substitute(d=date, n=i, f=ext)\n"
"...     print('{0} --> {1}'.format(filename, newname))\n"
"\n"
"img_1074.jpg --> Ashley_0.jpg\n"
"img_1076.jpg --> Ashley_1.jpg\n"
"img_1077.jpg --> Ashley_2.jpg"
msgstr ""
">>> import time, os.path\n"
">>> photofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']\n"
">>> class BatchRename(Template):\n"
"...     delimiter = '%'\n"
"...\n"
">>> fmt = input('لطفاً سبک تغییر نام را وارد کنید (%d-تاریخ %n-شماره ترتیب %f-"
"فرمت):  ')\n"
"لطفاً سبک تغییر نام را وارد کنید (%d-تاریخ %n-شماره ترتیب %f-فرمت):  "
"Ashley_%n%f\n"
"\n"
">>> t = BatchRename(fmt)\n"
">>> date = time.strftime('%d%b%y')\n"
">>> for i, filename in enumerate(photofiles):\n"
"...     base, ext = os.path.splitext(filename)\n"
"...     newname = t.substitute(d=date, n=i, f=ext)\n"
"...     print('{0} --> {1}'.format(filename, newname))\n"
"\n"
"img_1074.jpg --> Ashley_0.jpg\n"
"img_1076.jpg --> Ashley_1.jpg\n"
"img_1077.jpg --> Ashley_2.jpg"

#: ../../tutorial/stdlib2.rst:126
msgid ""
"Another application for templating is separating program logic from the "
"details of multiple output formats.  This makes it possible to substitute "
"custom templates for XML files, plain text reports, and HTML web reports."
msgstr ""
"کاربرد دیگر قالب بندی، جدا کردن منطق برنامه از جزئیات قالب های مختلف خروجی "
"است. این کار امکان جایگزینی قالب های سفارشی برای فایل های XML، گزارش های متن "
"ساده و گزارش های وب HTML را فراهم می کند."

#: ../../tutorial/stdlib2.rst:134
msgid "Working with Binary Data Record Layouts"
msgstr "کار با طرح بندی داده های باینری رکوردها"

#: ../../tutorial/stdlib2.rst:136
msgid ""
"The :mod:`struct` module provides :func:`~struct.pack` and :func:`~struct."
"unpack` functions for working with variable length binary record formats.  "
"The following example shows how to loop through header information in a ZIP "
"file without using the :mod:`zipfile` module.  Pack codes ``\"H\"`` and "
"``\"I\"`` represent two and four byte unsigned numbers respectively.  The "
"``\"<\"`` indicates that they are standard size and in little-endian byte "
"order::"
msgstr ""
"ماژول :mod:`struct` توابع :func:`~struct.pack` و :func:`~struct.unpack` را "
"برای کار با فرمت های رکورد باینری با طول متغیر فراهم می کند. مثال زیر نشان "
"می دهد که چگونه می توان بدون استفاده از ماژول :mod:`zipfile` از اطلاعات هدر "
"در یک فایل ZIP عبور کرد. کدهای بسته بندی ``\"H\"`` و ``\"I\"`` به ترتیب نشان "
"دهنده اعداد بدون علامت دو بایتی و چهار بایتی هستند. ``\"<\"`` نشان می دهد که "
"آن ها اندازه استاندارد و به ترتیب بایت کوچک اندین هستند::"

#: ../../tutorial/stdlib2.rst:144
msgid ""
"import struct\n"
"\n"
"with open('myfile.zip', 'rb') as f:\n"
"    data = f.read()\n"
"\n"
"start = 0\n"
"for i in range(3):                      # show the first 3 file headers\n"
"    start += 14\n"
"    fields = struct.unpack('<IIIHH', data[start:start+16])\n"
"    crc32, comp_size, uncomp_size, filenamesize, extra_size = fields\n"
"\n"
"    start += 16\n"
"    filename = data[start:start+filenamesize]\n"
"    start += filenamesize\n"
"    extra = data[start:start+extra_size]\n"
"    print(filename, hex(crc32), comp_size, uncomp_size)\n"
"\n"
"    start += extra_size + comp_size     # skip to the next header"
msgstr ""
"import struct\n"
"\n"
"with open('myfile.zip', 'rb') as f:\n"
"    data = f.read()\n"
"\n"
"start = 0\n"
"for i in range(3):                      # show the first 3 file headers\n"
"    start += 14\n"
"    fields = struct.unpack('<IIIHH', data[start:start+16])\n"
"    crc32, comp_size, uncomp_size, filenamesize, extra_size = fields\n"
"\n"
"    start += 16\n"
"    filename = data[start:start+filenamesize]\n"
"    start += filenamesize\n"
"    extra = data[start:start+extra_size]\n"
"    print(filename, hex(crc32), comp_size, uncomp_size)\n"
"\n"
"    start += extra_size + comp_size     # skip to the next header"

#: ../../tutorial/stdlib2.rst:167
msgid "Multi-threading"
msgstr "چند نخی"

#: ../../tutorial/stdlib2.rst:169
msgid ""
"Threading is a technique for decoupling tasks which are not sequentially "
"dependent.  Threads can be used to improve the responsiveness of "
"applications that accept user input while other tasks run in the "
"background.  A related use case is running I/O in parallel with computations "
"in another thread."
msgstr ""
"استفاده از موضوع ها (Threading) روشی برای مستقل سازی وظایفی است که به صورت "
"متوالی به یکدیگر وابسته نیستند. موضوع ها می توانند برای بهبود پاسخگویی "
"برنامه هایی که ورودی کاربر را قبول می کنند، در حالی که وظایف دیگر در پس "
"زمینه اجرا می شوند، استفاده شوند. یک کاربرد مرتبط، اجرای عملیات ورودی/خروجی "
"(I/O) به صورت موازی با محاسبات در یک موضوع دیگر است."

#: ../../tutorial/stdlib2.rst:174
msgid ""
"The following code shows how the high level :mod:`threading` module can run "
"tasks in background while the main program continues to run::"
msgstr ""
"کد زیر نشان می دهد که چگونه ماژول سطح بالای :mod:`threading` می تواند وظایف "
"را در پس زمینه اجرا کند در حالی که برنامه اصلی به اجرای خود ادامه می دهد::"

#: ../../tutorial/stdlib2.rst:177
msgid ""
"import threading, zipfile\n"
"\n"
"class AsyncZip(threading.Thread):\n"
"    def __init__(self, infile, outfile):\n"
"        threading.Thread.__init__(self)\n"
"        self.infile = infile\n"
"        self.outfile = outfile\n"
"\n"
"    def run(self):\n"
"        f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)\n"
"        f.write(self.infile)\n"
"        f.close()\n"
"        print('Finished background zip of:', self.infile)\n"
"\n"
"background = AsyncZip('mydata.txt', 'myarchive.zip')\n"
"background.start()\n"
"print('The main program continues to run in foreground.')\n"
"\n"
"background.join()    # Wait for the background task to finish\n"
"print('Main program waited until background was done.')"
msgstr ""
"import threading, zipfile\n"
"\n"
"class AsyncZip(threading.Thread):\n"
"    def __init__(self, infile, outfile):\n"
"        threading.Thread.__init__(self)\n"
"        self.infile = infile\n"
"        self.outfile = outfile\n"
"\n"
"    def run(self):\n"
"        f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)\n"
"        f.write(self.infile)\n"
"        f.close()\n"
"        print('Finished background zip of:', self.infile)\n"
"\n"
"background = AsyncZip('mydata.txt', 'myarchive.zip')\n"
"background.start()\n"
"print('The main program continues to run in foreground.')\n"
"\n"
"background.join()    # Wait for the background task to finish\n"
"print('Main program waited until background was done.')"

#: ../../tutorial/stdlib2.rst:198
msgid ""
"The principal challenge of multi-threaded applications is coordinating "
"threads that share data or other resources.  To that end, the threading "
"module provides a number of synchronization primitives including locks, "
"events, condition variables, and semaphores."
msgstr ""
"چالش اصلی برنامه های چندنخی همگام سازی نخ هایی است که داده ها یا منابع دیگر "
"را به اشتراک می گذارند. به همین منظور، ماژول threading تعدادی از امکانات "
"همگام سازی از جمله `locks`، `events`، `condition variables` و `semaphores` "
"را فراهم می کند."

#: ../../tutorial/stdlib2.rst:203
msgid ""
"While those tools are powerful, minor design errors can result in problems "
"that are difficult to reproduce.  So, the preferred approach to task "
"coordination is to concentrate all access to a resource in a single thread "
"and then use the :mod:`queue` module to feed that thread with requests from "
"other threads. Applications using :class:`~queue.Queue` objects for inter-"
"thread communication and coordination are easier to design, more readable, "
"and more reliable."
msgstr ""
"هرچند این ابزارها قدرتمند هستند، اما خطاهای جزئی در طراحی می توانند منجر به "
"مشکلاتی شوند که بازتولید آن ها دشوار است. بنابراین، رویکرد ترجیحی برای "
"هماهنگی وظایف این است که تمام دسترسی ها به یک منبع را در یک نخ متمرکز کنید و "
"سپس از ماژول :mod:`queue` برای ارسال درخواست ها از نخ های دیگر به آن نخ "
"استفاده کنید. برنامه هایی که از اشیاء :class:`~queue.Queue` برای ارتباط و "
"هماهنگی بین نخ ها استفاده می کنند، طراحی آن ها آسان تر است، خواناتر هستند و "
"قابلیت اطمینان بیشتری دارند."

#: ../../tutorial/stdlib2.rst:214
msgid "Logging"
msgstr "ورود به سیستم"

#: ../../tutorial/stdlib2.rst:216
msgid ""
"The :mod:`logging` module offers a full featured and flexible logging "
"system. At its simplest, log messages are sent to a file or to ``sys."
"stderr``::"
msgstr ""
"ماژول :mod:`logging` یک سیستم ثبت وقایع کامل و انعطاف پذیر ارائه می دهد. در "
"ساده ترین حالت، پیام های ثبت وقایع به یک فایل یا به ``sys.stderr`` ارسال می "
"شوند::"

#: ../../tutorial/stdlib2.rst:219
msgid ""
"import logging\n"
"logging.debug('Debugging information')\n"
"logging.info('Informational message')\n"
"logging.warning('Warning:config file %s not found', 'server.conf')\n"
"logging.error('Error occurred')\n"
"logging.critical('Critical error -- shutting down')"
msgstr ""
"import logging\n"
"logging.debug('Debugging information')\n"
"logging.info('Informational message')\n"
"logging.warning('Warning:config file %s not found', 'server.conf')\n"
"logging.error('Error occurred')\n"
"logging.critical('Critical error -- shutting down')"

#: ../../tutorial/stdlib2.rst:226
msgid "This produces the following output:"
msgstr "این خروجی زیر را تولید می کند:"

#: ../../tutorial/stdlib2.rst:228
msgid ""
"WARNING:root:Warning:config file server.conf not found\n"
"ERROR:root:Error occurred\n"
"CRITICAL:root:Critical error -- shutting down"
msgstr ""
"هشدار:root:اخطار: فایل پیکربندی server.conf پیدا نشد  \n"
"خطا:root:خطا رخ داده است  \n"
"بحرانی:root:خطای بحرانی -- در حال خاموش کردن  "

#: ../../tutorial/stdlib2.rst:234
msgid ""
"By default, informational and debugging messages are suppressed and the "
"output is sent to standard error.  Other output options include routing "
"messages through email, datagrams, sockets, or to an HTTP Server.  New "
"filters can select different routing based on message priority: :const:"
"`~logging.DEBUG`, :const:`~logging.INFO`, :const:`~logging.WARNING`, :const:"
"`~logging.ERROR`, and :const:`~logging.CRITICAL`."
msgstr ""
"به طور پیش فرض، پیام های اطلاعاتی و اشکال زدایی مخفی شده و خروجی به خطای "
"استاندارد ارسال می شود. دیگر گزینه های خروجی شامل ارسال پیام ها از طریق "
"ایمیل، دیتاگرام ها، سوکت ها یا به یک سرور HTTP است. فیلترهای جدید می توانند "
"براساس اولویت پیام مسیرهای مختلفی را انتخاب کنند: :const:`~logging.DEBUG`، :"
"const:`~logging.INFO`، :const:`~logging.WARNING`، :const:`~logging.ERROR` و :"
"const:`~logging.CRITICAL`."

#: ../../tutorial/stdlib2.rst:241
msgid ""
"The logging system can be configured directly from Python or can be loaded "
"from a user editable configuration file for customized logging without "
"altering the application."
msgstr ""
"سیستم لاگ گیری می تواند به طور مستقیم از پایتون تنظیم شود یا از یک فایل "
"پیکربندی که کاربر می تواند آن را ویرایش کند بارگذاری شود تا لاگ گیری بدون "
"تغییر در برنامه سفارشی سازی شود."

#: ../../tutorial/stdlib2.rst:249
msgid "Weak References"
msgstr "مراجع ضعیف"

#: ../../tutorial/stdlib2.rst:251
msgid ""
"Python does automatic memory management (reference counting for most objects "
"and :term:`garbage collection` to eliminate cycles).  The memory is freed "
"shortly after the last reference to it has been eliminated."
msgstr ""
"پایتون مدیریت حافظه را به صورت خودکار انجام می دهد (شمارش مراجع برای اکثر "
"اشیاء و :term:`garbage collection` برای از بین بردن چرخه ها). حافظه بلافاصله "
"پس از حذف آخرین مرجع به آن آزاد می شود."

#: ../../tutorial/stdlib2.rst:255
msgid ""
"This approach works fine for most applications but occasionally there is a "
"need to track objects only as long as they are being used by something else. "
"Unfortunately, just tracking them creates a reference that makes them "
"permanent. The :mod:`weakref` module provides tools for tracking objects "
"without creating a reference.  When the object is no longer needed, it is "
"automatically removed from a weakref table and a callback is triggered for "
"weakref objects.  Typical applications include caching objects that are "
"expensive to create::"
msgstr ""
"این روش برای بیشتر برنامه ها به خوبی کار می کند، اما گاهی اوقات نیاز است که "
"اشیاء را فقط تا زمانی که توسط چیز دیگری استفاده می شوند دنبال کنیم. "
"متأسفانه، صرفاً دنبال کردن آنها یک مرجع ایجاد می کند که آنها را دائمی می کند. "
"ماژول :mod:`weakref` ابزارهایی برای دنبال کردن اشیاء بدون ایجاد مرجع فراهم "
"می کند. وقتی شیء دیگر مورد نیاز نیست، به طور خودکار از جدول weakref حذف شده "
"و برای اشیاء weakref یک کال بک فعال می شود. کاربردهای معمول شامل کش کردن "
"اشیائی است که ایجاد آنها هزینه بر است::"

#: ../../tutorial/stdlib2.rst:263
msgid ""
">>> import weakref, gc\n"
">>> class A:\n"
"...     def __init__(self, value):\n"
"...         self.value = value\n"
"...     def __repr__(self):\n"
"...         return str(self.value)\n"
"...\n"
">>> a = A(10)                   # create a reference\n"
">>> d = weakref.WeakValueDictionary()\n"
">>> d['primary'] = a            # does not create a reference\n"
">>> d['primary']                # fetch the object if it is still alive\n"
"10\n"
">>> del a                       # remove the one reference\n"
">>> gc.collect()                # run garbage collection right away\n"
"0\n"
">>> d['primary']                # entry was automatically removed\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"    d['primary']                # entry was automatically removed\n"
"  File \"C:/python312/lib/weakref.py\", line 46, in __getitem__\n"
"    o = self.data[key]()\n"
"KeyError: 'primary'"
msgstr ""

#: ../../tutorial/stdlib2.rst:290
msgid "Tools for Working with Lists"
msgstr "ابزارهایی برای کار با لیست ها"

#: ../../tutorial/stdlib2.rst:292
msgid ""
"Many data structure needs can be met with the built-in list type. However, "
"sometimes there is a need for alternative implementations with different "
"performance trade-offs."
msgstr ""
"نیازهای بسیاری از ساختارهای داده را می توان با نوع فهرست داخلی برآورده کرد. "
"با این حال، گاهی اوقات نیاز به پیاده سازی های جایگزین با مبادلات عملکردی "
"متفاوت وجود دارد."

#: ../../tutorial/stdlib2.rst:296
msgid ""
"The :mod:`array` module provides an :class:`~array.array` object that is "
"like a list that stores only homogeneous data and stores it more compactly.  "
"The following example shows an array of numbers stored as two byte unsigned "
"binary numbers (typecode ``\"H\"``) rather than the usual 16 bytes per entry "
"for regular lists of Python int objects::"
msgstr ""
"ماژول :mod:`array` یک شیء :class:`~array.array` فراهم می کند که شبیه به یک "
"لیست است اما فقط داده های همگن را ذخیره کرده و آن را به صورت فشرده تر ذخیره "
"می کند. مثال زیر یک آرایه از اعداد را نشان می دهد که به عنوان اعداد باینری "
"بدون علامت دو بایتی (با کد نوع ``\"H\"``) ذخیره شده اند. این در مقابل ذخیره "
"سازی معمول 16 بایت به ازای هر ورودی برای لیست های معمولی از اشیاء int در "
"پایتون است::"

#: ../../tutorial/stdlib2.rst:302
msgid ""
">>> from array import array\n"
">>> a = array('H', [4000, 10, 700, 22222])\n"
">>> sum(a)\n"
"26932\n"
">>> a[1:3]\n"
"array('H', [10, 700])"
msgstr ""
">>> from array import array\n"
">>> a = array('H', [4000, 10, 700, 22222])\n"
">>> sum(a)\n"
"26932\n"
">>> a[1:3]\n"
"array('H', [10, 700])"

#: ../../tutorial/stdlib2.rst:309
msgid ""
"The :mod:`collections` module provides a :class:`~collections.deque` object "
"that is like a list with faster appends and pops from the left side but "
"slower lookups in the middle. These objects are well suited for implementing "
"queues and breadth first tree searches::"
msgstr ""
"ماژول :mod:`collections` یک شیء :class:`~collections.deque` را فراهم می کند "
"که شبیه به یک لیست است با این تفاوت که اضافه کردن و حذف از سمت چپ در آن سریع "
"تر است اما جستجو در میانه کندتر صورت می گیرد. این اشیاء برای پیاده سازی صف "
"ها و جستجو به روش اول سطح درخت به خوبی مناسب هستند::"

#: ../../tutorial/stdlib2.rst:314
msgid ""
">>> from collections import deque\n"
">>> d = deque([\"task1\", \"task2\", \"task3\"])\n"
">>> d.append(\"task4\")\n"
">>> print(\"Handling\", d.popleft())\n"
"Handling task1"
msgstr ""
">>> from collections import deque\n"
">>> d = deque([\"task1\", \"task2\", \"task3\"])\n"
">>> d.append(\"task4\")\n"
">>> print(\"Handling\", d.popleft())\n"
"Handling task1"

#: ../../tutorial/stdlib2.rst:322
msgid ""
"unsearched = deque([starting_node])\n"
"def breadth_first_search(unsearched):\n"
"    node = unsearched.popleft()\n"
"    for m in gen_moves(node):\n"
"        if is_goal(m):\n"
"            return m\n"
"        unsearched.append(m)"
msgstr ""
"unsearched = deque([starting_node])\n"
"def breadth_first_search(unsearched):\n"
"    node = unsearched.popleft()\n"
"    for m in gen_moves(node):\n"
"        if is_goal(m):\n"
"            return m\n"
"        unsearched.append(m)"

#: ../../tutorial/stdlib2.rst:330
msgid ""
"In addition to alternative list implementations, the library also offers "
"other tools such as the :mod:`bisect` module with functions for manipulating "
"sorted lists::"
msgstr ""
"علاوه بر پیاده سازی های لیست جایگزین، این کتابخانه ابزارهای دیگری نیز ارائه "
"می دهد مثل ماژول :mod:`bisect` با توابعی برای دستکاری لیست های مرتب شده::"

#: ../../tutorial/stdlib2.rst:334
msgid ""
">>> import bisect\n"
">>> scores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')]\n"
">>> bisect.insort(scores, (300, 'ruby'))\n"
">>> scores\n"
"[(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')]"
msgstr ""
">>> import bisect\n"
">>> scores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')]\n"
">>> bisect.insort(scores, (300, 'ruby'))\n"
">>> scores\n"
"[(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')]"

#: ../../tutorial/stdlib2.rst:340
msgid ""
"The :mod:`heapq` module provides functions for implementing heaps based on "
"regular lists.  The lowest valued entry is always kept at position zero.  "
"This is useful for applications which repeatedly access the smallest element "
"but do not want to run a full list sort::"
msgstr ""
"ماژول :mod:`heapq` توابعی برای پیاده سازی heapها بر اساس لیست های معمولی "
"ارائه می دهد. کم ارزش ترین ورودی همیشه در موقعیت صفر نگه داشته می شود. این "
"برای برنامه هایی که به طور مکرر به کوچک ترین عنصر دسترسی دارند اما نمی "
"خواهند یک مرتب سازی کامل لیست اجرا کنند، مفید است::"

#: ../../tutorial/stdlib2.rst:345
msgid ""
">>> from heapq import heapify, heappop, heappush\n"
">>> data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]\n"
">>> heapify(data)                      # rearrange the list into heap order\n"
">>> heappush(data, -5)                 # add a new entry\n"
">>> [heappop(data) for i in range(3)]  # fetch the three smallest entries\n"
"[-5, 0, 1]"
msgstr ""
">>> from heapq import heapify, heappop, heappush\n"
">>> data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]\n"
">>> heapify(data)                      # rearrange the list into heap order\n"
">>> heappush(data, -5)                 # add a new entry\n"
">>> [heappop(data) for i in range(3)]  # fetch the three smallest entries\n"
"[-5, 0, 1]"

#: ../../tutorial/stdlib2.rst:356
msgid "Decimal Floating-Point Arithmetic"
msgstr "محاسبات اعشاری با نقطه شناور"

#: ../../tutorial/stdlib2.rst:358
msgid ""
"The :mod:`decimal` module offers a :class:`~decimal.Decimal` datatype for "
"decimal floating-point arithmetic.  Compared to the built-in :class:`float` "
"implementation of binary floating point, the class is especially helpful for"
msgstr ""
"ماژول :mod:`decimal` یک نوع داده :class:`~decimal.Decimal` برای محاسبات "
"اعشاری با نقطه شناور ارائه می دهد. در مقایسه با پیاده سازی داخلی :class:"
"`float` برای اعداد با نقطه شناور دودویی، این کلاس به ویژه برای..."

#: ../../tutorial/stdlib2.rst:362
msgid ""
"financial applications and other uses which require exact decimal "
"representation,"
msgstr ""
"برنامه های کاربردی مالی و استفاده های دیگری که نیاز به نمایش دقیق اعشاری "
"دارند،"

#: ../../tutorial/stdlib2.rst:364
msgid "control over precision,"
msgstr "کنترل بر دقت،"

#: ../../tutorial/stdlib2.rst:365
msgid "control over rounding to meet legal or regulatory requirements,"
msgstr "کنترل بر گرد کردن به منظور رعایت الزامات قانونی یا مقرراتی،"

#: ../../tutorial/stdlib2.rst:366
msgid "tracking of significant decimal places, or"
msgstr "ردیابی ارقام اعشاری قابل توجه، یا"

#: ../../tutorial/stdlib2.rst:367
msgid ""
"applications where the user expects the results to match calculations done "
"by hand."
msgstr ""
"کاربردهایی که کاربر انتظار دارد نتایج با محاسبات انجام شده به صورت دستی "
"تطابق داشته باشند."

#: ../../tutorial/stdlib2.rst:370
msgid ""
"For example, calculating a 5% tax on a 70 cent phone charge gives different "
"results in decimal floating point and binary floating point. The difference "
"becomes significant if the results are rounded to the nearest cent::"
msgstr ""
"به عنوان مثال، محاسبه ۵٪ مالیات بر روی یک هزینه تماس ۷۰ سنتی نتایج متفاوتی "
"در محاسبات اعشاری نقطه شناور و محاسبات دودویی نقطه شناور می دهد. این تفاوت "
"زمانی که نتایج به نزدیک ترین سنت گرد شوند به وضوح قابل توجه خواهد بود::"

#: ../../tutorial/stdlib2.rst:374
msgid ""
">>> from decimal import *\n"
">>> round(Decimal('0.70') * Decimal('1.05'), 2)\n"
"Decimal('0.74')\n"
">>> round(.70 * 1.05, 2)\n"
"0.73"
msgstr ""
">>> from decimal import *\n"
">>> round(Decimal('0.70') * Decimal('1.05'), 2)\n"
"Decimal('0.74')\n"
">>> round(.70 * 1.05, 2)\n"
"0.73"

#: ../../tutorial/stdlib2.rst:380
msgid ""
"The :class:`~decimal.Decimal` result keeps a trailing zero, automatically "
"inferring four place significance from multiplicands with two place "
"significance.  Decimal reproduces mathematics as done by hand and avoids "
"issues that can arise when binary floating point cannot exactly represent "
"decimal quantities."
msgstr ""
"نتیجه :class:`~decimal.Decimal` یک صفر انتهایی را حفظ می کند و به طور خودکار "
"اهمیت چهار مکانی را از ضرایبی با اهمیت دو مکانی استنباط می کند. Decimal "
"ریاضیات انجام شده به صورت دستی را بازتولید می کند و از مسائلی که می تواند "
"زمانی که نقطه شناور باینری نمی تواند دقیقاً مقادیر ده دهی را نمایش دهد، "
"جلوگیری می کند."

#: ../../tutorial/stdlib2.rst:386
msgid ""
"Exact representation enables the :class:`~decimal.Decimal` class to perform "
"modulo calculations and equality tests that are unsuitable for binary "
"floating point::"
msgstr ""
"بازنمایی دقیق به کلاس :class:`~decimal.Decimal` امکان می دهد تا محاسبات "
"پیمانه ای و آزمون های برابری را که برای اعداد اعشاری دودویی نامناسب هستند، "
"انجام دهد::"

#: ../../tutorial/stdlib2.rst:390
msgid ""
">>> Decimal('1.00') % Decimal('.10')\n"
"Decimal('0.00')\n"
">>> 1.00 % 0.10\n"
"0.09999999999999995\n"
"\n"
">>> sum([Decimal('0.1')]*10) == Decimal('1.0')\n"
"True\n"
">>> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 == 1.0\n"
"False"
msgstr ""
">>> Decimal('1.00') % Decimal('.10')\n"
"Decimal('0.00')\n"
">>> 1.00 % 0.10\n"
"0.09999999999999995\n"
"\n"
">>> sum([Decimal('0.1')]*10) == Decimal('1.0')\n"
"True\n"
">>> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 == 1.0\n"
"False"

#: ../../tutorial/stdlib2.rst:400
msgid ""
"The :mod:`decimal` module provides arithmetic with as much precision as "
"needed::"
msgstr "ماژول :mod:`decimal` محاسبات ریاضی را با دقت مورد نیاز فراهم می کند::"

#: ../../tutorial/stdlib2.rst:402
msgid ""
">>> getcontext().prec = 36\n"
">>> Decimal(1) / Decimal(7)\n"
"Decimal('0.142857142857142857142857142857142857')"
msgstr ""
">>> getcontext().prec = 36\n"
">>> Decimal(1) / Decimal(7)\n"
"Decimal('0.142857142857142857142857142857142857')"
