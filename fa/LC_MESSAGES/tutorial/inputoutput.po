# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-03-21 14:55+0000\n"
"PO-Revision-Date: 2024-05-11 00:34+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Persian (https://app.transifex.com/python-doc/teams/5390/"
"fa/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fa\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../tutorial/inputoutput.rst:5
msgid "Input and Output"
msgstr "Input and Output"

#: ../../tutorial/inputoutput.rst:7
msgid ""
"There are several ways to present the output of a program; data can be "
"printed in a human-readable form, or written to a file for future use. This "
"chapter will discuss some of the possibilities."
msgstr ""
"راه های متعددی برای نمایش خروجی یک برنامه وجود دارد؛ اطلاعات می تواند به "
"صورت قابل خواندن برای انسان چاپ شود یا برای استفاده های آتی در فایل نوشته "
"شود. این فصل به برخی از این امکانات خواهد پرداخت."

#: ../../tutorial/inputoutput.rst:15
msgid "Fancier Output Formatting"
msgstr "قالب بندی خروجی جذاب تر"

#: ../../tutorial/inputoutput.rst:17
msgid ""
"So far we've encountered two ways of writing values: *expression statements* "
"and the :func:`print` function.  (A third way is using the :meth:`~io."
"TextIOBase.write` method of file objects; the standard output file can be "
"referenced as ``sys.stdout``. See the Library Reference for more information "
"on this.)"
msgstr ""
"تا کنون با دو روش برای نوشتن مقادیر آشنا شده ایم: *expression statements* و "
"تابع :func:`print`. (روش سوم استفاده از متد :meth:`~io.TextIOBase.write` "
"برای آبجکت های فایل است؛ فایل خروجی استاندارد می تواند به عنوان ``sys."
"stdout`` اشاره شود. برای اطلاعات بیشتر به مراجعه کنید به Library Reference.)"

#: ../../tutorial/inputoutput.rst:22
msgid ""
"Often you'll want more control over the formatting of your output than "
"simply printing space-separated values. There are several ways to format "
"output."
msgstr ""
"اغلب اوقات شما می خواهید کنترل بیشتری بر روی فرمت بندی خروجی خود نسبت به "
"صرفاً چاپ مقادیر با فاصله های جداکننده داشته باشید. راه های مختلفی برای فرمت "
"کردن خروجی وجود دارد."

#: ../../tutorial/inputoutput.rst:25
msgid ""
"To use :ref:`formatted string literals <tut-f-strings>`, begin a string with "
"``f`` or ``F`` before the opening quotation mark or triple quotation mark. "
"Inside this string, you can write a Python expression between ``{`` and ``}"
"`` characters that can refer to variables or literal values."
msgstr ""
"برای استفاده از :ref:`formatted string literals <tut-f-strings>`، یک رشته را "
"با ``f`` یا ``F`` قبل از علامت نقل قول یا نقل قول سه گانه آغاز کنید. درون "
"این رشته، می توانید یک عبارت پایتون را بین کاراکترهای ``{`` و ``}`` بنویسید "
"که می تواند به متغیرها یا مقادیر صریح اشاره کند."

#: ../../tutorial/inputoutput.rst:32
msgid ""
">>> year = 2016\n"
">>> event = 'Referendum'\n"
">>> f'Results of the {year} {event}'\n"
"'Results of the 2016 Referendum'"
msgstr ""
">>> year = 2016\n"
">>> event = 'Referendum'\n"
">>> f'Results of the {year} {event}'\n"
"'Results of the 2016 Referendum'"

#: ../../tutorial/inputoutput.rst:37
msgid ""
"The :meth:`str.format` method of strings requires more manual effort.  "
"You'll still use ``{`` and ``}`` to mark where a variable will be "
"substituted and can provide detailed formatting directives, but you'll also "
"need to provide the information to be formatted. In the following code block "
"there are two examples of how to format variables:"
msgstr ""
"روش :meth:`str.format` در رشته ها نیاز به تلاش دستی بیشتری دارد. شما همچنان "
"از ``{`` و ``}`` استفاده خواهید کرد تا مشخص کنید که یک متغیر کجا جایگزین "
"خواهد شد و می توانید دستورات قالب بندی دقیقی ارائه دهید، اما همچنین لازم است "
"اطلاعاتی که باید قالب بندی شوند، را فراهم کنید. در بلوک کد زیر دو مثال از "
"چگونگی قالب بندی متغیرها وجود دارد:"

#: ../../tutorial/inputoutput.rst:46
msgid ""
">>> yes_votes = 42_572_654\n"
">>> total_votes = 85_705_149\n"
">>> percentage = yes_votes / total_votes\n"
">>> '{:-9} YES votes  {:2.2%}'.format(yes_votes, percentage)\n"
"' 42572654 YES votes  49.67%'"
msgstr ""
">>> yes_votes = 42_572_654\n"
">>> total_votes = 85_705_149\n"
">>> percentage = yes_votes / total_votes\n"
">>> '{:-9} YES votes  {:2.2%}'.format(yes_votes, percentage)\n"
"' 42572654 YES votes  49.67%'"

#: ../../tutorial/inputoutput.rst:52
msgid ""
"Notice how the ``yes_votes`` are padded with spaces and a negative sign only "
"for negative numbers. The example also prints ``percentage`` multiplied by "
"100, with 2 decimal places and followed by a percent sign (see :ref:"
"`formatspec` for details)."
msgstr ""
"توجه کنید که ``yes_votes`` با فاصله ها و یک علامت منفی فقط برای اعداد منفی "
"پر می شوند. این مثال همچنین ``percentage`` را که در 100 ضرب شده است چاپ می "
"کند، با 2 رقم اعشار و به دنبال آن علامت درصد (جزئیات را در :ref:`formatspec` "
"ببینید)."

#: ../../tutorial/inputoutput.rst:57
msgid ""
"Finally, you can do all the string handling yourself by using string slicing "
"and concatenation operations to create any layout you can imagine.  The "
"string type has some methods that perform useful operations for padding "
"strings to a given column width."
msgstr ""
"در نهایت، شما می توانید با استفاده از عملیات برش زدن و الحاق رشته ، مدیریت "
"رشته ها را به طور کامل خودتان انجام دهید تا هر چیدمانی که تصور می کنید ایجاد "
"کنید. نوع داده ی رشته دارای روش هایی است که عملیات مفیدی برای پر کردن رشته "
"ها به عرض یک ستون مشخص انجام می دهند."

#: ../../tutorial/inputoutput.rst:62
msgid ""
"When you don't need fancy output but just want a quick display of some "
"variables for debugging purposes, you can convert any value to a string with "
"the :func:`repr` or :func:`str` functions."
msgstr ""
"هنگامی که به خروجی فانتزی نیاز ندارید اما فقط می خواهید یک نمایش سریع از "
"برخی متغیرها برای اهداف اشکال زدایی داشته باشید، می توانید هر مقداری را با "
"توابع :func:`repr` یا :func:`str` به رشته ای تبدیل کنید."

#: ../../tutorial/inputoutput.rst:66
msgid ""
"The :func:`str` function is meant to return representations of values which "
"are fairly human-readable, while :func:`repr` is meant to generate "
"representations which can be read by the interpreter (or will force a :exc:"
"`SyntaxError` if there is no equivalent syntax).  For objects which don't "
"have a particular representation for human consumption, :func:`str` will "
"return the same value as :func:`repr`.  Many values, such as numbers or "
"structures like lists and dictionaries, have the same representation using "
"either function.  Strings, in particular, have two distinct representations."
msgstr ""
"تابع :func:`str` قرار است که نمایش هایی از مقادیر را برگرداند که برای انسان "
"قابل فهم باشند، در حالی که :func:`repr` هدف دارد نمایش هایی تولید کند که "
"توسط مفسر خوانده شوند (یا اگر هیچ سینتکس معادلی وجود نداشته باشد, یک :exc:"
"`SyntaxError` را اجباری می کند). برای اشیایی که نمایش خاصی برای مصرف انسانی "
"ندارند، :func:`str` همان مقداری که :func:`repr` برمی گرداند را برمی گرداند. "
"بسیاری از مقادیر، مانند اعداد یا ساختارهایی مانند لیست ها و دیکشنری ها، با "
"استفاده از هر دو تابع نمایش یکسانی دارند. به ویژه، رشته ها دو نمایش متمایز "
"دارند."

#: ../../tutorial/inputoutput.rst:75
msgid "Some examples::"
msgstr "چند نمونه::"

#: ../../tutorial/inputoutput.rst:77
msgid ""
">>> s = 'Hello, world.'\n"
">>> str(s)\n"
"'Hello, world.'\n"
">>> repr(s)\n"
"\"'Hello, world.'\"\n"
">>> str(1/7)\n"
"'0.14285714285714285'\n"
">>> x = 10 * 3.25\n"
">>> y = 200 * 200\n"
">>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'\n"
">>> print(s)\n"
"The value of x is 32.5, and y is 40000...\n"
">>> # The repr() of a string adds string quotes and backslashes:\n"
">>> hello = 'hello, world\\n'\n"
">>> hellos = repr(hello)\n"
">>> print(hellos)\n"
"'hello, world\\n'\n"
">>> # The argument to repr() may be any Python object:\n"
">>> repr((x, y, ('spam', 'eggs')))\n"
"\"(32.5, 40000, ('spam', 'eggs'))\""
msgstr ""
">>> s = 'سلام, دنیا.'\n"
">>> str(s)\n"
"'سلام، دنیا.'\n"
">>> repr(s)\n"
"\"'سلام، دنیا.'\"\n"
">>> str(1/7)\n"
"'0.14285714285714285'\n"
">>> x = 10 * 3.25\n"
">>> y = 200 * 200\n"
">>> s = 'مقدار x برابر است با ' + repr(x) + ', و y برابر است با ' + repr(y) "
"+ '...'\n"
">>> print(s)\n"
"مقدار x برابر است با 32.5، و y برابر است با 40000...\n"
">>> # تابع repr() در رشته ها, نقل قول ها و بک اسلش ها را اضافه می کند:\n"
">>> hello = 'سلام, دنیا\\n'\n"
">>> hellos = repr(hello)\n"
">>> print(hellos)\n"
"'سلام، دنیا\\n'\n"
">>> # آرگومان تابع repr() می تواند هر شیء پایتونی باشد:\n"
">>> repr((x, y, ('spam', 'eggs')))\n"
"\"(32.5, 40000, ('spam', 'eggs'))\""

#: ../../tutorial/inputoutput.rst:98
msgid ""
"The :mod:`string` module contains a :class:`~string.Template` class that "
"offers yet another way to substitute values into strings, using placeholders "
"like ``$x`` and replacing them with values from a dictionary, but offers "
"much less control of the formatting."
msgstr ""
"ماژول :mod:`string` شامل یک کلاس :class:`~string.Template` است که راه دیگری "
"برای جایگزین کردن مقادیر در رشته ها با استفاده از جای نگهدارهایی مانند "
"``$x`` ارائه می دهد و آن ها را با مقادیر یک دیکشنری جایگزین می کند، اما "
"کنترل بسیار کمتری بر قالب بندی ارائه می دهد."

#: ../../tutorial/inputoutput.rst:114
msgid "Formatted String Literals"
msgstr "رشته های قالب بندی شده (Formatted String Literals)"

#: ../../tutorial/inputoutput.rst:116
msgid ""
":ref:`Formatted string literals <f-strings>` (also called f-strings for "
"short) let you include the value of Python expressions inside a string by "
"prefixing the string with ``f`` or ``F`` and writing expressions as "
"``{expression}``."
msgstr ""
"رشته های :ref:`Formatted string literals <f-strings>` (که به اختصار به عنوان "
"f-strings شناخته می شوند) به شما این امکان را می دهند که مقدار عبارات پایتون "
"را درون یک رشته قرار دهید. این کار را با اضافه کردن پیشوند ``f`` یا ``F`` به "
"رشته و نوشتن عبارات به صورت ``{expression}`` انجام می دهید."

#: ../../tutorial/inputoutput.rst:121
msgid ""
"An optional format specifier can follow the expression. This allows greater "
"control over how the value is formatted. The following example rounds pi to "
"three places after the decimal::"
msgstr ""
"یک مشخص کنندهٔ قالب اختیاری می تواند پس از عبارت بیاید. این کار کنترل بیشتری "
"بر روی نحوه ی قالب بندی مقدار فراهم می کند. مثال زیر عدد پی را به سه رقم "
"اعشار گرد می کند::"

#: ../../tutorial/inputoutput.rst:125
msgid ""
">>> import math\n"
">>> print(f'The value of pi is approximately {math.pi:.3f}.')\n"
"The value of pi is approximately 3.142."
msgstr ""
">>> import math\n"
">>> print(f'The value of pi is approximately {math.pi:.3f}.')\n"
"مقدار pi تقریباً 3.142 است."

#: ../../tutorial/inputoutput.rst:129
msgid ""
"Passing an integer after the ``':'`` will cause that field to be a minimum "
"number of characters wide.  This is useful for making columns line up. ::"
msgstr ""
"قراردادن یک عدد صحیح بعد از ``':'`` باعث می شود که آن فیلد حداقل تعداد مشخصی "
"کاراکتر داشته باشد. این قابلیت برای هم تراز کردن ستون ها مفید است. ::"

#: ../../tutorial/inputoutput.rst:132
msgid ""
">>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}\n"
">>> for name, phone in table.items():\n"
"...     print(f'{name:10} ==> {phone:10d}')\n"
"...\n"
"Sjoerd     ==>       4127\n"
"Jack       ==>       4098\n"
"Dcab       ==>       7678"
msgstr ""
">>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}\n"
">>> for name, phone in table.items():\n"
"...     print(f'{name:10} ==> {phone:10d}')\n"
"...\n"
"Sjoerd     ==>       4127\n"
"Jack       ==>       4098\n"
"Dcab       ==>       7678"

#: ../../tutorial/inputoutput.rst:140
msgid ""
"Other modifiers can be used to convert the value before it is formatted. ``'!"
"a'`` applies :func:`ascii`, ``'!s'`` applies :func:`str`, and ``'!r'`` "
"applies :func:`repr`::"
msgstr ""
"تغییر دهنده های دیگر می توانند برای تبدیل مقدار قبل از فرمت بندی استفاده "
"شوند. ``'!a'`` تابع :func:`ascii` را اعمال می کند، ``'!s'`` تابع :func:`str` "
"را اعمال می کند، و ``'!r'`` تابع :func:`repr` را اعمال می کند::"

#: ../../tutorial/inputoutput.rst:144
msgid ""
">>> animals = 'eels'\n"
">>> print(f'My hovercraft is full of {animals}.')\n"
"My hovercraft is full of eels.\n"
">>> print(f'My hovercraft is full of {animals!r}.')\n"
"My hovercraft is full of 'eels'."
msgstr ""
">>> animals = 'eels'\n"
">>> print(f'My hovercraft is full of {animals}.')\n"
"هاورکرافت من پر از eels است.\n"
">>> print(f'My hovercraft is full of {animals!r}.')\n"
"هاورکرافت من پر از 'eels' است."

#: ../../tutorial/inputoutput.rst:150
msgid ""
"The ``=`` specifier can be used to expand an expression to the text of the "
"expression, an equal sign, then the representation of the evaluated "
"expression:"
msgstr ""
"مشخص کننده ``=`` می تواند برای بسط یک عبارت به متن عبارت، علامت مساوی و سپس "
"نمایش عبارت ارزیابی شده استفاده شود:"

#: ../../tutorial/inputoutput.rst:159
msgid ""
"See :ref:`self-documenting expressions <bpo-36817-whatsnew>` for more "
"information on the ``=`` specifier. For a reference on these format "
"specifications, see the reference guide for the :ref:`formatspec`."
msgstr ""
"برای کسب اطلاعات بیشتر در مورد ``=`` به :ref:`self-documenting expressions "
"<bpo-36817-whatsnew>` مراجعه کنید. برای مرجعی در مورد این مشخصات فرمت، به "
"راهنمای مرجع :ref:`formatspec` مراجعه کنید."

#: ../../tutorial/inputoutput.rst:166
msgid "The String format() Method"
msgstr "متد String `format()`"

#: ../../tutorial/inputoutput.rst:168
msgid "Basic usage of the :meth:`str.format` method looks like this::"
msgstr "استفاده ی پایه از روش :meth:`str.format` به این صورت است::"

#: ../../tutorial/inputoutput.rst:170
msgid ""
">>> print('We are the {} who say \"{}!\"'.format('knights', 'Ni'))\n"
"We are the knights who say \"Ni!\""
msgstr ""
">>> print('ما {} هستيم كه مي گويند \"{}!\"'.format('knights', 'Ni'))\n"
"We are the knights who say \"Ni!\""

#: ../../tutorial/inputoutput.rst:173
msgid ""
"The brackets and characters within them (called format fields) are replaced "
"with the objects passed into the :meth:`str.format` method.  A number in the "
"brackets can be used to refer to the position of the object passed into the :"
"meth:`str.format` method. ::"
msgstr ""
"کروشه ها و کاراکترهای درون آن ها (که به آن ها فیلدهای قالب گذاری گفته می "
"شود) با اشیای پاس داده شده به متد :meth:`str.format` جایگزین می شوند. یک عدد "
"در کروشه ها می تواند برای اشاره به موقعیت شیء پاس داده شده به متد :meth:`str."
"format` استفاده شود. ::"

#: ../../tutorial/inputoutput.rst:178
msgid ""
">>> print('{0} and {1}'.format('spam', 'eggs'))\n"
"spam and eggs\n"
">>> print('{1} and {0}'.format('spam', 'eggs'))\n"
"eggs and spam"
msgstr ""
">>> print('{0} and {1}'.format('spam', 'eggs'))\n"
"spam and eggs\n"
">>> print('{1} and {0}'.format('spam', 'eggs'))\n"
"eggs and spam"

#: ../../tutorial/inputoutput.rst:183
msgid ""
"If keyword arguments are used in the :meth:`str.format` method, their values "
"are referred to by using the name of the argument. ::"
msgstr ""
"اگر از آرگومان های کلیدی در متد :meth:`str.format` استفاده شود، مقادیر آن ها "
"با استفاده از نام آرگومان ارجاع داده می شوند. ::"

#: ../../tutorial/inputoutput.rst:186
msgid ""
">>> print('This {food} is {adjective}.'.format(\n"
"...       food='spam', adjective='absolutely horrible'))\n"
"This spam is absolutely horrible."
msgstr ""
">>> print('این {food} کاملاً {adjective} است.'.format(\n"
"...       food='spam', adjective='وحشتناک'))\n"
"This spam is absolutely horrible."

#: ../../tutorial/inputoutput.rst:190
msgid "Positional and keyword arguments can be arbitrarily combined::"
msgstr "آرگومان های مکانی و کلیدی می توانند به صورت دلخواه ترکیب شوند::"

#: ../../tutorial/inputoutput.rst:192
msgid ""
">>> print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',\n"
"...                                                    other='Georg'))\n"
"The story of Bill, Manfred, and Georg."
msgstr ""
">>> print('داستان {0}, {1} و {other}.'.format('Bill', 'Manfred',\n"
"...                                                    other='Georg'))\n"
"داستان Bill, Manfred و Georg."

#: ../../tutorial/inputoutput.rst:196
msgid ""
"If you have a really long format string that you don't want to split up, it "
"would be nice if you could reference the variables to be formatted by name "
"instead of by position.  This can be done by simply passing the dict and "
"using square brackets ``'[]'`` to access the keys. ::"
msgstr ""
"اگر شما دارای یک رشته فرمت بسیار طولانی هستید که نمی خواهید آن را تقسیم "
"کنید، بهتر است که متغیرهایی که قرار است فرمت شوند را به جای موقعیت، با نام "
"فراخوانی کنید. این کار به سادگی با ارسال `dict` و استفاده از کروشه ها برای "
"دسترسی به کلیدها انجام می شود. ::"

#: ../../tutorial/inputoutput.rst:201
msgid ""
">>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}\n"
">>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '\n"
"...       'Dcab: {0[Dcab]:d}'.format(table))\n"
"Jack: 4098; Sjoerd: 4127; Dcab: 8637678"
msgstr ""
">>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}\n"
">>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '\n"
"...       'Dcab: {0[Dcab]:d}'.format(table))\n"
"Jack: 4098; Sjoerd: 4127; Dcab: 8637678"

#: ../../tutorial/inputoutput.rst:206
msgid ""
"This could also be done by passing the ``table`` dictionary as keyword "
"arguments with the ``**`` notation. ::"
msgstr ""
"این کار همچنین می تواند با ارسال دیکشنری ``table`` به عنوان آرگومان های کلمه "
"کلیدی با نوتیشن ``**`` انجام شود. ::"

#: ../../tutorial/inputoutput.rst:209
msgid ""
">>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}\n"
">>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'."
"format(**table))\n"
"Jack: 4098; Sjoerd: 4127; Dcab: 8637678"
msgstr ""
">>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}\n"
">>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'."
"format(**table))\n"
"Jack: 4098; Sjoerd: 4127; Dcab: 8637678"

#: ../../tutorial/inputoutput.rst:213
msgid ""
"This is particularly useful in combination with the built-in function :func:"
"`vars`, which returns a dictionary containing all local variables::"
msgstr ""
"این به ویژه در ترکیب با تابع داخلی :func:`vars` مفید است که یک دیکشنری حاوی "
"تمام متغیرهای محلی را برمی گرداند::"

#: ../../tutorial/inputoutput.rst:216
msgid ""
">>> table = {k: str(v) for k, v in vars().items()}\n"
">>> message = \" \".join([f'{k}: ' + '{' + k +'};' for k in table.keys()])\n"
">>> print(message.format(**table))\n"
"__name__: __main__; __doc__: None; __package__: None; __loader__: ..."
msgstr ""
">>> table = {k: str(v) for k, v in vars().items()}\n"
">>> message = \" \".join([f'{k}: ' + '{' + k +'};' for k in table.keys()])\n"
">>> print(message.format(**table))\n"
"__name__: __main__; __doc__: None; __package__: None; __loader__: ..."

#: ../../tutorial/inputoutput.rst:221
msgid ""
"As an example, the following lines produce a tidily aligned set of columns "
"giving integers and their squares and cubes::"
msgstr ""
"به عنوان یک مثال، خطوط زیر مجموعه ای به خوبی مرتب شده از ستون ها را تولید می "
"کنند که عددهای صحیح و توان دوم و سوم آن ها را نشان می دهد::"

#: ../../tutorial/inputoutput.rst:224
msgid ""
">>> for x in range(1, 11):\n"
"...     print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))\n"
"...\n"
" 1   1    1\n"
" 2   4    8\n"
" 3   9   27\n"
" 4  16   64\n"
" 5  25  125\n"
" 6  36  216\n"
" 7  49  343\n"
" 8  64  512\n"
" 9  81  729\n"
"10 100 1000"
msgstr ""
">>> برای x در محدوده (1, 11):\n"
"... print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))\n"
"...\n"
" 1 1 1\n"
" 2 4 8\n"
" 3 9 27\n"
" 4 16 64\n"
" 5 25 125\n"
" 6 36 216\n"
" 7 49 343\n"
" 8 64 512\n"
" 9 81 729\n"
"10 100 1000"

#: ../../tutorial/inputoutput.rst:238
msgid ""
"For a complete overview of string formatting with :meth:`str.format`, see :"
"ref:`formatstrings`."
msgstr ""
"برای دید کلی از قالب بندی رشته با :meth:`str.format`، به :ref:"
"`formatstrings` مراجعه کنید."

#: ../../tutorial/inputoutput.rst:243
msgid "Manual String Formatting"
msgstr "فرمت بندی رشته به صورت دستی"

#: ../../tutorial/inputoutput.rst:245
msgid "Here's the same table of squares and cubes, formatted manually::"
msgstr ""
"در اینجا همان جدول مربعات و مکعب ها قرار دارد که به صورت دستی قالب بندی شده "
"است::"

#: ../../tutorial/inputoutput.rst:247
msgid ""
">>> for x in range(1, 11):\n"
"...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')\n"
"...     # Note use of 'end' on previous line\n"
"...     print(repr(x*x*x).rjust(4))\n"
"...\n"
" 1   1    1\n"
" 2   4    8\n"
" 3   9   27\n"
" 4  16   64\n"
" 5  25  125\n"
" 6  36  216\n"
" 7  49  343\n"
" 8  64  512\n"
" 9  81  729\n"
"10 100 1000"
msgstr ""
">>> برای x در بازه ی range(1, 11):\n"
"...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')\n"
"...     # Note use of 'end' on previous line\n"
"...     print(repr(x*x*x).rjust(4))\n"
"...\n"
" 1   1    1\n"
" 2   4    8\n"
" 3   9   27\n"
" 4  16   64\n"
" 5  25  125\n"
" 6  36  216\n"
" 7  49  343\n"
" 8  64  512\n"
" 9  81  729\n"
"10 100 1000"

#: ../../tutorial/inputoutput.rst:263
msgid ""
"(Note that the one space between each column was added by the way :func:"
"`print` works: it always adds spaces between its arguments.)"
msgstr ""
"(توجه داشته باشید که یک فاصله بین هر ستون توسط :func:`print` اضافه شده است: "
"این همیشه بین آرگومان هایش فاصله ایجاد می کند.)"

#: ../../tutorial/inputoutput.rst:266
msgid ""
"The :meth:`str.rjust` method of string objects right-justifies a string in a "
"field of a given width by padding it with spaces on the left. There are "
"similar methods :meth:`str.ljust` and :meth:`str.center`. These methods do "
"not write anything, they just return a new string. If the input string is "
"too long, they don't truncate it, but return it unchanged; this will mess up "
"your column lay-out but that's usually better than the alternative, which "
"would be lying about a value. (If you really want truncation you can always "
"add a slice operation, as in ``x.ljust(n)[:n]``.)"
msgstr ""
"متد :meth:`str.rjust` در اشیاء رشته ای، یک رشته را در یک فیلد با عرض مشخص با "
"افزودن فاصله در سمت چپ، به راست جا به جا می کند. متدهای مشابه :meth:`str."
"ljust` و :meth:`str.center` نیز وجود دارند. این متدها چیزی نخواهند نوشت و "
"فقط یک رشته جدید برمی گردانند. اگر رشته ورودی بیش از حد طولانی باشد، آن را "
"کوتاه نمی کنند و به صورت تغییر نیافته برمی گردانند؛ این ممکن است چینش ستون "
"های شما را به هم بریزد، اما این اغلب بهتر از جایگزینی غلط است که می تواند "
"باعث اشتباه در یک مقدار شود. (اگر به راستی به کوتاه کردن نیاز دارید, می "
"توانید همیشه یک عملیات برش اضافه کنید, مانند ``x.ljust(n)[:n]``.)"

#: ../../tutorial/inputoutput.rst:275
msgid ""
"There is another method, :meth:`str.zfill`, which pads a numeric string on "
"the left with zeros.  It understands about plus and minus signs::"
msgstr ""
"روش دیگری وجود دارد به نام :meth:`str.zfill` که یک رشته عددی را از سمت چپ با "
"صفرها پر می کند. این روش علامت های مثبت و منفی را می فهمد::"

#: ../../tutorial/inputoutput.rst:278
msgid ""
">>> '12'.zfill(5)\n"
"'00012'\n"
">>> '-3.14'.zfill(7)\n"
"'-003.14'\n"
">>> '3.14159265359'.zfill(5)\n"
"'3.14159265359'"
msgstr ""
">>> '12'.zfill(5)\n"
"'00012'\n"
">>> '-3.14'.zfill(7)\n"
"'-003.14'\n"
">>> '3.14159265359'.zfill(5)\n"
"'3.14159265359'"

#: ../../tutorial/inputoutput.rst:287
msgid "Old string formatting"
msgstr "قالب بندی رشته ای قدیمی"

#: ../../tutorial/inputoutput.rst:289
msgid ""
"The % operator (modulo) can also be used for string formatting. Given "
"``format % values`` (where *format* is a string), ``%`` conversion "
"specifications in *format* are replaced with zero or more elements of "
"*values*. This operation is commonly known as string interpolation. For "
"example::"
msgstr ""
"عملگر % (باقی مانده) می تواند برای قالب بندی رشته ها نیز استفاده شود. با فرض "
"یک رشته ``format % values``، مشخصات تبدیل ``%`` در *format* با یک یا چند "
"عنصر از *values* جایگزین می شوند. این عمل به طور معمول به عنوان درج رشته "
"شناخته می شود. به عنوان مثال::"

#: ../../tutorial/inputoutput.rst:296
msgid ""
">>> import math\n"
">>> print('The value of pi is approximately %5.3f.' % math.pi)\n"
"The value of pi is approximately 3.142."
msgstr ""
">>> import math\n"
">>> print('The value of pi is approximately %5.3f.' % math.pi)\n"
"مقدار pi تقریباً برابر با 3.142 است."

#: ../../tutorial/inputoutput.rst:300
msgid ""
"More information can be found in the :ref:`old-string-formatting` section."
msgstr ""
"اطلاعات بیشتر را می توانید در بخش :ref:`old-string-formatting` پیدا کنید."

#: ../../tutorial/inputoutput.rst:306
msgid "Reading and Writing Files"
msgstr "خواندن و نوشتن فایل ها"

#: ../../tutorial/inputoutput.rst:312
msgid ""
":func:`open` returns a :term:`file object`, and is most commonly used with "
"two positional arguments and one keyword argument: ``open(filename, mode, "
"encoding=None)``"
msgstr ""
":func:`open` یک :term:`file object` برمی گرداند و معمولاً با دو آرگومان مکانی "
"و یک آرگومان کلیدی استفاده می شود: ``open(filename, mode, encoding=None)``"

#: ../../tutorial/inputoutput.rst:318
msgid ">>> f = open('workfile', 'w', encoding=\"utf-8\")"
msgstr ">>> f = open('workfile', 'w', encoding=\"utf-8\")"

#: ../../tutorial/inputoutput.rst:325
msgid ""
"The first argument is a string containing the filename.  The second argument "
"is another string containing a few characters describing the way in which "
"the file will be used.  *mode* can be ``'r'`` when the file will only be "
"read, ``'w'`` for only writing (an existing file with the same name will be "
"erased), and ``'a'`` opens the file for appending; any data written to the "
"file is automatically added to the end.  ``'r+'`` opens the file for both "
"reading and writing. The *mode* argument is optional; ``'r'`` will be "
"assumed if it's omitted."
msgstr ""
"اولین آرگومان یک رشته است که نام فایل را در بر دارد. آرگومان دوم رشته دیگری "
"است که شامل چند کاراکتر است که نحوه استفاده از فایل را توصیف می کند. *mode* "
"زمانی می تواند ``'r'`` باشد که فایل فقط خوانده شود، ``'w'`` برای نوشتن تنها "
"(فایل موجود با همان نام پاک خواهد شد) و ``'a'`` فایل را برای اضافه کردن باز "
"می کند؛ هر داده ای که به فایل نوشته شود به صورت خودکار به انتهای آن اضافه می "
"شود. ``'r+'`` فایل را برای خواندن و نوشتن همزمان باز می کند. آرگومان *mode* "
"اختیاری است؛ اگر حذف شود، ``'r'`` در نظر گرفته خواهد شد."

#: ../../tutorial/inputoutput.rst:334
msgid ""
"Normally, files are opened in :dfn:`text mode`, that means, you read and "
"write strings from and to the file, which are encoded in a specific "
"*encoding*. If *encoding* is not specified, the default is platform "
"dependent (see :func:`open`). Because UTF-8 is the modern de-facto standard, "
"``encoding=\"utf-8\"`` is recommended unless you know that you need to use a "
"different encoding. Appending a ``'b'`` to the mode opens the file in :dfn:"
"`binary mode`. Binary mode data is read and written as :class:`bytes` "
"objects. You can not specify *encoding* when opening file in binary mode."
msgstr ""
"به طور معمول، فایل ها در :dfn:`حالت متنی` باز می شوند، به این معنا که شما "
"رشته ها را از فایل می خوانید و به فایل می نویسید، که با یک *encoding* خاص "
"کدگذاری می شوند. اگر *encoding* مشخص نشده باشد، مقدار پیش فرض وابسته به "
"پلتفرم است (به :func:`open` مراجعه کنید). از آنجایی که UTF-8 استاندارد مدرن "
"و رایج است، ``encoding=\"utf-8\"`` توصیه می شود مگر اینکه بدانید که به یک "
"کدگذاری متفاوت نیاز دارید. افزودن یک ``'b'`` به حالت، فایل را در :dfn:`حالت "
"باینری` باز می کند. داده های حالت باینری به صورت اشیاء :class:`bytes` خوانده "
"و نوشته می شوند. نمی توانید *encoding* را هنگام باز کردن فایل در حالت باینری "
"مشخص کنید."

#: ../../tutorial/inputoutput.rst:344
msgid ""
"In text mode, the default when reading is to convert platform-specific line "
"endings (``\\n`` on Unix, ``\\r\\n`` on Windows) to just ``\\n``.  When "
"writing in text mode, the default is to convert occurrences of ``\\n`` back "
"to platform-specific line endings.  This behind-the-scenes modification to "
"file data is fine for text files, but will corrupt binary data like that in :"
"file:`JPEG` or :file:`EXE` files.  Be very careful to use binary mode when "
"reading and writing such files."
msgstr ""
"در حالت متنی، به صورت پیش فرض هنگام خواندن، انتهای خطوط مختص به پلتفرم "
"(``\\n`` در یونیکس, ``\\r\\n`` در ویندوز) به سادگی به ``\\n`` تبدیل می شود. "
"هنگام نوشتن در حالت متنی، پیش فرض این است که وقوعات ``\\n`` به انتهای خطوط "
"مختص به پلتفرم تبدیل شوند. این تغییرات پشت صحنه در داده های فایل برای فایل "
"های متنی مناسب است، اما داده های باینری مانند آنچه در فایل های :file:`JPEG` "
"یا :file:`EXE` است را خراب می کند. دقت کنید که هنگام خواندن و نوشتن چنین "
"فایل هایی از حالت باینری استفاده کنید."

#: ../../tutorial/inputoutput.rst:352
msgid ""
"It is good practice to use the :keyword:`with` keyword when dealing with "
"file objects.  The advantage is that the file is properly closed after its "
"suite finishes, even if an exception is raised at some point.  Using :"
"keyword:`!with` is also much shorter than writing equivalent :keyword:"
"`try`\\ -\\ :keyword:`finally` blocks::"
msgstr ""
"استفاده از کلیدواژه :keyword:`with` زمانی که با اشیاء فایل کار می کنید، یک "
"روش خوب است. مزیت این کار این است که فایل بعد از تمام شدن دنباله عملیات به "
"درستی بسته می شود، حتی اگر در جایی یک استثنا رخ دهد. استفاده از :keyword:`!"
"with` نیز بسیار کوتاه تر از نوشتن :keyword:`try` - :keyword:`finally` بلوک "
"های معادل است::"

#: ../../tutorial/inputoutput.rst:358
msgid ""
">>> with open('workfile', encoding=\"utf-8\") as f:\n"
"...     read_data = f.read()\n"
"\n"
">>> # We can check that the file has been automatically closed.\n"
">>> f.closed\n"
"True"
msgstr ""
">>> with open('workfile', encoding=\"utf-8\") as f:\n"
"...     read_data = f.read()\n"
"\n"
">>> # We can check that the file has been automatically closed.\n"
">>> f.closed\n"
"True"

#: ../../tutorial/inputoutput.rst:365
msgid ""
"If you're not using the :keyword:`with` keyword, then you should call ``f."
"close()`` to close the file and immediately free up any system resources "
"used by it."
msgstr ""
"اگر شما از کلیدواژه :keyword:`with` استفاده نمی کنید، در این صورت باید ``f."
"close()`` را برای بستن فایل و آزادسازی فوری هرگونه منابع سیستم مورد استفاده "
"آن فراخوانی کنید."

#: ../../tutorial/inputoutput.rst:370
msgid ""
"Calling ``f.write()`` without using the :keyword:`!with` keyword or calling "
"``f.close()`` **might** result in the arguments of ``f.write()`` not being "
"completely written to the disk, even if the program exits successfully."
msgstr ""
"فراخوانی ``f.write()`` بدون استفاده از کلیدواژه :keyword:`!with` یا فراخوانی "
"``f.close()`` **might** منجر به این می شود که آرگومان های ``f.write()`` به "
"طور کامل روی دیسک نوشته نشوند، حتی اگر برنامه با موفقیت خارج شود."

#: ../../tutorial/inputoutput.rst:378
msgid ""
"After a file object is closed, either by a :keyword:`with` statement or by "
"calling ``f.close()``, attempts to use the file object will automatically "
"fail. ::"
msgstr ""
"پس از بسته شدن یک شیء فایل، چه با یک دستور :keyword:`with` و چه با فراخوانی "
"``f.close()``، تلاش برای استفاده از شیء فایل به طور خودکار شکست می خورد. ::"

#: ../../tutorial/inputoutput.rst:382
msgid ""
">>> f.close()\n"
">>> f.read()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: I/O operation on closed file."
msgstr ""
">>> f.close()\n"
">>> f.read()\n"
"ردیابی (آخرین تماس اخیر):\n"
"  فایل \"<stdin>\", خط 1، در <module>\n"
"ValueError: عملیات I/O روی فایل بسته."

#: ../../tutorial/inputoutput.rst:392
msgid "Methods of File Objects"
msgstr "روش های اشیاء فایل"

#: ../../tutorial/inputoutput.rst:394
msgid ""
"The rest of the examples in this section will assume that a file object "
"called ``f`` has already been created."
msgstr ""
"بقیه مثال های این بخش فرض می کنند که یک شی فایل با نام ``f`` از قبل ایجاد "
"شده است."

#: ../../tutorial/inputoutput.rst:397
msgid ""
"To read a file's contents, call ``f.read(size)``, which reads some quantity "
"of data and returns it as a string (in text mode) or bytes object (in binary "
"mode). *size* is an optional numeric argument.  When *size* is omitted or "
"negative, the entire contents of the file will be read and returned; it's "
"your problem if the file is twice as large as your machine's memory. "
"Otherwise, at most *size* characters (in text mode) or *size* bytes (in "
"binary mode) are read and returned. If the end of the file has been reached, "
"``f.read()`` will return an empty string (``''``).  ::"
msgstr ""
"برای خواندن محتوای یک فایل، ``f.read(size)`` را فراخوانی کنید، که میزانی از "
"داده را خوانده و آن را به صورت یک رشته (در حالت متنی) یا شئ بایت (در حالت "
"باینری) برمی گرداند. *size* یک آرگومان عددی اختیاری است. هنگامی که *size* "
"حذف شود یا منفی باشد، تمام محتوای فایل خوانده و برگردانده می شود؛ اگر فایل "
"دو برابر حافظه ماشین شما بزرگتر باشد، این مشکل شماست. در غیر این صورت، "
"حداکثر *size* کاراکتر (در حالت متنی) یا *size* بایت (در حالت باینری) خوانده "
"و برگردانده می شوند. اگر انتهای فایل رسیده باشد، ``f.read()`` یک رشته خالی "
"(``''``) برمی گرداند.  ::"

#: ../../tutorial/inputoutput.rst:406
msgid ""
">>> f.read()\n"
"'This is the entire file.\\n'\n"
">>> f.read()\n"
"''"
msgstr ""
">>> f.read()\n"
"'This is the entire file.\\n'\n"
">>> f.read()\n"
"''"

#: ../../tutorial/inputoutput.rst:411
msgid ""
"``f.readline()`` reads a single line from the file; a newline character "
"(``\\n``) is left at the end of the string, and is only omitted on the last "
"line of the file if the file doesn't end in a newline.  This makes the "
"return value unambiguous; if ``f.readline()`` returns an empty string, the "
"end of the file has been reached, while a blank line is represented by "
"``'\\n'``, a string containing only a single newline.  ::"
msgstr ""
"``f.readline()`` یک خط از فایل می خواند؛ یک کاراکتر خط جدید (``\\n``) در "
"انتهای رشته باقی می ماند و فقط در آخرین خط فایل نادیده گرفته می شود اگر فایل "
"با یک خط جدید خاتمه نیافته باشد. این رفتار باعث می شود که مقدار بازگشتی مبهم "
"نباشد؛ اگر ``f.readline()`` یک رشته خالی برگرداند، به انتهای فایل رسیده ایم، "
"در حالی که یک خط خالی با ``'\\n'`` نمایش داده می شود، رشته ای که فقط یک خط "
"جدید دارد. ::"

#: ../../tutorial/inputoutput.rst:418
msgid ""
">>> f.readline()\n"
"'This is the first line of the file.\\n'\n"
">>> f.readline()\n"
"'Second line of the file\\n'\n"
">>> f.readline()\n"
"''"
msgstr ""
">>> f.readline()\n"
"'This is the first line of the file.\\n'\n"
">>> f.readline()\n"
"'Second line of the file\\n'\n"
">>> f.readline()\n"
"''"

#: ../../tutorial/inputoutput.rst:425
msgid ""
"For reading lines from a file, you can loop over the file object. This is "
"memory efficient, fast, and leads to simple code::"
msgstr ""
"برای خواندن خطوط از یک فایل، می توانید روی شیء فایل حلقه بزنید. این روش از "
"نظر حافظه بهینه، سریع و منجر به کد ساده می شود::"

#: ../../tutorial/inputoutput.rst:428
msgid ""
">>> for line in f:\n"
"...     print(line, end='')\n"
"...\n"
"This is the first line of the file.\n"
"Second line of the file"
msgstr ""
">>> for line in f:\n"
"...     print(line, end='')\n"
"...\n"
"این اولین خط فایل است.\n"
"خط دوم فایل"

#: ../../tutorial/inputoutput.rst:434
msgid ""
"If you want to read all the lines of a file in a list you can also use "
"``list(f)`` or ``f.readlines()``."
msgstr ""
"اگر می خواهید تمام خطوط یک فایل را به صورت یک لیست بخوانید، می توانید از "
"``list(f)`` یا ``f.readlines()`` استفاده کنید."

#: ../../tutorial/inputoutput.rst:437
msgid ""
"``f.write(string)`` writes the contents of *string* to the file, returning "
"the number of characters written. ::"
msgstr ""
"``f.write(string)`` محتوای *string* را به فایل می نویسد و تعداد کاراکترهای "
"نوشته شده را برمی گرداند. ::"

#: ../../tutorial/inputoutput.rst:440
msgid ""
">>> f.write('This is a test\\n')\n"
"15"
msgstr ""
">>> f.write('This is a test\\n')\n"
"15"

#: ../../tutorial/inputoutput.rst:443
msgid ""
"Other types of objects need to be converted -- either to a string (in text "
"mode) or a bytes object (in binary mode) -- before writing them::"
msgstr ""
"انواع دیگر اشیاء باید قبل از نوشتن -- به یک رشته متنی (در حالت متنی) یا یک "
"شیء بایت (در حالت باینری) -- تبدیل شوند::"

#: ../../tutorial/inputoutput.rst:446
msgid ""
">>> value = ('the answer', 42)\n"
">>> s = str(value)  # convert the tuple to string\n"
">>> f.write(s)\n"
"18"
msgstr ""
">>> value = ('the answer', 42)\n"
">>> s = str(value)  # convert the tuple to string\n"
">>> f.write(s)\n"
"18"

#: ../../tutorial/inputoutput.rst:451
msgid ""
"``f.tell()`` returns an integer giving the file object's current position in "
"the file represented as number of bytes from the beginning of the file when "
"in binary mode and an opaque number when in text mode."
msgstr ""
"``f.tell()`` یک عدد صحیح را برمی گرداند که موقعیت فعلی شیء فایل را در فایل "
"نشان می دهد که به صورت تعداد بایت ها از ابتدای فایل در حالت دودویی و یک عدد "
"نامشخص در حالت متنی ارائه می شود."

#: ../../tutorial/inputoutput.rst:455
msgid ""
"To change the file object's position, use ``f.seek(offset, whence)``.  The "
"position is computed from adding *offset* to a reference point; the "
"reference point is selected by the *whence* argument.  A *whence* value of 0 "
"measures from the beginning of the file, 1 uses the current file position, "
"and 2 uses the end of the file as the reference point.  *whence* can be "
"omitted and defaults to 0, using the beginning of the file as the reference "
"point. ::"
msgstr ""
"برای تغییر موقعیت شیء فایل از ``f.seek(offset, whence)`` استفاده کنید. "
"موقعیت از طریق اضافه کردن *offset* به یک نقطه مرجع محاسبه می شود؛ نقطه مرجع "
"با آرگومان *whence* انتخاب می شود. مقدار *whence* برابر 0 از ابتدای فایل، 1 "
"استفاده از موقعیت کنونی فایل، و 2 استفاده از انتهای فایل به عنوان نقطه مرجع "
"اندازه گیری می کند. *whence* می تواند حذف شود و به طور پیش فرض 0 است که از "
"ابتدای فایل به عنوان نقطه مرجع استفاده می کند. ::"

#: ../../tutorial/inputoutput.rst:462
msgid ""
">>> f = open('workfile', 'rb+')\n"
">>> f.write(b'0123456789abcdef')\n"
"16\n"
">>> f.seek(5)      # Go to the 6th byte in the file\n"
"5\n"
">>> f.read(1)\n"
"b'5'\n"
">>> f.seek(-3, 2)  # Go to the 3rd byte before the end\n"
"13\n"
">>> f.read(1)\n"
"b'd'"
msgstr ""
">>> f = open('workfile', 'rb+')\n"
">>> f.write(b'0123456789abcdef')\n"
"16\n"
">>> f.seek(5)      # Go to the 6th byte in the file\n"
"5\n"
">>> f.read(1)\n"
"b'5'\n"
">>> f.seek(-3, 2)  # Go to the 3rd byte before the end\n"
"13\n"
">>> f.read(1)\n"
"b'd'"

#: ../../tutorial/inputoutput.rst:474
msgid ""
"In text files (those opened without a ``b`` in the mode string), only seeks "
"relative to the beginning of the file are allowed (the exception being "
"seeking to the very file end with ``seek(0, 2)``) and the only valid "
"*offset* values are those returned from the ``f.tell()``, or zero. Any other "
"*offset* value produces undefined behaviour."
msgstr ""
"در فایل های متنی (آنهایی که بدون ``b`` در رشته حالت باز می شوند), فقط جابه "
"جایی های نسبی نسبت به ابتدای فایل مجاز هستند (استثنا جابه جایی به انتهای "
"فایل با ``seek(0, 2)`` است) و تنها مقادیر معتبر *offset* آنهایی هستند که از "
"``f.tell()`` برگشت داده می شوند، یا صفر. هر مقدار *offset* دیگر رفتار "
"نامشخصی تولید می کند."

#: ../../tutorial/inputoutput.rst:480
msgid ""
"File objects have some additional methods, such as :meth:`~io.IOBase.isatty` "
"and :meth:`~io.IOBase.truncate` which are less frequently used; consult the "
"Library Reference for a complete guide to file objects."
msgstr ""
"کائنات فایل برخی متدهای اضافی دارند، مانند :meth:`~io.IOBase.isatty` و :meth:"
"`~io.IOBase.truncate` که کمتر مورد استفاده قرار می گیرند؛ برای گرفتن راهنمای "
"کامل در مورد کائنات فایل به مرجع کتابخانه مراجعه کنید."

#: ../../tutorial/inputoutput.rst:488
msgid "Saving structured data with :mod:`json`"
msgstr "ذخیره داده های ساختاریافته با :mod:`json`"

#: ../../tutorial/inputoutput.rst:492
msgid ""
"Strings can easily be written to and read from a file.  Numbers take a bit "
"more effort, since the :meth:`~io.TextIOBase.read` method only returns "
"strings, which will have to be passed to a function like :func:`int`, which "
"takes a string like ``'123'`` and returns its numeric value 123.  When you "
"want to save more complex data types like nested lists and dictionaries, "
"parsing and serializing by hand becomes complicated."
msgstr ""
"رشته ها به راحتی می توانند به فایل نوشته و از آن خوانده شوند. اعداد نیاز به "
"تلاش بیشتری دارند، زیرا روش :meth:`~io.TextIOBase.read` تنها رشته ها را برمی "
"گرداند، که باید به یک تابع مانند :func:`int` که یک رشته مانند ``'123'`` را "
"می گیرد و مقدار عددی 123 را برمی گرداند، منتقل شوند. زمانی که می خواهید "
"انواع داده ای پیچیده تر مانند فهرست های تو در تو و دیکشنری ها را ذخیره کنید، "
"تجزیه و تحلیل و سریال سازی به صورت دستی پیچیده می شود."

#: ../../tutorial/inputoutput.rst:499
msgid ""
"Rather than having users constantly writing and debugging code to save "
"complicated data types to files, Python allows you to use the popular data "
"interchange format called `JSON (JavaScript Object Notation) <https://json."
"org>`_.  The standard module called :mod:`json` can take Python data "
"hierarchies, and convert them to string representations; this process is "
"called :dfn:`serializing`.  Reconstructing the data from the string "
"representation is called :dfn:`deserializing`.  Between serializing and "
"deserializing, the string representing the object may have been stored in a "
"file or data, or sent over a network connection to some distant machine."
msgstr ""
"به جای آنکه کاربران به طور مداوم کد نویسی و رفع اشکال کنند تا انواع داده های "
"پیچیده را در فایل ها ذخیره کنند، پایتون به شما اجازه می دهد تا از قالب تبادل "
"داده های محبوبی به نام `JSON (JavaScript Object Notation) <https://json."
"org>`_ استفاده کنید. ماژول استانداردی به نام :mod:`json` می تواند سلسله "
"مراتب داده های پایتون را گرفته و آنها را به نمایش های رشته ای تبدیل کند؛ این "
"فرآیند :dfn:`سریال سازی` نامیده می شود. بازسازی داده ها از نمایش رشته ای :"
"dfn:`دی سریال سازی` نامیده می شود. در بین سریال سازی و دی سریال سازی، ممکن "
"است رشته نمایانگر شیء در یک فایل یا داده ذخیره شده باشد، یا از طریق اتصال "
"شبکه به دستگاهی دور ارسال شده باشد."

#: ../../tutorial/inputoutput.rst:510
msgid ""
"The JSON format is commonly used by modern applications to allow for data "
"exchange.  Many programmers are already familiar with it, which makes it a "
"good choice for interoperability."
msgstr ""
"فرمت JSON به طور گسترده توسط برنامه های مدرن برای تبادل داده استفاده می شود. "
"بسیاری از برنامه نویسان با آن آشنا هستند، که آن را به یک انتخاب مناسب برای "
"همکاری بین سیستم ها تبدیل می کند."

#: ../../tutorial/inputoutput.rst:514
msgid ""
"If you have an object ``x``, you can view its JSON string representation "
"with a simple line of code::"
msgstr ""
"اگر شیء ``x`` را داشته باشید، می توانید نمایش رشته ای JSON آن را با یک خط کد "
"ساده مشاهده کنید::"

#: ../../tutorial/inputoutput.rst:517
msgid ""
">>> import json\n"
">>> x = [1, 'simple', 'list']\n"
">>> json.dumps(x)\n"
"'[1, \"simple\", \"list\"]'"
msgstr ""
">>> import json\n"
">>> x = [1, 'simple', 'list']\n"
">>> json.dumps(x)\n"
"'[1, \"simple\", \"list\"]'"

#: ../../tutorial/inputoutput.rst:522
msgid ""
"Another variant of the :func:`~json.dumps` function, called :func:`~json."
"dump`, simply serializes the object to a :term:`text file`.  So if ``f`` is "
"a :term:`text file` object opened for writing, we can do this::"
msgstr ""
"یکی دیگر از انواع تابع :func:`~json.dumps`، به نام :func:`~json.dump`، به "
"سادگی شیء را به یک :term:`text file` سریالیزه می کند. بنابراین اگر ``f`` یک "
"شیء :term:`text file` باشد که برای نوشتن باز شده است، می توانیم این کار را "
"انجام دهیم::"

#: ../../tutorial/inputoutput.rst:526
msgid "json.dump(x, f)"
msgstr "json.dump(x, f)"

#: ../../tutorial/inputoutput.rst:528
msgid ""
"To decode the object again, if ``f`` is a :term:`binary file` or :term:`text "
"file` object which has been opened for reading::"
msgstr ""
"برای رمزگشایی مجدد شیء، اگر ``f`` یک شیء از نوع :term:`binary file` یا :term:"
"`text file` است که برای خواندن باز شده است::"

#: ../../tutorial/inputoutput.rst:531
msgid "x = json.load(f)"
msgstr "x = json.load(f)"

#: ../../tutorial/inputoutput.rst:534
msgid ""
"JSON files must be encoded in UTF-8. Use ``encoding=\"utf-8\"`` when opening "
"JSON file as a :term:`text file` for both of reading and writing."
msgstr ""
"فایل های JSON باید به صورت UTF-8 کدگذاری شوند. از ``encoding=\"utf-8\"`` "
"هنگام باز کردن فایل JSON به عنوان :term:`text file` برای هر دو عملیات خواندن "
"و نوشتن استفاده کنید."

#: ../../tutorial/inputoutput.rst:537
msgid ""
"This simple serialization technique can handle lists and dictionaries, but "
"serializing arbitrary class instances in JSON requires a bit of extra "
"effort. The reference for the :mod:`json` module contains an explanation of "
"this."
msgstr ""
"این تکنیک سریال سازی ساده می تواند لیست ها و دیکشنری ها را مدیریت کند، اما "
"سریال سازی نمونه های دلخواه کلاس در JSON نیاز به کمی تلاش اضافی دارد. مرجع "
"ماژول :mod:`json` شامل توضیحی در مورد این موضوع است."

#: ../../tutorial/inputoutput.rst:543
msgid ":mod:`pickle` - the pickle module"
msgstr ":mod:`pickle` - ماژول pickle"

#: ../../tutorial/inputoutput.rst:545
msgid ""
"Contrary to :ref:`JSON <tut-json>`, *pickle* is a protocol which allows the "
"serialization of arbitrarily complex Python objects.  As such, it is "
"specific to Python and cannot be used to communicate with applications "
"written in other languages.  It is also insecure by default: deserializing "
"pickle data coming from an untrusted source can execute arbitrary code, if "
"the data was crafted by a skilled attacker."
msgstr ""
"برخلاف :ref:`JSON <tut-json>`، *pickle* یک پروتکل است که امکان سریال سازی "
"اشیای پیچیده ی پایتون را فراهم می کند. بنابراین، این پروتکل مخصوص پایتون است "
"و نمی توان از آن برای ارتباط با برنامه هایی که به زبان های دیگر نوشته شده "
"اند استفاده کرد. همچنین به صورت پیش فرض ناامن است: غیر سریال سازی داده های "
"``pickle`` که از یک منبع غیرقابل اعتماد می آیند می تواند کد دلخواه را اجرا "
"کند، اگر داده ها توسط یک مهاجم ماهر ساخته شده باشند."

#: ../../tutorial/inputoutput.rst:103
msgid "formatted string literal"
msgstr "رشته قالب بندی شده"

#: ../../tutorial/inputoutput.rst:103
msgid "interpolated string literal"
msgstr "رشته متنی درونیابی شده"

#: ../../tutorial/inputoutput.rst:103
msgid "string"
msgstr "رشته"

#: ../../tutorial/inputoutput.rst:103
msgid "formatted literal"
msgstr "رشته قالب بندی شده"

#: ../../tutorial/inputoutput.rst:103
msgid "interpolated literal"
msgstr "رشته های متفاوت pítonیزه (interpolated literal)"

#: ../../tutorial/inputoutput.rst:103
msgid "f-string"
msgstr ""
"رشته های f یا `f-string` در نسخه ی 3.6 پایتون معرفی شدند و روشی ساده و خوانا "
"برای قالب بندی رشته ها ارائه می دهند. وقتی به استفاده ی مکرر از اتصال رشته "
"ها نیاز دارید یا وقتی داده ها را در یک قالب خاص نمایش می دهید، رشته های f "
"اغلب بهترین انتخاب هستند. برای استفاده از رشته های f، تنها کافیست حرف `f` یا "
"`F` را قبل از رشته اضافه کنید و از جفت آکولاد «{}» برای قرار دادن کدهای "
"پایتون درون آن استفاده کنید. این کار منجر به تولید یک `str` جدید می شود که "
"حاوی نمایش محاسبه شده ی عبارت هاست."

#: ../../tutorial/inputoutput.rst:103
msgid "fstring"
msgstr ""
"رشته های قالب بندی شده (fstring) در پایتون به شما این امکان را می دهند که "
"تعابیر را به آسانی درون رشته ها قرار دهید. این امر با پیشوند قرار دادن حرف "
"`f` یا `F` قبل از رشته و استفاده از آکولاد های `{}` برای قرار دادن تعابیر "
"امکان پذیر است. تعابیر داخل آکولاد ها ارزیابی شده، تبدیل به رشته می شوند، و "
"در جای خود قرار می گیرند. \n"
"\n"
"مثال::\n"
"\n"
"    name = \"Ali\"\n"
"    age = 25\n"
"    greeting = f\"Hello, my name is {name} and I am {age} years old.\"\n"
"    print(greeting)\n"
"\n"
"در این کد، مقدار `name` و `age` به صورت مستقیم در رشته ای که به متغیر "
"`greeting` اختصاص داده شده است، تزریق می شوند."

#: ../../tutorial/inputoutput.rst:308
msgid "built-in function"
msgstr "تابع داخلی"

#: ../../tutorial/inputoutput.rst:308
msgid "open"
msgstr "باز کردن"

#: ../../tutorial/inputoutput.rst:308
msgid "object"
msgstr "شیء"

#: ../../tutorial/inputoutput.rst:308
msgid "file"
msgstr "فایل"

#: ../../tutorial/inputoutput.rst:490
msgid "module"
msgstr "ماژول"

#: ../../tutorial/inputoutput.rst:490
msgid "json"
msgstr "json"
