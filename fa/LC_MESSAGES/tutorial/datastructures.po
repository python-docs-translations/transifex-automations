# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-11-11 14:15+0000\n"
"PO-Revision-Date: 2025-09-16 00:02+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Persian (https://app.transifex.com/python-doc/teams/5390/"
"fa/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fa\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../tutorial/datastructures.rst:5
msgid "Data Structures"
msgstr "ساختارهای داده"

#: ../../tutorial/datastructures.rst:7
msgid ""
"This chapter describes some things you've learned about already in more "
"detail, and adds some new things as well."
msgstr ""
"این فصل برخی از مواردی را که قبلاً یاد گرفته اید با جزئیات بیشتری توصیف می "
"کند و همچنین برخی از موارد جدید را نیز اضافه می کند."

#: ../../tutorial/datastructures.rst:13
msgid "More on Lists"
msgstr "بیشتر در مورد لیست ها"

#: ../../tutorial/datastructures.rst:15
msgid ""
"The :ref:`list <typesseq-list>` data type has some more methods. Here are "
"all of the methods of list objects:"
msgstr ""

#: ../../tutorial/datastructures.rst:21
msgid "Add an item to the end of the list.  Similar to ``a[len(a):] = [x]``."
msgstr "یک آیتم به انتهای لیست اضافه کنید. مشابه با ``a[len(a):] = [x]``."

#: ../../tutorial/datastructures.rst:27
msgid ""
"Extend the list by appending all the items from the iterable.  Similar to "
"``a[len(a):] = iterable``."
msgstr ""
"لیست را با افزودن تمام آیتم ها از شیء قابل تکرار گسترش دهید. مشابه "
"``a[len(a):] = iterable``."

#: ../../tutorial/datastructures.rst:34
msgid ""
"Insert an item at a given position.  The first argument is the index of the "
"element before which to insert, so ``a.insert(0, x)`` inserts at the front "
"of the list, and ``a.insert(len(a), x)`` is equivalent to ``a.append(x)``."
msgstr ""
"یک آیتم را در یک موقعیت مشخص درج کنید. اولین آرگومان، شاخص المانی است که قبل "
"از آن درج انجام می شود. بنابراین ``a.insert(0, x)`` در ابتدای لیست درج می "
"شود و ``a.insert(len(a), x)`` معادل ``a.append(x)`` است."

#: ../../tutorial/datastructures.rst:42
msgid ""
"Remove the first item from the list whose value is equal to *x*.  It raises "
"a :exc:`ValueError` if there is no such item."
msgstr ""
"اولین مورد را از لیست که مقدار آن برابر با *x* است حذف کنید. اگر چنین موردی "
"وجود نداشته باشد، یک :exc:`ValueError` ایجاد می کند."

#: ../../tutorial/datastructures.rst:49
msgid ""
"Remove the item at the given position in the list, and return it.  If no "
"index is specified, ``a.pop()`` removes and returns the last item in the "
"list. It raises an :exc:`IndexError` if the list is empty or the index is "
"outside the list range."
msgstr ""
"مورد را در موقعیت داده شده در لیست حذف کرده و آن را برمی گرداند. اگر هیچ "
"شاخصی مشخص نشده باشد، ``a.pop()`` آخرین مورد موجود در لیست را حذف کرده و "
"برمی گرداند. اگر لیست خالی باشد یا شاخص خارج از محدوده لیست باشد، :exc:"
"`IndexError` ایجاد می کند."

#: ../../tutorial/datastructures.rst:58
msgid "Remove all items from the list.  Similar to ``del a[:]``."
msgstr "همه اقلام را از لیست حذف کنید. مشابه ``del a[:]``."

#: ../../tutorial/datastructures.rst:64
msgid ""
"Return zero-based index of the first occurrence of *x* in the list. Raises "
"a :exc:`ValueError` if there is no such item."
msgstr ""

#: ../../tutorial/datastructures.rst:67
msgid ""
"The optional arguments *start* and *end* are interpreted as in the slice "
"notation and are used to limit the search to a particular subsequence of the "
"list.  The returned index is computed relative to the beginning of the full "
"sequence rather than the *start* argument."
msgstr ""
"آرگومان های اختیاری *start* و *end* همانند نمادگذاری برش تعبیر می شوند و "
"برای محدود کردن جستجو به زیرتوالی خاصی از لیست استفاده می شوند. شاخص بازگشتی "
"نسبت به ابتدای کل توالی محاسبه می شود و نه نسبت به آرگومان *start*."

#: ../../tutorial/datastructures.rst:76
msgid "Return the number of times *x* appears in the list."
msgstr "تعداد دفعاتی که *x* در لیست ظاهر می شود را برگردان."

#: ../../tutorial/datastructures.rst:82
msgid ""
"Sort the items of the list in place (the arguments can be used for sort "
"customization, see :func:`sorted` for their explanation)."
msgstr ""
"اقلام لیست را در جای خود مرتب کنید (می توان از آرگومان ها برای سفارشی سازی "
"مرتب سازی استفاده کرد, برای توضیح آنها به :func:`sorted` مراجعه کنید)."

#: ../../tutorial/datastructures.rst:89
msgid "Reverse the elements of the list in place."
msgstr "عناصر لیست را به صورت در جا معکوس کنید."

#: ../../tutorial/datastructures.rst:95
msgid "Return a shallow copy of the list.  Similar to ``a[:]``."
msgstr "برگشتی یک کپی سطحی از لیست. مشابه ``a[:]``."

#: ../../tutorial/datastructures.rst:98
msgid "An example that uses most of the list methods::"
msgstr "یک مثال که از اکثر متدهای لیست استفاده می کند::"

#: ../../tutorial/datastructures.rst:100
msgid ""
">>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', "
"'banana']\n"
">>> fruits.count('apple')\n"
"2\n"
">>> fruits.count('tangerine')\n"
"0\n"
">>> fruits.index('banana')\n"
"3\n"
">>> fruits.index('banana', 4)  # Find next banana starting at position 4\n"
"6\n"
">>> fruits.reverse()\n"
">>> fruits\n"
"['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']\n"
">>> fruits.append('grape')\n"
">>> fruits\n"
"['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']\n"
">>> fruits.sort()\n"
">>> fruits\n"
"['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']\n"
">>> fruits.pop()\n"
"'pear'"
msgstr ""
">>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', "
"'banana']\n"
">>> fruits.count('apple')\n"
"2\n"
">>> fruits.count('tangerine')\n"
"0\n"
">>> fruits.index('banana')\n"
"3\n"
">>> fruits.index('banana', 4)  # Find next banana starting at position 4\n"
"6\n"
">>> fruits.reverse()\n"
">>> fruits\n"
"['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']\n"
">>> fruits.append('grape')\n"
">>> fruits\n"
"['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']\n"
">>> fruits.sort()\n"
">>> fruits\n"
"['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']\n"
">>> fruits.pop()\n"
"'pear'"

#: ../../tutorial/datastructures.rst:121
msgid ""
"You might have noticed that methods like ``insert``, ``remove`` or ``sort`` "
"that only modify the list have no return value printed -- they return the "
"default ``None``. [#]_  This is a design principle for all mutable data "
"structures in Python."
msgstr ""
"ممکن است متوجه شده باشید که متدهایی مانند ``insert``، ``remove`` یا ``sort`` "
"که فقط لیست را تغییر می دهند، هیچ مقدار بازگشتی چاپ شده ای ندارند -- آن ها "
"مقدار پیش فرض ``None`` را بازمی گردانند. [#]_ این یک اصل طراحی برای تمامی "
"ساختارهای داده قابل تغییر در پایتون است."

#: ../../tutorial/datastructures.rst:126
msgid ""
"Another thing you might notice is that not all data can be sorted or "
"compared.  For instance, ``[None, 'hello', 10]`` doesn't sort because "
"integers can't be compared to strings and ``None`` can't be compared to "
"other types.  Also, there are some types that don't have a defined ordering "
"relation.  For example, ``3+4j < 5+7j`` isn't a valid comparison."
msgstr ""
"چیز دیگری که ممکن است متوجه شوید این است که همه داده ها نمی توانند مرتب یا "
"مقایسه شوند. به عنوان مثال، ``[None, 'hello', 10]`` مرتب نمی شود زیرا اعداد "
"صحیح نمی توانند با رشته ها مقایسه شوند و ``None`` نمی تواند با انواع دیگر "
"مقایسه شود. همچنین، برخی از انواع وجود دارند که رابطه مرتب سازی مشخصی "
"ندارند. برای مثال، ``3+4j < 5+7j`` یک مقایسه معتبر نیست."

#: ../../tutorial/datastructures.rst:137
msgid "Using Lists as Stacks"
msgstr "استفاده از لیست ها به عنوان پشته ها"

#: ../../tutorial/datastructures.rst:142
msgid ""
"The list methods make it very easy to use a list as a stack, where the last "
"element added is the first element retrieved (\"last-in, first-out\").  To "
"add an item to the top of the stack, use :meth:`~list.append`.  To retrieve "
"an item from the top of the stack, use :meth:`~list.pop` without an explicit "
"index.  For example::"
msgstr ""

#: ../../tutorial/datastructures.rst:147
msgid ""
">>> stack = [3, 4, 5]\n"
">>> stack.append(6)\n"
">>> stack.append(7)\n"
">>> stack\n"
"[3, 4, 5, 6, 7]\n"
">>> stack.pop()\n"
"7\n"
">>> stack\n"
"[3, 4, 5, 6]\n"
">>> stack.pop()\n"
"6\n"
">>> stack.pop()\n"
"5\n"
">>> stack\n"
"[3, 4]"
msgstr ""
">>> stack = [3, 4, 5]\n"
">>> stack.append(6)\n"
">>> stack.append(7)\n"
">>> stack\n"
"[3, 4, 5, 6, 7]\n"
">>> stack.pop()\n"
"7\n"
">>> stack\n"
"[3, 4, 5, 6]\n"
">>> stack.pop()\n"
"6\n"
">>> stack.pop()\n"
"5\n"
">>> stack\n"
"[3, 4]"

#: ../../tutorial/datastructures.rst:167
msgid "Using Lists as Queues"
msgstr "استفاده از لیست ها به عنوان صف ها"

#: ../../tutorial/datastructures.rst:171
msgid ""
"It is also possible to use a list as a queue, where the first element added "
"is the first element retrieved (\"first-in, first-out\"); however, lists are "
"not efficient for this purpose.  While appends and pops from the end of list "
"are fast, doing inserts or pops from the beginning of a list is slow "
"(because all of the other elements have to be shifted by one)."
msgstr ""
"همچنین می توان از یک لیست به عنوان صف استفاده کرد، به طوری که اولین عنصری که "
"اضافه می شود، اولین عنصری است که بازیابی می شود (\"اولین ورودی, اولین "
"خروجی\")؛ با این حال، لیست ها برای این منظور کارآمد نیستند. در حالی که اضافه "
"کردن ها و حذف ها از انتهای لیست سریع هستند، انجام وارد کردن ها یا حذف ها از "
"ابتدای لیست کند است (زیرا همه عناصر دیگر باید به اندازه یک واحد جابجا شوند)."

#: ../../tutorial/datastructures.rst:177
msgid ""
"To implement a queue, use :class:`collections.deque` which was designed to "
"have fast appends and pops from both ends.  For example::"
msgstr ""
"برای پیاده سازی یک صف، از :class:`collections.deque` استفاده کنید که برای "
"افزودن و حذف سریع از هر دو انتها طراحی شده است. برای مثال::"

#: ../../tutorial/datastructures.rst:180
msgid ""
">>> from collections import deque\n"
">>> queue = deque([\"Eric\", \"John\", \"Michael\"])\n"
">>> queue.append(\"Terry\")           # Terry arrives\n"
">>> queue.append(\"Graham\")          # Graham arrives\n"
">>> queue.popleft()                 # The first to arrive now leaves\n"
"'Eric'\n"
">>> queue.popleft()                 # The second to arrive now leaves\n"
"'John'\n"
">>> queue                           # Remaining queue in order of arrival\n"
"deque(['Michael', 'Terry', 'Graham'])"
msgstr ""
">>> from collections import deque\n"
">>> queue = deque([\"Eric\", \"John\", \"Michael\"])\n"
">>> queue.append(\"Terry\")           # Terry arrives\n"
">>> queue.append(\"Graham\")          # Graham arrives\n"
">>> queue.popleft()                 # The first to arrive now leaves\n"
"'Eric'\n"
">>> queue.popleft()                 # The second to arrive now leaves\n"
"'John'\n"
">>> queue                           # Remaining queue in order of arrival\n"
"deque(['Michael', 'Terry', 'Graham'])"

#: ../../tutorial/datastructures.rst:195
msgid "List Comprehensions"
msgstr "لیست کامپرهنشن ها"

#: ../../tutorial/datastructures.rst:197
msgid ""
"List comprehensions provide a concise way to create lists. Common "
"applications are to make new lists where each element is the result of some "
"operations applied to each member of another sequence or iterable, or to "
"create a subsequence of those elements that satisfy a certain condition."
msgstr ""
"تعبیرات لیستی روشی مختصر برای ایجاد لیست ها فراهم می کند. کاربردهای معمول "
"شامل ایجاد لیست های جدیدی است که در آن هر عنصر نتیجه ٔ اعمال عملیات هایی بر "
"روی هر عضو یک توالی یا قابل پیمایش دیگر است، یا ایجاد زیرتوالی از آن عناصر "
"که یک شرط خاص را برآورده می کنند."

#: ../../tutorial/datastructures.rst:202
msgid "For example, assume we want to create a list of squares, like::"
msgstr "به عنوان مثال، فرض کنید می خواهیم فهرستی از مربعات ایجاد کنیم، مانند::"

#: ../../tutorial/datastructures.rst:204
msgid ""
">>> squares = []\n"
">>> for x in range(10):\n"
"...     squares.append(x**2)\n"
"...\n"
">>> squares\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]"
msgstr ""
">>> squares = []\n"
">>> for x in range(10):\n"
"...     squares.append(x**2)\n"
"...\n"
">>> squares\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]"

#: ../../tutorial/datastructures.rst:211
msgid ""
"Note that this creates (or overwrites) a variable named ``x`` that still "
"exists after the loop completes.  We can calculate the list of squares "
"without any side effects using::"
msgstr ""
"توجه داشته باشید که این کار یک متغیر به نام ``x`` ایجاد (یا بازنویسی) می کند "
"که پس از پایان حلقه همچنان وجود دارد. ما می توانیم لیست مربعات را بدون هیچ "
"اثر جانبی محاسبه کنیم با استفاده از::"

#: ../../tutorial/datastructures.rst:215
msgid "squares = list(map(lambda x: x**2, range(10)))"
msgstr "squares = list(map(lambda x: x**2, range(10)))"

#: ../../tutorial/datastructures.rst:217
msgid "or, equivalently::"
msgstr "یا به طور معادل::"

#: ../../tutorial/datastructures.rst:219
msgid "squares = [x**2 for x in range(10)]"
msgstr "squares = [x**2 for x in range(10)]"

#: ../../tutorial/datastructures.rst:221
msgid "which is more concise and readable."
msgstr "که مختصرتر و خواناتر است."

#: ../../tutorial/datastructures.rst:223
msgid ""
"A list comprehension consists of brackets containing an expression followed "
"by a :keyword:`!for` clause, then zero or more :keyword:`!for` or :keyword:`!"
"if` clauses.  The result will be a new list resulting from evaluating the "
"expression in the context of the :keyword:`!for` and :keyword:`!if` clauses "
"which follow it. For example, this listcomp combines the elements of two "
"lists if they are not equal::"
msgstr ""
"یک ترکیب لیستی شامل کروشه هایی است که یک عبارت را در بر می گیرد و به دنبال "
"آن یک بند :keyword:`!for` قرار دارد، سپس صفر یا چند بند :keyword:`!for` یا :"
"keyword:`!if` نیز ممکن است بیایند. نتیجه یک لیست جدید خواهد بود که با "
"ارزیابی عبارت در زمینه بندهای :keyword:`!for` و :keyword:`!if` که بعد از آن "
"می آیند به دست می آید. به عنوان مثال، این ترکیب لیستی عناصر دو لیست را ترکیب "
"می کند اگر آن ها برابر نباشند::"

#: ../../tutorial/datastructures.rst:230
msgid ""
">>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"
msgstr ""
">>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"

#: ../../tutorial/datastructures.rst:233
msgid "and it's equivalent to::"
msgstr "و معادل آن به این صورت است::"

#: ../../tutorial/datastructures.rst:235
msgid ""
">>> combs = []\n"
">>> for x in [1,2,3]:\n"
"...     for y in [3,1,4]:\n"
"...         if x != y:\n"
"...             combs.append((x, y))\n"
"...\n"
">>> combs\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"
msgstr ""
">>> combs = []\n"
">>> for x in [1,2,3]:\n"
"...     for y in [3,1,4]:\n"
"...         if x != y:\n"
"...             combs.append((x, y))\n"
"...\n"
">>> combs\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"

#: ../../tutorial/datastructures.rst:244
msgid ""
"Note how the order of the :keyword:`for` and :keyword:`if` statements is the "
"same in both these snippets."
msgstr ""
"توجه کنید که ترتیب دستورات :keyword:`for` و :keyword:`if` در هر دو این تکه "
"کدها مشابه است."

#: ../../tutorial/datastructures.rst:247
msgid ""
"If the expression is a tuple (e.g. the ``(x, y)`` in the previous example), "
"it must be parenthesized. ::"
msgstr ""
"اگر عبارت یک تاپل باشد (مثلاً ``(x, y)`` در مثال قبلی), باید در پرانتز قرار "
"گیرد. ::"

#: ../../tutorial/datastructures.rst:250
msgid ""
">>> vec = [-4, -2, 0, 2, 4]\n"
">>> # create a new list with the values doubled\n"
">>> [x*2 for x in vec]\n"
"[-8, -4, 0, 4, 8]\n"
">>> # filter the list to exclude negative numbers\n"
">>> [x for x in vec if x >= 0]\n"
"[0, 2, 4]\n"
">>> # apply a function to all the elements\n"
">>> [abs(x) for x in vec]\n"
"[4, 2, 0, 2, 4]\n"
">>> # call a method on each element\n"
">>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']\n"
">>> [weapon.strip() for weapon in freshfruit]\n"
"['banana', 'loganberry', 'passion fruit']\n"
">>> # create a list of 2-tuples like (number, square)\n"
">>> [(x, x**2) for x in range(6)]\n"
"[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n"
">>> # the tuple must be parenthesized, otherwise an error is raised\n"
">>> [x, x**2 for x in range(6)]\n"
"  File \"<stdin>\", line 1\n"
"    [x, x**2 for x in range(6)]\n"
"     ^^^^^^^\n"
"SyntaxError: did you forget parentheses around the comprehension target?\n"
">>> # flatten a list using a listcomp with two 'for'\n"
">>> vec = [[1,2,3], [4,5,6], [7,8,9]]\n"
">>> [num for elem in vec for num in elem]\n"
"[1, 2, 3, 4, 5, 6, 7, 8, 9]"
msgstr ""
">>> vec = [-4, -2, 0, 2, 4]\n"
">>> # یک لیست جدید با مقادیر دو برابر شده ایجاد کنید\n"
">>> [x*2 for x in vec]\n"
"[-8, -4, 0, 4, 8]\n"
">>> # filter the list to exclude negative numbers\n"
">>> [x for x in vec if x >= 0]\n"
"[0, 2, 4]\n"
">>> # apply a function to all the elements\n"
">>> [abs(x) for x in vec]\n"
"[4, 2, 0, 2, 4]\n"
">>> # call a method on each element\n"
">>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']\n"
">>> [weapon.strip() for weapon in freshfruit]\n"
"['banana', 'loganberry', 'passion fruit']\n"
">>> # create a list of 2-tuples like (number, square)\n"
">>> [(x, x**2) for x in range(6)]\n"
"[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n"
">>> # the tuple must be parenthesized, otherwise an error is raised\n"
">>> [x, x**2 for x in range(6)]\n"
"  File \"<stdin>\", line 1\n"
"    [x, x**2 for x in range(6)]\n"
"     ^^^^^^^\n"
"SyntaxError: آیا در اطراف هدف درک، پرانتزها را فراموش کرده اید؟\n"
">>> # کاهش ابعاد یک لیست با استفاده از یک فهرست ساز با دو 'for'\n"
">>> vec = [[1,2,3], [4,5,6], [7,8,9]]\n"
">>> [num for elem in vec for num in elem]\n"
"[1, 2, 3, 4, 5, 6, 7, 8, 9]"

#: ../../tutorial/datastructures.rst:278
msgid ""
"List comprehensions can contain complex expressions and nested functions::"
msgstr "درک لیست ها می توانند شامل عبارات پیچیده و توابع تو در تو باشند::"

#: ../../tutorial/datastructures.rst:280
msgid ""
">>> from math import pi\n"
">>> [str(round(pi, i)) for i in range(1, 6)]\n"
"['3.1', '3.14', '3.142', '3.1416', '3.14159']"
msgstr ""
">>> from math import pi\n"
">>> [str(round(pi, i)) for i in range(1, 6)]\n"
"['3.1', '3.14', '3.142', '3.1416', '3.14159']"

#: ../../tutorial/datastructures.rst:285
msgid "Nested List Comprehensions"
msgstr "تودرتوی لیست درک ها (Nested List Comprehensions)"

#: ../../tutorial/datastructures.rst:287
msgid ""
"The initial expression in a list comprehension can be any arbitrary "
"expression, including another list comprehension."
msgstr ""
"عبارت اولیه در یک درک لیست می تواند هر عبارت دلخواهی باشد، از جمله یک درک "
"لیست دیگر."

#: ../../tutorial/datastructures.rst:290
msgid ""
"Consider the following example of a 3x4 matrix implemented as a list of 3 "
"lists of length 4::"
msgstr ""
"مثال زیر یک ماتریس ۳x4 را نشان می دهد که به صورت لیستی از ۳ لیست با طول ۴ "
"پیاده سازی شده است::"

#: ../../tutorial/datastructures.rst:293
msgid ""
">>> matrix = [\n"
"...     [1, 2, 3, 4],\n"
"...     [5, 6, 7, 8],\n"
"...     [9, 10, 11, 12],\n"
"... ]"
msgstr ""
">>> matrix = [\n"
"...     [1, 2, 3, 4],\n"
"...     [5, 6, 7, 8],\n"
"...     [9, 10, 11, 12],\n"
"... ]"

#: ../../tutorial/datastructures.rst:299
msgid "The following list comprehension will transpose rows and columns::"
msgstr "فهمیدن فهرست هم قالب زیر ستون ها و سطرها را جابه جا می کند::"

#: ../../tutorial/datastructures.rst:301
msgid ""
">>> [[row[i] for row in matrix] for i in range(4)]\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
msgstr ""
">>> [[row[i] for row in matrix] for i in range(4)]\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"

#: ../../tutorial/datastructures.rst:304
msgid ""
"As we saw in the previous section, the inner list comprehension is evaluated "
"in the context of the :keyword:`for` that follows it, so this example is "
"equivalent to::"
msgstr ""
"همان طور که در بخش قبلی دیدیم، comprehension لیست داخلی در زمینه ی :keyword:"
"`for` که بعد از آن می آید ارزیابی می شود، بنابراین این مثال معادل است با::"

#: ../../tutorial/datastructures.rst:308
msgid ""
">>> transposed = []\n"
">>> for i in range(4):\n"
"...     transposed.append([row[i] for row in matrix])\n"
"...\n"
">>> transposed\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
msgstr ""
">>> transposed = []\n"
">>> for i in range(4):\n"
"...     transposed.append([row[i] for row in matrix])\n"
"...\n"
">>> transposed\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"

#: ../../tutorial/datastructures.rst:315
msgid "which, in turn, is the same as::"
msgstr "که به نوبه خود معادل زیر است::"

#: ../../tutorial/datastructures.rst:317
msgid ""
">>> transposed = []\n"
">>> for i in range(4):\n"
"...     # the following 3 lines implement the nested listcomp\n"
"...     transposed_row = []\n"
"...     for row in matrix:\n"
"...         transposed_row.append(row[i])\n"
"...     transposed.append(transposed_row)\n"
"...\n"
">>> transposed\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
msgstr ""
">>> transposed = []\n"
">>> for i in range(4):\n"
"...     # the following 3 lines implement the nested listcomp\n"
"...     transposed_row = []\n"
"...     for row in matrix:\n"
"...         transposed_row.append(row[i])\n"
"...     transposed.append(transposed_row)\n"
"...\n"
">>> transposed\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"

#: ../../tutorial/datastructures.rst:328
msgid ""
"In the real world, you should prefer built-in functions to complex flow "
"statements. The :func:`zip` function would do a great job for this use case::"
msgstr ""
"در دنیای واقعی، شما باید توابع داخلی را به جای جملات کنترلی پیچیده ترجیح "
"دهید. تابع :func:`zip` برای این مورد استفاده کار بسیار خوبی انجام خواهد داد::"

#: ../../tutorial/datastructures.rst:331
msgid ""
">>> list(zip(*matrix))\n"
"[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]"
msgstr ""
">>> list(zip(*matrix))\n"
"[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]"

#: ../../tutorial/datastructures.rst:334
msgid ""
"See :ref:`tut-unpacking-arguments` for details on the asterisk in this line."
msgstr ""
"برای جزئیات در مورد ستاره در این خط، به :ref:`tut-unpacking-arguments` "
"مراجعه کنید."

#: ../../tutorial/datastructures.rst:339
msgid "The :keyword:`!del` statement"
msgstr "بیانیه :keyword:`!del`"

#: ../../tutorial/datastructures.rst:341
msgid ""
"There is a way to remove an item from a list given its index instead of its "
"value: the :keyword:`del` statement.  This differs from the :meth:`~list."
"pop` method which returns a value.  The :keyword:`!del` statement can also "
"be used to remove slices from a list or clear the entire list (which we did "
"earlier by assignment of an empty list to the slice).  For example::"
msgstr ""

#: ../../tutorial/datastructures.rst:347
msgid ""
">>> a = [-1, 1, 66.25, 333, 333, 1234.5]\n"
">>> del a[0]\n"
">>> a\n"
"[1, 66.25, 333, 333, 1234.5]\n"
">>> del a[2:4]\n"
">>> a\n"
"[1, 66.25, 1234.5]\n"
">>> del a[:]\n"
">>> a\n"
"[]"
msgstr ""
">>> a = [-1, 1, 66.25, 333, 333, 1234.5]\n"
">>> del a[0]\n"
">>> a\n"
"[1, 66.25, 333, 333, 1234.5]\n"
">>> del a[2:4]\n"
">>> a\n"
"[1, 66.25, 1234.5]\n"
">>> del a[:]\n"
">>> a\n"
"[]"

#: ../../tutorial/datastructures.rst:358
msgid ":keyword:`del` can also be used to delete entire variables::"
msgstr ":keyword:`del` همچنین می تواند برای حذف کامل متغیرها نیز استفاده شود::"

#: ../../tutorial/datastructures.rst:360
msgid ">>> del a"
msgstr ">>> del a"

#: ../../tutorial/datastructures.rst:362
msgid ""
"Referencing the name ``a`` hereafter is an error (at least until another "
"value is assigned to it).  We'll find other uses for :keyword:`del` later."
msgstr ""
"استفاده از نام ``a`` از اینجا به بعد یک خطا است (حداقل تا زمانی که مقدار "
"دیگری به آن اختصاص داده شود). بعداً استفاده های دیگری برای :keyword:`del` "
"پیدا خواهیم کرد."

#: ../../tutorial/datastructures.rst:369
msgid "Tuples and Sequences"
msgstr "Tuples and Sequences"

#: ../../tutorial/datastructures.rst:371
msgid ""
"We saw that lists and strings have many common properties, such as indexing "
"and slicing operations.  They are two examples of *sequence* data types "
"(see :ref:`typesseq`).  Since Python is an evolving language, other sequence "
"data types may be added.  There is also another standard sequence data type: "
"the *tuple*."
msgstr ""
"ما دیدیم که لیست ها و رشته ها خصوصیات مشترک زیادی دارند، مانند عملیات اندیس "
"گذاری و برش. آنها دو مثال از انواع داده *sequence* هستند (نگاه کنید به :ref:"
"`typesseq`). از آنجایی که پایتون یک زبان در حال تکامل است، ممکن است انواع "
"داده  توالی دیگری اضافه شود. همچنین یک نوع داده توالی استاندارد دیگر وجود "
"دارد: *tuple*."

#: ../../tutorial/datastructures.rst:377
msgid ""
"A tuple consists of a number of values separated by commas, for instance::"
msgstr ""
"یک \"tuple\" شامل تعدادی مقدار است که با کاما از هم جدا شده اند، به عنوان "
"مثال::"

#: ../../tutorial/datastructures.rst:379
msgid ""
">>> t = 12345, 54321, 'hello!'\n"
">>> t[0]\n"
"12345\n"
">>> t\n"
"(12345, 54321, 'hello!')\n"
">>> # Tuples may be nested:\n"
">>> u = t, (1, 2, 3, 4, 5)\n"
">>> u\n"
"((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))\n"
">>> # Tuples are immutable:\n"
">>> t[0] = 88888\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: 'tuple' object does not support item assignment\n"
">>> # but they can contain mutable objects:\n"
">>> v = ([1, 2, 3], [3, 2, 1])\n"
">>> v\n"
"([1, 2, 3], [3, 2, 1])"
msgstr ""
">>> t = 12345, 54321, 'hello!'\n"
">>> t[0]\n"
"12345\n"
">>> t\n"
"(12345, 54321, 'hello!')\n"
">>> # تاپل ها می توانند تودرتو باشند:\n"
">>> u = t, (1, 2, 3, 4, 5)\n"
">>> u\n"
"((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))\n"
">>> # تاپل ها غیر قابل تغییر هستند:\n"
">>> t[0] = 88888\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: 'tuple' object does not support item assignment\n"
">>> # اما می توانند شامل اشیاء قابل تغییر باشند:\n"
">>> v = ([1, 2, 3], [3, 2, 1])\n"
">>> v\n"
"([1, 2, 3], [3, 2, 1])"

#: ../../tutorial/datastructures.rst:399
msgid ""
"As you see, on output tuples are always enclosed in parentheses, so that "
"nested tuples are interpreted correctly; they may be input with or without "
"surrounding parentheses, although often parentheses are necessary anyway (if "
"the tuple is part of a larger expression).  It is not possible to assign to "
"the individual items of a tuple, however it is possible to create tuples "
"which contain mutable objects, such as lists."
msgstr ""
"همان طور که می بینید، خروجی ها همیشه در پرانتز قرار می گیرند تا تاپل های تو "
"در تو به درستی تفسیر شوند؛ آن ها می توانند با یا بدون پرانتز ورودی باشند، "
"اگرچه اغلب پرانتزها به هر حال لازم هستند (اگر تاپل بخشی از یک عبارت بزرگ تر "
"باشد). امکان انتساب به آیتم های تکی یک تاپل وجود ندارد، اما می توان تاپل "
"هایی ایجاد کرد که شامل اشیاء قابل تغییر، مانند لیست ها باشند."

#: ../../tutorial/datastructures.rst:406
msgid ""
"Though tuples may seem similar to lists, they are often used in different "
"situations and for different purposes. Tuples are :term:`immutable`, and "
"usually contain a heterogeneous sequence of elements that are accessed via "
"unpacking (see later in this section) or indexing (or even by attribute in "
"the case of :func:`namedtuples <collections.namedtuple>`). Lists are :term:"
"`mutable`, and their elements are usually homogeneous and are accessed by "
"iterating over the list."
msgstr ""
"اگرچه به نظر می رسد که تاپل ها شبیه به فهرست ها باشند، اما اغلب در شرایط و "
"اهداف متفاوتی مورد استفاده قرار می گیرند. تاپل ها :term:`immutable` هستند و "
"معمولاً حاوی یک دنباله ناهمگون از عناصر می باشند که از طریق باز کردن (نکته: "
"بخش بعدی را ببینید) یا ایندکس گذاری (و حتی از طریق صفت در مورد :func:"
"`namedtuples <collections.namedtuple>`) قابل دسترسی هستند. فهرست ها :term:"
"`mutable` هستند و عناصر آن ها معمولاً همگون بوده و با تکرار بر روی فهرست به "
"آن ها دسترسی پیدا می شود."

#: ../../tutorial/datastructures.rst:414
msgid ""
"A special problem is the construction of tuples containing 0 or 1 items: the "
"syntax has some extra quirks to accommodate these.  Empty tuples are "
"constructed by an empty pair of parentheses; a tuple with one item is "
"constructed by following a value with a comma (it is not sufficient to "
"enclose a single value in parentheses). Ugly, but effective.  For example::"
msgstr ""
"یک مشکل ویژه در ساختن تاپل هایی است که 0 یا 1 آیتم دارند: نحو زبان نیازمند "
"تغییرات اضافی برای تطابق با این موارد است. تاپل های خالی با یک جفت پرانتز "
"خالی ساخته می شوند؛ یک تاپل با یک آیتم با قرار دادن یک کاما پس از مقدار "
"ساخته می شود (قرار دادن یک مقدار تنها درون پرانتز کافی نیست). این کار شاید "
"زیبا نباشد، اما مؤثر است. برای مثال::"

#: ../../tutorial/datastructures.rst:420
msgid ""
">>> empty = ()\n"
">>> singleton = 'hello',    # <-- note trailing comma\n"
">>> len(empty)\n"
"0\n"
">>> len(singleton)\n"
"1\n"
">>> singleton\n"
"('hello',)"
msgstr ""
">>> empty = ()\n"
">>> singleton = 'hello',    # <-- note trailing comma\n"
">>> len(empty)\n"
"0\n"
">>> len(singleton)\n"
"1\n"
">>> singleton\n"
"('hello',)"

#: ../../tutorial/datastructures.rst:429
msgid ""
"The statement ``t = 12345, 54321, 'hello!'`` is an example of *tuple "
"packing*: the values ``12345``, ``54321`` and ``'hello!'`` are packed "
"together in a tuple. The reverse operation is also possible::"
msgstr ""
"عبارت ``t = 12345, 54321, 'hello!'`` نمونه ای از *tuple packing* است: مقادیر "
"``12345``، ``54321`` و ``'hello!'`` در یک تاپل با هم بسته بندی می شوند. "
"عملیات معکوس نیز امکان پذیر است::"

#: ../../tutorial/datastructures.rst:433
msgid ">>> x, y, z = t"
msgstr ">>> x, y, z = t"

#: ../../tutorial/datastructures.rst:435
msgid ""
"This is called, appropriately enough, *sequence unpacking* and works for any "
"sequence on the right-hand side.  Sequence unpacking requires that there are "
"as many variables on the left side of the equals sign as there are elements "
"in the sequence.  Note that multiple assignment is really just a combination "
"of tuple packing and sequence unpacking."
msgstr ""
"این به درستی *sequence unpacking* نامیده می شود و برای هر دنباله ای در سمت "
"راست کار می کند. بازگشایی دنباله نیاز دارد که به همان تعداد متغیر در سمت چپ "
"علامت مساوی وجود داشته باشد که عناصر در دنباله وجود دارند. توجه داشته باشید "
"که تخصیص چندگانه در واقع فقط یک ترکیب از بسته بندی تاپل و بازگشایی دنباله "
"است."

#: ../../tutorial/datastructures.rst:445
msgid "Sets"
msgstr "مجموعه ها"

#: ../../tutorial/datastructures.rst:447
msgid ""
"Python also includes a data type for :ref:`sets <types-set>`.  A set is an "
"unordered collection with no duplicate elements.  Basic uses include "
"membership testing and eliminating duplicate entries.  Set objects also "
"support mathematical operations like union, intersection, difference, and "
"symmetric difference."
msgstr ""

#: ../../tutorial/datastructures.rst:453
msgid ""
"Curly braces or the :func:`set` function can be used to create sets.  Note: "
"to create an empty set you have to use ``set()``, not ``{}``; the latter "
"creates an empty dictionary, a data structure that we discuss in the next "
"section."
msgstr ""
"از آکولادها یا تابع :func:`set` می توان برای ایجاد مجموعه ها استفاده کرد. "
"توجه: برای ایجاد یک مجموعه خالی باید از ``set()`` استفاده کنید، نه ``{}``؛ "
"دومی یک دیکشنری خالی ایجاد می کند که یک ساختار داده است و آن را در بخش بعدی "
"بررسی خواهیم کرد."

#: ../../tutorial/datastructures.rst:457
msgid "Here is a brief demonstration::"
msgstr "در اینجا یک نمایش مختصر ارائه شده است::"

#: ../../tutorial/datastructures.rst:459
msgid ""
">>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}\n"
">>> print(basket)                      # show that duplicates have been "
"removed\n"
"{'orange', 'banana', 'pear', 'apple'}\n"
">>> 'orange' in basket                 # fast membership testing\n"
"True\n"
">>> 'crabgrass' in basket\n"
"False\n"
"\n"
">>> # Demonstrate set operations on unique letters from two words\n"
">>>\n"
">>> a = set('abracadabra')\n"
">>> b = set('alacazam')\n"
">>> a                                  # unique letters in a\n"
"{'a', 'r', 'b', 'c', 'd'}\n"
">>> a - b                              # letters in a but not in b\n"
"{'r', 'd', 'b'}\n"
">>> a | b                              # letters in a or b or both\n"
"{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n"
">>> a & b                              # letters in both a and b\n"
"{'a', 'c'}\n"
">>> a ^ b                              # letters in a or b but not both\n"
"{'r', 'd', 'b', 'm', 'z', 'l'}"
msgstr ""
">>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}\n"
">>> print(basket)                      # نشان می دهد که موارد تکراری حذف شده "
"اند\n"
"{'orange', 'banana', 'pear', 'apple'}\n"
">>> 'orange' in basket                 # تست سریع عضویت\n"
"True\n"
">>> 'crabgrass' in basket\n"
"False\n"
"\n"
">>> # نشان دادن عملیات مجموعه روی حروف یکتا از دو کلمه\n"
">>>\n"
">>> a = set('abracadabra')\n"
">>> b = set('alacazam')\n"
">>> a                                  # حروف یکتا در a\n"
"{'a', 'r', 'b', 'c', 'd'}\n"
">>> a - b                              # حروفی که در a هستند اما در b "
"نیستند\n"
"{'r', 'd', 'b'}\n"
">>> a | b                              # حروفی که در a یا b یا هر دو هستند\n"
"{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n"
">>> a & b                              # حروفی که هم در a و هم در b هستند\n"
"{'a', 'c'}\n"
">>> a ^ b                              # حروفی که در a یا b هستند اما نه هر "
"دو\n"
"{'r', 'd', 'b', 'm', 'z', 'l'}"

#: ../../tutorial/datastructures.rst:482
msgid ""
"Similarly to :ref:`list comprehensions <tut-listcomps>`, set comprehensions "
"are also supported::"
msgstr ""
"به طور مشابه با :ref:`list comprehensions <tut-listcomps>`، comprehensions "
"مجموعه نیز پشتیبانی می شوند::"

#: ../../tutorial/datastructures.rst:485
msgid ""
">>> a = {x for x in 'abracadabra' if x not in 'abc'}\n"
">>> a\n"
"{'r', 'd'}"
msgstr ""
">>> a = {x for x in 'abracadabra' if x not in 'abc'}\n"
">>> a\n"
"{'r', 'd'}"

#: ../../tutorial/datastructures.rst:493
msgid "Dictionaries"
msgstr "دایره المعارف ها"

#: ../../tutorial/datastructures.rst:495
msgid ""
"Another useful data type built into Python is the *dictionary* (see :ref:"
"`typesmapping`). Dictionaries are sometimes found in other languages as "
"\"associative memories\" or \"associative arrays\".  Unlike sequences, which "
"are indexed by a range of numbers, dictionaries are indexed by *keys*, which "
"can be any immutable type; strings and numbers can always be keys.  Tuples "
"can be used as keys if they contain only strings, numbers, or tuples; if a "
"tuple contains any mutable object either directly or indirectly, it cannot "
"be used as a key. You can't use lists as keys, since lists can be modified "
"in place using index assignments, slice assignments, or methods like :meth:"
"`~list.append` and :meth:`~list.extend`."
msgstr ""

#: ../../tutorial/datastructures.rst:506
msgid ""
"It is best to think of a dictionary as a set of *key: value* pairs, with the "
"requirement that the keys are unique (within one dictionary). A pair of "
"braces creates an empty dictionary: ``{}``. Placing a comma-separated list "
"of key:value pairs within the braces adds initial key:value pairs to the "
"dictionary; this is also the way dictionaries are written on output."
msgstr ""
"بهتر است یک دیکشنری را به عنوان یک مجموعه از جفت  *key: value* در نظر "
"بگیریم، با این شرط که کلیدها در یک دیکشنری منحصر به فرد باشند. یک جفت آکولاد "
"یک دیکشنری خالی ایجاد می کند: ``{}``. قراردادن یک لیست از جفت های کلید:مقدار "
"که با کاما از هم جدا شده اند، در داخل آکولادها، جفت های کلید:مقدار اولیه را "
"به دیکشنری اضافه می کند؛ این همچنین روشی است که دیکشنری ها در خروجی نوشته می "
"شوند."

#: ../../tutorial/datastructures.rst:512
msgid ""
"The main operations on a dictionary are storing a value with some key and "
"extracting the value given the key.  It is also possible to delete a key:"
"value pair with ``del``. If you store using a key that is already in use, "
"the old value associated with that key is forgotten."
msgstr ""

#: ../../tutorial/datastructures.rst:517
msgid ""
"Extracting a value for a non-existent key by subscripting (``d[key]``) "
"raises a :exc:`KeyError`. To avoid getting this error when trying to access "
"a possibly non-existent key, use the :meth:`~dict.get` method instead, which "
"returns ``None`` (or a specified default value) if the key is not in the "
"dictionary."
msgstr ""

#: ../../tutorial/datastructures.rst:522
msgid ""
"Performing ``list(d)`` on a dictionary returns a list of all the keys used "
"in the dictionary, in insertion order (if you want it sorted, just use "
"``sorted(d)`` instead). To check whether a single key is in the dictionary, "
"use the :keyword:`in` keyword."
msgstr ""
"انجام ``list(d)`` بر روی یک دیکشنری، لیستی از تمامی کلیدهای استفاده شده در "
"دیکشنری را در ترتیب درج شده بر می گرداند (اگر می خواهید مرتب باشد, به جای آن "
"از ``sorted(d)`` استفاده کنید). برای بررسی اینکه آیا یک کلید خاص در دیکشنری "
"وجود دارد، از کلمه کلیدی :keyword:`in` استفاده کنید."

#: ../../tutorial/datastructures.rst:527
msgid "Here is a small example using a dictionary::"
msgstr "در اینجا یک مثال کوچک با استفاده از یک دیکشنری آمده است::"

#: ../../tutorial/datastructures.rst:529
msgid ""
">>> tel = {'jack': 4098, 'sape': 4139}\n"
">>> tel['guido'] = 4127\n"
">>> tel\n"
"{'jack': 4098, 'sape': 4139, 'guido': 4127}\n"
">>> tel['jack']\n"
"4098\n"
">>> tel['irv']\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"KeyError: 'irv'\n"
">>> print(tel.get('irv'))\n"
"None\n"
">>> del tel['sape']\n"
">>> tel['irv'] = 4127\n"
">>> tel\n"
"{'jack': 4098, 'guido': 4127, 'irv': 4127}\n"
">>> list(tel)\n"
"['jack', 'guido', 'irv']\n"
">>> sorted(tel)\n"
"['guido', 'irv', 'jack']\n"
">>> 'guido' in tel\n"
"True\n"
">>> 'jack' not in tel\n"
"False"
msgstr ""

#: ../../tutorial/datastructures.rst:554
msgid ""
"The :func:`dict` constructor builds dictionaries directly from sequences of "
"key-value pairs::"
msgstr ""
"سازنده :func:`dict` دیکشنری ها را به طور مستقیم از دنباله های جفت کلید-مقدار "
"می سازد::"

#: ../../tutorial/datastructures.rst:557
msgid ""
">>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"
msgstr ""
">>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"

#: ../../tutorial/datastructures.rst:560
msgid ""
"In addition, dict comprehensions can be used to create dictionaries from "
"arbitrary key and value expressions::"
msgstr ""
"علاوه بر این، می توان از dict comprehensions برای ایجاد دیکشنری ها از عبارات "
"دلخواه کلید و مقدار استفاده کرد::"

#: ../../tutorial/datastructures.rst:563
msgid ""
">>> {x: x**2 for x in (2, 4, 6)}\n"
"{2: 4, 4: 16, 6: 36}"
msgstr ""
">>> {x: x**2 for x in (2, 4, 6)}\n"
"{2: 4, 4: 16, 6: 36}"

#: ../../tutorial/datastructures.rst:566
msgid ""
"When the keys are simple strings, it is sometimes easier to specify pairs "
"using keyword arguments::"
msgstr ""
"هنگامی که کلیدها رشته های ساده باشند، گاهی اوقات آسان تر است که جفت ها را با "
"استفاده از آرگومان های کلیدواژه مشخص کنید::"

#: ../../tutorial/datastructures.rst:569
msgid ""
">>> dict(sape=4139, guido=4127, jack=4098)\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"
msgstr ""
">>> dict(sape=4139, guido=4127, jack=4098)\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"

#: ../../tutorial/datastructures.rst:576
msgid "Looping Techniques"
msgstr "تکنیک های حلقه زدن"

#: ../../tutorial/datastructures.rst:578
msgid ""
"When looping through dictionaries, the key and corresponding value can be "
"retrieved at the same time using the :meth:`~dict.items` method. ::"
msgstr ""
"هنگام پیمایش در دیکشنری ها، کلید و مقدار مربوطه را می توان همزمان با استفاده "
"از روش :meth:`~dict.items` بازیابی کرد. ::"

#: ../../tutorial/datastructures.rst:581
msgid ""
">>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}\n"
">>> for k, v in knights.items():\n"
"...     print(k, v)\n"
"...\n"
"gallahad the pure\n"
"robin the brave"
msgstr ""
">>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}\n"
">>> for k, v in knights.items():\n"
"...     print(k, v)\n"
"...\n"
"gallahad the pure\n"
"robin the brave"

#: ../../tutorial/datastructures.rst:588
msgid ""
"When looping through a sequence, the position index and corresponding value "
"can be retrieved at the same time using the :func:`enumerate` function. ::"
msgstr ""
"هنگام گردش در یک توالی، می توان به طور همزمان به شاخص موقعیت و مقدار مربوطه "
"با استفاده از تابع :func:`enumerate` دسترسی پیدا کرد. ::"

#: ../../tutorial/datastructures.rst:591
msgid ""
">>> for i, v in enumerate(['tic', 'tac', 'toe']):\n"
"...     print(i, v)\n"
"...\n"
"0 tic\n"
"1 tac\n"
"2 toe"
msgstr ""
">>> for i, v in enumerate(['tic', 'tac', 'toe']):\n"
"...     print(i, v)\n"
"...\n"
"0 tic\n"
"1 tac\n"
"2 toe"

#: ../../tutorial/datastructures.rst:598
msgid ""
"To loop over two or more sequences at the same time, the entries can be "
"paired with the :func:`zip` function. ::"
msgstr ""
"برای پیمایش همزمان در دو یا چند توالی، می توان از تابع :func:`zip` برای جفت "
"کردن ورودی ها استفاده کرد. ::"

#: ../../tutorial/datastructures.rst:601
msgid ""
">>> questions = ['name', 'quest', 'favorite color']\n"
">>> answers = ['lancelot', 'the holy grail', 'blue']\n"
">>> for q, a in zip(questions, answers):\n"
"...     print('What is your {0}?  It is {1}.'.format(q, a))\n"
"...\n"
"What is your name?  It is lancelot.\n"
"What is your quest?  It is the holy grail.\n"
"What is your favorite color?  It is blue."
msgstr ""
">>> questions = ['name', 'quest', 'favorite color']\n"
">>> answers = ['lancelot', 'the holy grail', 'blue']\n"
">>> for q, a in zip(questions, answers):\n"
"...     print('What is your {0}?  It is {1}.'.format(q, a))\n"
"...\n"
"نام شما چیست؟  آن lancelot است.\n"
"ماموریت شما چیست؟  آن the holy grail است.\n"
"رنگ مورد علاقه ی شما چیست؟  آن blue است."

#: ../../tutorial/datastructures.rst:610
msgid ""
"To loop over a sequence in reverse, first specify the sequence in a forward "
"direction and then call the :func:`reversed` function. ::"
msgstr ""
"برای پیمایش بر روی یک دنباله به صورت معکوس، ابتدا دنباله را به صورت رو به "
"جلو مشخص کرده و سپس تابع :func:`reversed` را فراخوانی کنید. ::"

#: ../../tutorial/datastructures.rst:613
msgid ""
">>> for i in reversed(range(1, 10, 2)):\n"
"...     print(i)\n"
"...\n"
"9\n"
"7\n"
"5\n"
"3\n"
"1"
msgstr ""
">>> for i in reversed(range(1, 10, 2)):\n"
"...     print(i)\n"
"...\n"
"9\n"
"7\n"
"5\n"
"3\n"
"1"

#: ../../tutorial/datastructures.rst:622
msgid ""
"To loop over a sequence in sorted order, use the :func:`sorted` function "
"which returns a new sorted list while leaving the source unaltered. ::"
msgstr ""
"برای مرور بر روی یک دنباله به ترتیب مرتب، از تابع :func:`sorted` استفاده "
"کنید که یک لیست مرتب جدید را بازمی گرداند در حالی که منبع را به صورت تغییر "
"نیافته باقی می گذارد. ::"

#: ../../tutorial/datastructures.rst:625
msgid ""
">>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n"
">>> for i in sorted(basket):\n"
"...     print(i)\n"
"...\n"
"apple\n"
"apple\n"
"banana\n"
"orange\n"
"orange\n"
"pear"
msgstr ""
">>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n"
">>> for i in sorted(basket):\n"
"...     print(i)\n"
"...\n"
"apple\n"
"apple\n"
"banana\n"
"orange\n"
"orange\n"
"pear"

#: ../../tutorial/datastructures.rst:636
msgid ""
"Using :func:`set` on a sequence eliminates duplicate elements. The use of :"
"func:`sorted` in combination with :func:`set` over a sequence is an "
"idiomatic way to loop over unique elements of the sequence in sorted "
"order. ::"
msgstr ""
"استفاده از :func:`set` بر روی دنباله، عناصر تکراری را حذف می کند. استفاده "
"از :func:`sorted` به همراه :func:`set` بر روی یک دنباله، روشی ایدئوماتیک "
"برای پیمایش بر روی عناصر منحصر به فرد دنباله به صورت مرتب شده است. ::"

#: ../../tutorial/datastructures.rst:640
msgid ""
">>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n"
">>> for f in sorted(set(basket)):\n"
"...     print(f)\n"
"...\n"
"apple\n"
"banana\n"
"orange\n"
"pear"
msgstr ""
">>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n"
">>> for f in sorted(set(basket)):\n"
"...     print(f)\n"
"...\n"
"apple\n"
"banana\n"
"orange\n"
"pear"

#: ../../tutorial/datastructures.rst:649
msgid ""
"It is sometimes tempting to change a list while you are looping over it; "
"however, it is often simpler and safer to create a new list instead. ::"
msgstr ""
"گاهی وسوسه انگیز است که هنگام پیمایش یک لیست، آن را تغییر دهید؛ اما اغلب "
"ساده تر و ایمن تر است که به جای آن یک لیست جدید ایجاد کنید. ::"

#: ../../tutorial/datastructures.rst:652
msgid ""
">>> import math\n"
">>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]\n"
">>> filtered_data = []\n"
">>> for value in raw_data:\n"
"...     if not math.isnan(value):\n"
"...         filtered_data.append(value)\n"
"...\n"
">>> filtered_data\n"
"[56.2, 51.7, 55.3, 52.5, 47.8]"
msgstr ""
">>> import math\n"
">>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]\n"
">>> filtered_data = []\n"
">>> for value in raw_data:\n"
"...     if not math.isnan(value):\n"
"...         filtered_data.append(value)\n"
"...\n"
">>> filtered_data\n"
"[56.2, 51.7, 55.3, 52.5, 47.8]"

#: ../../tutorial/datastructures.rst:666
msgid "More on Conditions"
msgstr "بیشتر درباره شرایط"

#: ../../tutorial/datastructures.rst:668
msgid ""
"The conditions used in ``while`` and ``if`` statements can contain any "
"operators, not just comparisons."
msgstr ""
"شرایط استفاده شده در دستورات ``while`` و ``if`` می توانند شامل هر گونه "
"عملگرها باشند، نه فقط مقایسه ها."

#: ../../tutorial/datastructures.rst:672
msgid ""
"The comparison operators ``in`` and ``not in`` are membership tests that "
"determine whether a value is in (or not in) a container.  The operators "
"``is`` and ``is not`` compare whether two objects are really the same "
"object.  All comparison operators have the same priority, which is lower "
"than that of all numerical operators."
msgstr ""
"عملگرهای مقایسه ای ``in`` و ``not in`` تست های عضویت هستند که تعیین می کنند "
"آیا یک مقدار در یک محفظه وجود دارد یا خیر. عملگرهای ``is`` و ``is not`` "
"بررسی می کنند آیا دو شیء عملاً یک شیء واحد هستند یا خیر. تمام عملگرهای مقایسه "
"ای دارای اولویت یکسانی هستند که این اولویت کمتر از تمام عملگرهای عددی است."

#: ../../tutorial/datastructures.rst:678
msgid ""
"Comparisons can be chained.  For example, ``a < b == c`` tests whether ``a`` "
"is less than ``b`` and moreover ``b`` equals ``c``."
msgstr ""
"می توان مقایسه ها را به هم زنجیر کرد. به عنوان مثال، ``a < b == c`` بررسی می "
"کند که آیا ``a`` کمتر از ``b`` است و علاوه بر این ``b`` برابر با ``c`` می "
"باشد."

#: ../../tutorial/datastructures.rst:681
msgid ""
"Comparisons may be combined using the Boolean operators ``and`` and ``or``, "
"and the outcome of a comparison (or of any other Boolean expression) may be "
"negated with ``not``.  These have lower priorities than comparison "
"operators; between them, ``not`` has the highest priority and ``or`` the "
"lowest, so that ``A and not B or C`` is equivalent to ``(A and (not B)) or "
"C``. As always, parentheses can be used to express the desired composition."
msgstr ""
"مقایسه ها می توانند با استفاده از عملگرهای بولی ``and`` و ``or`` ترکیب شوند "
"و نتیجه یک مقایسه (یا هر عبارت بولی دیگر) می تواند با ``not`` منفی شود. این "
"ها اولویت کمتری نسبت به عملگرهای مقایسه دارند؛ بین آن ها، ``not`` بالاترین "
"اولویت و ``or`` پایین ترین اولویت را دارد، به طوری که ``A and not B or C`` "
"معادل ``(A and (not B)) or C`` است. همانطور که همیشه، پرانتزها می توانند "
"برای نشان دادن ترکیب مطلوب استفاده شوند."

#: ../../tutorial/datastructures.rst:688
msgid ""
"The Boolean operators ``and`` and ``or`` are so-called *short-circuit* "
"operators: their arguments are evaluated from left to right, and evaluation "
"stops as soon as the outcome is determined.  For example, if ``A`` and ``C`` "
"are true but ``B`` is false, ``A and B and C`` does not evaluate the "
"expression ``C``.  When used as a general value and not as a Boolean, the "
"return value of a short-circuit operator is the last evaluated argument."
msgstr ""
"عملگرهای بولی ``and`` و ``or`` به عنوان عملگرهای *short-circuit* شناخته می "
"شوند: آرگومان های آن ها از چپ به راست ارزیابی می شوند و ارزیابی به محض تعیین "
"نتیجه متوقف می شود. به عنوان مثال، اگر ``A`` و ``C`` درست باشند اما ``B`` "
"غلط باشد، ``A and B and C`` عبارت ``C`` را ارزیابی نمی کند. زمانی که به "
"عنوان یک مقدار عمومی و نه به عنوان بولی استفاده شوند، مقدار بازگشتی یک عملگر "
"*short-circuit* برابر با آخرین آرگومانی است که ارزیابی شده است."

#: ../../tutorial/datastructures.rst:695
msgid ""
"It is possible to assign the result of a comparison or other Boolean "
"expression to a variable.  For example, ::"
msgstr ""
"امکان انتساب نتیجه یک مقایسه یا دیگر عبارات بولی به یک متغیر وجود دارد. برای "
"مثال، ::"

#: ../../tutorial/datastructures.rst:698
msgid ""
">>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'\n"
">>> non_null = string1 or string2 or string3\n"
">>> non_null\n"
"'Trondheim'"
msgstr ""
">>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'\n"
">>> non_null = string1 or string2 or string3\n"
">>> non_null\n"
"'Trondheim'"

#: ../../tutorial/datastructures.rst:703
msgid ""
"Note that in Python, unlike C, assignment inside expressions must be done "
"explicitly with the :ref:`walrus operator <why-can-t-i-use-an-assignment-in-"
"an-expression>` ``:=``. This avoids a common class of problems encountered "
"in C programs: typing ``=`` in an expression when ``==`` was intended."
msgstr ""
"توجه داشته باشید که در پایتون، برخلاف زبان C، تخصیص در عبارات باید به صورت "
"صریح با :ref:`walrus operator <why-can-t-i-use-an-assignment-in-an-"
"expression>` ``:=`` انجام شود. این کار یک دسته مشکلات رایج در برنامه های C "
"را که به علت تایپ ``=`` در یک عبارت در زمانی رخ می دهد که ``==`` مورد نظر "
"بوده است، اجتناب می کند."

#: ../../tutorial/datastructures.rst:713
msgid "Comparing Sequences and Other Types"
msgstr "مقایسه ی دنباله ها و انواع دیگر"

#: ../../tutorial/datastructures.rst:714
msgid ""
"Sequence objects typically may be compared to other objects with the same "
"sequence type. The comparison uses *lexicographical* ordering: first the "
"first two items are compared, and if they differ this determines the outcome "
"of the comparison; if they are equal, the next two items are compared, and "
"so on, until either sequence is exhausted. If two items to be compared are "
"themselves sequences of the same type, the lexicographical comparison is "
"carried out recursively.  If all items of two sequences compare equal, the "
"sequences are considered equal. If one sequence is an initial sub-sequence "
"of the other, the shorter sequence is the smaller (lesser) one.  "
"Lexicographical ordering for strings uses the Unicode code point number to "
"order individual characters. Some examples of comparisons between sequences "
"of the same type::"
msgstr ""
"اشیاء دنباله ای معمولاً می توانند با دیگر اشیاء از همان نوع دنباله مقایسه "
"شوند. مقایسه از ترتیب *lexicographical* استفاده می کند: ابتدا دو آیتم اول "
"مقایسه می شوند و اگر متفاوت باشند، نتیجه مقایسه را تعیین می کند؛ اگر برابر "
"باشند، دو آیتم بعدی مقایسه می شوند و این روند ادامه می یابد تا زمانی که یکی "
"از دنباله ها تمام شود. اگر دو آیتمی که مقایسه می شوند خودشان دنباله هایی از "
"همان نوع باشند، مقایسه لغتنامه ای به صورت بازگشتی انجام می شود. اگر تمام "
"آیتم های دو دنباله برابر باشند، دنباله ها برابر در نظر گرفته می شوند. اگر یک "
"دنباله زیر-دنباله ابتدایی دیگری باشد، دنباله کوتاه تر کوچک تر در نظر گرفته "
"می شود. ترتیب لغتنامه ای برای رشته ها از شماره نقطه کد Unicode برای مرتب "
"سازی کاراکترهای فردی استفاده می کند. چند مثال از مقایسه بین  دنباله های از "
"همان نوع::"

#: ../../tutorial/datastructures.rst:726
msgid ""
"(1, 2, 3)              < (1, 2, 4)\n"
"[1, 2, 3]              < [1, 2, 4]\n"
"'ABC' < 'C' < 'Pascal' < 'Python'\n"
"(1, 2, 3, 4)           < (1, 2, 4)\n"
"(1, 2)                 < (1, 2, -1)\n"
"(1, 2, 3)             == (1.0, 2.0, 3.0)\n"
"(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)"
msgstr ""
"(1, 2, 3)              < (1, 2, 4)\n"
"[1, 2, 3]              < [1, 2, 4]\n"
"'ABC' < 'C' < 'Pascal' < 'Python'\n"
"(1, 2, 3, 4)           < (1, 2, 4)\n"
"(1, 2)                 < (1, 2, -1)\n"
"(1, 2, 3)             == (1.0, 2.0, 3.0)\n"
"(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)"

#: ../../tutorial/datastructures.rst:734
msgid ""
"Note that comparing objects of different types with ``<`` or ``>`` is legal "
"provided that the objects have appropriate comparison methods.  For example, "
"mixed numeric types are compared according to their numeric value, so 0 "
"equals 0.0, etc.  Otherwise, rather than providing an arbitrary ordering, "
"the interpreter will raise a :exc:`TypeError` exception."
msgstr ""
"توجه داشته باشید که مقایسه اشیاء از انواع مختلف با ``<`` یا ``>`` قانونی است "
"به شرطی که اشیاء روش های مقایسه مناسب داشته باشند. به عنوان مثال، انواع عددی "
"مختلط بر اساس مقدار عددی خود مقایسه می شوند، بنابراین 0 برابر 0.0 است و "
"غیره. در غیر این صورت، به جای ارائه یک ترتیب دلخواه، مفسر یک استثنا از نوع :"
"exc:`TypeError` ایجاد خواهد کرد."

#: ../../tutorial/datastructures.rst:742
msgid "Footnotes"
msgstr "پاورقی ها"

#: ../../tutorial/datastructures.rst:743
msgid ""
"Other languages may return the mutated object, which allows method chaining, "
"such as ``d->insert(\"a\")->remove(\"b\")->sort();``."
msgstr ""
"زبان های دیگر ممکن است شیء تغییر یافته را برگردانند که این امکان را فراهم می "
"کند که متدها به صورت زنجیره ای فراخوانی شوند، مانند ``d->insert(\"a\")-"
">remove(\"b\")->sort();``."
