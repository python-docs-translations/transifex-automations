# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-03-21 14:55+0000\n"
"PO-Revision-Date: 2024-05-11 00:34+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Persian (https://app.transifex.com/python-doc/teams/5390/"
"fa/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fa\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../tutorial/datastructures.rst:5
msgid "Data Structures"
msgstr "ساختارهای داده"

#: ../../tutorial/datastructures.rst:7
msgid ""
"This chapter describes some things you've learned about already in more "
"detail, and adds some new things as well."
msgstr ""
"این فصل برخی از مواردی را که قبلاً یاد گرفته اید با جزئیات بیشتری توصیف می "
"کند و همچنین برخی از موارد جدید را نیز اضافه می کند."

#: ../../tutorial/datastructures.rst:13
msgid "More on Lists"
msgstr "بیشتر در مورد لیست ها"

#: ../../tutorial/datastructures.rst:15
msgid ""
"The list data type has some more methods.  Here are all of the methods of "
"list objects:"
msgstr ""
"نوع داده ای لیست روش های بیشتری دارد. در اینجا تمام روش های اشیاء لیست وجود "
"دارد:"

#: ../../tutorial/datastructures.rst:22
msgid "Add an item to the end of the list.  Similar to ``a[len(a):] = [x]``."
msgstr "یک آیتم به انتهای لیست اضافه کنید. مشابه با ``a[len(a):] = [x]``."

#: ../../tutorial/datastructures.rst:28
msgid ""
"Extend the list by appending all the items from the iterable.  Similar to "
"``a[len(a):] = iterable``."
msgstr ""
"لیست را با افزودن تمام آیتم ها از شیء قابل تکرار گسترش دهید. مشابه "
"``a[len(a):] = iterable``."

#: ../../tutorial/datastructures.rst:35
msgid ""
"Insert an item at a given position.  The first argument is the index of the "
"element before which to insert, so ``a.insert(0, x)`` inserts at the front "
"of the list, and ``a.insert(len(a), x)`` is equivalent to ``a.append(x)``."
msgstr ""
"یک آیتم را در یک موقعیت مشخص درج کنید. اولین آرگومان، شاخص المانی است که قبل "
"از آن درج انجام می شود. بنابراین ``a.insert(0, x)`` در ابتدای لیست درج می "
"شود و ``a.insert(len(a), x)`` معادل ``a.append(x)`` است."

#: ../../tutorial/datastructures.rst:43
msgid ""
"Remove the first item from the list whose value is equal to *x*.  It raises "
"a :exc:`ValueError` if there is no such item."
msgstr ""
"اولین مورد را از لیست که مقدار آن برابر با *x* است حذف کنید. اگر چنین موردی "
"وجود نداشته باشد، یک :exc:`ValueError` ایجاد می کند."

#: ../../tutorial/datastructures.rst:50
msgid ""
"Remove the item at the given position in the list, and return it.  If no "
"index is specified, ``a.pop()`` removes and returns the last item in the "
"list. It raises an :exc:`IndexError` if the list is empty or the index is "
"outside the list range."
msgstr ""
"مورد را در موقعیت داده شده در لیست حذف کرده و آن را برمی گرداند. اگر هیچ "
"شاخصی مشخص نشده باشد، ``a.pop()`` آخرین مورد موجود در لیست را حذف کرده و "
"برمی گرداند. اگر لیست خالی باشد یا شاخص خارج از محدوده لیست باشد، :exc:"
"`IndexError` ایجاد می کند."

#: ../../tutorial/datastructures.rst:59
msgid "Remove all items from the list.  Similar to ``del a[:]``."
msgstr "همه اقلام را از لیست حذف کنید. مشابه ``del a[:]``."

#: ../../tutorial/datastructures.rst:65
msgid ""
"Return zero-based index in the list of the first item whose value is equal "
"to *x*. Raises a :exc:`ValueError` if there is no such item."
msgstr ""
"مقدار شاخص صفرم در لیست از اولین موردی که مقدارش برابر با *x* است را برمی "
"گرداند. اگر چنین موردی وجود نداشته باشد، یک :exc:`ValueError` ایجاد می کند."

#: ../../tutorial/datastructures.rst:68
msgid ""
"The optional arguments *start* and *end* are interpreted as in the slice "
"notation and are used to limit the search to a particular subsequence of the "
"list.  The returned index is computed relative to the beginning of the full "
"sequence rather than the *start* argument."
msgstr ""
"آرگومان های اختیاری *start* و *end* همانند نمادگذاری برش تعبیر می شوند و "
"برای محدود کردن جستجو به زیرتوالی خاصی از لیست استفاده می شوند. شاخص بازگشتی "
"نسبت به ابتدای کل توالی محاسبه می شود و نه نسبت به آرگومان *start*."

#: ../../tutorial/datastructures.rst:77
msgid "Return the number of times *x* appears in the list."
msgstr "تعداد دفعاتی که *x* در لیست ظاهر می شود را برگردان."

#: ../../tutorial/datastructures.rst:83
msgid ""
"Sort the items of the list in place (the arguments can be used for sort "
"customization, see :func:`sorted` for their explanation)."
msgstr ""
"اقلام لیست را در جای خود مرتب کنید (می توان از آرگومان ها برای سفارشی سازی "
"مرتب سازی استفاده کرد, برای توضیح آنها به :func:`sorted` مراجعه کنید)."

#: ../../tutorial/datastructures.rst:90
msgid "Reverse the elements of the list in place."
msgstr "عناصر لیست را به صورت در جا معکوس کنید."

#: ../../tutorial/datastructures.rst:96
msgid "Return a shallow copy of the list.  Similar to ``a[:]``."
msgstr "برگشتی یک کپی سطحی از لیست. مشابه ``a[:]``."

#: ../../tutorial/datastructures.rst:99
msgid "An example that uses most of the list methods::"
msgstr "یک مثال که از اکثر متدهای لیست استفاده می کند::"

#: ../../tutorial/datastructures.rst:101
msgid ""
">>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', "
"'banana']\n"
">>> fruits.count('apple')\n"
"2\n"
">>> fruits.count('tangerine')\n"
"0\n"
">>> fruits.index('banana')\n"
"3\n"
">>> fruits.index('banana', 4)  # Find next banana starting at position 4\n"
"6\n"
">>> fruits.reverse()\n"
">>> fruits\n"
"['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']\n"
">>> fruits.append('grape')\n"
">>> fruits\n"
"['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']\n"
">>> fruits.sort()\n"
">>> fruits\n"
"['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']\n"
">>> fruits.pop()\n"
"'pear'"
msgstr ""
">>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', "
"'banana']\n"
">>> fruits.count('apple')\n"
"2\n"
">>> fruits.count('tangerine')\n"
"0\n"
">>> fruits.index('banana')\n"
"3\n"
">>> fruits.index('banana', 4)  # Find next banana starting at position 4\n"
"6\n"
">>> fruits.reverse()\n"
">>> fruits\n"
"['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']\n"
">>> fruits.append('grape')\n"
">>> fruits\n"
"['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']\n"
">>> fruits.sort()\n"
">>> fruits\n"
"['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']\n"
">>> fruits.pop()\n"
"'pear'"

#: ../../tutorial/datastructures.rst:122
msgid ""
"You might have noticed that methods like ``insert``, ``remove`` or ``sort`` "
"that only modify the list have no return value printed -- they return the "
"default ``None``. [#]_  This is a design principle for all mutable data "
"structures in Python."
msgstr ""
"ممکن است متوجه شده باشید که متدهایی مانند ``insert``، ``remove`` یا ``sort`` "
"که فقط لیست را تغییر می دهند، هیچ مقدار بازگشتی چاپ شده ای ندارند -- آن ها "
"مقدار پیش فرض ``None`` را بازمی گردانند. [#]_ این یک اصل طراحی برای تمامی "
"ساختارهای داده قابل تغییر در پایتون است."

#: ../../tutorial/datastructures.rst:127
msgid ""
"Another thing you might notice is that not all data can be sorted or "
"compared.  For instance, ``[None, 'hello', 10]`` doesn't sort because "
"integers can't be compared to strings and ``None`` can't be compared to "
"other types.  Also, there are some types that don't have a defined ordering "
"relation.  For example, ``3+4j < 5+7j`` isn't a valid comparison."
msgstr ""
"چیز دیگری که ممکن است متوجه شوید این است که همه داده ها نمی توانند مرتب یا "
"مقایسه شوند. به عنوان مثال، ``[None, 'hello', 10]`` مرتب نمی شود زیرا اعداد "
"صحیح نمی توانند با رشته ها مقایسه شوند و ``None`` نمی تواند با انواع دیگر "
"مقایسه شود. همچنین، برخی از انواع وجود دارند که رابطه مرتب سازی مشخصی "
"ندارند. برای مثال، ``3+4j < 5+7j`` یک مقایسه معتبر نیست."

#: ../../tutorial/datastructures.rst:138
msgid "Using Lists as Stacks"
msgstr "استفاده از لیست ها به عنوان پشته ها"

#: ../../tutorial/datastructures.rst:143
msgid ""
"The list methods make it very easy to use a list as a stack, where the last "
"element added is the first element retrieved (\"last-in, first-out\").  To "
"add an item to the top of the stack, use :meth:`!append`.  To retrieve an "
"item from the top of the stack, use :meth:`!pop` without an explicit index.  "
"For example::"
msgstr ""
"متدهای لیست استفاده از یک لیست به عنوان یک پشته را بسیار آسان می کنند، جایی "
"که آخرین عنصر اضافه شده اولین عنصر بازیابی شده است (\"آخرین ورودی, اولین "
"خروجی\"). برای افزودن یک آیتم به بالای پشته از :meth:`!append` استفاده کنید. "
"برای بازیابی یک آیتم از بالای پشته، از :meth:`!pop` بدون یک اندیس مشخص "
"استفاده کنید. برای مثال::"

#: ../../tutorial/datastructures.rst:148
msgid ""
">>> stack = [3, 4, 5]\n"
">>> stack.append(6)\n"
">>> stack.append(7)\n"
">>> stack\n"
"[3, 4, 5, 6, 7]\n"
">>> stack.pop()\n"
"7\n"
">>> stack\n"
"[3, 4, 5, 6]\n"
">>> stack.pop()\n"
"6\n"
">>> stack.pop()\n"
"5\n"
">>> stack\n"
"[3, 4]"
msgstr ""
">>> stack = [3, 4, 5]\n"
">>> stack.append(6)\n"
">>> stack.append(7)\n"
">>> stack\n"
"[3, 4, 5, 6, 7]\n"
">>> stack.pop()\n"
"7\n"
">>> stack\n"
"[3, 4, 5, 6]\n"
">>> stack.pop()\n"
"6\n"
">>> stack.pop()\n"
"5\n"
">>> stack\n"
"[3, 4]"

#: ../../tutorial/datastructures.rst:168
msgid "Using Lists as Queues"
msgstr "استفاده از لیست ها به عنوان صف ها"

#: ../../tutorial/datastructures.rst:172
msgid ""
"It is also possible to use a list as a queue, where the first element added "
"is the first element retrieved (\"first-in, first-out\"); however, lists are "
"not efficient for this purpose.  While appends and pops from the end of list "
"are fast, doing inserts or pops from the beginning of a list is slow "
"(because all of the other elements have to be shifted by one)."
msgstr ""
"همچنین می توان از یک لیست به عنوان صف استفاده کرد، به طوری که اولین عنصری که "
"اضافه می شود، اولین عنصری است که بازیابی می شود (\"اولین ورودی, اولین "
"خروجی\")؛ با این حال، لیست ها برای این منظور کارآمد نیستند. در حالی که اضافه "
"کردن ها و حذف ها از انتهای لیست سریع هستند، انجام وارد کردن ها یا حذف ها از "
"ابتدای لیست کند است (زیرا همه عناصر دیگر باید به اندازه یک واحد جابجا شوند)."

#: ../../tutorial/datastructures.rst:178
msgid ""
"To implement a queue, use :class:`collections.deque` which was designed to "
"have fast appends and pops from both ends.  For example::"
msgstr ""
"برای پیاده سازی یک صف، از :class:`collections.deque` استفاده کنید که برای "
"افزودن و حذف سریع از هر دو انتها طراحی شده است. برای مثال::"

#: ../../tutorial/datastructures.rst:181
msgid ""
">>> from collections import deque\n"
">>> queue = deque([\"Eric\", \"John\", \"Michael\"])\n"
">>> queue.append(\"Terry\")           # Terry arrives\n"
">>> queue.append(\"Graham\")          # Graham arrives\n"
">>> queue.popleft()                 # The first to arrive now leaves\n"
"'Eric'\n"
">>> queue.popleft()                 # The second to arrive now leaves\n"
"'John'\n"
">>> queue                           # Remaining queue in order of arrival\n"
"deque(['Michael', 'Terry', 'Graham'])"
msgstr ""
">>> from collections import deque\n"
">>> queue = deque([\"Eric\", \"John\", \"Michael\"])\n"
">>> queue.append(\"Terry\")           # Terry arrives\n"
">>> queue.append(\"Graham\")          # Graham arrives\n"
">>> queue.popleft()                 # The first to arrive now leaves\n"
"'Eric'\n"
">>> queue.popleft()                 # The second to arrive now leaves\n"
"'John'\n"
">>> queue                           # Remaining queue in order of arrival\n"
"deque(['Michael', 'Terry', 'Graham'])"

#: ../../tutorial/datastructures.rst:196
msgid "List Comprehensions"
msgstr "فهرست درک"

#: ../../tutorial/datastructures.rst:198
msgid ""
"List comprehensions provide a concise way to create lists. Common "
"applications are to make new lists where each element is the result of some "
"operations applied to each member of another sequence or iterable, or to "
"create a subsequence of those elements that satisfy a certain condition."
msgstr ""
"تعبیرات لیستی روشی مختصر برای ایجاد لیست ها فراهم می کند. کاربردهای معمول "
"شامل ایجاد لیست های جدیدی است که در آن هر عنصر نتیجه ٔ اعمال عملیات هایی بر "
"روی هر عضو یک توالی یا قابل پیمایش دیگر است، یا ایجاد زیرتوالی از آن عناصر "
"که یک شرط خاص را برآورده می کنند."

#: ../../tutorial/datastructures.rst:203
msgid "For example, assume we want to create a list of squares, like::"
msgstr "به عنوان مثال، فرض کنید می خواهیم فهرستی از مربعات ایجاد کنیم، مانند::"

#: ../../tutorial/datastructures.rst:205
msgid ""
">>> squares = []\n"
">>> for x in range(10):\n"
"...     squares.append(x**2)\n"
"...\n"
">>> squares\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]"
msgstr ""
">>> squares = []\n"
">>> for x in range(10):\n"
"...     squares.append(x**2)\n"
"...\n"
">>> squares\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]"

#: ../../tutorial/datastructures.rst:212
msgid ""
"Note that this creates (or overwrites) a variable named ``x`` that still "
"exists after the loop completes.  We can calculate the list of squares "
"without any side effects using::"
msgstr ""
"توجه داشته باشید که این کار یک متغیر به نام ``x`` ایجاد (یا بازنویسی) می کند "
"که پس از پایان حلقه همچنان وجود دارد. ما می توانیم لیست مربعات را بدون هیچ "
"اثر جانبی محاسبه کنیم با استفاده از::"

#: ../../tutorial/datastructures.rst:216
msgid "squares = list(map(lambda x: x**2, range(10)))"
msgstr "squares = list(map(lambda x: x**2, range(10)))"

#: ../../tutorial/datastructures.rst:218
msgid "or, equivalently::"
msgstr "یا به طور معادل::"

#: ../../tutorial/datastructures.rst:220
msgid "squares = [x**2 for x in range(10)]"
msgstr "squares = [x**2 for x in range(10)]"

#: ../../tutorial/datastructures.rst:222
msgid "which is more concise and readable."
msgstr "که مختصرتر و خواناتر است."

#: ../../tutorial/datastructures.rst:224
msgid ""
"A list comprehension consists of brackets containing an expression followed "
"by a :keyword:`!for` clause, then zero or more :keyword:`!for` or :keyword:`!"
"if` clauses.  The result will be a new list resulting from evaluating the "
"expression in the context of the :keyword:`!for` and :keyword:`!if` clauses "
"which follow it. For example, this listcomp combines the elements of two "
"lists if they are not equal::"
msgstr ""
"یک ترکیب لیستی شامل کروشه هایی است که یک عبارت را در بر می گیرد و به دنبال "
"آن یک بند :keyword:`!for` قرار دارد، سپس صفر یا چند بند :keyword:`!for` یا :"
"keyword:`!if` نیز ممکن است بیایند. نتیجه یک لیست جدید خواهد بود که با "
"ارزیابی عبارت در زمینه بندهای :keyword:`!for` و :keyword:`!if` که بعد از آن "
"می آیند به دست می آید. به عنوان مثال، این ترکیب لیستی عناصر دو لیست را ترکیب "
"می کند اگر آن ها برابر نباشند::"

#: ../../tutorial/datastructures.rst:231
msgid ""
">>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"
msgstr ""
">>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"

#: ../../tutorial/datastructures.rst:234
msgid "and it's equivalent to::"
msgstr "و معادل آن به این صورت است::"

#: ../../tutorial/datastructures.rst:236
msgid ""
">>> combs = []\n"
">>> for x in [1,2,3]:\n"
"...     for y in [3,1,4]:\n"
"...         if x != y:\n"
"...             combs.append((x, y))\n"
"...\n"
">>> combs\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"
msgstr ""
">>> combs = []\n"
">>> for x in [1,2,3]:\n"
"...     for y in [3,1,4]:\n"
"...         if x != y:\n"
"...             combs.append((x, y))\n"
"...\n"
">>> combs\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"

#: ../../tutorial/datastructures.rst:245
msgid ""
"Note how the order of the :keyword:`for` and :keyword:`if` statements is the "
"same in both these snippets."
msgstr ""
"توجه کنید که ترتیب دستورات :keyword:`for` و :keyword:`if` در هر دو این تکه "
"کدها مشابه است."

#: ../../tutorial/datastructures.rst:248
msgid ""
"If the expression is a tuple (e.g. the ``(x, y)`` in the previous example), "
"it must be parenthesized. ::"
msgstr ""
"اگر عبارت یک تاپل باشد (مثلاً ``(x, y)`` در مثال قبلی), باید در پرانتز قرار "
"گیرد. ::"

#: ../../tutorial/datastructures.rst:251
msgid ""
">>> vec = [-4, -2, 0, 2, 4]\n"
">>> # create a new list with the values doubled\n"
">>> [x*2 for x in vec]\n"
"[-8, -4, 0, 4, 8]\n"
">>> # filter the list to exclude negative numbers\n"
">>> [x for x in vec if x >= 0]\n"
"[0, 2, 4]\n"
">>> # apply a function to all the elements\n"
">>> [abs(x) for x in vec]\n"
"[4, 2, 0, 2, 4]\n"
">>> # call a method on each element\n"
">>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']\n"
">>> [weapon.strip() for weapon in freshfruit]\n"
"['banana', 'loganberry', 'passion fruit']\n"
">>> # create a list of 2-tuples like (number, square)\n"
">>> [(x, x**2) for x in range(6)]\n"
"[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n"
">>> # the tuple must be parenthesized, otherwise an error is raised\n"
">>> [x, x**2 for x in range(6)]\n"
"  File \"<stdin>\", line 1\n"
"    [x, x**2 for x in range(6)]\n"
"     ^^^^^^^\n"
"SyntaxError: did you forget parentheses around the comprehension target?\n"
">>> # flatten a list using a listcomp with two 'for'\n"
">>> vec = [[1,2,3], [4,5,6], [7,8,9]]\n"
">>> [num for elem in vec for num in elem]\n"
"[1, 2, 3, 4, 5, 6, 7, 8, 9]"
msgstr ""
">>> vec = [-4, -2, 0, 2, 4]\n"
">>> # یک لیست جدید با مقادیر دو برابر شده ایجاد کنید\n"
">>> [x*2 for x in vec]\n"
"[-8, -4, 0, 4, 8]\n"
">>> # filter the list to exclude negative numbers\n"
">>> [x for x in vec if x >= 0]\n"
"[0, 2, 4]\n"
">>> # apply a function to all the elements\n"
">>> [abs(x) for x in vec]\n"
"[4, 2, 0, 2, 4]\n"
">>> # call a method on each element\n"
">>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']\n"
">>> [weapon.strip() for weapon in freshfruit]\n"
"['banana', 'loganberry', 'passion fruit']\n"
">>> # create a list of 2-tuples like (number, square)\n"
">>> [(x, x**2) for x in range(6)]\n"
"[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n"
">>> # the tuple must be parenthesized, otherwise an error is raised\n"
">>> [x, x**2 for x in range(6)]\n"
"  File \"<stdin>\", line 1\n"
"    [x, x**2 for x in range(6)]\n"
"     ^^^^^^^\n"
"SyntaxError: آیا در اطراف هدف درک، پرانتزها را فراموش کرده اید؟\n"
">>> # کاهش ابعاد یک لیست با استفاده از یک فهرست ساز با دو 'for'\n"
">>> vec = [[1,2,3], [4,5,6], [7,8,9]]\n"
">>> [num for elem in vec for num in elem]\n"
"[1, 2, 3, 4, 5, 6, 7, 8, 9]"

#: ../../tutorial/datastructures.rst:279
msgid ""
"List comprehensions can contain complex expressions and nested functions::"
msgstr ""
"\n"
"درک لیست ها می توانند شامل عبارات پیچیده و توابع تو در تو باشند::"

#: ../../tutorial/datastructures.rst:281
msgid ""
">>> from math import pi\n"
">>> [str(round(pi, i)) for i in range(1, 6)]\n"
"['3.1', '3.14', '3.142', '3.1416', '3.14159']"
msgstr ""
">>> from math import pi\n"
">>> [str(round(pi, i)) for i in range(1, 6)]\n"
"['3.1', '3.14', '3.142', '3.1416', '3.14159']"

#: ../../tutorial/datastructures.rst:286
msgid "Nested List Comprehensions"
msgstr "تودرتوی لیست درک ها (Nested List Comprehensions)"

#: ../../tutorial/datastructures.rst:288
msgid ""
"The initial expression in a list comprehension can be any arbitrary "
"expression, including another list comprehension."
msgstr ""
"عبارت اولیه در یک درک لیست می تواند هر عبارت دلخواهی باشد، از جمله یک درک "
"لیست دیگر."

#: ../../tutorial/datastructures.rst:291
msgid ""
"Consider the following example of a 3x4 matrix implemented as a list of 3 "
"lists of length 4::"
msgstr ""
"مثال زیر یک ماتریس ۳x4 را نشان می دهد که به صورت لیستی از ۳ لیست با طول ۴ "
"پیاده سازی شده است::"

#: ../../tutorial/datastructures.rst:294
msgid ""
">>> matrix = [\n"
"...     [1, 2, 3, 4],\n"
"...     [5, 6, 7, 8],\n"
"...     [9, 10, 11, 12],\n"
"... ]"
msgstr ""
">>> matrix = [\n"
"...     [1, 2, 3, 4],\n"
"...     [5, 6, 7, 8],\n"
"...     [9, 10, 11, 12],\n"
"... ]"

#: ../../tutorial/datastructures.rst:300
msgid "The following list comprehension will transpose rows and columns::"
msgstr "فهمیدن فهرست هم قالب زیر ستون ها و سطرها را جابه جا می کند::"

#: ../../tutorial/datastructures.rst:302
msgid ""
">>> [[row[i] for row in matrix] for i in range(4)]\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
msgstr ""
">>> [[row[i] for row in matrix] for i in range(4)]\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"

#: ../../tutorial/datastructures.rst:305
msgid ""
"As we saw in the previous section, the inner list comprehension is evaluated "
"in the context of the :keyword:`for` that follows it, so this example is "
"equivalent to::"
msgstr ""
"همان طور که در بخش قبلی دیدیم، comprehension لیست داخلی در زمینه ی :keyword:"
"`for` که بعد از آن می آید ارزیابی می شود، بنابراین این مثال معادل است با::"

#: ../../tutorial/datastructures.rst:309
msgid ""
">>> transposed = []\n"
">>> for i in range(4):\n"
"...     transposed.append([row[i] for row in matrix])\n"
"...\n"
">>> transposed\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
msgstr ""
">>> transposed = []\n"
">>> for i in range(4):\n"
"...     transposed.append([row[i] for row in matrix])\n"
"...\n"
">>> transposed\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"

#: ../../tutorial/datastructures.rst:316
msgid "which, in turn, is the same as::"
msgstr "که به نوبه خود معادل زیر است::"

#: ../../tutorial/datastructures.rst:318
msgid ""
">>> transposed = []\n"
">>> for i in range(4):\n"
"...     # the following 3 lines implement the nested listcomp\n"
"...     transposed_row = []\n"
"...     for row in matrix:\n"
"...         transposed_row.append(row[i])\n"
"...     transposed.append(transposed_row)\n"
"...\n"
">>> transposed\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
msgstr ""
">>> transposed = []\n"
">>> for i in range(4):\n"
"...     # the following 3 lines implement the nested listcomp\n"
"...     transposed_row = []\n"
"...     for row in matrix:\n"
"...         transposed_row.append(row[i])\n"
"...     transposed.append(transposed_row)\n"
"...\n"
">>> transposed\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"

#: ../../tutorial/datastructures.rst:329
msgid ""
"In the real world, you should prefer built-in functions to complex flow "
"statements. The :func:`zip` function would do a great job for this use case::"
msgstr ""
"در دنیای واقعی، شما باید توابع داخلی را به جای جملات کنترلی پیچیده ترجیح "
"دهید. تابع :func:`zip` برای این مورد استفاده کار بسیار خوبی انجام خواهد داد::"

#: ../../tutorial/datastructures.rst:332
msgid ""
">>> list(zip(*matrix))\n"
"[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]"
msgstr ""
">>> list(zip(*matrix))\n"
"[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]"

#: ../../tutorial/datastructures.rst:335
msgid ""
"See :ref:`tut-unpacking-arguments` for details on the asterisk in this line."
msgstr ""
"برای جزئیات در مورد ستاره در این خط، به :ref:`tut-unpacking-arguments` "
"مراجعه کنید."

#: ../../tutorial/datastructures.rst:340
msgid "The :keyword:`!del` statement"
msgstr "بیانیه :keyword:`!del`"

#: ../../tutorial/datastructures.rst:342
msgid ""
"There is a way to remove an item from a list given its index instead of its "
"value: the :keyword:`del` statement.  This differs from the :meth:`!pop` "
"method which returns a value.  The :keyword:`!del` statement can also be "
"used to remove slices from a list or clear the entire list (which we did "
"earlier by assignment of an empty list to the slice).  For example::"
msgstr ""
"راهی برای حذف یک آیتم از لیست با استفاده از ایندکس آن به جای مقدارش وجود "
"دارد: دستور :keyword:`del`. این روش با متد :meth:`!pop` که یک مقدار را برمی "
"گرداند، متفاوت است. دستور :keyword:`!del` نیز می تواند برای حذف برش ها از یک "
"لیست یا پاک سازی کل لیست استفاده شود (که قبلاً با تخصیص یک لیست خالی به برش "
"انجام دادیم). برای مثال::"

#: ../../tutorial/datastructures.rst:348
msgid ""
">>> a = [-1, 1, 66.25, 333, 333, 1234.5]\n"
">>> del a[0]\n"
">>> a\n"
"[1, 66.25, 333, 333, 1234.5]\n"
">>> del a[2:4]\n"
">>> a\n"
"[1, 66.25, 1234.5]\n"
">>> del a[:]\n"
">>> a\n"
"[]"
msgstr ""
">>> a = [-1, 1, 66.25, 333, 333, 1234.5]\n"
">>> del a[0]\n"
">>> a\n"
"[1, 66.25, 333, 333, 1234.5]\n"
">>> del a[2:4]\n"
">>> a\n"
"[1, 66.25, 1234.5]\n"
">>> del a[:]\n"
">>> a\n"
"[]"

#: ../../tutorial/datastructures.rst:359
msgid ":keyword:`del` can also be used to delete entire variables::"
msgstr ":keyword:`del` همچنین می تواند برای حذف کامل متغیرها نیز استفاده شود::"

#: ../../tutorial/datastructures.rst:361
msgid ">>> del a"
msgstr ">>> del a"

#: ../../tutorial/datastructures.rst:363
msgid ""
"Referencing the name ``a`` hereafter is an error (at least until another "
"value is assigned to it).  We'll find other uses for :keyword:`del` later."
msgstr ""
"استفاده از نام ``a`` از اینجا به بعد یک خطا است (حداقل تا زمانی که مقدار "
"دیگری به آن اختصاص داده شود). بعداً استفاده های دیگری برای :keyword:`del` "
"پیدا خواهیم کرد."

#: ../../tutorial/datastructures.rst:370
msgid "Tuples and Sequences"
msgstr "Tuples and Sequences"

#: ../../tutorial/datastructures.rst:372
msgid ""
"We saw that lists and strings have many common properties, such as indexing "
"and slicing operations.  They are two examples of *sequence* data types "
"(see :ref:`typesseq`).  Since Python is an evolving language, other sequence "
"data types may be added.  There is also another standard sequence data type: "
"the *tuple*."
msgstr ""
"ما دیدیم که لیست ها و رشته ها خصوصیات مشترک زیادی دارند، مانند عملیات اندیس "
"گذاری و برش. آنها دو مثال از انواع داده *sequence* هستند (نگاه کنید به :ref:"
"`typesseq`). از آنجایی که پایتون یک زبان در حال تکامل است، ممکن است انواع "
"داده  توالی دیگری اضافه شود. همچنین یک نوع داده توالی استاندارد دیگر وجود "
"دارد: *tuple*."

#: ../../tutorial/datastructures.rst:378
msgid ""
"A tuple consists of a number of values separated by commas, for instance::"
msgstr ""
"یک \"tuple\" شامل تعدادی مقدار است که با کاما از هم جدا شده اند، به عنوان "
"مثال::"

#: ../../tutorial/datastructures.rst:380
msgid ""
">>> t = 12345, 54321, 'hello!'\n"
">>> t[0]\n"
"12345\n"
">>> t\n"
"(12345, 54321, 'hello!')\n"
">>> # Tuples may be nested:\n"
">>> u = t, (1, 2, 3, 4, 5)\n"
">>> u\n"
"((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))\n"
">>> # Tuples are immutable:\n"
">>> t[0] = 88888\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: 'tuple' object does not support item assignment\n"
">>> # but they can contain mutable objects:\n"
">>> v = ([1, 2, 3], [3, 2, 1])\n"
">>> v\n"
"([1, 2, 3], [3, 2, 1])"
msgstr ""
">>> t = 12345, 54321, 'hello!'\n"
">>> t[0]\n"
"12345\n"
">>> t\n"
"(12345, 54321, 'hello!')\n"
">>> # تاپل ها می توانند تودرتو باشند:\n"
">>> u = t, (1, 2, 3, 4, 5)\n"
">>> u\n"
"((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))\n"
">>> # تاپل ها غیر قابل تغییر هستند:\n"
">>> t[0] = 88888\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: 'tuple' object does not support item assignment\n"
">>> # اما می توانند شامل اشیاء قابل تغییر باشند:\n"
">>> v = ([1, 2, 3], [3, 2, 1])\n"
">>> v\n"
"([1, 2, 3], [3, 2, 1])"

#: ../../tutorial/datastructures.rst:400
msgid ""
"As you see, on output tuples are always enclosed in parentheses, so that "
"nested tuples are interpreted correctly; they may be input with or without "
"surrounding parentheses, although often parentheses are necessary anyway (if "
"the tuple is part of a larger expression).  It is not possible to assign to "
"the individual items of a tuple, however it is possible to create tuples "
"which contain mutable objects, such as lists."
msgstr ""
"همان طور که می بینید، خروجی ها همیشه در پرانتز قرار می گیرند تا تاپل های تو "
"در تو به درستی تفسیر شوند؛ آن ها می توانند با یا بدون پرانتز ورودی باشند، "
"اگرچه اغلب پرانتزها به هر حال لازم هستند (اگر تاپل بخشی از یک عبارت بزرگ تر "
"باشد). امکان انتساب به آیتم های تکی یک تاپل وجود ندارد، اما می توان تاپل "
"هایی ایجاد کرد که شامل اشیاء قابل تغییر، مانند لیست ها باشند."

#: ../../tutorial/datastructures.rst:407
msgid ""
"Though tuples may seem similar to lists, they are often used in different "
"situations and for different purposes. Tuples are :term:`immutable`, and "
"usually contain a heterogeneous sequence of elements that are accessed via "
"unpacking (see later in this section) or indexing (or even by attribute in "
"the case of :func:`namedtuples <collections.namedtuple>`). Lists are :term:"
"`mutable`, and their elements are usually homogeneous and are accessed by "
"iterating over the list."
msgstr ""
"اگرچه به نظر می رسد که تاپل ها شبیه به فهرست ها باشند، اما اغلب در شرایط و "
"اهداف متفاوتی مورد استفاده قرار می گیرند. تاپل ها :term:`immutable` هستند و "
"معمولاً حاوی یک دنباله ناهمگون از عناصر می باشند که از طریق باز کردن (نکته: "
"بخش بعدی را ببینید) یا ایندکس گذاری (و حتی از طریق صفت در مورد :func:"
"`namedtuples <collections.namedtuple>`) قابل دسترسی هستند. فهرست ها :term:"
"`mutable` هستند و عناصر آن ها معمولاً همگون بوده و با تکرار بر روی فهرست به "
"آن ها دسترسی پیدا می شود."

#: ../../tutorial/datastructures.rst:415
msgid ""
"A special problem is the construction of tuples containing 0 or 1 items: the "
"syntax has some extra quirks to accommodate these.  Empty tuples are "
"constructed by an empty pair of parentheses; a tuple with one item is "
"constructed by following a value with a comma (it is not sufficient to "
"enclose a single value in parentheses). Ugly, but effective.  For example::"
msgstr ""
"یک مشکل ویژه در ساختن تاپل هایی است که 0 یا 1 آیتم دارند: نحو زبان نیازمند "
"تغییرات اضافی برای تطابق با این موارد است. تاپل های خالی با یک جفت پرانتز "
"خالی ساخته می شوند؛ یک تاپل با یک آیتم با قرار دادن یک کاما پس از مقدار "
"ساخته می شود (قرار دادن یک مقدار تنها درون پرانتز کافی نیست). این کار شاید "
"زیبا نباشد، اما مؤثر است. برای مثال::"

#: ../../tutorial/datastructures.rst:421
msgid ""
">>> empty = ()\n"
">>> singleton = 'hello',    # <-- note trailing comma\n"
">>> len(empty)\n"
"0\n"
">>> len(singleton)\n"
"1\n"
">>> singleton\n"
"('hello',)"
msgstr ""
">>> empty = ()\n"
">>> singleton = 'hello',    # <-- note trailing comma\n"
">>> len(empty)\n"
"0\n"
">>> len(singleton)\n"
"1\n"
">>> singleton\n"
"('hello',)"

#: ../../tutorial/datastructures.rst:430
msgid ""
"The statement ``t = 12345, 54321, 'hello!'`` is an example of *tuple "
"packing*: the values ``12345``, ``54321`` and ``'hello!'`` are packed "
"together in a tuple. The reverse operation is also possible::"
msgstr ""
"عبارت ``t = 12345, 54321, 'hello!'`` نمونه ای از *tuple packing* است: مقادیر "
"``12345``، ``54321`` و ``'hello!'`` در یک تاپل با هم بسته بندی می شوند. "
"عملیات معکوس نیز امکان پذیر است::"

#: ../../tutorial/datastructures.rst:434
msgid ">>> x, y, z = t"
msgstr ">>> x, y, z = t"

#: ../../tutorial/datastructures.rst:436
msgid ""
"This is called, appropriately enough, *sequence unpacking* and works for any "
"sequence on the right-hand side.  Sequence unpacking requires that there are "
"as many variables on the left side of the equals sign as there are elements "
"in the sequence.  Note that multiple assignment is really just a combination "
"of tuple packing and sequence unpacking."
msgstr ""
"این به درستی *sequence unpacking* نامیده می شود و برای هر دنباله ای در سمت "
"راست کار می کند. بازگشایی دنباله نیاز دارد که به همان تعداد متغیر در سمت چپ "
"علامت مساوی وجود داشته باشد که عناصر در دنباله وجود دارند. توجه داشته باشید "
"که تخصیص چندگانه در واقع فقط یک ترکیب از بسته بندی تاپل و بازگشایی دنباله "
"است."

#: ../../tutorial/datastructures.rst:446
msgid "Sets"
msgstr "مجموعه ها"

#: ../../tutorial/datastructures.rst:448
msgid ""
"Python also includes a data type for *sets*.  A set is an unordered "
"collection with no duplicate elements.  Basic uses include membership "
"testing and eliminating duplicate entries.  Set objects also support "
"mathematical operations like union, intersection, difference, and symmetric "
"difference."
msgstr ""
"پایتون همچنین شامل یک نوع داده برای *sets* است. یک مجموعه (set) یک مجموعه ی "
"نامرتب بدون عناصر تکراری است. استفاده های پایه شامل آزمایش عضویت و حذف ورودی "
"های تکراری است. اشیاء مجموعه (set) همچنین از عملیات ریاضی مثل اجتماع، "
"اشتراک، تفاضل و تفاضل متقارن پشتیبانی می کنند."

#: ../../tutorial/datastructures.rst:453
msgid ""
"Curly braces or the :func:`set` function can be used to create sets.  Note: "
"to create an empty set you have to use ``set()``, not ``{}``; the latter "
"creates an empty dictionary, a data structure that we discuss in the next "
"section."
msgstr ""
"از آکولادها یا تابع :func:`set` می توان برای ایجاد مجموعه ها استفاده کرد. "
"توجه: برای ایجاد یک مجموعه خالی باید از ``set()`` استفاده کنید، نه ``{}``؛ "
"دومی یک دیکشنری خالی ایجاد می کند که یک ساختار داده است و آن را در بخش بعدی "
"بررسی خواهیم کرد."

#: ../../tutorial/datastructures.rst:457
msgid "Here is a brief demonstration::"
msgstr "در اینجا یک نمایش مختصر ارائه شده است::"

#: ../../tutorial/datastructures.rst:459
msgid ""
">>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}\n"
">>> print(basket)                      # show that duplicates have been "
"removed\n"
"{'orange', 'banana', 'pear', 'apple'}\n"
">>> 'orange' in basket                 # fast membership testing\n"
"True\n"
">>> 'crabgrass' in basket\n"
"False\n"
"\n"
">>> # Demonstrate set operations on unique letters from two words\n"
">>>\n"
">>> a = set('abracadabra')\n"
">>> b = set('alacazam')\n"
">>> a                                  # unique letters in a\n"
"{'a', 'r', 'b', 'c', 'd'}\n"
">>> a - b                              # letters in a but not in b\n"
"{'r', 'd', 'b'}\n"
">>> a | b                              # letters in a or b or both\n"
"{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n"
">>> a & b                              # letters in both a and b\n"
"{'a', 'c'}\n"
">>> a ^ b                              # letters in a or b but not both\n"
"{'r', 'd', 'b', 'm', 'z', 'l'}"
msgstr ""
">>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}\n"
">>> print(basket)                      # نشان می دهد که موارد تکراری حذف شده "
"اند\n"
"{'orange', 'banana', 'pear', 'apple'}\n"
">>> 'orange' in basket                 # تست سریع عضویت\n"
"True\n"
">>> 'crabgrass' in basket\n"
"False\n"
"\n"
">>> # نشان دادن عملیات مجموعه روی حروف یکتا از دو کلمه\n"
">>>\n"
">>> a = set('abracadabra')\n"
">>> b = set('alacazam')\n"
">>> a                                  # حروف یکتا در a\n"
"{'a', 'r', 'b', 'c', 'd'}\n"
">>> a - b                              # حروفی که در a هستند اما در b "
"نیستند\n"
"{'r', 'd', 'b'}\n"
">>> a | b                              # حروفی که در a یا b یا هر دو هستند\n"
"{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n"
">>> a & b                              # حروفی که هم در a و هم در b هستند\n"
"{'a', 'c'}\n"
">>> a ^ b                              # حروفی که در a یا b هستند اما نه هر "
"دو\n"
"{'r', 'd', 'b', 'm', 'z', 'l'}"

#: ../../tutorial/datastructures.rst:482
msgid ""
"Similarly to :ref:`list comprehensions <tut-listcomps>`, set comprehensions "
"are also supported::"
msgstr ""
"به طور مشابه با :ref:`list comprehensions <tut-listcomps>`، comprehensions "
"مجموعه نیز پشتیبانی می شوند::"

#: ../../tutorial/datastructures.rst:485
msgid ""
">>> a = {x for x in 'abracadabra' if x not in 'abc'}\n"
">>> a\n"
"{'r', 'd'}"
msgstr ""
">>> a = {x for x in 'abracadabra' if x not in 'abc'}\n"
">>> a\n"
"{'r', 'd'}"

#: ../../tutorial/datastructures.rst:493
msgid "Dictionaries"
msgstr "دایره المعارف ها"

#: ../../tutorial/datastructures.rst:495
msgid ""
"Another useful data type built into Python is the *dictionary* (see :ref:"
"`typesmapping`). Dictionaries are sometimes found in other languages as "
"\"associative memories\" or \"associative arrays\".  Unlike sequences, which "
"are indexed by a range of numbers, dictionaries are indexed by *keys*, which "
"can be any immutable type; strings and numbers can always be keys.  Tuples "
"can be used as keys if they contain only strings, numbers, or tuples; if a "
"tuple contains any mutable object either directly or indirectly, it cannot "
"be used as a key. You can't use lists as keys, since lists can be modified "
"in place using index assignments, slice assignments, or methods like :meth:`!"
"append` and :meth:`!extend`."
msgstr ""
"یکی دیگر از نوع های داده مفید موجود در پایتون، *dictionary* (به :ref:"
"`typesmapping` مراجعه کنید) است. دیکشنری ها در بعضی زبان ها به عنوان \"حافظه "
"های انجمنی\" یا \"آرایه های انجمنی\" شناخته می شوند. برخلاف توالی ها که با "
"یک محدوده از اعداد شاخص گذاری می شوند، دیکشنری ها توسط *keys* شاخص گذاری می "
"شوند که می تواند هر نوع غیر قابل تغییر باشد؛ رشته ها و اعداد همیشه می توانند "
"کلید باشند. در صورتی که یک تاپل تنها حاوی رشته ها، اعداد یا تاپل دیگری باشد، "
"می تواند به عنوان کلید استفاده شود؛ اگر یک تاپل به صورت مستقیم یا غیر مستقیم "
"شامل هر شیء قابل تغییر باشد، نمی تواند به عنوان کلید استفاده شود. شما نمی "
"توانید از لیست ها به عنوان کلید استفاده کنید، زیرا لیست ها می توانند با "
"استفاده از انتساب شاخص، انتساب قطعه ای یا متدهایی مانند :meth:`!append` و :"
"meth:`!extend` در محل تغییر کنند."

#: ../../tutorial/datastructures.rst:506
msgid ""
"It is best to think of a dictionary as a set of *key: value* pairs, with the "
"requirement that the keys are unique (within one dictionary). A pair of "
"braces creates an empty dictionary: ``{}``. Placing a comma-separated list "
"of key:value pairs within the braces adds initial key:value pairs to the "
"dictionary; this is also the way dictionaries are written on output."
msgstr ""
"بهتر است یک دیکشنری را به عنوان یک مجموعه از جفت  *key: value* در نظر "
"بگیریم، با این شرط که کلیدها در یک دیکشنری منحصر به فرد باشند. یک جفت آکولاد "
"یک دیکشنری خالی ایجاد می کند: ``{}``. قراردادن یک لیست از جفت های کلید:مقدار "
"که با کاما از هم جدا شده اند، در داخل آکولادها، جفت های کلید:مقدار اولیه را "
"به دیکشنری اضافه می کند؛ این همچنین روشی است که دیکشنری ها در خروجی نوشته می "
"شوند."

#: ../../tutorial/datastructures.rst:512
msgid ""
"The main operations on a dictionary are storing a value with some key and "
"extracting the value given the key.  It is also possible to delete a key:"
"value pair with ``del``. If you store using a key that is already in use, "
"the old value associated with that key is forgotten.  It is an error to "
"extract a value using a non-existent key."
msgstr ""
"عملیات اصلی روی یک دیکشنری ذخیره یک مقدار با یک کلید و استخراج مقدار با "
"استفاده از کلید است. همچنین امکان حذف یک جفت کلید:مقدار با استفاده از "
"``del`` وجود دارد. اگر از کلیدی که قبلاً استفاده شده است استفاده کنید، مقدار "
"قدیمی مرتبط با آن کلید فراموش می شود. استخراج یک مقدار با استفاده از یک کلید "
"ناموجود یک خطا است."

#: ../../tutorial/datastructures.rst:518
msgid ""
"Performing ``list(d)`` on a dictionary returns a list of all the keys used "
"in the dictionary, in insertion order (if you want it sorted, just use "
"``sorted(d)`` instead). To check whether a single key is in the dictionary, "
"use the :keyword:`in` keyword."
msgstr ""
"انجام ``list(d)`` بر روی یک دیکشنری، لیستی از تمامی کلیدهای استفاده شده در "
"دیکشنری را در ترتیب درج شده بر می گرداند (اگر می خواهید مرتب باشد, به جای آن "
"از ``sorted(d)`` استفاده کنید). برای بررسی اینکه آیا یک کلید خاص در دیکشنری "
"وجود دارد، از کلمه کلیدی :keyword:`in` استفاده کنید."

#: ../../tutorial/datastructures.rst:523
msgid "Here is a small example using a dictionary::"
msgstr "در اینجا یک مثال کوچک با استفاده از یک دیکشنری آمده است::"

#: ../../tutorial/datastructures.rst:525
msgid ""
">>> tel = {'jack': 4098, 'sape': 4139}\n"
">>> tel['guido'] = 4127\n"
">>> tel\n"
"{'jack': 4098, 'sape': 4139, 'guido': 4127}\n"
">>> tel['jack']\n"
"4098\n"
">>> del tel['sape']\n"
">>> tel['irv'] = 4127\n"
">>> tel\n"
"{'jack': 4098, 'guido': 4127, 'irv': 4127}\n"
">>> list(tel)\n"
"['jack', 'guido', 'irv']\n"
">>> sorted(tel)\n"
"['guido', 'irv', 'jack']\n"
">>> 'guido' in tel\n"
"True\n"
">>> 'jack' not in tel\n"
"False"
msgstr ""
">>> tel = {'jack': 4098, 'sape': 4139}\n"
">>> tel['guido'] = 4127\n"
">>> tel\n"
"{'jack': 4098, 'sape': 4139, 'guido': 4127}\n"
">>> tel['jack']\n"
"4098\n"
">>> del tel['sape']\n"
">>> tel['irv'] = 4127\n"
">>> tel\n"
"{'jack': 4098, 'guido': 4127, 'irv': 4127}\n"
">>> list(tel)\n"
"['jack', 'guido', 'irv']\n"
">>> sorted(tel)\n"
"['guido', 'irv', 'jack']\n"
">>> 'guido' in tel\n"
"True\n"
">>> 'jack' not in tel\n"
"False"

#: ../../tutorial/datastructures.rst:544
msgid ""
"The :func:`dict` constructor builds dictionaries directly from sequences of "
"key-value pairs::"
msgstr ""
"سازنده :func:`dict` دیکشنری ها را به طور مستقیم از دنباله های جفت کلید-مقدار "
"می سازد::"

#: ../../tutorial/datastructures.rst:547
msgid ""
">>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"
msgstr ""
">>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"

#: ../../tutorial/datastructures.rst:550
msgid ""
"In addition, dict comprehensions can be used to create dictionaries from "
"arbitrary key and value expressions::"
msgstr ""
"علاوه بر این، می توان از dict comprehensions برای ایجاد دیکشنری ها از عبارات "
"دلخواه کلید و مقدار استفاده کرد::"

#: ../../tutorial/datastructures.rst:553
msgid ""
">>> {x: x**2 for x in (2, 4, 6)}\n"
"{2: 4, 4: 16, 6: 36}"
msgstr ""
">>> {x: x**2 for x in (2, 4, 6)}\n"
"{2: 4, 4: 16, 6: 36}"

#: ../../tutorial/datastructures.rst:556
msgid ""
"When the keys are simple strings, it is sometimes easier to specify pairs "
"using keyword arguments::"
msgstr ""
"هنگامی که کلیدها رشته های ساده باشند، گاهی اوقات آسان تر است که جفت ها را با "
"استفاده از آرگومان های کلیدواژه مشخص کنید::"

#: ../../tutorial/datastructures.rst:559
msgid ""
">>> dict(sape=4139, guido=4127, jack=4098)\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"
msgstr ""
">>> dict(sape=4139, guido=4127, jack=4098)\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"

#: ../../tutorial/datastructures.rst:566
msgid "Looping Techniques"
msgstr "تکنیک های حلقه زدن"

#: ../../tutorial/datastructures.rst:568
msgid ""
"When looping through dictionaries, the key and corresponding value can be "
"retrieved at the same time using the :meth:`~dict.items` method. ::"
msgstr ""
"هنگام پیمایش در دیکشنری ها، کلید و مقدار مربوطه را می توان همزمان با استفاده "
"از روش :meth:`~dict.items` بازیابی کرد. ::"

#: ../../tutorial/datastructures.rst:571
msgid ""
">>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}\n"
">>> for k, v in knights.items():\n"
"...     print(k, v)\n"
"...\n"
"gallahad the pure\n"
"robin the brave"
msgstr ""
">>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}\n"
">>> for k, v in knights.items():\n"
"...     print(k, v)\n"
"...\n"
"gallahad the pure\n"
"robin the brave"

#: ../../tutorial/datastructures.rst:578
msgid ""
"When looping through a sequence, the position index and corresponding value "
"can be retrieved at the same time using the :func:`enumerate` function. ::"
msgstr ""
"هنگام گردش در یک توالی، می توان به طور همزمان به شاخص موقعیت و مقدار مربوطه "
"با استفاده از تابع :func:`enumerate` دسترسی پیدا کرد. ::"

#: ../../tutorial/datastructures.rst:581
msgid ""
">>> for i, v in enumerate(['tic', 'tac', 'toe']):\n"
"...     print(i, v)\n"
"...\n"
"0 tic\n"
"1 tac\n"
"2 toe"
msgstr ""
">>> for i, v in enumerate(['tic', 'tac', 'toe']):\n"
"...     print(i, v)\n"
"...\n"
"0 tic\n"
"1 tac\n"
"2 toe"

#: ../../tutorial/datastructures.rst:588
msgid ""
"To loop over two or more sequences at the same time, the entries can be "
"paired with the :func:`zip` function. ::"
msgstr ""
"برای پیمایش همزمان در دو یا چند توالی، می توان از تابع :func:`zip` برای جفت "
"کردن ورودی ها استفاده کرد. ::"

#: ../../tutorial/datastructures.rst:591
msgid ""
">>> questions = ['name', 'quest', 'favorite color']\n"
">>> answers = ['lancelot', 'the holy grail', 'blue']\n"
">>> for q, a in zip(questions, answers):\n"
"...     print('What is your {0}?  It is {1}.'.format(q, a))\n"
"...\n"
"What is your name?  It is lancelot.\n"
"What is your quest?  It is the holy grail.\n"
"What is your favorite color?  It is blue."
msgstr ""
">>> questions = ['name', 'quest', 'favorite color']\n"
">>> answers = ['lancelot', 'the holy grail', 'blue']\n"
">>> for q, a in zip(questions, answers):\n"
"...     print('What is your {0}?  It is {1}.'.format(q, a))\n"
"...\n"
"نام شما چیست؟  آن lancelot است.\n"
"ماموریت شما چیست؟  آن the holy grail است.\n"
"رنگ مورد علاقه ی شما چیست؟  آن blue است."

#: ../../tutorial/datastructures.rst:600
msgid ""
"To loop over a sequence in reverse, first specify the sequence in a forward "
"direction and then call the :func:`reversed` function. ::"
msgstr ""
"برای پیمایش بر روی یک دنباله به صورت معکوس، ابتدا دنباله را به صورت رو به "
"جلو مشخص کرده و سپس تابع :func:`reversed` را فراخوانی کنید. ::"

#: ../../tutorial/datastructures.rst:603
msgid ""
">>> for i in reversed(range(1, 10, 2)):\n"
"...     print(i)\n"
"...\n"
"9\n"
"7\n"
"5\n"
"3\n"
"1"
msgstr ""
">>> for i in reversed(range(1, 10, 2)):\n"
"...     print(i)\n"
"...\n"
"9\n"
"7\n"
"5\n"
"3\n"
"1"

#: ../../tutorial/datastructures.rst:612
msgid ""
"To loop over a sequence in sorted order, use the :func:`sorted` function "
"which returns a new sorted list while leaving the source unaltered. ::"
msgstr ""
"برای مرور بر روی یک دنباله به ترتیب مرتب، از تابع :func:`sorted` استفاده "
"کنید که یک لیست مرتب جدید را بازمی گرداند در حالی که منبع را به صورت تغییر "
"نیافته باقی می گذارد. ::"

#: ../../tutorial/datastructures.rst:615
msgid ""
">>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n"
">>> for i in sorted(basket):\n"
"...     print(i)\n"
"...\n"
"apple\n"
"apple\n"
"banana\n"
"orange\n"
"orange\n"
"pear"
msgstr ""
">>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n"
">>> for i in sorted(basket):\n"
"...     print(i)\n"
"...\n"
"apple\n"
"apple\n"
"banana\n"
"orange\n"
"orange\n"
"pear"

#: ../../tutorial/datastructures.rst:626
msgid ""
"Using :func:`set` on a sequence eliminates duplicate elements. The use of :"
"func:`sorted` in combination with :func:`set` over a sequence is an "
"idiomatic way to loop over unique elements of the sequence in sorted "
"order. ::"
msgstr ""
"استفاده از :func:`set` بر روی دنباله، عناصر تکراری را حذف می کند. استفاده "
"از :func:`sorted` به همراه :func:`set` بر روی یک دنباله، روشی ایدئوماتیک "
"برای پیمایش بر روی عناصر منحصر به فرد دنباله به صورت مرتب شده است. ::"

#: ../../tutorial/datastructures.rst:630
msgid ""
">>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n"
">>> for f in sorted(set(basket)):\n"
"...     print(f)\n"
"...\n"
"apple\n"
"banana\n"
"orange\n"
"pear"
msgstr ""
">>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n"
">>> for f in sorted(set(basket)):\n"
"...     print(f)\n"
"...\n"
"apple\n"
"banana\n"
"orange\n"
"pear"

#: ../../tutorial/datastructures.rst:639
msgid ""
"It is sometimes tempting to change a list while you are looping over it; "
"however, it is often simpler and safer to create a new list instead. ::"
msgstr ""
"گاهی وسوسه انگیز است که هنگام پیمایش یک لیست، آن را تغییر دهید؛ اما اغلب "
"ساده تر و ایمن تر است که به جای آن یک لیست جدید ایجاد کنید. ::"

#: ../../tutorial/datastructures.rst:642
msgid ""
">>> import math\n"
">>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]\n"
">>> filtered_data = []\n"
">>> for value in raw_data:\n"
"...     if not math.isnan(value):\n"
"...         filtered_data.append(value)\n"
"...\n"
">>> filtered_data\n"
"[56.2, 51.7, 55.3, 52.5, 47.8]"
msgstr ""
">>> import math\n"
">>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]\n"
">>> filtered_data = []\n"
">>> for value in raw_data:\n"
"...     if not math.isnan(value):\n"
"...         filtered_data.append(value)\n"
"...\n"
">>> filtered_data\n"
"[56.2, 51.7, 55.3, 52.5, 47.8]"

#: ../../tutorial/datastructures.rst:656
msgid "More on Conditions"
msgstr "بیشتر درباره شرایط"

#: ../../tutorial/datastructures.rst:658
msgid ""
"The conditions used in ``while`` and ``if`` statements can contain any "
"operators, not just comparisons."
msgstr ""
"شرایط استفاده شده در دستورات ``while`` و ``if`` می توانند شامل هر گونه "
"عملگرها باشند، نه فقط مقایسه ها."

#: ../../tutorial/datastructures.rst:662
msgid ""
"The comparison operators ``in`` and ``not in`` are membership tests that "
"determine whether a value is in (or not in) a container.  The operators "
"``is`` and ``is not`` compare whether two objects are really the same "
"object.  All comparison operators have the same priority, which is lower "
"than that of all numerical operators."
msgstr ""
"عملگرهای مقایسه ای ``in`` و ``not in`` تست های عضویت هستند که تعیین می کنند "
"آیا یک مقدار در یک محفظه وجود دارد یا خیر. عملگرهای ``is`` و ``is not`` "
"بررسی می کنند آیا دو شیء عملاً یک شیء واحد هستند یا خیر. تمام عملگرهای مقایسه "
"ای دارای اولویت یکسانی هستند که این اولویت کمتر از تمام عملگرهای عددی است."

#: ../../tutorial/datastructures.rst:668
msgid ""
"Comparisons can be chained.  For example, ``a < b == c`` tests whether ``a`` "
"is less than ``b`` and moreover ``b`` equals ``c``."
msgstr ""
"می توان مقایسه ها را به هم زنجیر کرد. به عنوان مثال، ``a < b == c`` بررسی می "
"کند که آیا ``a`` کمتر از ``b`` است و علاوه بر این ``b`` برابر با ``c`` می "
"باشد."

#: ../../tutorial/datastructures.rst:671
msgid ""
"Comparisons may be combined using the Boolean operators ``and`` and ``or``, "
"and the outcome of a comparison (or of any other Boolean expression) may be "
"negated with ``not``.  These have lower priorities than comparison "
"operators; between them, ``not`` has the highest priority and ``or`` the "
"lowest, so that ``A and not B or C`` is equivalent to ``(A and (not B)) or "
"C``. As always, parentheses can be used to express the desired composition."
msgstr ""
"مقایسه ها می توانند با استفاده از عملگرهای بولی ``and`` و ``or`` ترکیب شوند "
"و نتیجه یک مقایسه (یا هر عبارت بولی دیگر) می تواند با ``not`` منفی شود. این "
"ها اولویت کمتری نسبت به عملگرهای مقایسه دارند؛ بین آن ها، ``not`` بالاترین "
"اولویت و ``or`` پایین ترین اولویت را دارد، به طوری که ``A and not B or C`` "
"معادل ``(A and (not B)) or C`` است. همانطور که همیشه، پرانتزها می توانند "
"برای نشان دادن ترکیب مطلوب استفاده شوند."

#: ../../tutorial/datastructures.rst:678
msgid ""
"The Boolean operators ``and`` and ``or`` are so-called *short-circuit* "
"operators: their arguments are evaluated from left to right, and evaluation "
"stops as soon as the outcome is determined.  For example, if ``A`` and ``C`` "
"are true but ``B`` is false, ``A and B and C`` does not evaluate the "
"expression ``C``.  When used as a general value and not as a Boolean, the "
"return value of a short-circuit operator is the last evaluated argument."
msgstr ""
"عملگرهای بولی ``and`` و ``or`` به عنوان عملگرهای *short-circuit* شناخته می "
"شوند: آرگومان های آن ها از چپ به راست ارزیابی می شوند و ارزیابی به محض تعیین "
"نتیجه متوقف می شود. به عنوان مثال، اگر ``A`` و ``C`` درست باشند اما ``B`` "
"غلط باشد، ``A and B and C`` عبارت ``C`` را ارزیابی نمی کند. زمانی که به "
"عنوان یک مقدار عمومی و نه به عنوان بولی استفاده شوند، مقدار بازگشتی یک عملگر "
"*short-circuit* برابر با آخرین آرگومانی است که ارزیابی شده است."

#: ../../tutorial/datastructures.rst:685
msgid ""
"It is possible to assign the result of a comparison or other Boolean "
"expression to a variable.  For example, ::"
msgstr ""
"امکان انتساب نتیجه یک مقایسه یا دیگر عبارات بولی به یک متغیر وجود دارد. برای "
"مثال، ::"

#: ../../tutorial/datastructures.rst:688
msgid ""
">>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'\n"
">>> non_null = string1 or string2 or string3\n"
">>> non_null\n"
"'Trondheim'"
msgstr ""
">>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'\n"
">>> non_null = string1 or string2 or string3\n"
">>> non_null\n"
"'Trondheim'"

#: ../../tutorial/datastructures.rst:693
msgid ""
"Note that in Python, unlike C, assignment inside expressions must be done "
"explicitly with the :ref:`walrus operator <why-can-t-i-use-an-assignment-in-"
"an-expression>` ``:=``. This avoids a common class of problems encountered "
"in C programs: typing ``=`` in an expression when ``==`` was intended."
msgstr ""
"توجه داشته باشید که در پایتون، برخلاف زبان C، تخصیص در عبارات باید به صورت "
"صریح با :ref:`walrus operator <why-can-t-i-use-an-assignment-in-an-"
"expression>` ``:=`` انجام شود. این کار یک دسته مشکلات رایج در برنامه های C "
"را که به علت تایپ ``=`` در یک عبارت در زمانی رخ می دهد که ``==`` مورد نظر "
"بوده است، اجتناب می کند."

#: ../../tutorial/datastructures.rst:703
msgid "Comparing Sequences and Other Types"
msgstr "مقایسه ی دنباله ها و انواع دیگر"

#: ../../tutorial/datastructures.rst:704
msgid ""
"Sequence objects typically may be compared to other objects with the same "
"sequence type. The comparison uses *lexicographical* ordering: first the "
"first two items are compared, and if they differ this determines the outcome "
"of the comparison; if they are equal, the next two items are compared, and "
"so on, until either sequence is exhausted. If two items to be compared are "
"themselves sequences of the same type, the lexicographical comparison is "
"carried out recursively.  If all items of two sequences compare equal, the "
"sequences are considered equal. If one sequence is an initial sub-sequence "
"of the other, the shorter sequence is the smaller (lesser) one.  "
"Lexicographical ordering for strings uses the Unicode code point number to "
"order individual characters. Some examples of comparisons between sequences "
"of the same type::"
msgstr ""
"اشیاء دنباله ای معمولاً می توانند با دیگر اشیاء از همان نوع دنباله مقایسه "
"شوند. مقایسه از ترتیب *lexicographical* استفاده می کند: ابتدا دو آیتم اول "
"مقایسه می شوند و اگر متفاوت باشند، نتیجه مقایسه را تعیین می کند؛ اگر برابر "
"باشند، دو آیتم بعدی مقایسه می شوند و این روند ادامه می یابد تا زمانی که یکی "
"از دنباله ها تمام شود. اگر دو آیتمی که مقایسه می شوند خودشان دنباله هایی از "
"همان نوع باشند، مقایسه لغتنامه ای به صورت بازگشتی انجام می شود. اگر تمام "
"آیتم های دو دنباله برابر باشند، دنباله ها برابر در نظر گرفته می شوند. اگر یک "
"دنباله زیر-دنباله ابتدایی دیگری باشد، دنباله کوتاه تر کوچک تر در نظر گرفته "
"می شود. ترتیب لغتنامه ای برای رشته ها از شماره نقطه کد Unicode برای مرتب "
"سازی کاراکترهای فردی استفاده می کند. چند مثال از مقایسه بین  دنباله های از "
"همان نوع::"

#: ../../tutorial/datastructures.rst:716
msgid ""
"(1, 2, 3)              < (1, 2, 4)\n"
"[1, 2, 3]              < [1, 2, 4]\n"
"'ABC' < 'C' < 'Pascal' < 'Python'\n"
"(1, 2, 3, 4)           < (1, 2, 4)\n"
"(1, 2)                 < (1, 2, -1)\n"
"(1, 2, 3)             == (1.0, 2.0, 3.0)\n"
"(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)"
msgstr ""
"(1, 2, 3)              < (1, 2, 4)\n"
"[1, 2, 3]              < [1, 2, 4]\n"
"'ABC' < 'C' < 'Pascal' < 'Python'\n"
"(1, 2, 3, 4)           < (1, 2, 4)\n"
"(1, 2)                 < (1, 2, -1)\n"
"(1, 2, 3)             == (1.0, 2.0, 3.0)\n"
"(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)"

#: ../../tutorial/datastructures.rst:724
msgid ""
"Note that comparing objects of different types with ``<`` or ``>`` is legal "
"provided that the objects have appropriate comparison methods.  For example, "
"mixed numeric types are compared according to their numeric value, so 0 "
"equals 0.0, etc.  Otherwise, rather than providing an arbitrary ordering, "
"the interpreter will raise a :exc:`TypeError` exception."
msgstr ""
"توجه داشته باشید که مقایسه اشیاء از انواع مختلف با ``<`` یا ``>`` قانونی است "
"به شرطی که اشیاء روش های مقایسه مناسب داشته باشند. به عنوان مثال، انواع عددی "
"مختلط بر اساس مقدار عددی خود مقایسه می شوند، بنابراین 0 برابر 0.0 است و "
"غیره. در غیر این صورت، به جای ارائه یک ترتیب دلخواه، مفسر یک استثنا از نوع :"
"exc:`TypeError` ایجاد خواهد کرد."

#: ../../tutorial/datastructures.rst:732
msgid "Footnotes"
msgstr "پاورقی ها"

#: ../../tutorial/datastructures.rst:733
msgid ""
"Other languages may return the mutated object, which allows method chaining, "
"such as ``d->insert(\"a\")->remove(\"b\")->sort();``."
msgstr ""
"زبان های دیگر ممکن است شیء تغییر یافته را برگردانند که این امکان را فراهم می "
"کند که متدها به صورت زنجیره ای فراخوانی شوند، مانند ``d->insert(\"a\")-"
">remove(\"b\")->sort();``."
