# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-25 15:29+0000\n"
"PO-Revision-Date: 2023-05-24 02:15+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Persian (https://app.transifex.com/python-doc/teams/5390/"
"fa/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fa\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../library/functions.rst:5 ../../library/functions.rst:11
msgid "Built-in Functions"
msgstr "توابع پیش ساخته"

#: ../../library/functions.rst:7
msgid ""
"The Python interpreter has a number of functions and types built into it "
"that are always available.  They are listed here in alphabetical order."
msgstr ""
"مفسر پایتون دارای تعدادی function و type است که در آن بصورت built-in همیشه "
"در دسترس می‌باشند. آن‌ها در اینجا به ترتیب حروف الفبا فهرست شده اند."

#: ../../library/functions.rst:0
msgid "**A**"
msgstr "**A**"

#: ../../library/functions.rst:0
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: ../../library/functions.rst:0
msgid ":func:`aiter`"
msgstr ":func:`aiter`"

#: ../../library/functions.rst:0
msgid ":func:`all`"
msgstr ":func:`all`"

#: ../../library/functions.rst:0
msgid ":func:`anext`"
msgstr ":func:`anext`"

#: ../../library/functions.rst:0
msgid ":func:`any`"
msgstr ":func:`any`"

#: ../../library/functions.rst:0
msgid ":func:`ascii`"
msgstr ":func:`ascii`"

#: ../../library/functions.rst:0
msgid "**B**"
msgstr "**B**"

#: ../../library/functions.rst:0
msgid ":func:`bin`"
msgstr ":func:`bin`"

#: ../../library/functions.rst:0
msgid ":func:`bool`"
msgstr ":func:`bool`"

#: ../../library/functions.rst:0
msgid ":func:`breakpoint`"
msgstr ":func:`breakpoint`"

#: ../../library/functions.rst:0
msgid "|func-bytearray|_"
msgstr "|func-bytearray|_"

#: ../../library/functions.rst:0
msgid "|func-bytes|_"
msgstr "|func-bytes|_"

#: ../../library/functions.rst:0
msgid "**C**"
msgstr "**C**"

#: ../../library/functions.rst:0
msgid ":func:`callable`"
msgstr ":func:`callable`"

#: ../../library/functions.rst:0
msgid ":func:`chr`"
msgstr ":func:`chr`"

#: ../../library/functions.rst:0
msgid ":func:`classmethod`"
msgstr ":func:`classmethod`"

#: ../../library/functions.rst:0
msgid ":func:`compile`"
msgstr ":func:`compile`"

#: ../../library/functions.rst:0
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: ../../library/functions.rst:0
msgid "**D**"
msgstr "**D**"

#: ../../library/functions.rst:0
msgid ":func:`delattr`"
msgstr ":func:`delattr`"

#: ../../library/functions.rst:0
msgid "|func-dict|_"
msgstr "|func-dict|_"

#: ../../library/functions.rst:0
msgid ":func:`dir`"
msgstr ":func:`dir`"

#: ../../library/functions.rst:0
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: ../../library/functions.rst:0
msgid "**E**"
msgstr "**E**"

#: ../../library/functions.rst:0
msgid ":func:`enumerate`"
msgstr ":func:`enumerate`"

#: ../../library/functions.rst:0
msgid ":func:`eval`"
msgstr ":func:`eval`"

#: ../../library/functions.rst:0
msgid ":func:`exec`"
msgstr ":func:`exec`"

#: ../../library/functions.rst:0
msgid "**F**"
msgstr "**F**"

#: ../../library/functions.rst:0
msgid ":func:`filter`"
msgstr ":func:`filter`"

#: ../../library/functions.rst:0
msgid ":func:`float`"
msgstr ":func:`float`"

#: ../../library/functions.rst:0
msgid ":func:`format`"
msgstr ":func:`format`"

#: ../../library/functions.rst:0
msgid "|func-frozenset|_"
msgstr "|func-frozenset|_"

#: ../../library/functions.rst:0
msgid "**G**"
msgstr "**G**"

#: ../../library/functions.rst:0
msgid ":func:`getattr`"
msgstr ":func:`getattr`"

#: ../../library/functions.rst:0
msgid ":func:`globals`"
msgstr ":func:`globals`"

#: ../../library/functions.rst:0
msgid "**H**"
msgstr "**H**"

#: ../../library/functions.rst:0
msgid ":func:`hasattr`"
msgstr ":func:`hasattr`"

#: ../../library/functions.rst:0
msgid ":func:`hash`"
msgstr ":func:`hash`"

#: ../../library/functions.rst:0
msgid ":func:`help`"
msgstr ":func:`help`"

#: ../../library/functions.rst:0
msgid ":func:`hex`"
msgstr ":func:`hex`"

#: ../../library/functions.rst:0
msgid "**I**"
msgstr "**I**"

#: ../../library/functions.rst:0
msgid ":func:`id`"
msgstr ":func:`id`"

#: ../../library/functions.rst:0
msgid ":func:`input`"
msgstr ":func:`input`"

#: ../../library/functions.rst:0
msgid ":func:`int`"
msgstr ":func:`int`"

#: ../../library/functions.rst:0
msgid ":func:`isinstance`"
msgstr ":func:`isinstance`"

#: ../../library/functions.rst:0
msgid ":func:`issubclass`"
msgstr ":func:`issubclass`"

#: ../../library/functions.rst:0
msgid ":func:`iter`"
msgstr ":func:`iter`"

#: ../../library/functions.rst:0
msgid "**L**"
msgstr "**L**"

#: ../../library/functions.rst:0
msgid ":func:`len`"
msgstr ":func:`len`"

#: ../../library/functions.rst:0
msgid "|func-list|_"
msgstr "|func-list|_"

#: ../../library/functions.rst:0
msgid ":func:`locals`"
msgstr ":func:`locals`"

#: ../../library/functions.rst:0
msgid "**M**"
msgstr "**M**"

#: ../../library/functions.rst:0
msgid ":func:`map`"
msgstr ":func:`map`"

#: ../../library/functions.rst:0
msgid ":func:`max`"
msgstr ":func:`max`"

#: ../../library/functions.rst:0
msgid "|func-memoryview|_"
msgstr "|func-memoryview|_"

#: ../../library/functions.rst:0
msgid ":func:`min`"
msgstr ":func:`min`"

#: ../../library/functions.rst:0
msgid "**N**"
msgstr "**N**"

#: ../../library/functions.rst:0
msgid ":func:`next`"
msgstr ":func:`next`"

#: ../../library/functions.rst:0
msgid "**O**"
msgstr "**O**"

#: ../../library/functions.rst:0
msgid ":func:`object`"
msgstr ":func:`object`"

#: ../../library/functions.rst:0
msgid ":func:`oct`"
msgstr ":func:`oct`"

#: ../../library/functions.rst:0
msgid ":func:`open`"
msgstr ":func:`open`"

#: ../../library/functions.rst:0
msgid ":func:`ord`"
msgstr ":func:`ord`"

#: ../../library/functions.rst:0
msgid "**P**"
msgstr "**P**"

#: ../../library/functions.rst:0
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: ../../library/functions.rst:0
msgid ":func:`print`"
msgstr ":func:`print`"

#: ../../library/functions.rst:0
msgid ":func:`property`"
msgstr ":func:`property`"

#: ../../library/functions.rst:0
msgid "**R**"
msgstr ""
"\n"
"**R**"

#: ../../library/functions.rst:0
msgid "|func-range|_"
msgstr "|func-range|_"

#: ../../library/functions.rst:0
msgid ":func:`repr`"
msgstr ":func:`repr`"

#: ../../library/functions.rst:0
msgid ":func:`reversed`"
msgstr ":func:`reversed`"

#: ../../library/functions.rst:0
msgid ":func:`round`"
msgstr ":func:`round`"

#: ../../library/functions.rst:0
msgid "**S**"
msgstr "**S**"

#: ../../library/functions.rst:0
msgid "|func-set|_"
msgstr "|func-set|_"

#: ../../library/functions.rst:0
msgid ":func:`setattr`"
msgstr ":func:`setattr`"

#: ../../library/functions.rst:0
msgid ":func:`slice`"
msgstr ":func:`slice`"

#: ../../library/functions.rst:0
msgid ":func:`sorted`"
msgstr ":func:`sorted`"

#: ../../library/functions.rst:0
msgid ":func:`staticmethod`"
msgstr ":func:`staticmethod`"

#: ../../library/functions.rst:0
msgid "|func-str|_"
msgstr "|func-str|_"

#: ../../library/functions.rst:0
msgid ":func:`sum`"
msgstr ":func:`sum`"

#: ../../library/functions.rst:0
msgid ":func:`super`"
msgstr ":func:`super`"

#: ../../library/functions.rst:0
msgid "**T**"
msgstr "**T**"

#: ../../library/functions.rst:0
msgid "|func-tuple|_"
msgstr "|func-tuple|_"

#: ../../library/functions.rst:0
msgid ":func:`type`"
msgstr ":func:`type`"

#: ../../library/functions.rst:0
msgid "**V**"
msgstr "**V**"

#: ../../library/functions.rst:0
msgid ":func:`vars`"
msgstr ":func:`vars`"

#: ../../library/functions.rst:0
msgid "**Z**"
msgstr "**Z**"

#: ../../library/functions.rst:0
msgid ":func:`zip`"
msgstr ":func:`zip`"

#: ../../library/functions.rst:0
msgid "**_**"
msgstr "**_**"

#: ../../library/functions.rst:0
msgid ":func:`__import__`"
msgstr ":func:`__import__`"

#: ../../library/functions.rst:59
msgid ""
"Return the absolute value of a number.  The argument may be an integer, a "
"floating point number, or an object implementing :meth:`~object.__abs__`. If "
"the argument is a complex number, its magnitude is returned."
msgstr ""

#: ../../library/functions.rst:67
msgid ""
"Return an :term:`asynchronous iterator` for an :term:`asynchronous "
"iterable`. Equivalent to calling ``x.__aiter__()``."
msgstr ""
"بازگرداندن یک :term:`asynchronous iterator` برای یک :term:`asynchronous "
"iterable`. معادل فراخوانی ``x.__aiter__()`` است."

#: ../../library/functions.rst:70
msgid "Note: Unlike :func:`iter`, :func:`aiter` has no 2-argument variant."
msgstr "توجه: برخلاف :func:`iter`، :func:`aiter` نسخه دو آرگومانی ندارد."

#: ../../library/functions.rst:76
msgid ""
"Return ``True`` if all elements of the *iterable* are true (or if the "
"iterable is empty).  Equivalent to::"
msgstr ""
"در صورتی که تمام عناصر *iterable* درست باشند (یا اگر iterable خالی باشد)، "
"``True`` را برمی گرداند. معادل با::"

#: ../../library/functions.rst:89
msgid ""
"When awaited, return the next item from the given :term:`asynchronous "
"iterator`, or *default* if given and the iterator is exhausted."
msgstr ""
"هنگامی که انتظار می رود، آیتم بعدی را از :term:`asynchronous iterator` مشخص "
"شده برگردانید، یا *default* اگر داده شده و پیمایش گر تمام شده باشد."

#: ../../library/functions.rst:92
msgid ""
"This is the async variant of the :func:`next` builtin, and behaves similarly."
msgstr "این نسخه ناهمگام از :func:`next` داخلی است، و به طور مشابه عمل می کند."

#: ../../library/functions.rst:95
msgid ""
"This calls the :meth:`~object.__anext__` method of *async_iterator*, "
"returning an :term:`awaitable`. Awaiting this returns the next value of the "
"iterator. If *default* is given, it is returned if the iterator is "
"exhausted, otherwise :exc:`StopAsyncIteration` is raised."
msgstr ""
"این، متد :meth:`~object.__anext__` از *async_iterator* را فراخوانی می کند و "
"یک :term:`awaitable` برمی گرداند. منتظر ماندن برای این، مقدار بعدی تکرارگر "
"را برمی گرداند. اگر *default* داده شود، در صورت اتمام تکرارگر، آن برگردانده "
"می شود و در غیر این صورت :exc:`StopAsyncIteration` برانگیخته می شود."

#: ../../library/functions.rst:104
msgid ""
"Return ``True`` if any element of the *iterable* is true.  If the iterable "
"is empty, return ``False``.  Equivalent to::"
msgstr ""
"اگر هر عنصری از *iterable* درست باشد، ``True`` را برگردانید. اگر iterable "
"خالی باشد، ``False`` را برگردانید. معادل با::"

#: ../../library/functions.rst:116
msgid ""
"As :func:`repr`, return a string containing a printable representation of an "
"object, but escape the non-ASCII characters in the string returned by :func:"
"`repr` using ``\\x``, ``\\u``, or ``\\U`` escapes.  This generates a string "
"similar to that returned by :func:`repr` in Python 2."
msgstr ""
"به عنوان :func:`repr`، یک رشته که نمایشی قابل چاپ از یک شیء است را برمی "
"گرداند، اما کاراکترهای غیر ASCII در رشته برگشتی توسط :func:`repr` را با "
"فرارهای ``\\x``، ``\\u``، یا ``\\U`` فرار دهید. این رشته ای شبیه به آنچه "
"توسط :func:`repr` در پایتون 2 برگردانده می شود را تولید می کند."

#: ../../library/functions.rst:124
msgid ""
"Convert an integer number to a binary string prefixed with \"0b\". The "
"result is a valid Python expression. If *x* is not a Python :class:`int` "
"object, it has to define an :meth:`~object.__index__` method that returns an "
"integer. Some examples:"
msgstr ""
"تبدیل یک عدد صحیح به یک رشته باینری که با \"0b\" پیشوند شده است. نتیجه یک "
"عبارت معتبر پایتون خواهد بود. اگر *x* یک شیء پایتون :class:`int` نباشد، لازم "
"است یک متد :meth:`~object.__index__` تعریف کند که یک عدد صحیح برگرداند. برخی "
"مثال ها:"

#: ../../library/functions.rst:134
msgid ""
"If the prefix \"0b\" is desired or not, you can use either of the following "
"ways."
msgstr ""
"اگر پیشوند \"0b\" مورد نظر است یا خیر، می توانید از هر یک از روش های زیر "
"استفاده کنید."

#: ../../library/functions.rst:141 ../../library/functions.rst:844
#: ../../library/functions.rst:1162
msgid "See also :func:`format` for more information."
msgstr "برای اطلاعات بیشتر به :func:`format` مراجعه کنید."

#: ../../library/functions.rst:146
msgid ""
"Return a Boolean value, i.e. one of ``True`` or ``False``.  *x* is converted "
"using the standard :ref:`truth testing procedure <truth>`.  If *x* is false "
"or omitted, this returns ``False``; otherwise, it returns ``True``.  The :"
"class:`bool` class is a subclass of :class:`int` (see :ref:`typesnumeric`). "
"It cannot be subclassed further.  Its only instances are ``False`` and "
"``True`` (see :ref:`bltin-boolean-values`)."
msgstr ""

#: ../../library/functions.rst:155 ../../library/functions.rst:709
#: ../../library/functions.rst:933
msgid "*x* is now a positional-only parameter."
msgstr ""

#: ../../library/functions.rst:160
msgid ""
"This function drops you into the debugger at the call site.  Specifically, "
"it calls :func:`sys.breakpointhook`, passing ``args`` and ``kws`` straight "
"through.  By default, ``sys.breakpointhook()`` calls :func:`pdb.set_trace()` "
"expecting no arguments.  In this case, it is purely a convenience function "
"so you don't have to explicitly import :mod:`pdb` or type as much code to "
"enter the debugger.  However, :func:`sys.breakpointhook` can be set to some "
"other function and :func:`breakpoint` will automatically call that, allowing "
"you to drop into the debugger of choice. If :func:`sys.breakpointhook` is "
"not accessible, this function will raise :exc:`RuntimeError`."
msgstr ""

#: ../../library/functions.rst:172
msgid ""
"By default, the behavior of :func:`breakpoint` can be changed with the :"
"envvar:`PYTHONBREAKPOINT` environment variable. See :func:`sys."
"breakpointhook` for usage details."
msgstr ""
"به  طور پیش فرض، رفتار :func:`breakpoint` می تواند با متغیر محیطی :envvar:"
"`PYTHONBREAKPOINT` تغییر کند. برای جزئیات استفاده، به :func:`sys."
"breakpointhook` مراجعه کنید."

#: ../../library/functions.rst:176
msgid ""
"Note that this is not guaranteed if :func:`sys.breakpointhook` has been "
"replaced."
msgstr ""
"توجه داشته باشید که این موضوع تضمین نمی شود اگر :func:`sys.breakpointhook` "
"جایگزین شده باشد."

#: ../../library/functions.rst:179
msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.breakpoint`` with "
"argument ``breakpointhook``."
msgstr ""
"یک :ref:`auditing event <auditing>` ``builtins.breakpoint`` با آرگومان "
"``breakpointhook`` ایجاد می کند."

#: ../../library/functions.rst:189
msgid ""
"Return a new array of bytes.  The :class:`bytearray` class is a mutable "
"sequence of integers in the range 0 <= x < 256.  It has most of the usual "
"methods of mutable sequences, described in :ref:`typesseq-mutable`, as well "
"as most methods that the :class:`bytes` type has, see :ref:`bytes-methods`."
msgstr ""
"یک آرایه بایتی جدید برمی گرداند. کلاس :class:`bytearray` یک دنباله قابل "
"تغییر از اعداد صحیح در محدوده 0 <= x < 256 است. این کلاس اکثر روش های معمول "
"دنباله های قابل تغییر را دارد که در :ref:`typesseq-mutable` توضیح داده شده "
"اند و همچنین بیشتر روش هایی که نوع :class:`bytes` دارد را داراست، به :ref:"
"`bytes-methods` مراجعه کنید."

#: ../../library/functions.rst:194
msgid ""
"The optional *source* parameter can be used to initialize the array in a few "
"different ways:"
msgstr ""
"پارامتر اختیاری *source* می تواند برای مقداردهی اولیه آرایه به چند روش مختلف "
"استفاده شود:"

#: ../../library/functions.rst:197
msgid ""
"If it is a *string*, you must also give the *encoding* (and optionally, "
"*errors*) parameters; :func:`bytearray` then converts the string to bytes "
"using :meth:`str.encode`."
msgstr ""
"اگر یک *string* باشد، شما باید همچنین پارامترهای *encoding* (و به طور "
"اختیاری، *errors*) را ارائه دهید؛ سپس :func:`bytearray` رشته را با استفاده "
"از :meth:`str.encode` به بایت تبدیل می کند."

#: ../../library/functions.rst:201
msgid ""
"If it is an *integer*, the array will have that size and will be initialized "
"with null bytes."
msgstr ""
"اگر یک *integer* باشد، آرایه به آن اندازه خواهد بود و با بایت های خالی "
"مقداردهی اولیه می شود."

#: ../../library/functions.rst:204
msgid ""
"If it is an object conforming to the :ref:`buffer interface "
"<bufferobjects>`, a read-only buffer of the object will be used to "
"initialize the bytes array."
msgstr ""
"اگر این یک شیء مطابق با :ref:`buffer interface <bufferobjects>` باشد، یک "
"بافر فقط خواندنی از شیء برای مقداردهی اولیه آرایه bytes استفاده خواهد شد."

#: ../../library/functions.rst:207
msgid ""
"If it is an *iterable*, it must be an iterable of integers in the range ``0 "
"<= x < 256``, which are used as the initial contents of the array."
msgstr ""
"اگر یک *iterable* باشد، باید یک تکرارشونده از اعداد صحیح در بازه ``0 <= x < "
"256`` باشد که به عنوان محتوای اولیه آرایه استفاده می شود."

#: ../../library/functions.rst:210
msgid "Without an argument, an array of size 0 is created."
msgstr "بدون آرگومان، یک آرایه با اندازه 0 ایجاد می شود."

#: ../../library/functions.rst:212
msgid "See also :ref:`binaryseq` and :ref:`typebytearray`."
msgstr "همچنین ببینید :ref:`binaryseq` و :ref:`typebytearray`."

#: ../../library/functions.rst:221
msgid ""
"Return a new \"bytes\" object which is an immutable sequence of integers in "
"the range ``0 <= x < 256``.  :class:`bytes` is an immutable version of :"
"class:`bytearray` -- it has the same non-mutating methods and the same "
"indexing and slicing behavior."
msgstr ""
"یک شیء جدید \"bytes\" بازگردانید که دنباله ای غیرقابل تغییر از اعداد صحیح در "
"محدوده ``0 <= x < 256`` است. :class:`bytes` نسخه غیرقابل تغییر از :class:"
"`bytearray` است -- دارای همان روش های غیرقابل تغییر و همان رفتار ایندکس بندی "
"و برش است."

#: ../../library/functions.rst:226
msgid ""
"Accordingly, constructor arguments are interpreted as for :func:`bytearray`."
msgstr "بنابراین، آرگومان های سازنده مثل :func:`bytearray` تفسیر می شوند."

#: ../../library/functions.rst:228
msgid "Bytes objects can also be created with literals, see :ref:`strings`."
msgstr ""
"شیء های بایت همچنین می توانند با استفاده از لیترال ها ایجاد شوند، به :ref:"
"`strings` مراجعه کنید."

#: ../../library/functions.rst:230
msgid "See also :ref:`binaryseq`, :ref:`typebytes`, and :ref:`bytes-methods`."
msgstr ""
"همچنین ببینید :ref:`binaryseq`، :ref:`typebytes`، و :ref:`bytes-methods`."

#: ../../library/functions.rst:235
msgid ""
"Return :const:`True` if the *object* argument appears callable, :const:"
"`False` if not.  If this returns ``True``, it is still possible that a call "
"fails, but if it is ``False``, calling *object* will never succeed. Note "
"that classes are callable (calling a class returns a new instance); "
"instances are callable if their class has a :meth:`~object.__call__` method."
msgstr ""
"برمی گرداند :const:`True` اگر آرگومان *object* قابل فراخوانی به نظر برسد، :"
"const:`False` اگر نه. اگر این ``True`` برگرداند، هنوز ممکن است که یک "
"فراخوانی شکست بخورد، اما اگر ``False`` باشد، فراخوانی *object* هرگز موفق "
"نخواهد شد. توجه داشته باشید که کلاس ها قابل فراخوانی هستند (فراخوانی یک کلاس "
"یک نمونه جدید برمی گرداند)؛ نمونه ها قابل فراخوانی هستند اگر کلاس آن ها یک "
"متد :meth:`~object.__call__` داشته باشد."

#: ../../library/functions.rst:241
msgid ""
"This function was first removed in Python 3.0 and then brought back in "
"Python 3.2."
msgstr "این تابع ابتدا در پایتون 3.0 حذف شد و سپس در پایتون 3.2 بازگردانده شد."

#: ../../library/functions.rst:248
msgid ""
"Return the string representing a character whose Unicode code point is the "
"integer *i*.  For example, ``chr(97)`` returns the string ``'a'``, while "
"``chr(8364)`` returns the string ``'€'``. This is the inverse of :func:`ord`."
msgstr ""
"رشته ای را برگردانید که نمایانگر کاراکتری باشد که نقطه کد یونیکد آن عدد صحیح "
"*i* است. به عنوان مثال، ``chr(97)`` رشته ``'a'`` را برمی گرداند، درحالی که "
"``chr(8364)`` رشته ``'€'`` را برمی گرداند. این عملکرد معکوس :func:`ord` است."

#: ../../library/functions.rst:252
msgid ""
"The valid range for the argument is from 0 through 1,114,111 (0x10FFFF in "
"base 16).  :exc:`ValueError` will be raised if *i* is outside that range."
msgstr ""
"محدوده معتبر برای آرگومان از 0 تا 1,114,111 (0x10FFFF در مبنای 16) است. :exc:"
"`ValueError` زمانی که *i* خارج از آن محدوده باشد، ایجاد خواهد شد."

#: ../../library/functions.rst:258
msgid "Transform a method into a class method."
msgstr "تبدیل یک متد به یک متد کلاسی."

#: ../../library/functions.rst:260
msgid ""
"A class method receives the class as an implicit first argument, just like "
"an instance method receives the instance. To declare a class method, use "
"this idiom::"
msgstr ""
"یک متد کلاس، کلاس را به عنوان اولین آرگومان ضمنی دریافت می کند، درست همانطور "
"که یک متد نمونه، نمونه را دریافت می کند. برای اعلام یک متد کلاس از این روش "
"استفاده کنید:"

#: ../../library/functions.rst:268
msgid ""
"The ``@classmethod`` form is a function :term:`decorator` -- see :ref:"
"`function` for details."
msgstr ""
"فرم ``@classmethod`` یک تابع :term:`decorator` است -- برای جزئیات بیشتر به :"
"ref:`function` مراجعه کنید."

#: ../../library/functions.rst:271
msgid ""
"A class method can be called either on the class (such as ``C.f()``) or on "
"an instance (such as ``C().f()``).  The instance is ignored except for its "
"class. If a class method is called for a derived class, the derived class "
"object is passed as the implied first argument."
msgstr ""
"یک متد کلاسی می تواند یا بر روی کلاس (مانند ``C.f()``) و یا بر روی یک نمونه "
"(مانند ``C().f()``) فراخوانی شود. نمونه نادیده گرفته می شود به جز کلاس آن. "
"اگر یک متد کلاسی برای یک کلاس مشتق شده فراخوانی شود، شیء کلاس مشتق شده به "
"عنوان آرگومان اول ضمنی ارسال می شود."

#: ../../library/functions.rst:276
msgid ""
"Class methods are different than C++ or Java static methods. If you want "
"those, see :func:`staticmethod` in this section. For more information on "
"class methods, see :ref:`types`."
msgstr ""
"متدهای کلاس با متدهای استاتیک C++ یا جاوا متفاوت هستند. اگر به دنبال آن ها "
"هستید، به :func:`staticmethod` در این بخش مراجعه کنید. برای اطلاعات بیشتر در "
"مورد متدهای کلاس، به :ref:`types` مراجعه کنید."

#: ../../library/functions.rst:280
msgid ""
"Class methods can now wrap other :term:`descriptors <descriptor>` such as :"
"func:`property`."
msgstr ""
"متدهای کلاس اکنون می توانند سایر :term:`descriptors <descriptor>` ها مانند :"
"func:`property` را پوشش دهند."

#: ../../library/functions.rst:284
msgid ""
"Class methods now inherit the method attributes (``__module__``, "
"``__name__``, ``__qualname__``, ``__doc__`` and ``__annotations__``) and "
"have a new ``__wrapped__`` attribute."
msgstr ""

#: ../../library/functions.rst:289
msgid ""
"Class methods can no longer wrap other :term:`descriptors <descriptor>` such "
"as :func:`property`."
msgstr ""
"روش های کلاس دیگر نمی توانند :term:`descriptors <descriptor>` دیگری مانند :"
"func:`property` را بپیچند."

#: ../../library/functions.rst:296
msgid ""
"Compile the *source* into a code or AST object.  Code objects can be "
"executed by :func:`exec` or :func:`eval`.  *source* can either be a normal "
"string, a byte string, or an AST object.  Refer to the :mod:`ast` module "
"documentation for information on how to work with AST objects."
msgstr ""
"*source* را به یک شیء کد یا AST کامپایل کنید. اشیاء کد می توانند توسط :func:"
"`exec` یا :func:`eval` اجرا شوند. *source* می تواند یک رشته معمولی، یک رشته "
"بایت یا یک شیء AST باشد. به مستندات ماژول :mod:`ast` برای اطلاعاتی درباره "
"نحوه کار با اشیاء AST مراجعه کنید."

#: ../../library/functions.rst:301
msgid ""
"The *filename* argument should give the file from which the code was read; "
"pass some recognizable value if it wasn't read from a file (``'<string>'`` "
"is commonly used)."
msgstr ""
"استدلال *filename* باید فایل را که کد از آن خوانده شده است، فراهم کند؛ اگر "
"از یک فایل خوانده نشده است، یک مقدار قابل شناسایی را ارسال کنید (معمولاً "
"``'<string>'`` استفاده می شود)."

#: ../../library/functions.rst:305
msgid ""
"The *mode* argument specifies what kind of code must be compiled; it can be "
"``'exec'`` if *source* consists of a sequence of statements, ``'eval'`` if "
"it consists of a single expression, or ``'single'`` if it consists of a "
"single interactive statement (in the latter case, expression statements that "
"evaluate to something other than ``None`` will be printed)."
msgstr ""
"آرگومان *mode* تعیین می کند که چه نوع کدی باید کامپایل شود؛ می تواند "
"``'exec'`` باشد اگر *source* شامل یک دنباله از دستورها باشد، ``'eval'`` باشد "
"اگر شامل یک عبارت منفرد باشد، یا ``'single'`` باشد اگر که شامل یک دستور "
"تعاملی منفرد باشد (در حالت آخر، عبارت هایی که به چیزی جز ``None`` ارزیابی می "
"شوند چاپ خواهند شد)."

#: ../../library/functions.rst:311
msgid ""
"The optional arguments *flags* and *dont_inherit* control which :ref:"
"`compiler options <ast-compiler-flags>` should be activated and which :ref:"
"`future features <future>` should be allowed. If neither is present (or both "
"are zero) the code is compiled with the same flags that affect the code that "
"is calling :func:`compile`. If the *flags* argument is given and "
"*dont_inherit* is not (or is zero) then the compiler options and the future "
"statements specified by the *flags* argument are used in addition to those "
"that would be used anyway. If *dont_inherit* is a non-zero integer then the "
"*flags* argument is it -- the flags (future features and compiler options) "
"in the surrounding code are ignored."
msgstr ""
"آرگومان های اختیاری *flags* و *dont_inherit* کنترل می کنند که کدام :ref:"
"`compiler options <ast-compiler-flags>` باید فعال شود و کدام :ref:`future "
"features <future>` باید مجاز باشد. اگر هیچ کدام حضور نداشته باشند (یا هر دو "
"صفر باشند) کد با همان پرچم هایی که بر کدی که :func:`compile` را فراخوانی می "
"کند تأثیر می گذارند، کامپایل می شود. اگر آرگومان *flags* داده شود و "
"*dont_inherit* داده نشود (یا صفر باشد) آنگاه گزینه های کامپایلر و دستورات "
"آینده ای که توسط آرگومان *flags* مشخص شده اند، علاوه بر آنهایی که به هر حال "
"استفاده می شوند، به کار می روند. اگر *dont_inherit* عددی غیرصفر باشد، آنگاه "
"آرگومان *flags* آن است -- پرچم های (ویژگی های آینده و گزینه های کامپایلر) در "
"کد اطراف نادیده گرفته می شوند."

#: ../../library/functions.rst:322
msgid ""
"Compiler options and future statements are specified by bits which can be "
"bitwise ORed together to specify multiple options. The bitfield required to "
"specify a given future feature can be found as the :attr:`~__future__."
"_Feature.compiler_flag` attribute on the :class:`~__future__._Feature` "
"instance in the :mod:`__future__` module. :ref:`Compiler flags <ast-compiler-"
"flags>` can be found in :mod:`ast` module, with ``PyCF_`` prefix."
msgstr ""
"گزینه های کامپایلر و بیانیه های آینده با بیت هایی مشخص می شوند که می توان آن "
"ها را با عملگر OR بیتی به هم الحاق کرد تا گزینه های متعددی مشخص شوند. فیلد "
"بیتی موردنیاز برای مشخص کردن یک ویژگی آینده مشخص به صورت خاصیت :attr:"
"`~__future__._Feature.compiler_flag` بر روی نمونه :class:`~__future__."
"_Feature` در ماژول :mod:`__future__` یافت می شود. :ref:`Compiler flags <ast-"
"compiler-flags>` در ماژول :mod:`ast` با پیش وند ``PyCF_`` یافت می شود."

#: ../../library/functions.rst:330
msgid ""
"The argument *optimize* specifies the optimization level of the compiler; "
"the default value of ``-1`` selects the optimization level of the "
"interpreter as given by :option:`-O` options.  Explicit levels are ``0`` (no "
"optimization; ``__debug__`` is true), ``1`` (asserts are removed, "
"``__debug__`` is false) or ``2`` (docstrings are removed too)."
msgstr ""
"*optimize* این پارامتر سطح بهینه سازی کامپایلر را مشخص می کند؛ مقدار پیش فرض "
"``-1`` سطح بهینه سازی مفسر را به روشی که توسط :option:`-O` گزینه ها داده "
"شده، انتخاب می کند. سطوح صریح عبارتند از ``0`` (بدون بهینه سازی؛ "
"``__debug__`` درست است)، ``1`` (assertها حذف شده، ``__debug__`` نادرست است) "
"یا ``2`` (docstrings نیز حذف می شوند)."

#: ../../library/functions.rst:336
msgid ""
"This function raises :exc:`SyntaxError` if the compiled source is invalid, "
"and :exc:`ValueError` if the source contains null bytes."
msgstr ""
"این تابع :exc:`SyntaxError` را در صورتی که کد منبع کامپایل شده نامعتبر باشد، "
"و :exc:`ValueError` را اگر منبع شامل بایت های null باشد، برمی گرداند."

#: ../../library/functions.rst:339
msgid ""
"If you want to parse Python code into its AST representation, see :func:`ast."
"parse`."
msgstr ""
"اگر می خواهید کد پایتون را به نمایش AST آن تجزیه کنید، :func:`ast.parse` را "
"ببینید."

#: ../../library/functions.rst:342
msgid ""
"Raises an :ref:`auditing event <auditing>` ``compile`` with arguments "
"``source``, ``filename``."
msgstr ""

#: ../../library/functions.rst:344
msgid ""
"Raises an :ref:`auditing event <auditing>` ``compile`` with arguments "
"``source`` and ``filename``. This event may also be raised by implicit "
"compilation."
msgstr ""
"یک :ref:`auditing event <auditing>` ``compile`` با آرگومان های ``source`` و "
"``filename`` مطرح می شود. این رویداد ممکن است توسط کامپایل ضمنی نیز مطرح شود."

#: ../../library/functions.rst:350
msgid ""
"When compiling a string with multi-line code in ``'single'`` or ``'eval'`` "
"mode, input must be terminated by at least one newline character.  This is "
"to facilitate detection of incomplete and complete statements in the :mod:"
"`code` module."
msgstr ""
"هنگام کامپایل کردن یک رشته با کد چندخطی در حالت ``'single'`` یا ``'eval'``، "
"ورودی باید حداقل با یک کاراکتر newline خاتمه یابد. این کار به منظور تسهیل "
"تشخیص جملات ناقص و کامل در ماژول :mod:`code` است."

#: ../../library/functions.rst:357
msgid ""
"It is possible to crash the Python interpreter with a sufficiently large/"
"complex string when compiling to an AST object due to stack depth "
"limitations in Python's AST compiler."
msgstr ""
"ممکن است با یک رشته به اندازه کافی بزرگ/پیچیده، مفسر پایتون را هنگام کامپایل "
"به یک شیء AST به دلیل محدودیت های عمق پشته در کامپایلر AST پایتون از کار "
"بیاندازید."

#: ../../library/functions.rst:361
msgid ""
"Allowed use of Windows and Mac newlines.  Also, input in ``'exec'`` mode "
"does not have to end in a newline anymore.  Added the *optimize* parameter."
msgstr ""
"استفاده از خط جدید ویندوز و مک مجاز است. همچنین، ورودی در حالت ``'exec'`` "
"لازم نیست با یک خط جدید پایان یابد. پارامتر *optimize* اضافه شده است."

#: ../../library/functions.rst:365
msgid ""
"Previously, :exc:`TypeError` was raised when null bytes were encountered in "
"*source*."
msgstr ""
"قبلاً، :exc:`TypeError` زمانی افزایش می یافت که بایت های نال در *source* "
"مشاهده می شدند."

#: ../../library/functions.rst:369
msgid ""
"``ast.PyCF_ALLOW_TOP_LEVEL_AWAIT`` can now be passed in flags to enable "
"support for top-level ``await``, ``async for``, and ``async with``."
msgstr ""
"می توان ``ast.PyCF_ALLOW_TOP_LEVEL_AWAIT`` را اکنون در پرچم ها برای فعال "
"کردن پشتیبانی از ``await``، ``async for``، و ``async with`` در سطح بالا "
"گذراند."

#: ../../library/functions.rst:377
msgid ""
"Return a complex number with the value *real* + *imag*\\*1j or convert a "
"string or number to a complex number.  If the first parameter is a string, "
"it will be interpreted as a complex number and the function must be called "
"without a second parameter.  The second parameter can never be a string. "
"Each argument may be any numeric type (including complex).  If *imag* is "
"omitted, it defaults to zero and the constructor serves as a numeric "
"conversion like :class:`int` and :class:`float`.  If both arguments are "
"omitted, returns ``0j``."
msgstr ""

#: ../../library/functions.rst:386
msgid ""
"For a general Python object ``x``, ``complex(x)`` delegates to ``x."
"__complex__()``.  If :meth:`~object.__complex__` is not defined then it "
"falls back to :meth:`~object.__float__`.  If :meth:`!__float__` is not "
"defined then it falls back to :meth:`~object.__index__`."
msgstr ""

#: ../../library/functions.rst:393
msgid ""
"When converting from a string, the string must not contain whitespace around "
"the central ``+`` or ``-`` operator.  For example, ``complex('1+2j')`` is "
"fine, but ``complex('1 + 2j')`` raises :exc:`ValueError`."
msgstr ""

#: ../../library/functions.rst:398
msgid "The complex type is described in :ref:`typesnumeric`."
msgstr "نوع complex در :ref:`typesnumeric` توضیح داده شده است."

#: ../../library/functions.rst:400 ../../library/functions.rst:706
#: ../../library/functions.rst:930
msgid "Grouping digits with underscores as in code literals is allowed."
msgstr "از خط تیره برای جداسازی اعداد در نمایه های کد می توان استفاده کرد."

#: ../../library/functions.rst:403
msgid ""
"Falls back to :meth:`~object.__index__` if :meth:`~object.__complex__` and :"
"meth:`~object.__float__` are not defined."
msgstr ""
"به :meth:`~object.__index__` برمی گردد اگر :meth:`~object.__complex__` و :"
"meth:`~object.__float__` تعریف نشده باشند."

#: ../../library/functions.rst:410
msgid ""
"This is a relative of :func:`setattr`.  The arguments are an object and a "
"string.  The string must be the name of one of the object's attributes.  The "
"function deletes the named attribute, provided the object allows it.  For "
"example, ``delattr(x, 'foobar')`` is equivalent to ``del x.foobar``. *name* "
"need not be a Python identifier (see :func:`setattr`)."
msgstr ""
"این یک خویشاوند از :func:`setattr` است. آرگومان ها یک شیء و یک رشته هستند. "
"رشته باید نام یکی از ویژگی های شیء باشد. تابع ویژگی نام گذاری شده را حذف می "
"کند، به شرطی که شیء این اجازه را بدهد. به عنوان مثال، ``delattr(x, "
"'foobar')`` معادل ``del x.foobar`` است.  *name* نیازی نیست که یک شناسگر "
"پایتون باشد (به :func:`setattr` مراجعه کنید)."

#: ../../library/functions.rst:423
msgid ""
"Create a new dictionary.  The :class:`dict` object is the dictionary class. "
"See :class:`dict` and :ref:`typesmapping` for documentation about this class."
msgstr ""
"یک دیکشنری جدید ایجاد کنید. شیء :class:`dict` کلاس دیکشنری است. برای مستندات "
"مربوط به این کلاس به :class:`dict` و :ref:`typesmapping` مراجعه کنید."

#: ../../library/functions.rst:426
msgid ""
"For other containers see the built-in :class:`list`, :class:`set`, and :"
"class:`tuple` classes, as well as the :mod:`collections` module."
msgstr ""
"برای سایر کانتینرها به کلاس های داخلی :class:`list`، :class:`set` و :class:"
"`tuple`، و همچنین ماژول :mod:`collections` مراجعه کنید."

#: ../../library/functions.rst:433
msgid ""
"Without arguments, return the list of names in the current local scope.  "
"With an argument, attempt to return a list of valid attributes for that "
"object."
msgstr ""
"اگر بدون آرگومان استفاده شود، لیستی از نام ها در حوزه محلی جاری را برمی "
"گرداند. اگر با یک آرگومان استفاده شود، تلاش می کند تا لیستی از ویژگی های "
"معتبر برای آن شی را برگرداند."

#: ../../library/functions.rst:436
msgid ""
"If the object has a method named :meth:`~object.__dir__`, this method will "
"be called and must return the list of attributes. This allows objects that "
"implement a custom :func:`~object.__getattr__` or :func:`~object."
"__getattribute__` function to customize the way :func:`dir` reports their "
"attributes."
msgstr ""
"اگر شیء دارای متدی به نام :meth:`~object.__dir__` باشد، این متد فراخوانی شده "
"و باید لیستی از ویژگی ها را برگرداند. این امکان را فراهم می کند که اشیایی که "
"یک تابع :func:`~object.__getattr__` یا :func:`~object.__getattribute__` "
"سفارشی را پیاده سازی کرده اند، بتوانند نحوه گزارش ویژگی های خود توسط :func:"
"`dir` را سفارشی سازی کنند."

#: ../../library/functions.rst:443
msgid ""
"If the object does not provide :meth:`~object.__dir__`, the function tries "
"its best to gather information from the object's :attr:`~object.__dict__` "
"attribute, if defined, and from its type object.  The resulting list is not "
"necessarily complete and may be inaccurate when the object has a custom :"
"func:`~object.__getattr__`."
msgstr ""
"اگر شیء :meth:`~object.__dir__` را ارائه ندهد، تابع تمام تلاش خود را می کند "
"تا اطلاعات لازم را از ویژگی :attr:`~object.__dict__` شیء، در صورتی که تعریف "
"شده باشد، و از شیء نوع آن جمع آوری کند. لیستی که به دست می آید لزوماً کامل "
"نیست و ممکن است زمانی که شیء دارای :func:`~object.__getattr__` سفارشی باشد، "
"نادرست باشد."

#: ../../library/functions.rst:449
msgid ""
"The default :func:`dir` mechanism behaves differently with different types "
"of objects, as it attempts to produce the most relevant, rather than "
"complete, information:"
msgstr ""
"مکانیسم پیش فرض :func:`dir` با انواع مختلف اشیا به گونه ای متفاوت رفتار می "
"کند، زیرا سعی دارد اطلاعات مرتبط تر (و نه کامل) را تولید کند:"

#: ../../library/functions.rst:453
msgid ""
"If the object is a module object, the list contains the names of the "
"module's attributes."
msgstr "اگر شیء یک شیء ماژول باشد، لیست شامل نام های ویژگی های ماژول است."

#: ../../library/functions.rst:456
msgid ""
"If the object is a type or class object, the list contains the names of its "
"attributes, and recursively of the attributes of its bases."
msgstr ""
"اگر شیء یک نوع یا شیء کلاس باشد، لیست شامل نام های ویژگی های آن و به صورت "
"بازگشتی شامل ویژگی های مبناهای آن می باشد."

#: ../../library/functions.rst:459
msgid ""
"Otherwise, the list contains the object's attributes' names, the names of "
"its class's attributes, and recursively of the attributes of its class's "
"base classes."
msgstr ""
"در غیر این صورت، فهرست شامل نام های ویژگی های شئ، نام های ویژگی های کلاس آن، "
"و به صورت بازگشتی ویژگی های کلاس های پایه آن کلاس خواهد بود."

#: ../../library/functions.rst:463
msgid "The resulting list is sorted alphabetically.  For example:"
msgstr "لیست نهایی به صورت حروف الفبا مرتب می شود. برای مثال:"

#: ../../library/functions.rst:482
msgid ""
"Because :func:`dir` is supplied primarily as a convenience for use at an "
"interactive prompt, it tries to supply an interesting set of names more than "
"it tries to supply a rigorously or consistently defined set of names, and "
"its detailed behavior may change across releases.  For example, metaclass "
"attributes are not in the result list when the argument is a class."
msgstr ""
"از آنجا که :func:`dir` به  طور عمده برای استفاده در یک پرامپت تعاملی ارائه  "
"می شود، سعی دارد تا مجموعه ای جذاب از نام ها را فراهم کند، بیشتر از اینکه "
"سعی کند مجموعه ای به  طور دقیق یا پیوسته تعریف  شده  از نام ها را ارائه دهد. "
"رفتار دقیق آن ممکن است در نسخه های مختلف تغییر کند. برای مثال، زمانی که "
"آرگومان یک کلاس است، صفات متاکلاس در لیست نتیجه نیستند."

#: ../../library/functions.rst:492
msgid ""
"Take two (non-complex) numbers as arguments and return a pair of numbers "
"consisting of their quotient and remainder when using integer division.  "
"With mixed operand types, the rules for binary arithmetic operators apply.  "
"For integers, the result is the same as ``(a // b, a % b)``. For floating "
"point numbers the result is ``(q, a % b)``, where *q* is usually ``math."
"floor(a / b)`` but may be 1 less than that.  In any case ``q * b + a % b`` "
"is very close to *a*, if ``a % b`` is non-zero it has the same sign as *b*, "
"and ``0 <= abs(a % b) < abs(b)``."
msgstr ""

#: ../../library/functions.rst:504
msgid ""
"Return an enumerate object. *iterable* must be a sequence, an :term:"
"`iterator`, or some other object which supports iteration. The :meth:"
"`~iterator.__next__` method of the iterator returned by :func:`enumerate` "
"returns a tuple containing a count (from *start* which defaults to 0) and "
"the values obtained from iterating over *iterable*."
msgstr ""
"یک شیء شمارشی را برمی گرداند. *iterable* باید یک توالی، یک :term:`iterator`، "
"یا یک شیء دیگر باشد که از تکرارپذیری پشتیبانی می کند. متد :meth:`~iterator."
"__next__` از تکرارگر بازگردانده شده توسط :func:`enumerate` یک تاپل شامل یک "
"شمارشگر (از *start* که به طور پیش فرض صفر است) و مقادیری که از تکرار بر روی "
"*iterable* به دست می آیند را بازمی گرداند."

#: ../../library/functions.rst:516
msgid "Equivalent to::"
msgstr "معادل::"

#: ../../library/functions.rst:528
msgid ""
"The arguments are a string and optional globals and locals.  If provided, "
"*globals* must be a dictionary.  If provided, *locals* can be any mapping "
"object."
msgstr ""

#: ../../library/functions.rst:532
msgid ""
"The *expression* argument is parsed and evaluated as a Python expression "
"(technically speaking, a condition list) using the *globals* and *locals* "
"dictionaries as global and local namespace.  If the *globals* dictionary is "
"present and does not contain a value for the key ``__builtins__``, a "
"reference to the dictionary of the built-in module :mod:`builtins` is "
"inserted under that key before *expression* is parsed.  That way you can "
"control what builtins are available to the executed code by inserting your "
"own ``__builtins__`` dictionary into *globals* before passing it to :func:"
"`eval`.  If the *locals* dictionary is omitted it defaults to the *globals* "
"dictionary.  If both dictionaries are omitted, the expression is executed "
"with the *globals* and *locals* in the environment where :func:`eval` is "
"called.  Note, *eval()* does not have access to the :term:`nested scopes "
"<nested scope>` (non-locals) in the enclosing environment."
msgstr ""

#: ../../library/functions.rst:547
msgid ""
"The return value is the result of the evaluated expression. Syntax errors "
"are reported as exceptions.  Example:"
msgstr ""

#: ../../library/functions.rst:554
msgid ""
"This function can also be used to execute arbitrary code objects (such as "
"those created by :func:`compile`).  In this case, pass a code object instead "
"of a string.  If the code object has been compiled with ``'exec'`` as the "
"*mode* argument, :func:`eval`\\'s return value will be ``None``."
msgstr ""
"این تابع همچنین می تواند برای اجرای اشیاء کد دلخواه (مانند آنهایی که توسط :"
"func:`compile` ایجاد شده اند) استفاده شود. در این حالت، به جای یک رشته، یک "
"شیء کد را وارد کنید. اگر شیء کد با استفاده از ``'exec'`` به عنوان آرگومان "
"*mode* کامپایل شده باشد، مقدار بازگشتی :func:`eval` برابر با ``None`` خواهد "
"بود."

#: ../../library/functions.rst:559
msgid ""
"Hints: dynamic execution of statements is supported by the :func:`exec` "
"function.  The :func:`globals` and :func:`locals` functions return the "
"current global and local dictionary, respectively, which may be useful to "
"pass around for use by :func:`eval` or :func:`exec`."
msgstr ""
"اجرای پویا از جملات توسط تابع :func:`exec` پشتیبانی می شود. توابع :func:"
"`globals` و :func:`locals` به ترتیب دیکشنری های سراسری و محلی فعلی را برمی "
"گردانند که ممکن است برای استفاده توسط :func:`eval` یا :func:`exec` مفید باشد."

#: ../../library/functions.rst:564
msgid ""
"If the given source is a string, then leading and trailing spaces and tabs "
"are stripped."
msgstr ""
"اگر منبع داده شده یک رشته باشد، فضاهای خالی و تب های ابتدای و انتهای آن حذف "
"می شوند."

#: ../../library/functions.rst:567
msgid ""
"See :func:`ast.literal_eval` for a function that can safely evaluate strings "
"with expressions containing only literals."
msgstr ""
"برای مشاهده تابعی که می تواند رشته ها را با عبارات حاوی تنها مقادیر مستقیم "
"به طور امن ارزیابی کند، به :func:`ast.literal_eval` مراجعه کنید."

#: ../../library/functions.rst:570 ../../library/functions.rst:611
msgid ""
"Raises an :ref:`auditing event <auditing>` ``exec`` with argument "
"``code_object``."
msgstr ""

#: ../../library/functions.rst:572 ../../library/functions.rst:613
msgid ""
"Raises an :ref:`auditing event <auditing>` ``exec`` with the code object as "
"the argument. Code compilation events may also be raised."
msgstr ""
"یک :ref:`auditing event <auditing>` ``exec`` را با شیء کد به عنوان آرگومان "
"برمی انگیزد. رویدادهای کامپایل کد نیز ممکن است برانگیخته شوند."

#: ../../library/functions.rst:579
msgid ""
"This function supports dynamic execution of Python code. *object* must be "
"either a string or a code object.  If it is a string, the string is parsed "
"as a suite of Python statements which is then executed (unless a syntax "
"error occurs). [#]_ If it is a code object, it is simply executed.  In all "
"cases, the code that's executed is expected to be valid as file input (see "
"the section :ref:`file-input` in the Reference Manual). Be aware that the :"
"keyword:`nonlocal`, :keyword:`yield`,  and :keyword:`return` statements may "
"not be used outside of function definitions even within the context of code "
"passed to the :func:`exec` function. The return value is ``None``."
msgstr ""

#: ../../library/functions.rst:590
msgid ""
"In all cases, if the optional parts are omitted, the code is executed in the "
"current scope.  If only *globals* is provided, it must be a dictionary (and "
"not a subclass of dictionary), which will be used for both the global and "
"the local variables.  If *globals* and *locals* are given, they are used for "
"the global and local variables, respectively.  If provided, *locals* can be "
"any mapping object.  Remember that at the module level, globals and locals "
"are the same dictionary. If exec gets two separate objects as *globals* and "
"*locals*, the code will be executed as if it were embedded in a class "
"definition."
msgstr ""

#: ../../library/functions.rst:600
msgid ""
"If the *globals* dictionary does not contain a value for the key "
"``__builtins__``, a reference to the dictionary of the built-in module :mod:"
"`builtins` is inserted under that key.  That way you can control what "
"builtins are available to the executed code by inserting your own "
"``__builtins__`` dictionary into *globals* before passing it to :func:`exec`."
msgstr ""
"اگر دیکشنری *globals* حاوی مقداری برای کلید ``__builtins__`` نباشد، یک مرجع "
"به دیکشنری ماژول ساخته شده :mod:`builtins` در زیر آن کلید اضافه می شود. به "
"این ترتیب، می توانید با وارد کردن دیکشنری ``__builtins__`` خودتان در "
"*globals* قبل از اینکه آن را به :func:`exec` بدهید، کنترل کنید که چه "
"ساختارهای داخلی در کد اجرا شده در دسترس هستند."

#: ../../library/functions.rst:606
msgid ""
"The *closure* argument specifies a closure--a tuple of cellvars. It's only "
"valid when the *object* is a code object containing free variables. The "
"length of the tuple must exactly match the number of free variables "
"referenced by the code object."
msgstr ""

#: ../../library/functions.rst:618
msgid ""
"The built-in functions :func:`globals` and :func:`locals` return the current "
"global and local dictionary, respectively, which may be useful to pass "
"around for use as the second and third argument to :func:`exec`."
msgstr ""

#: ../../library/functions.rst:624
msgid ""
"The default *locals* act as described for function :func:`locals` below: "
"modifications to the default *locals* dictionary should not be attempted. "
"Pass an explicit *locals* dictionary if you need to see effects of the code "
"on *locals* after function :func:`exec` returns."
msgstr ""

#: ../../library/functions.rst:629
msgid "Added the *closure* parameter."
msgstr "پارامتر *closure* اضافه شد."

#: ../../library/functions.rst:635
msgid ""
"Construct an iterator from those elements of *iterable* for which *function* "
"is true.  *iterable* may be either a sequence, a container which supports "
"iteration, or an iterator.  If *function* is ``None``, the identity function "
"is assumed, that is, all elements of *iterable* that are false are removed."
msgstr ""
"یک تکرارگر از آن عناصری از *iterable* که برای آن ها *function* درست است، "
"بسازید. *iterable* می تواند یک دنباله، یک ظرف که از تکرار پشتیبانی می کند، "
"یا یک تکرارگر باشد. اگر *function* برابر ``None`` باشد، تابع هویت فرض می "
"شود، یعنی همه عناصر *iterable* که نادرست هستند حذف می شوند."

#: ../../library/functions.rst:641
msgid ""
"Note that ``filter(function, iterable)`` is equivalent to the generator "
"expression ``(item for item in iterable if function(item))`` if function is "
"not ``None`` and ``(item for item in iterable if item)`` if function is "
"``None``."
msgstr ""
"توجه داشته باشید که ``filter(function, iterable)`` معادل عبارت مولد ``(item "
"for item in iterable if function(item))`` است، اگر function برابر با "
"``None`` نباشد و ``(item for item in iterable if item)`` اگر function برابر "
"با ``None`` باشد."

#: ../../library/functions.rst:646
msgid ""
"See :func:`itertools.filterfalse` for the complementary function that "
"returns elements of *iterable* for which *function* is false."
msgstr ""
"متناظر :func:`itertools.filterfalse` را ببینید که عناصری از *iterable* را "
"برمی گرداند که برای آن ها *function* نادرست است."

#: ../../library/functions.rst:656
msgid "Return a floating point number constructed from a number or string *x*."
msgstr ""

#: ../../library/functions.rst:658
msgid ""
"If the argument is a string, it should contain a decimal number, optionally "
"preceded by a sign, and optionally embedded in whitespace.  The optional "
"sign may be ``'+'`` or ``'-'``; a ``'+'`` sign has no effect on the value "
"produced.  The argument may also be a string representing a NaN (not-a-"
"number), or positive or negative infinity.  More precisely, the input must "
"conform to the ``floatvalue`` production rule in the following grammar, "
"after leading and trailing whitespace characters are removed:"
msgstr ""

#: ../../library/functions.rst:677
msgid ""
"Case is not significant, so, for example, \"inf\", \"Inf\", \"INFINITY\", "
"and \"iNfINity\" are all acceptable spellings for positive infinity."
msgstr ""
"اندازه حروف در اینجا مهم نیست، بنابراین به عنوان مثال، \"inf\"، \"Inf\"، "
"\"INFINITY\" و \"iNfINity\" همگی نگارش های قابل قبول برای بی نهایت مثبت "
"هستند."

#: ../../library/functions.rst:680
msgid ""
"Otherwise, if the argument is an integer or a floating point number, a "
"floating point number with the same value (within Python's floating point "
"precision) is returned.  If the argument is outside the range of a Python "
"float, an :exc:`OverflowError` will be raised."
msgstr ""

#: ../../library/functions.rst:685
msgid ""
"For a general Python object ``x``, ``float(x)`` delegates to ``x."
"__float__()``.  If :meth:`~object.__float__` is not defined then it falls "
"back to :meth:`~object.__index__`."
msgstr ""
"برای یک شیء عمومی پایتون ``x``، ``float(x)`` به ``x.__float__()`` ارجاع می "
"دهد. اگر :meth:`~object.__float__` تعریف نشده باشد، به :meth:`~object."
"__index__` باز می گردد."

#: ../../library/functions.rst:689
msgid "If no argument is given, ``0.0`` is returned."
msgstr "اگر هیچ آرگومانی داده نشود، ``0.0`` بازگردانده می شود."

#: ../../library/functions.rst:691
msgid "Examples::"
msgstr "مثال ها::"

#: ../../library/functions.rst:704
msgid "The float type is described in :ref:`typesnumeric`."
msgstr "نوع float در :ref:`typesnumeric` توضیح داده شده است."

#: ../../library/functions.rst:712
msgid ""
"Falls back to :meth:`~object.__index__` if :meth:`~object.__float__` is not "
"defined."
msgstr ""
"در صورتی که :meth:`~object.__float__` تعریف نشده باشد، به :meth:`~object."
"__index__` بازگشت می کند."

#: ../../library/functions.rst:722
msgid ""
"Convert a *value* to a \"formatted\" representation, as controlled by "
"*format_spec*.  The interpretation of *format_spec* will depend on the type "
"of the *value* argument; however, there is a standard formatting syntax that "
"is used by most built-in types: :ref:`formatspec`."
msgstr ""
"تبدیل *value* به نمایشی \"قالب بندی شده\"، همان طور که توسط *format_spec* "
"کنترل می شود. تفسیر *format_spec* وابسته به نوع آرگومان *value* خواهد بود؛ "
"با این حال، یک نگارش استاندارد قالب بندی وجود دارد که توسط اکثر انواع داخلی "
"مورد استفاده قرار می گیرد: :ref:`formatspec`."

#: ../../library/functions.rst:727
msgid ""
"The default *format_spec* is an empty string which usually gives the same "
"effect as calling :func:`str(value) <str>`."
msgstr ""
"پیش فرض *format_spec* یک رشته  خالی است که معمولاً همان اثری را دارد که با "
"فراخوانی :func:`str(value) <str>` به دست می آید."

#: ../../library/functions.rst:730
msgid ""
"A call to ``format(value, format_spec)`` is translated to ``type(value)."
"__format__(value, format_spec)`` which bypasses the instance dictionary when "
"searching for the value's :meth:`~object.__format__` method. A :exc:"
"`TypeError` exception is raised if the method search reaches :mod:`object` "
"and the *format_spec* is non-empty, or if either the *format_spec* or the "
"return value are not strings."
msgstr ""
"فراخوانی به ``format(value, format_spec)`` به ``type(value)."
"__format__(value, format_spec)`` ترجمه می شود که هنگام جست وجوی روش :meth:"
"`~object.__format__` مقدار، از دیکشنری نمونه عبور می کند. یک استثنای :exc:"
"`TypeError` در صورتی پرتاب می شود که جست وجوی روش به :mod:`object` برسد و "
"*format_spec* غیرخالی باشد، یا اگر *format_spec* یا مقدار بازگشتی رشته "
"نباشند."

#: ../../library/functions.rst:737
msgid ""
"``object().__format__(format_spec)`` raises :exc:`TypeError` if "
"*format_spec* is not an empty string."
msgstr ""
"``object().__format__(format_spec)`` خطای :exc:`TypeError` را تولید می کند "
"اگر *format_spec* یک رشته خالی نباشد."

#: ../../library/functions.rst:746
msgid ""
"Return a new :class:`frozenset` object, optionally with elements taken from "
"*iterable*.  ``frozenset`` is a built-in class.  See :class:`frozenset` and :"
"ref:`types-set` for documentation about this class."
msgstr ""
"یک شیء جدید :class:`frozenset` برمی گرداند که اختیاری می تواند عناصری از "
"*iterable* داشته باشد. ``frozenset`` یک کلاس داخلی است. برای مستندات مربوط "
"به این کلاس به :class:`frozenset` و :ref:`types-set` مراجعه کنید."

#: ../../library/functions.rst:750
msgid ""
"For other containers see the built-in :class:`set`, :class:`list`, :class:"
"`tuple`, and :class:`dict` classes, as well as the :mod:`collections` module."
msgstr ""
"برای سایر کانتینرها به کلاس های داخلی :class:`set`، :class:`list`، :class:"
"`tuple` و :class:`dict` و همچنین ماژول :mod:`collections` مراجعه کنید."

#: ../../library/functions.rst:758
msgid ""
"Return the value of the named attribute of *object*.  *name* must be a "
"string. If the string is the name of one of the object's attributes, the "
"result is the value of that attribute.  For example, ``getattr(x, "
"'foobar')`` is equivalent to ``x.foobar``.  If the named attribute does not "
"exist, *default* is returned if provided, otherwise :exc:`AttributeError` is "
"raised. *name* need not be a Python identifier (see :func:`setattr`)."
msgstr ""
"ارزش خصیصه ای به نام *object* را برمی گرداند. *name* باید یک رشته باشد. اگر "
"این رشته نام یکی از خصوصیات شیء باشد، نتیجه مقدار آن خصوصیت خواهد بود. به "
"عنوان مثال، ``getattr(x, 'foobar')`` معادل ``x.foobar`` است. اگر خصیصه مورد "
"نظر وجود نداشته باشد، *default* برگردانده می شود در صورتیکه ارائه شده باشد، "
"در غیر این صورت :exc:`AttributeError` خطا می دهد. *name* لازم نیست یک شناسه "
"پایتون باشد (به :func:`setattr` مراجعه کنید)."

#: ../../library/functions.rst:767
msgid ""
"Since :ref:`private name mangling <private-name-mangling>` happens at "
"compilation time, one must manually mangle a private attribute's (attributes "
"with two leading underscores) name in order to retrieve it with :func:"
"`getattr`."
msgstr ""
"از آنجایی که :ref:`private name mangling <private-name-mangling>` در زمان "
"کامپایل اتفاق می افتد، باید به صورت دستی نام یک ویژگی خصوصی (ویژگی هایی که "
"با دو خط تیره آغاز می شوند) را برای بازیابی با :func:`getattr` تغییر دهید."

#: ../../library/functions.rst:775
msgid ""
"Return the dictionary implementing the current module namespace. For code "
"within functions, this is set when the function is defined and remains the "
"same regardless of where the function is called."
msgstr ""
"دیکشنری ای را که فضای نام فعلی ماژول را پیاده سازی می کند، برگردانید. برای "
"کدی که درون توابع قرار دارد، این دیکشنری در زمان تعریف تابع تنظیم می شود و "
"بدون توجه به محلی که تابع فراخوانی می شود، ثابت می ماند."

#: ../../library/functions.rst:782
msgid ""
"The arguments are an object and a string.  The result is ``True`` if the "
"string is the name of one of the object's attributes, ``False`` if not. "
"(This is implemented by calling ``getattr(object, name)`` and seeing whether "
"it raises an :exc:`AttributeError` or not.)"
msgstr ""
"استدلال ها یک شیء و یک رشته هستند. نتیجه ``True`` است اگر رشته نام یکی از "
"ویژگی های شیء باشد، و ``False`` اگر نباشد. (این با فراخوانی "
"``getattr(object, name)`` پیاده سازی شده و بررسی می کند که آیا :exc:"
"`AttributeError` ایجاد می شود یا خیر.)"

#: ../../library/functions.rst:790
msgid ""
"Return the hash value of the object (if it has one).  Hash values are "
"integers.  They are used to quickly compare dictionary keys during a "
"dictionary lookup.  Numeric values that compare equal have the same hash "
"value (even if they are of different types, as is the case for 1 and 1.0)."
msgstr ""
"بازگرداندن مقدار هش شیء (در صورتی که یکی داشته باشد). مقادیر هش اعداد صحیح "
"هستند. از آنها برای مقایسه سریع کلیدهای دیکشنری در هنگام جستجوی دیکشنری "
"استفاده می شود. مقادیر عددی که برابر مقایسه می شوند دارای مقدار هش یکسانی "
"هستند (حتی اگر از انواع مختلف باشند، مانند 1 و 1.0)."

#: ../../library/functions.rst:797
msgid ""
"For objects with custom :meth:`~object.__hash__` methods, note that :func:"
"`hash` truncates the return value based on the bit width of the host machine."
msgstr ""
"برای اشیائی که دارای متدهای سفارشی :meth:`~object.__hash__` هستند، توجه "
"داشته باشید که :func:`hash` مقدار بازگشتی را بر اساس عرض بیت ماشین میزبان "
"کوتاه می کند."

#: ../../library/functions.rst:804
msgid ""
"Invoke the built-in help system.  (This function is intended for interactive "
"use.)  If no argument is given, the interactive help system starts on the "
"interpreter console.  If the argument is a string, then the string is looked "
"up as the name of a module, function, class, method, keyword, or "
"documentation topic, and a help page is printed on the console.  If the "
"argument is any other kind of object, a help page on the object is generated."
msgstr ""
"سیستم راهنمای داخلی را فراخوانی کنید. (این تابع برای استفاده تعاملی طراحی "
"شده است.) اگر هیچ آرگومانی داده نشود، سیستم راهنمای تعاملی روی کنسول مفسر "
"شروع می شود. اگر آرگومان یک رشته باشد، آن رشته به عنوان نام یک ماژول، تابع، "
"کلاس، متد، کلمه کلیدی یا موضوع مستندات جستجو می شود و یک صفحه راهنما بر روی "
"کنسول چاپ می شود. اگر آرگومان هر نوع شیء دیگری باشد، یک صفحه راهنما درباره "
"آن شیء تولید می شود."

#: ../../library/functions.rst:811
msgid ""
"Note that if a slash(/) appears in the parameter list of a function when "
"invoking :func:`help`, it means that the parameters prior to the slash are "
"positional-only. For more info, see :ref:`the FAQ entry on positional-only "
"parameters <faq-positional-only-arguments>`."
msgstr ""
"توجه داشته باشید که اگر علامت اسلش (/) در لیست پارامترهای یک تابع هنگام "
"فراخوانی :func:`help` ظاهر شود، به این معنی است که پارامترهای قبل از اسلش "
"فقط موقعیتی هستند. برای اطلاعات بیشتر، به :ref:`the FAQ entry on positional-"
"only parameters <faq-positional-only-arguments>` مراجعه کنید."

#: ../../library/functions.rst:816
msgid ""
"This function is added to the built-in namespace by the :mod:`site` module."
msgstr "این تابع توسط ماژول :mod:`site` به فضای نام داخلی اضافه شده است."

#: ../../library/functions.rst:818
msgid ""
"Changes to :mod:`pydoc` and :mod:`inspect` mean that the reported signatures "
"for callables are now more comprehensive and consistent."
msgstr ""
"تغییرات به :mod:`pydoc` و :mod:`inspect` به این معناست که امضاهای گزارش شده "
"برای فراخوان ها اکنون جامع تر و سازگارتر هستند."

#: ../../library/functions.rst:825
msgid ""
"Convert an integer number to a lowercase hexadecimal string prefixed with "
"\"0x\". If *x* is not a Python :class:`int` object, it has to define an :"
"meth:`~object.__index__` method that returns an integer. Some examples:"
msgstr ""
"تبدیل یک عدد صحیح به یک رشته هگزادسیمال با حروف کوچک که با \"0x\" شروع می "
"شود. اگر *x* یک شیء Python :class:`int` نباشد، باید یک متد :meth:`~object."
"__index__` تعریف کند که یک عدد صحیح را برگرداند. چند مثال:"

#: ../../library/functions.rst:834
msgid ""
"If you want to convert an integer number to an uppercase or lower "
"hexadecimal string with prefix or not, you can use either of the following "
"ways:"
msgstr ""
"اگر می خواهید یک عدد صحیح را به یک رشته شانزده شانزدهی بزرگ یا کوچک با "
"پیشوند یا بدون آن تبدیل کنید، می توانید از روش های زیر استفاده کنید:"

#: ../../library/functions.rst:846
msgid ""
"See also :func:`int` for converting a hexadecimal string to an integer using "
"a base of 16."
msgstr ""
"همچنین :func:`int` را ببینید برای تبدیل یک رشته هگزادسیمال به یک عدد صحیح با "
"استفاده از مبنای 16."

#: ../../library/functions.rst:851
msgid ""
"To obtain a hexadecimal string representation for a float, use the :meth:"
"`float.hex` method."
msgstr ""
"برای به دست آوردن یک نمایش رشته ای هگزادسیمال برای یک float، از روش :meth:"
"`float.hex` استفاده کنید."

#: ../../library/functions.rst:857
msgid ""
"Return the \"identity\" of an object.  This is an integer which is "
"guaranteed to be unique and constant for this object during its lifetime. "
"Two objects with non-overlapping lifetimes may have the same :func:`id` "
"value."
msgstr ""
"\"شناسه\" یک شیء را برمی گرداند. این یک عدد صحیح است که تضمین می شود در طول "
"عمر شیء، منحصر به فرد و ثابت باشد. دو شیء که دوره های عمرشان با هم تلاقی "
"ندارند ممکن است مقدار :func:`id` یکسانی داشته باشند."

#: ../../library/functions.rst:862
msgid "This is the address of the object in memory."
msgstr "این آدرس شیء در حافظه است."

#: ../../library/functions.rst:864
msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.id`` with argument "
"``id``."
msgstr ""
"یک :ref:`auditing event <auditing>` ``builtins.id`` با آرگومان ``id`` برمی "
"گرداند."

#: ../../library/functions.rst:870
msgid ""
"If the *prompt* argument is present, it is written to standard output "
"without a trailing newline.  The function then reads a line from input, "
"converts it to a string (stripping a trailing newline), and returns that.  "
"When EOF is read, :exc:`EOFError` is raised.  Example::"
msgstr ""
"اگر آرگومان *prompt* وجود داشته باشد، بدون یک خط جدید به خروجی استاندارد "
"نوشته می شود. سپس تابع یک خط از ورودی می خواند، آن را به رشته تبدیل می کند "
"(خط جدید انتهایی را حذف می کند)، و آن را برمی گرداند. وقتی EOF خوانده شد، :"
"exc:`EOFError` تولید می شود. مثال::"

#: ../../library/functions.rst:880
msgid ""
"If the :mod:`readline` module was loaded, then :func:`input` will use it to "
"provide elaborate line editing and history features."
msgstr ""
"اگر ماژول :mod:`readline` بارگذاری شده باشد، سپس :func:`input` از آن استفاده "
"خواهد کرد تا ویژگی های ویرایش خط و تاریخچه پیشرفته ای را فراهم کند."

#: ../../library/functions.rst:883
msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.input`` with argument "
"``prompt``."
msgstr ""

#: ../../library/functions.rst:885
msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.input`` with argument "
"``prompt`` before reading input"
msgstr ""
"قبل از خواندن ورودی، یک :ref:`auditing event <auditing>` ``builtins.input`` "
"با آرگومان ``prompt`` ایجاد می کند."

#: ../../library/functions.rst:888
msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.input/result`` with "
"argument ``result``."
msgstr ""

#: ../../library/functions.rst:890
msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.input/result`` with "
"the result after successfully reading input."
msgstr ""
"یک :ref:`auditing event <auditing>` ``builtins.input/result`` را با نتیجه پس "
"از خواندن موفقیت آمیز ورودی ایجاد می کند."

#: ../../library/functions.rst:897
msgid ""
"Return an integer object constructed from a number or string *x*, or return "
"``0`` if no arguments are given.  If *x* defines :meth:`~object.__int__`, "
"``int(x)`` returns ``x.__int__()``.  If *x* defines :meth:`~object."
"__index__`, it returns ``x.__index__()``.  If *x* defines :meth:`~object."
"__trunc__`, it returns ``x.__trunc__()``. For floating point numbers, this "
"truncates towards zero."
msgstr ""

#: ../../library/functions.rst:904
msgid ""
"If *x* is not a number or if *base* is given, then *x* must be a string, :"
"class:`bytes`, or :class:`bytearray` instance representing an integer in "
"radix *base*.  Optionally, the string can be preceded by ``+`` or ``-`` "
"(with no space in between), have leading zeros, be surrounded by whitespace, "
"and have single underscores interspersed between digits."
msgstr ""

#: ../../library/functions.rst:910
msgid ""
"A base-n integer string contains digits, each representing a value from 0 to "
"n-1. The values 0--9 can be represented by any Unicode decimal digit. The "
"values 10--35 can be represented by ``a`` to ``z`` (or ``A`` to ``Z``). The "
"default *base* is 10. The allowed bases are 0 and 2--36. Base-2, -8, and -16 "
"strings can be optionally prefixed with ``0b``/``0B``, ``0o``/``0O``, or "
"``0x``/``0X``, as with integer literals in code.  For base 0, the string is "
"interpreted in a similar way to an :ref:`integer literal in code "
"<integers>`, in that the actual base is 2, 8, 10, or 16 as determined by the "
"prefix. Base 0 also disallows leading zeros: ``int('010', 0)`` is not legal, "
"while ``int('010')`` and ``int('010', 8)`` are."
msgstr ""
"یک رشته عدد صحیح مبنای-n شامل ارقامی است که هر یک مقداری از 0 تا n-1 را "
"نمایش می دهد. مقادیر 0--9 می توانند توسط هر رقم اعشاری یونیکد نمایش داده "
"شوند. مقادیر 10--35 می توانند با ``a`` تا ``z`` (یا ``A`` تا ``Z``) نمایش "
"داده شوند. مقدار پیش فرض *base*، 10 است. مبناهای مجاز 0 و 2--36 هستند. رشته "
"های مبنای-2، -8 و -16 می توانند به صورت اختیاری با ``0b``/``0B``، ``0o``/"
"``0O``، یا ``0x``/``0X`` پیشوند شوند، مشابه با عبارت های عددی صحیح در کد. "
"برای مبنای 0، رشته به صورت مشابهی با یک :ref:`integer literal in code "
"<integers>` تفسیر می شود، به گونه ای که مبنای واقعی 2، 8، 10، یا 16 باشد که "
"توسط پیشوند مشخص می شود. مبنای 0 همچنین اجازه استفاده از صفرهای پیش رو را "
"نمی دهد: ``int('010', 0)`` قانونی نیست، در حالی که ``int('010')`` و "
"``int('010', 8)`` قانونی هستند."

#: ../../library/functions.rst:921
msgid "The integer type is described in :ref:`typesnumeric`."
msgstr "نوع عدد صحیح در :ref:`typesnumeric` توصیف شده است."

#: ../../library/functions.rst:923
msgid ""
"If *base* is not an instance of :class:`int` and the *base* object has a :"
"meth:`base.__index__ <object.__index__>` method, that method is called to "
"obtain an integer for the base.  Previous versions used :meth:`base.__int__ "
"<object.__int__>` instead of :meth:`base.__index__ <object.__index__>`."
msgstr ""
"اگر *base* یک نمونه از :class:`int` نباشد و شیء *base* یک متد :meth:`base."
"__index__ <object.__index__>` داشته باشد، آن متد برای به دست آوردن یک عدد "
"صحیح برای پایه فراخوانی می شود. نسخه های قبلی از :meth:`base.__int__ <object."
"__int__>` به جای :meth:`base.__index__ <object.__index__>` استفاده می کردند."

#: ../../library/functions.rst:936
msgid ""
"Falls back to :meth:`~object.__index__` if :meth:`~object.__int__` is not "
"defined."
msgstr ""
"اگر :meth:`~object.__int__` تعریف نشده باشد، به :meth:`~object.__index__` "
"بازمی گردد."

#: ../../library/functions.rst:939
msgid "The delegation to :meth:`~object.__trunc__` is deprecated."
msgstr "واگذاری به :meth:`~object.__trunc__` منسوخ شده است."

#: ../../library/functions.rst:942
msgid ""
":class:`int` string inputs and string representations can be limited to help "
"avoid denial of service attacks. A :exc:`ValueError` is raised when the "
"limit is exceeded while converting a string *x* to an :class:`int` or when "
"converting an :class:`int` into a string would exceed the limit. See the :"
"ref:`integer string conversion length limitation <int_max_str_digits>` "
"documentation."
msgstr ""

#: ../../library/functions.rst:952
msgid ""
"Return ``True`` if the *object* argument is an instance of the *classinfo* "
"argument, or of a (direct, indirect, or :term:`virtual <abstract base "
"class>`) subclass thereof.  If *object* is not an object of the given type, "
"the function always returns ``False``. If *classinfo* is a tuple of type "
"objects (or recursively, other such tuples) or a :ref:`types-union` of "
"multiple types, return ``True`` if *object* is an instance of any of the "
"types. If *classinfo* is not a type or tuple of types and such tuples, a :"
"exc:`TypeError` exception is raised. :exc:`TypeError` may not be raised for "
"an invalid type if an earlier check succeeds."
msgstr ""
"``True`` را بازگردانید اگر آرگومان *object* یک نمونه از آرگومان *classinfo* "
"باشد، یا یک زیرکلاس (مستقیم، غیرمستقیم یا :term:`virtual <abstract base "
"class>`) آن. اگر *object* شیءای از نوع داده شده نباشد، تابع همیشه ``False`` "
"را برمی گرداند. اگر *classinfo* یک تاپل از اشیاء نوع (یا به صورت بازگشتی، "
"تاپل های دیگر) یا یک :ref:`types-union` از انواع متعدد باشد، ``True`` را "
"بازگردانید اگر *object* یک نمونه از هر یک از انواع باشد. اگر *classinfo* یک "
"نوع یا تاپل از انواع و این گونه تاپل ها نباشد، یک استثنای :exc:`TypeError` "
"ایجاد می شود. :exc:`TypeError` ممکن است برای یک نوع نامعتبر ایجاد نشود اگر "
"بررسی زودتری موفق باشد."

#: ../../library/functions.rst:963 ../../library/functions.rst:977
msgid "*classinfo* can be a :ref:`types-union`."
msgstr "*classinfo* می تواند یک :ref:`types-union` باشد."

#: ../../library/functions.rst:969
msgid ""
"Return ``True`` if *class* is a subclass (direct, indirect, or :term:"
"`virtual <abstract base class>`) of *classinfo*.  A class is considered a "
"subclass of itself. *classinfo* may be a tuple of class objects (or "
"recursively, other such tuples) or a :ref:`types-union`, in which case "
"return ``True`` if *class* is a subclass of any entry in *classinfo*.  In "
"any other case, a :exc:`TypeError` exception is raised."
msgstr ""
"اگر *class* زیرکلاسی (مستقیم، غیرمستقیم، یا :term:`virtual <abstract base "
"class>`) از *classinfo* باشد، ``True`` را برمی گرداند. یک کلاس به عنوان "
"زیرکلاس خودش نیز در نظر گرفته می شود. *classinfo* ممکن است یک جفت از اشیاء "
"کلاس ها (یا به صورت بازگشتی، سایر همچنین جفت ها) یا یک :ref:`types-union` "
"باشد، که در این صورت ``True`` را برمی گرداند، اگر *class* زیرکلاس هر ورودی "
"در *classinfo* باشد. در هر حالت دیگری، یک استثناء :exc:`TypeError` ایجاد می "
"شود."

#: ../../library/functions.rst:984
msgid ""
"Return an :term:`iterator` object.  The first argument is interpreted very "
"differently depending on the presence of the second argument. Without a "
"second argument, *object* must be a collection object which supports the :"
"term:`iterable` protocol (the :meth:`~object.__iter__` method), or it must "
"support the sequence protocol (the :meth:`~object.__getitem__` method with "
"integer arguments starting at ``0``).  If it does not support either of "
"those protocols, :exc:`TypeError` is raised. If the second argument, "
"*sentinel*, is given, then *object* must be a callable object.  The iterator "
"created in this case will call *object* with no arguments for each call to "
"its :meth:`~iterator.__next__` method; if the value returned is equal to "
"*sentinel*, :exc:`StopIteration` will be raised, otherwise the value will be "
"returned."
msgstr ""
"یک شیء :term:`iterator` بازگشت داده می شود. اولین آرگومان به طور کاملاً "
"متفاوتی بر اساس حضور دومین آرگومان تفسیر می شود. بدون حضور یک آرگومان دوم، "
"*object* باید یک شیء جمع آوری باشد که پروتکل :term:`iterable` (متد :meth:"
"`~object.__iter__`) را پشتیبانی کند، یا باید پروتکل دنباله (متد :meth:"
"`~object.__getitem__` با آرگومان های عدد صحیح که از ``0`` شروع می شود) را "
"پشتیبانی کند. اگر هیچ کدام از این پروتکل ها را پشتیبانی نکند، :exc:"
"`TypeError` ایجاد می شود. اگر آرگومان دوم، *sentinel*، داده شود، آنگاه "
"*object* باید یک شیء قابل فراخوانی باشد. در این حالت، تکرارگر ایجاد شده "
"*object* را بدون هیچ آرگومانی برای هر بار فراخوانی متد :meth:`~iterator."
"__next__` خود فرا می خواند؛ اگر مقداری که بازگردانده می شود برابر با "
"*sentinel* باشد، :exc:`StopIteration` ایجاد خواهد شد، در غیر این صورت مقدار "
"بازگردانده خواهد شد."

#: ../../library/functions.rst:998
msgid "See also :ref:`typeiter`."
msgstr "همچنین به :ref:`typeiter` مراجعه کنید."

#: ../../library/functions.rst:1000
msgid ""
"One useful application of the second form of :func:`iter` is to build a "
"block-reader. For example, reading fixed-width blocks from a binary database "
"file until the end of file is reached::"
msgstr ""
"یکی از کاربردهای مفید فرم دوم :func:`iter` ساخت یک بلاک خوان است. به عنوان "
"مثال، خواندن بلوک های با عرض ثابت از یک فایل پایگاه داده باینری تا زمانی که "
"به انتهای فایل برسید:"

#: ../../library/functions.rst:1012
msgid ""
"Return the length (the number of items) of an object.  The argument may be a "
"sequence (such as a string, bytes, tuple, list, or range) or a collection "
"(such as a dictionary, set, or frozen set)."
msgstr ""
"اندازه (تعداد آیتم ها) یک شیء را برمی گرداند. آرگومان می تواند یک توالی "
"(مانند string، bytes، tuple، list، یا range) یا یک مجموعه (مانند dictionary، "
"set، یا frozen set) باشد."

#: ../../library/functions.rst:1018
msgid ""
"``len`` raises :exc:`OverflowError` on lengths larger than :data:`sys."
"maxsize`, such as :class:`range(2 ** 100) <range>`."
msgstr ""
"``len`` خطای :exc:`OverflowError` را برای طول هایی بزرگتر از :data:`sys."
"maxsize`، مانند :class:`range(2 ** 100) <range>`، ایجاد می کند."

#: ../../library/functions.rst:1027
msgid ""
"Rather than being a function, :class:`list` is actually a mutable sequence "
"type, as documented in :ref:`typesseq-list` and :ref:`typesseq`."
msgstr ""
"به جای اینکه یک تابع باشد، :class:`list` در واقع یک نوع توالی تغییرپذیر است، "
"همان طور که در :ref:`typesseq-list` و :ref:`typesseq` مستند شده است."

#: ../../library/functions.rst:1033
msgid ""
"Update and return a dictionary representing the current local symbol table. "
"Free variables are returned by :func:`locals` when it is called in function "
"blocks, but not in class blocks. Note that at the module level, :func:"
"`locals` and :func:`globals` are the same dictionary."
msgstr ""

#: ../../library/functions.rst:1039
msgid ""
"The contents of this dictionary should not be modified; changes may not "
"affect the values of local and free variables used by the interpreter."
msgstr ""

#: ../../library/functions.rst:1044
msgid ""
"Return an iterator that applies *function* to every item of *iterable*, "
"yielding the results.  If additional *iterables* arguments are passed, "
"*function* must take that many arguments and is applied to the items from "
"all iterables in parallel.  With multiple iterables, the iterator stops when "
"the shortest iterable is exhausted.  For cases where the function inputs are "
"already arranged into argument tuples, see :func:`itertools.starmap`\\."
msgstr ""
"یک تکرارگر برمی گرداند که *function* را بر روی هر مورد از *iterable* اعمال "
"می کند و نتایج را ایجاد می کند. اگر آرگومان های اضافی *iterables* ارسال "
"شوند، *function* باید به همان تعداد آرگومان ها را بپذیرد و بر روی آیتم ها از "
"تمام iterable ها به صورت موازی اعمال شود. با وجود چندین iterable، تکرارگر "
"زمانی متوقف می شود که کوتاه ترین iterable به پایان برسد. در مواردی که ورودی "
"های تابع به طور خودکار در قالب های آرگومان مرتب شده اند، به :func:`itertools."
"starmap` مراجعه کنید."

#: ../../library/functions.rst:1056
msgid ""
"Return the largest item in an iterable or the largest of two or more "
"arguments."
msgstr ""
"بزرگ ترین عنصر در یک iterable یا بزرگ ترین در میان دو یا چند آرگومان را "
"بازمی گرداند."

#: ../../library/functions.rst:1059
msgid ""
"If one positional argument is provided, it should be an :term:`iterable`. "
"The largest item in the iterable is returned.  If two or more positional "
"arguments are provided, the largest of the positional arguments is returned."
msgstr ""
"اگر یک آرگومان مکانی ارائه شود، باید :term:`iterable` باشد. بزرگترین آیتم در "
"iterable بازگردانده می شود. اگر دو یا چند آرگومان مکانی ارائه شوند، بزرگترین "
"آرگومان مکانی بازگردانده می شود."

#: ../../library/functions.rst:1064 ../../library/functions.rst:1102
msgid ""
"There are two optional keyword-only arguments. The *key* argument specifies "
"a one-argument ordering function like that used for :meth:`list.sort`. The "
"*default* argument specifies an object to return if the provided iterable is "
"empty. If the iterable is empty and *default* is not provided, a :exc:"
"`ValueError` is raised."
msgstr ""
"دو آرگومان اختیاری فقط با کلیدواژه وجود دارد. آرگومان *key* یک تابع مرتب "
"سازی با یک آرگومان مشابه آنچه برای :meth:`list.sort` استفاده می شود را مشخص "
"می کند. آرگومان *default* یک شیء را برای بازگشت مشخص می کند اگر مجموعه ارائه "
"شده خالی باشد. اگر مجموعه خالی باشد و *default* فراهم نشده باشد، یک :exc:"
"`ValueError` ایجاد می شود."

#: ../../library/functions.rst:1070
msgid ""
"If multiple items are maximal, the function returns the first one "
"encountered.  This is consistent with other sort-stability preserving tools "
"such as ``sorted(iterable, key=keyfunc, reverse=True)[0]`` and ``heapq."
"nlargest(1, iterable, key=keyfunc)``."
msgstr ""
"اگر چندین مورد حداکثر باشند، تابع اولین موردی را که پیدا کند برمی گرداند. "
"این با دیگر ابزارهایی که پایداری مرتب سازی را حفظ می کنند، مانند "
"``sorted(iterable, key=keyfunc, reverse=True)[0]`` و ``heapq.nlargest(1, "
"iterable, key=keyfunc)`` سازگار است."

#: ../../library/functions.rst:1075 ../../library/functions.rst:1113
msgid "Added the *default* keyword-only parameter."
msgstr "افزوده شدن پارامتر فقط-کلیدواژه *default*."

#: ../../library/functions.rst:1078 ../../library/functions.rst:1116
msgid "The *key* can be ``None``."
msgstr "  *key* می تواند ``None`` باشد."

#: ../../library/functions.rst:1086
msgid ""
"Return a \"memory view\" object created from the given argument.  See :ref:"
"`typememoryview` for more information."
msgstr ""
"یک شیء \"نمای حافظه\" ایجاد شده از آرگومان داده شده را برگردانید. برای "
"اطلاعات بیشتر به :ref:`typememoryview` مراجعه کنید."

#: ../../library/functions.rst:1094
msgid ""
"Return the smallest item in an iterable or the smallest of two or more "
"arguments."
msgstr ""
"کوچکترین مورد را در یک iterable یا کوچکترینِ دو یا چند آرگومان بازمی گرداند."

#: ../../library/functions.rst:1097
msgid ""
"If one positional argument is provided, it should be an :term:`iterable`. "
"The smallest item in the iterable is returned.  If two or more positional "
"arguments are provided, the smallest of the positional arguments is returned."
msgstr ""
"اگر یک آرگومان موضعی فراهم شود، باید یک :term:`iterable` باشد. کوچک ترین "
"آیتم در iterable بازگردانده می شود. اگر دو یا چند آرگومان موضعی فراهم شوند، "
"کوچک ترین آرگومان موضعی بازگردانده می شود."

#: ../../library/functions.rst:1108
msgid ""
"If multiple items are minimal, the function returns the first one "
"encountered.  This is consistent with other sort-stability preserving tools "
"such as ``sorted(iterable, key=keyfunc)[0]`` and ``heapq.nsmallest(1, "
"iterable, key=keyfunc)``."
msgstr ""
"اگر چندین مورد کوچکترین باشند، تابع اولین موردی را که با آن برخورد می کند "
"برمی گرداند. این با ابزارهای دیگری که پایداری مرتب سازی را حفظ می کنند، "
"مانند ``sorted(iterable, key=keyfunc)[0]`` و ``heapq.nsmallest(1, iterable, "
"key=keyfunc)`` سازگار است."

#: ../../library/functions.rst:1123
msgid ""
"Retrieve the next item from the :term:`iterator` by calling its :meth:"
"`~iterator.__next__` method.  If *default* is given, it is returned if the "
"iterator is exhausted, otherwise :exc:`StopIteration` is raised."
msgstr ""
"بازیابی آیتم بعدی از :term:`iterator` با فراخوانی متد :meth:`~iterator."
"__next__` آن. اگر *default* داده شود، در صورت اینکه تکرارگر تمام شده باشد، "
"بازگردانده می شود، در غیر این صورت :exc:`StopIteration` برافراشته می شود."

#: ../../library/functions.rst:1130
msgid ""
"Return a new featureless object.  :class:`object` is a base for all classes. "
"It has methods that are common to all instances of Python classes.  This "
"function does not accept any arguments."
msgstr ""

#: ../../library/functions.rst:1136
msgid ""
":class:`object` does *not* have a :attr:`~object.__dict__`, so you can't "
"assign arbitrary attributes to an instance of the :class:`object` class."
msgstr ""

#: ../../library/functions.rst:1142
msgid ""
"Convert an integer number to an octal string prefixed with \"0o\".  The "
"result is a valid Python expression. If *x* is not a Python :class:`int` "
"object, it has to define an :meth:`~object.__index__` method that returns an "
"integer. For example:"
msgstr ""
"یک عدد صحیح را به یک رشته هشت هشتی با پیشوند \"0o\" تبدیل میکند.  نتیجه یک "
"عبارت معتبر پایتون است. اگر *x* یک شیء :class:`int` پایتون نباشد، لازم است "
"یک متد :meth:`~object.__index__` تعریف کند که یک عدد صحیح برمی گرداند. به "
"عنوان مثال:"

#: ../../library/functions.rst:1152
msgid ""
"If you want to convert an integer number to an octal string either with the "
"prefix \"0o\" or not, you can use either of the following ways."
msgstr ""
"اگر می خواهید یک عدد صحیح را به رشته هشت هشتی با پیش وند \"0o\" یا بدون آن "
"تبدیل کنید، می توانید از یکی از روش های زیر استفاده کنید."

#: ../../library/functions.rst:1169
msgid ""
"Open *file* and return a corresponding :term:`file object`.  If the file "
"cannot be opened, an :exc:`OSError` is raised. See :ref:`tut-files` for more "
"examples of how to use this function."
msgstr ""
"*file* را باز کرده و :term:`file object` مربوطه را برگردانید. اگر فایل قابل "
"باز شدن نباشد، یک :exc:`OSError` مطرح می شود. برای مثال های بیشتر از نحوه "
"استفاده از این تابع، به :ref:`tut-files` مراجعه کنید."

#: ../../library/functions.rst:1173
msgid ""
"*file* is a :term:`path-like object` giving the pathname (absolute or "
"relative to the current working directory) of the file to be opened or an "
"integer file descriptor of the file to be wrapped.  (If a file descriptor is "
"given, it is closed when the returned I/O object is closed unless *closefd* "
"is set to ``False``.)"
msgstr ""
"*file* یک :term:`path-like object` است که مسیر فایل (به صورت مطلق یا نسبی "
"نسبت به پوشه کاری فعلی) که باید باز شود را یا یک تشخیص گر فایل از نوع عدد "
"صحیح از فایل برای بسته بندی ارائه می دهد. (اگر یک تشخیص گر فایل ارائه شود، "
"وقتی شیء ورودی/خروجی بازگشتی بسته می شود، آن نیز بسته می شود مگر اینکه "
"*closefd* به ``False`` تنظیم شود.)"

#: ../../library/functions.rst:1179
msgid ""
"*mode* is an optional string that specifies the mode in which the file is "
"opened.  It defaults to ``'r'`` which means open for reading in text mode. "
"Other common values are ``'w'`` for writing (truncating the file if it "
"already exists), ``'x'`` for exclusive creation, and ``'a'`` for appending "
"(which on *some* Unix systems, means that *all* writes append to the end of "
"the file regardless of the current seek position).  In text mode, if "
"*encoding* is not specified the encoding used is platform-dependent: :func:"
"`locale.getencoding()` is called to get the current locale encoding. (For "
"reading and writing raw bytes use binary mode and leave *encoding* "
"unspecified.)  The available modes are:"
msgstr ""

#: ../../library/functions.rst:1196
msgid "Character"
msgstr "شخصیت"

#: ../../library/functions.rst:1196
msgid "Meaning"
msgstr "معنی"

#: ../../library/functions.rst:1198
msgid "``'r'``"
msgstr "``'r'``"

#: ../../library/functions.rst:1198
msgid "open for reading (default)"
msgstr "باز برای خواندن (پیش فرض)"

#: ../../library/functions.rst:1199
msgid "``'w'``"
msgstr "``'w'``"

#: ../../library/functions.rst:1199
msgid "open for writing, truncating the file first"
msgstr "برای نوشتن، ابتدا فایل را کوتاه کنید."

#: ../../library/functions.rst:1200
msgid "``'x'``"
msgstr "``'x'``"

#: ../../library/functions.rst:1200
msgid "open for exclusive creation, failing if the file already exists"
msgstr ""
"برای ایجاد انحصاری باز کنید، اگر فایل از قبل وجود داشته باشد، عملیات ناموفق "
"خواهد بود."

#: ../../library/functions.rst:1201
msgid "``'a'``"
msgstr "``'a'``"

#: ../../library/functions.rst:1201
msgid "open for writing, appending to the end of file if it exists"
msgstr "باز کردن برای نوشتن، افزودن به انتهای فایل در صورت وجود فایل"

#: ../../library/functions.rst:1202
msgid "``'b'``"
msgstr "``'b'``"

#: ../../library/functions.rst:1202 ../../library/functions.rst:1346
msgid "binary mode"
msgstr "حالت دودویی"

#: ../../library/functions.rst:1203
msgid "``'t'``"
msgstr "``'t'``"

#: ../../library/functions.rst:1203
msgid "text mode (default)"
msgstr "حالت متنی (پیش فرض)"

#: ../../library/functions.rst:1204
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/functions.rst:1204
msgid "open for updating (reading and writing)"
msgstr "باز برای به روزرسانی (خواندن و نوشتن)"

#: ../../library/functions.rst:1207
msgid ""
"The default mode is ``'r'`` (open for reading text, a synonym of ``'rt'``). "
"Modes ``'w+'`` and ``'w+b'`` open and truncate the file.  Modes ``'r+'`` and "
"``'r+b'`` open the file with no truncation."
msgstr ""
"حالت پیش فرض ``'r'`` است (باز کردن برای خواندن متن، مترادف ``'rt'``). حالت "
"های ``'w+'`` و ``'w+b'`` فایل را باز کرده و آن را کوتاه می کنند. حالت های "
"``'r+'`` و ``'r+b'`` فایل را بدون کوتاه کردن باز می کنند."

#: ../../library/functions.rst:1211
msgid ""
"As mentioned in the :ref:`io-overview`, Python distinguishes between binary "
"and text I/O.  Files opened in binary mode (including ``'b'`` in the *mode* "
"argument) return contents as :class:`bytes` objects without any decoding.  "
"In text mode (the default, or when ``'t'`` is included in the *mode* "
"argument), the contents of the file are returned as :class:`str`, the bytes "
"having been first decoded using a platform-dependent encoding or using the "
"specified *encoding* if given."
msgstr ""
"همانطور که در :ref:`io-overview` ذکر شد، پایتون بین ورودی/خروجی باینری و "
"متنی تفاوت قائل می شود. فایل های باز شده در حالت باینری (شامل ``'b'`` در "
"آرگومان *mode*) محتوا را به صورت اشیاء :class:`bytes` بدون هیچ گونه رمزگشایی "
"بازمی گردانند. در حالت متنی (پیش فرض یا زمانی که ``'t'`` در آرگومان *mode* "
"قرار می گیرد)، محتوای فایل به صورت :class:`str` بازگردانده می شود، در حالی "
"که بایت ها ابتدا با استفاده از یک کدگذاری وابسته به پلتفرم یا با استفاده از "
"*encoding* مشخص شده، اگر داده شود، رمزگشایی شده اند."

#: ../../library/functions.rst:1221
msgid ""
"Python doesn't depend on the underlying operating system's notion of text "
"files; all the processing is done by Python itself, and is therefore "
"platform-independent."
msgstr ""
"پایتون به مفهوم فایل های متنی سیستم عامل زیربنایی وابسته نیست؛ تمام پردازش "
"ها توسط خود پایتون انجام می شود و بنابراین مستقل از پلتفرم است."

#: ../../library/functions.rst:1225
msgid ""
"*buffering* is an optional integer used to set the buffering policy.  Pass 0 "
"to switch buffering off (only allowed in binary mode), 1 to select line "
"buffering (only usable when writing in text mode), and an integer > 1 to "
"indicate the size in bytes of a fixed-size chunk buffer. Note that "
"specifying a buffer size this way applies for binary buffered I/O, but "
"``TextIOWrapper`` (i.e., files opened with ``mode='r+'``) would have another "
"buffering. To disable buffering in ``TextIOWrapper``, consider using the "
"``write_through`` flag for :func:`io.TextIOWrapper.reconfigure`. When no "
"*buffering* argument is given, the default buffering policy works as follows:"
msgstr ""
"*buffering* یک عدد صحیح اختیاری است که برای تنظیم سیاست بافرینگ استفاده می "
"شود. قرار دادن 0 به منظور خاموش کردن بافرینگ (فقط در حالت باینری مجاز است)، "
"1 برای انتخاب بافرینگ خط (فقط زمانی که در حالت نوشتار متنی است قابل استفاده "
"است)، و هر عدد صحیح بزرگتر از 1 برای نشان دادن اندازه به بایت های یک بافر "
"تکه ای با اندازه ثابت. توجه داشته باشید که مشخص کردن اندازه بافر به این روش "
"برای I/O بافر شده باینری اعمال می شود، اما ``TextIOWrapper`` (یعنی فایل هایی "
"که با ``mode='r+'`` باز شده اند) بافرینگ دیگری خواهند داشت. برای غیرفعال "
"کردن بافرینگ در ``TextIOWrapper``، استفاده از پرچم ``write_through`` برای :"
"func:`io.TextIOWrapper.reconfigure` را در نظر بگیرید. وقتی هیچ آرگومان "
"*buffering* ارائه نشده، سیاست پیش فرض بافرینگ به صورت زیر کار می کند:"

#: ../../library/functions.rst:1235
msgid ""
"Binary files are buffered in fixed-size chunks; the size of the buffer is "
"chosen using a heuristic trying to determine the underlying device's \"block "
"size\" and falling back on :const:`io.DEFAULT_BUFFER_SIZE`.  On many "
"systems, the buffer will typically be 4096 or 8192 bytes long."
msgstr ""
"فایل های باینری در بلوک هایی با اندازه ثابت بافر می شوند؛ اندازه بافر با "
"استفاده از یک ایده ی تخمینی انتخاب می شود که سعی دارد \"اندازه بلوک\" دستگاه "
"زیرین را تعیین کند و در صورت نیاز از :const:`io.DEFAULT_BUFFER_SIZE` استفاده "
"می کند. در بسیاری از سیستم ها، اندازه بافر معمولاً 4096 یا 8192 بایت خواهد "
"بود."

#: ../../library/functions.rst:1240
msgid ""
"\"Interactive\" text files (files for which :meth:`~io.IOBase.isatty` "
"returns ``True``) use line buffering.  Other text files use the policy "
"described above for binary files."
msgstr ""
"فایل های متنی \"تعاملی\" (فایل هایی که :meth:`~io.IOBase.isatty` برمی گرداند "
"``True``) از بافر خطی استفاده می کنند. سایر فایل های متنی از سیاستی که در "
"بالا برای فایل های باینری توصیف شد، استفاده می کنند."

#: ../../library/functions.rst:1244
msgid ""
"*encoding* is the name of the encoding used to decode or encode the file. "
"This should only be used in text mode.  The default encoding is platform "
"dependent (whatever :func:`locale.getencoding` returns), but any :term:`text "
"encoding` supported by Python can be used. See the :mod:`codecs` module for "
"the list of supported encodings."
msgstr ""
"*encoding* نام کدگذاری است که برای رمزگشایی یا رمزگذاری فایل استفاده می شود. "
"این فقط باید در حالت متنی استفاده شود. کدگذاری پیش فرض به پلتفرم بستگی دارد "
"(هر چه :func:`locale.getencoding` برمی گرداند)، اما هر :term:`text encoding` "
"که توسط پایتون پشتیبانی می شود، می تواند استفاده شود. برای لیست کدگذاری های "
"پشتیبانی شده به ماژول :mod:`codecs` مراجعه کنید."

#: ../../library/functions.rst:1250
msgid ""
"*errors* is an optional string that specifies how encoding and decoding "
"errors are to be handled—this cannot be used in binary mode. A variety of "
"standard error handlers are available (listed under :ref:`error-handlers`), "
"though any error handling name that has been registered with :func:`codecs."
"register_error` is also valid.  The standard names include:"
msgstr ""
"*errors* یک رشته اختیاری است که مشخص می کند خطاهای رمزگذاری و رمزگشایی چگونه "
"باید مدیریت شوند—این نمی تواند در حالت باینری استفاده شود. یک مجموعه از "
"هندلرهای خطای استاندارد در دسترس هستند (فهرست شده تحت :ref:`error-"
"handlers`)، اگرچه هر نام مدیریت خطایی که با :func:`codecs.register_error` "
"ثبت شده نیز معتبر است. نام های استاندارد شامل:"

#: ../../library/functions.rst:1258
msgid ""
"``'strict'`` to raise a :exc:`ValueError` exception if there is an encoding "
"error.  The default value of ``None`` has the same effect."
msgstr ""
"``'strict'`` برای بالا بردن :exc:`ValueError` استثنا اگر یک خطای encoding "
"وجود داشته باشد. مقدار پیش فرض ``None`` همان اثر را دارد."

#: ../../library/functions.rst:1262
msgid ""
"``'ignore'`` ignores errors.  Note that ignoring encoding errors can lead to "
"data loss."
msgstr ""
"``'ignore'`` خطاها را نادیده می گیرد. توجه داشته باشید که نادیده گرفتن "
"خطاهای رمزگذاری می تواند به از دست رفتن داده ها منجر شود."

#: ../../library/functions.rst:1265
msgid ""
"``'replace'`` causes a replacement marker (such as ``'?'``) to be inserted "
"where there is malformed data."
msgstr ""
"``'replace'`` باعث می شود یک نشانگر جایگزین (مانند ``'?'``) در جایی که داده "
"های ناقص وجود دارد، درج شود."

#: ../../library/functions.rst:1268
msgid ""
"``'surrogateescape'`` will represent any incorrect bytes as low surrogate "
"code units ranging from U+DC80 to U+DCFF. These surrogate code units will "
"then be turned back into the same bytes when the ``surrogateescape`` error "
"handler is used when writing data.  This is useful for processing files in "
"an unknown encoding."
msgstr ""
"``'surrogateescape'`` نشان دهنده هر بایت نادرست به عنوان واحد کد جایگاه "
"پایینی از U+DC80 تا U+DCFF خواهد بود. این واحدهای کد جایگاه سپس به همان بایت "
"ها تبدیل خواهند شد زمانی که از خطایاب ``surrogateescape`` برای نوشتن داده ها "
"استفاده شود. این روش برای پردازش فایل ها در یک کدگذاری ناشناخته مفید است."

#: ../../library/functions.rst:1275
msgid ""
"``'xmlcharrefreplace'`` is only supported when writing to a file. Characters "
"not supported by the encoding are replaced with the appropriate XML "
"character reference :samp:`&#{nnn};`."
msgstr ""
"``'xmlcharrefreplace'`` تنها زمانی که به یک فایل نوشته می شود پشتیبانی می "
"شود. کاراکترهایی که توسط کدگذاری پشتیبانی نمی شوند با مرجع کاراکتر XML مناسب "
"جایگزین می شوند :samp:`&#{nnn};`."

#: ../../library/functions.rst:1279
msgid ""
"``'backslashreplace'`` replaces malformed data by Python's backslashed "
"escape sequences."
msgstr ""
"``'backslashreplace'`` داده های نا درست را با دنباله های فرار پشت پشت شدهٔ "
"پایتون جایگزین می کند."

#: ../../library/functions.rst:1282
msgid ""
"``'namereplace'`` (also only supported when writing) replaces unsupported "
"characters with ``\\N{...}`` escape sequences."
msgstr ""
"``'namereplace'`` (تنها زمانی که نوشتن را پشتیبانی می کند) کاراکترهای "
"پشتیبانی نشده را با توالی فرار ``\\N{...}`` جایگزین می کند."

#: ../../library/functions.rst:1290
msgid ""
"*newline* determines how to parse newline characters from the stream. It can "
"be ``None``, ``''``, ``'\\n'``, ``'\\r'``, and ``'\\r\\n'``.  It works as "
"follows:"
msgstr ""
"*newline* تعیین می کند که چگونه کاراکترهای خط جدید از جریان خوانده شوند. می "
"تواند ``None``، ``''``، ``'\\n'``، ``'\\r'`` و ``'\\r\\n'`` باشد. کارکرد آن "
"به صورت زیر است:"

#: ../../library/functions.rst:1294
msgid ""
"When reading input from the stream, if *newline* is ``None``, universal "
"newlines mode is enabled.  Lines in the input can end in ``'\\n'``, "
"``'\\r'``, or ``'\\r\\n'``, and these are translated into ``'\\n'`` before "
"being returned to the caller.  If it is ``''``, universal newlines mode is "
"enabled, but line endings are returned to the caller untranslated.  If it "
"has any of the other legal values, input lines are only terminated by the "
"given string, and the line ending is returned to the caller untranslated."
msgstr ""
"هنگام خواندن ورودی از جریان، اگر *newline* برابر با ``None`` باشد، حالت خطوط "
"جدید جهانی فعال می شود. خطوط در ورودی می توانند با ``'\\n'``، ``'\\r'`` یا "
"``'\\r\\n'`` پایان یابند و این ها قبل از بازگشت به فراخوان، به ``'\\n'`` "
"تبدیل می شوند. اگر ``''`` باشد، حالت خطوط جدید جهانی فعال است، اما انتهای "
"خطوط بدون ترجمه به فراخوان بازگردانده می شود. اگر دارای هر یک از مقادیر "
"قانونی دیگر باشد، خطوط ورودی تنها با رشته داده شده خاتمه می یابند و انتهای "
"خط بدون ترجمه به فراخوان بازگردانده می شود."

#: ../../library/functions.rst:1302
msgid ""
"When writing output to the stream, if *newline* is ``None``, any ``'\\n'`` "
"characters written are translated to the system default line separator, :"
"data:`os.linesep`.  If *newline* is ``''`` or ``'\\n'``, no translation "
"takes place.  If *newline* is any of the other legal values, any ``'\\n'`` "
"characters written are translated to the given string."
msgstr ""
"هنگام نوشتن خروجی در جریان، اگر *newline* ``None`` باشد، هر کاراکتر "
"``'\\n'`` نوشته شده به جداکننده خط پیش‌فرض سیستم، :data:`os.linesep` ترجمه "
"می‌شود.  اگر *newline* ``''`` یا ``'\\n'`` باشد، هیچ ترجمه ای انجام نمی شود.  "
"اگر *newline* هر یک از مقادیر قانونی دیگر باشد، هر کاراکتر ``'\\n'`` نوشته "
"شده به رشته داده شده ترجمه می شود."

#: ../../library/functions.rst:1308
msgid ""
"If *closefd* is ``False`` and a file descriptor rather than a filename was "
"given, the underlying file descriptor will be kept open when the file is "
"closed.  If a filename is given *closefd* must be ``True`` (the default); "
"otherwise, an error will be raised."
msgstr ""
"اگر *closefd* برابر با ``False`` باشد و به جای یک نام فایل، یک شناسه فایل "
"داده شده باشد، زمانی که فایل بسته می شود، شناسه فایل اصلی باز خواهد ماند. "
"اگر یک نام فایل داده شود، *closefd* باید برابر با ``True`` باشد (به صورت پیش "
"فرض)؛ در غیر این صورت، خطا ایجاد خواهد شد."

#: ../../library/functions.rst:1313
msgid ""
"A custom opener can be used by passing a callable as *opener*. The "
"underlying file descriptor for the file object is then obtained by calling "
"*opener* with (*file*, *flags*). *opener* must return an open file "
"descriptor (passing :mod:`os.open` as *opener* results in functionality "
"similar to passing ``None``)."
msgstr ""
"یک گشاینده سفارشی را می توان با ارسال یک callable به عنوان *opener* استفاده "
"کرد. سپس توصیف کننده فایل پایه برای شیء فایل با فراخوانی *opener* با "
"(*file*, *flags*) به دست می آید. *opener* باید یک توصیف کننده فایل باز را "
"برگرداند (ارسال :mod:`os.open` به عنوان *opener* منجر به عملکردی مشابه با "
"ارسال ``None`` می شود)."

#: ../../library/functions.rst:1319
msgid "The newly created file is :ref:`non-inheritable <fd_inheritance>`."
msgstr "فایل جدید ایجاد شده :ref:`non-inheritable <fd_inheritance>` است."

#: ../../library/functions.rst:1321
msgid ""
"The following example uses the :ref:`dir_fd <dir_fd>` parameter of the :func:"
"`os.open` function to open a file relative to a given directory::"
msgstr ""
"مثال زیر از پارامتر :ref:`dir_fd <dir_fd>` تابع :func:`os.open` برای باز "
"کردن یک فایل نسبت به یک دایرکتوری داده شده استفاده می کند::"

#: ../../library/functions.rst:1334
msgid ""
"The type of :term:`file object` returned by the :func:`open` function "
"depends on the mode.  When :func:`open` is used to open a file in a text "
"mode (``'w'``, ``'r'``, ``'wt'``, ``'rt'``, etc.), it returns a subclass of :"
"class:`io.TextIOBase` (specifically :class:`io.TextIOWrapper`).  When used "
"to open a file in a binary mode with buffering, the returned class is a "
"subclass of :class:`io.BufferedIOBase`.  The exact class varies: in read "
"binary mode, it returns an :class:`io.BufferedReader`; in write binary and "
"append binary modes, it returns an :class:`io.BufferedWriter`, and in read/"
"write mode, it returns an :class:`io.BufferedRandom`.  When buffering is "
"disabled, the raw stream, a subclass of :class:`io.RawIOBase`, :class:`io."
"FileIO`, is returned."
msgstr ""
"نوع :term:`file object` که توسط تابع :func:`open` برگردانده می شود به حالت "
"بستگی دارد. هنگامی که :func:`open` برای باز کردن یک فایل در حالت متنی "
"(``'w'``، ``'r'``، ``'wt'``، ``'rt'`` و غیره) استفاده می شود، یک زیربخش از :"
"class:`io.TextIOBase` (به طور خاص :class:`io.TextIOWrapper`) برمی گرداند. "
"هنگامی که برای باز کردن یک فایل در حالت دودویی با بافرینگ استفاده می شود، "
"کلاس برگردانده شده یک زیربخش از :class:`io.BufferedIOBase` است. کلاس دقیق "
"متغیر است: در حالت خواندن دودویی، یک :class:`io.BufferedReader` برمی گرداند؛ "
"در حالت نوشتن دودویی و ضمیمه کردن دودویی، یک :class:`io.BufferedWriter` برمی "
"گرداند و در حالت خواندن/نوشتن، یک :class:`io.BufferedRandom` برمی گرداند. "
"وقتی که بافرینگ غیرفعال است، جریان خام، که زیرمجموعه ای از :class:`io."
"RawIOBase`، :class:`io.FileIO` است، بازگردانده می شود."

#: ../../library/functions.rst:1355
msgid ""
"See also the file handling modules, such as :mod:`fileinput`, :mod:`io` "
"(where :func:`open` is declared), :mod:`os`, :mod:`os.path`, :mod:"
"`tempfile`, and :mod:`shutil`."
msgstr ""
"همچنین به ماژول های مدیریت فایل مراجعه کنید، مانند :mod:`fileinput`، :mod:"
"`io` (که در آن :func:`open` تعریف شده است)، :mod:`os`، :mod:`os.path`، :mod:"
"`tempfile` و :mod:`shutil`."

#: ../../library/functions.rst:1359
msgid ""
"Raises an :ref:`auditing event <auditing>` ``open`` with arguments ``file``, "
"``mode``, ``flags``."
msgstr ""

#: ../../library/functions.rst:1361
msgid ""
"The ``mode`` and ``flags`` arguments may have been modified or inferred from "
"the original call."
msgstr ""
"ممکن است آرگومان های ``mode`` و ``flags`` از فراخوانی اصلی تغییر کرده یا "
"استنباط شده باشند."

#: ../../library/functions.rst:1366
msgid "The *opener* parameter was added."
msgstr "پارامتر *opener* اضافه شد."

#: ../../library/functions.rst:1367
msgid "The ``'x'`` mode was added."
msgstr "حالت ``'x'`` اضافه شد."

#: ../../library/functions.rst:1368
msgid ":exc:`IOError` used to be raised, it is now an alias of :exc:`OSError`."
msgstr ":exc:`IOError` قبلاً مطرح می شد، اکنون نام مستعار :exc:`OSError` است."

#: ../../library/functions.rst:1369
msgid ""
":exc:`FileExistsError` is now raised if the file opened in exclusive "
"creation mode (``'x'``) already exists."
msgstr ""
"اگر فایلی که در حالت ایجاد انحصاری باز شده است (``'x'``) قبلاً وجود داشته "
"باشد، اکنون :exc:`FileExistsError` برانگیخته می شود."

#: ../../library/functions.rst:1374
msgid "The file is now non-inheritable."
msgstr "فایل در حال حاضر غیر قابل ارث است."

#: ../../library/functions.rst:1378
msgid ""
"If the system call is interrupted and the signal handler does not raise an "
"exception, the function now retries the system call instead of raising an :"
"exc:`InterruptedError` exception (see :pep:`475` for the rationale)."
msgstr ""
"اگر فراخوانی سیستم قطع شود و مدیریت کننده سیگنال استثنایی ایجاد نکند، تابع "
"اکنون به جای ایجاد یک استثنای :exc:`InterruptedError` فراخوانی سیستم را "
"مجدداً امتحان می کند (برای دلایل مربوطه، به :pep:`475` مراجعه کنید)."

#: ../../library/functions.rst:1381
msgid "The ``'namereplace'`` error handler was added."
msgstr "مدبر خطای ``'namereplace'`` اضافه شد."

#: ../../library/functions.rst:1385
msgid "Support added to accept objects implementing :class:`os.PathLike`."
msgstr ""
"پشتیبانی برای پذیرش اشیایی که :class:`os.PathLike` را پیاده سازی می کنند "
"اضافه شد."

#: ../../library/functions.rst:1386
msgid ""
"On Windows, opening a console buffer may return a subclass of :class:`io."
"RawIOBase` other than :class:`io.FileIO`."
msgstr ""
"در ویندوز، باز کردن یک بافر کنسول ممکن است زیرکلاسی از :class:`io.RawIOBase` "
"را به جای :class:`io.FileIO` برگرداند."

#: ../../library/functions.rst:1389
msgid "The ``'U'`` mode has been removed."
msgstr "حالت ``'U'`` حذف شده است."

#: ../../library/functions.rst:1394
msgid ""
"Given a string representing one Unicode character, return an integer "
"representing the Unicode code point of that character.  For example, "
"``ord('a')`` returns the integer ``97`` and ``ord('€')`` (Euro sign) returns "
"``8364``.  This is the inverse of :func:`chr`."
msgstr ""
"با دریافت یک رشته که نشان دهنده ی یک نویسه ی یونیکد است، یک عدد صحیح که نشان "
"دهنده ی نقطه ی کد یونیکد آن نویسه است را برمی گرداند. به عنوان مثال، "
"``ord('a')`` عدد صحیح ``97`` را برمی گرداند و ``ord('€')`` (نماد یورو) عدد "
"``8364`` را برمی گرداند. این عملکرد عکس :func:`chr` است."

#: ../../library/functions.rst:1402
msgid ""
"Return *base* to the power *exp*; if *mod* is present, return *base* to the "
"power *exp*, modulo *mod* (computed more efficiently than ``pow(base, exp) % "
"mod``). The two-argument form ``pow(base, exp)`` is equivalent to using the "
"power operator: ``base**exp``."
msgstr ""
"بازگرداندن *base* به توان *exp*؛ اگر *mod* موجود است، بازگرداندن *base* به "
"توان *exp*، مدول *mod* (که به طور موثرتری نسبت به ``pow(base, exp) % mod`` "
"محاسبه می شود). فرم دو آرگومانی ``pow(base, exp)`` معادل استفاده از عملگر "
"توان است: ``base**exp``."

#: ../../library/functions.rst:1407
msgid ""
"The arguments must have numeric types.  With mixed operand types, the "
"coercion rules for binary arithmetic operators apply.  For :class:`int` "
"operands, the result has the same type as the operands (after coercion) "
"unless the second argument is negative; in that case, all arguments are "
"converted to float and a float result is delivered.  For example, ``pow(10, "
"2)`` returns ``100``, but ``pow(10, -2)`` returns ``0.01``.  For a negative "
"base of type :class:`int` or :class:`float` and a non-integral exponent, a "
"complex result is delivered.  For example, ``pow(-9, 0.5)`` returns a value "
"close to ``3j``."
msgstr ""

#: ../../library/functions.rst:1417
msgid ""
"For :class:`int` operands *base* and *exp*, if *mod* is present, *mod* must "
"also be of integer type and *mod* must be nonzero. If *mod* is present and "
"*exp* is negative, *base* must be relatively prime to *mod*. In that case, "
"``pow(inv_base, -exp, mod)`` is returned, where *inv_base* is an inverse to "
"*base* modulo *mod*."
msgstr ""
"برای عملوندهای :class:`int` یعنی *base* و *exp*، اگر *mod* وجود داشته باشد، "
"*mod* نیز باید از نوع عدد صحیح باشد و *mod* نباید صفر باشد. اگر *mod* وجود "
"داشته باشد و *exp* منفی باشد، *base* باید نسبت به *mod* نسبتاً اول باشد. در "
"این صورت، ``pow(inv_base, -exp, mod)`` بازگردانده می شود، جایی که *inv_base* "
"معکوس *base* به پیمانه *mod* است."

#: ../../library/functions.rst:1423
msgid "Here's an example of computing an inverse for ``38`` modulo ``97``::"
msgstr ""
"در اینجا یک مثال از محاسبه معکوس برای ``38`` مدولوی ``97`` ارائه شده است::"

#: ../../library/functions.rst:1430
msgid ""
"For :class:`int` operands, the three-argument form of ``pow`` now allows the "
"second argument to be negative, permitting computation of modular inverses."
msgstr ""
"برای عملگرهای :class:`int`، اکنون فرم سه آرگومانی ``pow`` اجازه می دهد که "
"آرگومان دوم منفی باشد، که این به محاسبه معکوس های مدولار کمک می کند."

#: ../../library/functions.rst:1435
msgid ""
"Allow keyword arguments.  Formerly, only positional arguments were supported."
msgstr ""
"اجازه دادن به آرگومان های کلیدواژه ای. قبلاً فقط آرگومان های موقعیتی پشتیبانی "
"می شدند."

#: ../../library/functions.rst:1442
msgid ""
"Print *objects* to the text stream *file*, separated by *sep* and followed "
"by *end*.  *sep*, *end*, *file*, and *flush*, if present, must be given as "
"keyword arguments."
msgstr ""
"*objects* را به جریان متنی *file* چاپ می کند، که توسط *sep* جدا شده و با "
"*end* دنبال می شود. *sep*, *end*, *file*, و *flush*، اگر موجود باشند، باید "
"به عنوان آرگومان های کلیدی ارائه شوند."

#: ../../library/functions.rst:1446
msgid ""
"All non-keyword arguments are converted to strings like :func:`str` does and "
"written to the stream, separated by *sep* and followed by *end*.  Both *sep* "
"and *end* must be strings; they can also be ``None``, which means to use the "
"default values.  If no *objects* are given, :func:`print` will just write "
"*end*."
msgstr ""
"همه آرگومان های غیرکلیدی به رشته ها تبدیل می شوند مانند :func:`str` و به "
"جریان نوشته می شوند، با *sep* از هم جدا شده و به دنبال *end* می آیند. هر دو "
"*sep* و *end* باید رشته باشند؛ آنها می توانند همچنین ``None`` باشند، به این "
"معنی که از مقادیر پیش فرض استفاده می شود. اگر هیچ *objects* داده نشده "
"باشند، :func:`print` فقط *end* را خواهد نوشت."

#: ../../library/functions.rst:1452
msgid ""
"The *file* argument must be an object with a ``write(string)`` method; if it "
"is not present or ``None``, :data:`sys.stdout` will be used.  Since printed "
"arguments are converted to text strings, :func:`print` cannot be used with "
"binary mode file objects.  For these, use ``file.write(...)`` instead."
msgstr ""
"آرگومان *file* باید یک شیء با یک متد ``write(string)`` باشد؛ اگر حضور نداشته "
"باشد یا ``None`` باشد، از :data:`sys.stdout` استفاده خواهد شد. از آنجایی که "
"آرگومان های پرینت شده به رشته های متنی تبدیل می شوند، :func:`print` نمی "
"تواند با اشیای فایل در حالت باینری استفاده شود. برای این موارد، به جای آن از "
"``file.write(...)`` استفاده کنید."

#: ../../library/functions.rst:1457
msgid ""
"Output buffering is usually determined by *file*. However, if *flush* is "
"true, the stream is forcibly flushed."
msgstr ""
"بافر خروجی معمولاً توسط *file* تعیین می شود. با این حال، اگر *flush* صحیح "
"باشد، جریان به طور اجباری تخلیه می شود."

#: ../../library/functions.rst:1461
msgid "Added the *flush* keyword argument."
msgstr "آرگومان کلیدواژه *flush* اضافه شد."

#: ../../library/functions.rst:1467
msgid "Return a property attribute."
msgstr "یک ویژگی property را بازمی گرداند."

#: ../../library/functions.rst:1469
msgid ""
"*fget* is a function for getting an attribute value.  *fset* is a function "
"for setting an attribute value. *fdel* is a function for deleting an "
"attribute value.  And *doc* creates a docstring for the attribute."
msgstr ""
"*fget* یک تابع برای دریافت مقدار یک ویژگی است. *fset* یک تابع برای تنظیم "
"مقدار یک ویژگی است. *fdel* یک تابع برای حذف مقدار یک ویژگی است. و *doc* یک "
"docstring برای ویژگی ایجاد می کند."

#: ../../library/functions.rst:1473
msgid "A typical use is to define a managed attribute ``x``::"
msgstr "یک استفاده معمول این است که یک ویژگی مدیریت شده ``x`` تعریف کنید::"

#: ../../library/functions.rst:1490
msgid ""
"If *c* is an instance of *C*, ``c.x`` will invoke the getter, ``c.x = "
"value`` will invoke the setter, and ``del c.x`` the deleter."
msgstr ""
"اگر *c* نمونه ای از *C* باشد، ``c.x`` فراخوانی کنندهٔ getter، ``c.x = value`` "
"فراخوانی کنندهٔ setter و ``del c.x`` فراخوانی کنندهٔ deleter خواهد بود."

#: ../../library/functions.rst:1493
msgid ""
"If given, *doc* will be the docstring of the property attribute. Otherwise, "
"the property will copy *fget*'s docstring (if it exists).  This makes it "
"possible to create read-only properties easily using :func:`property` as a :"
"term:`decorator`::"
msgstr ""
"اگر ارائه شده باشد، *doc* به عنوان docstring ویژگی property خواهد بود. در "
"غیر این صورت، property docstring *fget* را (اگر وجود داشته باشد) کپی خواهد "
"کرد. این امکان را فراهم می کند تا به سادگی از :func:`property` به عنوان یک :"
"term:`decorator` استفاده کنید و ویژگی های فقط خواندنی ایجاد نمایید::"

#: ../../library/functions.rst:1506
msgid ""
"The ``@property`` decorator turns the :meth:`!voltage` method into a "
"\"getter\" for a read-only attribute with the same name, and it sets the "
"docstring for *voltage* to \"Get the current voltage.\""
msgstr ""
"دکوراتور ``@property`` متد :meth:`!voltage` را به یک \"getter\" برای یک "
"ویژگی فقط خواندنی با همان نام تبدیل می کند و رشته داکیومنت برای *voltage* را "
"به \"Get the current voltage.\" تنظیم می کند."

#: ../../library/functions.rst:1514
msgid ""
"A property object has ``getter``, ``setter``, and ``deleter`` methods usable "
"as decorators that create a copy of the property with the corresponding "
"accessor function set to the decorated function.  This is best explained "
"with an example:"
msgstr ""
"یک شیء property دارای متدهای ``getter``، ``setter``، و ``deleter`` است که به "
"عنوان تزئین کننده ها استفاده می شوند و یک کپی از property را با تابع دسترسی "
"مربوطه که به تابع تزئین شده تنظیم شده است، ایجاد می کنند. این موضوع با یک "
"مثال بهتر توضیح داده می شود:"

#: ../../library/functions.rst:1538
msgid ""
"This code is exactly equivalent to the first example.  Be sure to give the "
"additional functions the same name as the original property (``x`` in this "
"case.)"
msgstr ""
"این کد دقیقا معادل با مثال اول است. مطمئن شوید که توابع اضافی همان نام ویژگی "
"اصلی (در اینجا ``x``) را داشته باشند."

#: ../../library/functions.rst:1542
msgid ""
"The returned property object also has the attributes ``fget``, ``fset``, and "
"``fdel`` corresponding to the constructor arguments."
msgstr ""
"شیء ویژگی برگردانده شده همچنین دارای خصوصیات ``fget``، ``fset`` و ``fdel`` "
"است که معادل با آرگومان های سازنده هستند."

#: ../../library/functions.rst:1545
msgid "The docstrings of property objects are now writeable."
msgstr "رشته های مستندات اشیاء ویژگی اکنون قابل نوشتن هستند."

#: ../../library/functions.rst:1554
msgid ""
"Rather than being a function, :class:`range` is actually an immutable "
"sequence type, as documented in :ref:`typesseq-range` and :ref:`typesseq`."
msgstr ""
"به جای اینکه :class:`range` یک تابع باشد، در واقع یک نوع دنباله ثابت است، "
"همان طور که در :ref:`typesseq-range` و :ref:`typesseq` مستند شده است."

#: ../../library/functions.rst:1560
msgid ""
"Return a string containing a printable representation of an object.  For "
"many types, this function makes an attempt to return a string that would "
"yield an object with the same value when passed to :func:`eval`; otherwise, "
"the representation is a string enclosed in angle brackets that contains the "
"name of the type of the object together with additional information often "
"including the name and address of the object.  A class can control what this "
"function returns for its instances by defining a :meth:`~object.__repr__` "
"method. If :func:`sys.displayhook` is not accessible, this function will "
"raise :exc:`RuntimeError`."
msgstr ""
"یک رشته که نمایش قابل چاپ از یک شئ را در بر دارد، بر می گرداند. برای بسیاری "
"از انواع، این تابع سعی می کند رشته ای را برگرداند که به عنوان ورودی :func:"
"`eval` یک شئ با همان مقدار را تولید کند؛ در غیر این صورت، نمایش به صورت یک "
"رشته داخل پرانتزهای زاویه دار است که نام نوع شئ به همراه اطلاعات اضافی که "
"معمولاً شامل نام و آدرس شئ است، می باشد. یک کلاس می تواند مشخص کند که این "
"تابع برای نمونه های خود چه چیزی بر می گرداند، با تعریف متد :meth:`~object."
"__repr__`. اگر :func:`sys.displayhook` قابل دسترسی نباشد، این تابع :exc:"
"`RuntimeError` را ایجاد می کند."

#: ../../library/functions.rst:1571
msgid "This class has a custom representation that can be evaluated::"
msgstr "این کلاس یک نمایش سفارشی دارد که می تواند ارزیابی شود::"

#: ../../library/functions.rst:1584
msgid ""
"Return a reverse :term:`iterator`.  *seq* must be an object which has a :"
"meth:`~object.__reversed__` method or supports the sequence protocol (the :"
"meth:`~object.__len__` method and the :meth:`~object.__getitem__` method "
"with integer arguments starting at ``0``)."
msgstr ""
"برمی گرداند یک :term:`iterator` معکوس. *seq* باید یک شی باشد که دارای یک "
"متد :meth:`~object.__reversed__` باشد یا از پروتکل توالی پشتیبانی کند (متد :"
"meth:`~object.__len__` و متد :meth:`~object.__getitem__` با آرگومان های عدد "
"صحیح که از ``0`` شروع می شوند)."

#: ../../library/functions.rst:1592
msgid ""
"Return *number* rounded to *ndigits* precision after the decimal point.  If "
"*ndigits* is omitted or is ``None``, it returns the nearest integer to its "
"input."
msgstr ""
"*number* را به دقت *ndigits* پس از نقطهٔ اعشار گرد می کند. اگر *ndigits* حذف "
"شود یا ``None`` باشد، نزدیک ترین عدد صحیح به ورودی بازگردانده می شود."

#: ../../library/functions.rst:1596
msgid ""
"For the built-in types supporting :func:`round`, values are rounded to the "
"closest multiple of 10 to the power minus *ndigits*; if two multiples are "
"equally close, rounding is done toward the even choice (so, for example, "
"both ``round(0.5)`` and ``round(-0.5)`` are ``0``, and ``round(1.5)`` is "
"``2``).  Any integer value is valid for *ndigits* (positive, zero, or "
"negative).  The return value is an integer if *ndigits* is omitted or "
"``None``. Otherwise, the return value has the same type as *number*."
msgstr ""
"برای انواع داخلی که از :func:`round` پشتیبانی می کنند، مقادیر به نزدیک ترین "
"مضرب 10 به توان منفی *ndigits* گرد می شوند؛ اگر دو مضرب به طور مساوی نزدیک "
"باشند، گرد کردن به سمت گزینه زوج انجام می شود (برای مثال، هر دو "
"``round(0.5)`` و ``round(-0.5)`` برابر با ``0`` هستند، و ``round(1.5)`` "
"برابر با ``2`` است). هر مقدار صحیح برای *ndigits* معتبر است (مثبت، صفر، یا "
"منفی). مقدار بازگشتی یک عدد صحیح است اگر *ndigits* حذف شود یا ``None`` باشد. "
"در غیر این صورت، مقدار بازگشتی از همان نوع *number* خواهد بود."

#: ../../library/functions.rst:1605
msgid ""
"For a general Python object ``number``, ``round`` delegates to ``number."
"__round__``."
msgstr ""
"برای یک شیء عمومی پایتون ``number``، ``round`` به ``number.__round__`` "
"واگذار می شود."

#: ../../library/functions.rst:1610
msgid ""
"The behavior of :func:`round` for floats can be surprising: for example, "
"``round(2.675, 2)`` gives ``2.67`` instead of the expected ``2.68``. This is "
"not a bug: it's a result of the fact that most decimal fractions can't be "
"represented exactly as a float.  See :ref:`tut-fp-issues` for more "
"information."
msgstr ""
"رفتار :func:`round` برای اعشار ممکن است تعجب آور باشد: به عنوان مثال، "
"``round(2.675, 2)`` به جای ``2.68`` مقدار ``2.67`` را می دهد. این یک اشکال "
"نیست: این به دلیل این واقعیت است که بیشتر کسرهای دهدهی نمی توانند به طور "
"دقیق به عنوان یک عدد اعشاری نشان داده شوند. برای اطلاعات بیشتر به :ref:`tut-"
"fp-issues` مراجعه کنید."

#: ../../library/functions.rst:1622
msgid ""
"Return a new :class:`set` object, optionally with elements taken from "
"*iterable*.  ``set`` is a built-in class.  See :class:`set` and :ref:`types-"
"set` for documentation about this class."
msgstr ""
"یک شیء جدید :class:`set` بازمی گرداند، در صورت نیاز با عناصری که از "
"*iterable* گرفته شده اند. ``set`` یک کلاس داخلی است. برای مستندسازی درباره "
"این کلاس به :class:`set` و :ref:`types-set` مراجعه کنید."

#: ../../library/functions.rst:1626
msgid ""
"For other containers see the built-in :class:`frozenset`, :class:`list`, :"
"class:`tuple`, and :class:`dict` classes, as well as the :mod:`collections` "
"module."
msgstr ""
"برای سایر کانتینرها، به کلاس های داخلی :class:`frozenset`، :class:`list`، :"
"class:`tuple`، و :class:`dict` مراجعه کنید، همچنین به ماژول :mod:"
"`collections` مراجعه نمایید."

#: ../../library/functions.rst:1633
msgid ""
"This is the counterpart of :func:`getattr`.  The arguments are an object, a "
"string, and an arbitrary value.  The string may name an existing attribute "
"or a new attribute.  The function assigns the value to the attribute, "
"provided the object allows it.  For example, ``setattr(x, 'foobar', 123)`` "
"is equivalent to ``x.foobar = 123``."
msgstr ""
"این قسمت معادل :func:`getattr` است. آرگومان ها شامل یک شیء، یک رشته و یک "
"مقدار دلخواه هستند. رشته می تواند نام یک ویژگی موجود یا یک ویژگی جدید باشد. "
"این تابع مقدار را به ویژگی تخصیص می دهد، به شرطی که شیء اجازه این کار را "
"بدهد. برای مثال، ``setattr(x, 'foobar', 123)`` معادل با ``x.foobar = 123`` "
"است."

#: ../../library/functions.rst:1639
msgid ""
"*name* need not be a Python identifier as defined in :ref:`identifiers` "
"unless the object chooses to enforce that, for example in a custom :meth:"
"`~object.__getattribute__` or via :attr:`~object.__slots__`. An attribute "
"whose name is not an identifier will not be accessible using the dot "
"notation, but is accessible through :func:`getattr` etc.."
msgstr ""
"*name* نیازی نیست که یک شناسه پایتون باشد همانطور که در :ref:`identifiers` "
"تعریف شده است، مگر اینکه شیء تصمیم بگیرد آن را اعمال کند، به عنوان مثال در "
"یک :meth:`~object.__getattribute__` سفارشی یا از طریق :attr:`~object."
"__slots__`. ویژگی ای که نامش شناسه نیست از طریق نشانه گذاری نقطه قابل دسترسی "
"نخواهد بود، اما از طریق :func:`getattr` و غیره قابل دسترسی است."

#: ../../library/functions.rst:1647
msgid ""
"Since :ref:`private name mangling <private-name-mangling>` happens at "
"compilation time, one must manually mangle a private attribute's (attributes "
"with two leading underscores) name in order to set it with :func:`setattr`."
msgstr ""
"از آنجا که :ref:`private name mangling <private-name-mangling>` در زمان "
"کامپایل رخ می دهد، لازم است که نام یک ویژگی خصوصی (ویژگی هایی با دو خط تیره "
"در ابتدا) را به صورت دستی تغییر دهید تا بتوانید آن را با :func:`setattr` "
"تنظیم کنید."

#: ../../library/functions.rst:1656
msgid ""
"Return a :term:`slice` object representing the set of indices specified by "
"``range(start, stop, step)``.  The *start* and *step* arguments default to "
"``None``."
msgstr ""
"یک شیء :term:`slice` را بازگردانید که مجموعه ای از شاخص های مشخص شده توسط "
"``range(start, stop, step)`` را نشان می دهد. آرگومان های *start* و *step* به "
"صورت پیش فرض به ``None`` تنظیم شده اند."

#: ../../library/functions.rst:1664
msgid ""
"Slice objects have read-only data attributes :attr:`!start`, :attr:`!stop`, "
"and :attr:`!step` which merely return the argument values (or their "
"default).  They have no other explicit functionality; however, they are used "
"by NumPy and other third-party packages."
msgstr ""
"اشیاء Slice دارای ویژگی های داده ای فقط خواندنی :attr:`!start`، :attr:`!"
"stop`، و :attr:`!step` هستند که صرفاً مقادیر آرگومان ها (یا مقدار پیش فرض آن "
"ها) را برمی گردانند. آن ها هیچ کارکرد صریح دیگری ندارند؛ با این حال، توسط "
"NumPy و سایر بسته های شخص ثالث استفاده می شوند."

#: ../../library/functions.rst:1669
msgid ""
"Slice objects are also generated when extended indexing syntax is used.  For "
"example: ``a[start:stop:step]`` or ``a[start:stop, i]``.  See :func:"
"`itertools.islice` for an alternate version that returns an :term:`iterator`."
msgstr ""
"همچنین وقتی از نگارش گسترش یافته ی ایندکس گذاری استفاده می شود، اشیاء برش "
"تولید می شوند. به عنوان مثال: ``a[start:stop:step]`` یا ``a[start:stop, "
"i]``. برای نسخه ای جایگزین که یک :term:`iterator` برمی گرداند، به :func:"
"`itertools.islice` مراجعه کنید."

#: ../../library/functions.rst:1677
msgid "Return a new sorted list from the items in *iterable*."
msgstr "یک لیست جدید مرتب شده از آیتم های موجود در *iterable* بازگردانید."

#: ../../library/functions.rst:1679
msgid ""
"Has two optional arguments which must be specified as keyword arguments."
msgstr ""
"دارای دو آرگومان اختیاری است که باید به عنوان آرگومان کلمه کلیدی مشخص شوند."

#: ../../library/functions.rst:1681
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each element in *iterable* (for example, ``key=str."
"lower``).  The default value is ``None`` (compare the elements directly)."
msgstr ""
"*key* یک تابع با یک آرگومان را مشخص می کند که برای استخراج یک کلید مقایسه از "
"هر عنصر در *iterable* استفاده می شود (برای مثال، ``key=str.lower``). مقدار "
"پیش فرض ``None`` است (عناصر را مستقیماً مقایسه کنید)."

#: ../../library/functions.rst:1685
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr ""
"*reverse* یک مقدار بولی است.  اگر روی ``True`` تنظیم شود، عناصر لیست طوری "
"مرتب می شوند که گویی هر مقایسه معکوس شده است."

#: ../../library/functions.rst:1688
msgid ""
"Use :func:`functools.cmp_to_key` to convert an old-style *cmp* function to a "
"*key* function."
msgstr ""
"از :func:`functools.cmp_to_key` استفاده کنید تا یک تابع *cmp* قدیمی را به یک "
"تابع *key* تبدیل کنید."

#: ../../library/functions.rst:1691
msgid ""
"The built-in :func:`sorted` function is guaranteed to be stable. A sort is "
"stable if it guarantees not to change the relative order of elements that "
"compare equal --- this is helpful for sorting in multiple passes (for "
"example, sort by department, then by salary grade)."
msgstr ""
"تابع داخلی :func:`sorted` تضمین شده که پایدار است. یک مرتب سازی زمانی پایدار "
"است که تضمین کند ترتیب نسبی عناصر با مقادیر برابر را تغییر ندهد --- این "
"ویژگی در مرتب سازی در چند مرحله مفید است (برای مثال، ابتدا بر اساس دپارتمان "
"و سپس بر اساس درجه حقوق مرتب سازی شود)."

#: ../../library/functions.rst:1696
msgid ""
"The sort algorithm uses only ``<`` comparisons between items.  While "
"defining an :meth:`~object.__lt__` method will suffice for sorting, :PEP:`8` "
"recommends that all six :ref:`rich comparisons <comparisons>` be "
"implemented.  This will help avoid bugs when using the same data with other "
"ordering tools such as :func:`max` that rely on a different underlying "
"method.  Implementing all six comparisons also helps avoid confusion for "
"mixed type comparisons which can call reflected the :meth:`~object.__gt__` "
"method."
msgstr ""
"الگوریتم مرتب سازی فقط از مقایسه های ``<`` بین آیتم ها استفاده می کند. در "
"حالی که تعریف یک روش :meth:`~object.__lt__` برای مرتب سازی کافی است، :PEP:"
"`8` توصیه می کند که هر شش :ref:`rich comparisons <comparisons>` پیاده سازی "
"شوند. این امر به جلوگیری از باگ ها هنگامی که از همان داده ها با ابزارهای "
"ترتیب دهی دیگر که وابسته به یک روش زیرین متفاوت مانند :func:`max` هستند، کمک "
"می کند. پیاده سازی هر شش مقایسه همچنین به جلوگیری از سردرگمی در مقایسه های "
"نوع مختلط که می توانند روش منعکس شده :meth:`~object.__gt__` را فراخوانی "
"کنند، کمک می کند."

#: ../../library/functions.rst:1705
msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr ""
"برای نمونه‌های مرتب‌سازی و یک آموزش مختصر مرتب‌سازی، به :ref:`sortinghowto` "
"مراجعه کنید."

#: ../../library/functions.rst:1709
msgid "Transform a method into a static method."
msgstr "تبدیل یک متد به یک متد ایستا."

#: ../../library/functions.rst:1711
msgid ""
"A static method does not receive an implicit first argument. To declare a "
"static method, use this idiom::"
msgstr ""
"یک متد استاتیک، آرگومان اول اولیه را به صورت ضمنی دریافت نمی کند. برای تعریف "
"یک متد استاتیک از این روش استفاده کنید::"

#: ../../library/functions.rst:1718
msgid ""
"The ``@staticmethod`` form is a function :term:`decorator` -- see :ref:"
"`function` for details."
msgstr ""
"فرم ``@staticmethod`` یک تابع :term:`decorator` است -- برای جزئیات به :ref:"
"`function` مراجعه کنید."

#: ../../library/functions.rst:1721
msgid ""
"A static method can be called either on the class (such as ``C.f()``) or on "
"an instance (such as ``C().f()``). Moreover, they can be called as regular "
"functions (such as ``f()``)."
msgstr ""

#: ../../library/functions.rst:1725
msgid ""
"Static methods in Python are similar to those found in Java or C++. Also, "
"see :func:`classmethod` for a variant that is useful for creating alternate "
"class constructors."
msgstr ""
"متدهای استاتیک در پایتون شبیه به آن هایی هستند که در جاوا یا C++ یافت می "
"شوند. همچنین، :func:`classmethod` را برای نوعی ببینید که برای ایجاد سازنده "
"های کلاس جایگزین مفید است."

#: ../../library/functions.rst:1729
msgid ""
"Like all decorators, it is also possible to call ``staticmethod`` as a "
"regular function and do something with its result.  This is needed in some "
"cases where you need a reference to a function from a class body and you "
"want to avoid the automatic transformation to instance method.  For these "
"cases, use this idiom::"
msgstr ""
"مانند تمام دکوراتورها، این امکان وجود دارد که ``staticmethod`` را به عنوان "
"یک تابع معمولی فراخوانی کرده و کاری با نتیجه آن انجام دهید. این در مواردی که "
"نیاز به مرجع یک تابع از بدنه یک کلاس دارید و می خواهید از تبدیل خودکار به "
"متد نمونه جلوگیری کنید، لازم است. برای این موارد، از این روش استفاده کنید::"

#: ../../library/functions.rst:1741
msgid "For more information on static methods, see :ref:`types`."
msgstr "برای اطلاعات بیشتر در مورد متدهای ایستا، به :ref:`types` مراجعه کنید."

#: ../../library/functions.rst:1743
msgid ""
"Static methods now inherit the method attributes (``__module__``, "
"``__name__``, ``__qualname__``, ``__doc__`` and ``__annotations__``), have a "
"new ``__wrapped__`` attribute, and are now callable as regular functions."
msgstr ""

#: ../../library/functions.rst:1758
msgid ""
"Return a :class:`str` version of *object*.  See :func:`str` for details."
msgstr ""
" یک نسخه :class:`str` از *شیء* برمیگرداند. برای جزئیات بیشتر به :func:"
"`str`مراجعه کنید."

#: ../../library/functions.rst:1760
msgid ""
"``str`` is the built-in string :term:`class`.  For general information about "
"strings, see :ref:`textseq`."
msgstr ""
"``str`` رشته ای داخلی است :term:`class`. برای اطلاعات کلی درباره رشته ها، "
"به :ref:`textseq` مراجعه کنید."

#: ../../library/functions.rst:1766
msgid ""
"Sums *start* and the items of an *iterable* from left to right and returns "
"the total.  The *iterable*'s items are normally numbers, and the start value "
"is not allowed to be a string."
msgstr ""
"مجموع *start* و آیتم های یک *iterable* را از چپ به راست محاسبه کرده و حاصل "
"را برمی گرداند. آیتم های *iterable* معمولاً اعداد هستند و مقدار شروع نمی "
"تواند یک رشته باشد."

#: ../../library/functions.rst:1770
msgid ""
"For some use cases, there are good alternatives to :func:`sum`. The "
"preferred, fast way to concatenate a sequence of strings is by calling ``''."
"join(sequence)``.  To add floating point values with extended precision, "
"see :func:`math.fsum`\\.  To concatenate a series of iterables, consider "
"using :func:`itertools.chain`."
msgstr ""

#: ../../library/functions.rst:1776
msgid "The *start* parameter can be specified as a keyword argument."
msgstr "پارامتر *start* می تواند به عنوان یک آرگومان کلیدواژه مشخص شود."

#: ../../library/functions.rst:1782
msgid ""
"Return a proxy object that delegates method calls to a parent or sibling "
"class of *type*.  This is useful for accessing inherited methods that have "
"been overridden in a class."
msgstr ""
"یک شیء نماینده را بازمی گرداند که فراخوانی متدها را به یک کلاس والد یا هم "
"سطح از *type* واگذار می کند. این کار برای دستیابی به متدهای به ارث برده شده "
"که در یک کلاس بازنویسی شده اند مفید است."

#: ../../library/functions.rst:1786
msgid ""
"The *object_or_type* determines the :term:`method resolution order` to be "
"searched.  The search starts from the class right after the *type*."
msgstr ""
"*object_or_type* عامل تعیین کننده :term:`method resolution order` برای جستجو "
"است. جستجو از کلاسی که بلافاصله پس از *type* قرار دارد شروع می شود."

#: ../../library/functions.rst:1790
msgid ""
"For example, if :attr:`~class.__mro__` of *object_or_type* is ``D -> B -> C -"
"> A -> object`` and the value of *type* is ``B``, then :func:`super` "
"searches ``C -> A -> object``."
msgstr ""

#: ../../library/functions.rst:1794
msgid ""
"The :attr:`~class.__mro__` attribute of the *object_or_type* lists the "
"method resolution search order used by both :func:`getattr` and :func:"
"`super`.  The attribute is dynamic and can change whenever the inheritance "
"hierarchy is updated."
msgstr ""

#: ../../library/functions.rst:1799
msgid ""
"If the second argument is omitted, the super object returned is unbound.  If "
"the second argument is an object, ``isinstance(obj, type)`` must be true.  "
"If the second argument is a type, ``issubclass(type2, type)`` must be true "
"(this is useful for classmethods)."
msgstr ""
"اگر آرگومان دوم حذف شود، شیء  super برگردانده شده بدون محدودیت خواهد بود. "
"اگر آرگومان دوم یک شیء باشد، ``isinstance(obj, type)`` باید درست باشد. اگر "
"آرگومان دوم یک نوع باشد، ``issubclass(type2, type)`` باید درست باشد (این "
"برای classmethods مفید است)."

#: ../../library/functions.rst:1804
msgid ""
"There are two typical use cases for *super*.  In a class hierarchy with "
"single inheritance, *super* can be used to refer to parent classes without "
"naming them explicitly, thus making the code more maintainable.  This use "
"closely parallels the use of *super* in other programming languages."
msgstr ""
"دو کاربرد معمول برای *super* وجود دارد. در سلسله مراتب کلاس با وراثت تک "
"گانه، *super* می تواند برای ارجاع به کلاس های والد بدون نام گذاری صریح آن ها "
"استفاده شود، و به این ترتیب کد قابل نگهداری تر می شود. این استفاده به طور "
"نزدیک با استفاده از *super* در زبان های برنامه نویسی دیگر مشابه است."

#: ../../library/functions.rst:1809
msgid ""
"The second use case is to support cooperative multiple inheritance in a "
"dynamic execution environment.  This use case is unique to Python and is not "
"found in statically compiled languages or languages that only support single "
"inheritance.  This makes it possible to implement \"diamond diagrams\" where "
"multiple base classes implement the same method.  Good design dictates that "
"such implementations have the same calling signature in every case (because "
"the order of calls is determined at runtime, because that order adapts to "
"changes in the class hierarchy, and because that order can include sibling "
"classes that are unknown prior to runtime)."
msgstr ""
"مورد استفاده دوم برای پشتیبانی از ارث بری چندگانه تعاونی در یک محیط اجرای "
"پویا است. این مورد استفاده به طور منحصر به فرد به پایتون تعلق دارد و در زبان "
"های که به صورت ایستا کامپایل می شوند یا تنها از ارث بری تکی پشتیبانی می "
"کنند، یافت نمی شود. این امکان را فراهم می کند تا \"نمودارهای الماس\" پیاده "
"سازی شود، جایی که کلاس های پایه متعدد یک روش یکسان را پیاده سازی می کنند. "
"طراحی خوب ایجاب می کند که چنین پیاده سازی هایی در هر مورد امضای یکسانی برای "
"فراخوانی داشته باشند (زیرا ترتیب فراخوانی ها در زمان اجرا تعیین می شود، زیرا "
"آن ترتیب با تغییرات در سلسله مراتب کلاس تطابق می یابد، و زیرا آن ترتیب می "
"تواند شامل کلاس های هم رده ای باشد که قبل از زمان اجرا ناشناخته هستند)."

#: ../../library/functions.rst:1819
msgid "For both use cases, a typical superclass call looks like this::"
msgstr ""
"برای هر دو مورد استفاده، یک فراخوانی معمولی به ابرکلاس به این صورت است::"

#: ../../library/functions.rst:1826
msgid ""
"In addition to method lookups, :func:`super` also works for attribute "
"lookups.  One possible use case for this is calling :term:`descriptors "
"<descriptor>` in a parent or sibling class."
msgstr ""
"علاوه بر جستجوی متد، :func:`super` همچنین برای جستجوی ویژگی ها نیز کار می "
"کند. یکی از موارد استفاده ممکن برای این کاربرد، فراخوانی :term:`descriptors "
"<descriptor>` در یک کلاس والد یا خواهر و برادر است."

#: ../../library/functions.rst:1830
msgid ""
"Note that :func:`super` is implemented as part of the binding process for "
"explicit dotted attribute lookups such as ``super().__getitem__(name)``. It "
"does so by implementing its own :meth:`~object.__getattribute__` method for "
"searching classes in a predictable order that supports cooperative multiple "
"inheritance. Accordingly, :func:`super` is undefined for implicit lookups "
"using statements or operators such as ``super()[name]``."
msgstr ""
"توجه داشته باشید که :func:`super` به عنوان بخشی از فرآیند اتصال برای جستجوی "
"صریح ویژگی های نقطه گذاری شده، مانند ``super().__getitem__(name)``، پیاده "
"سازی شده است. این کار را با پیاده سازی روش :meth:`~object.__getattribute__` "
"خود برای جستجوی کلاس ها به روشی قابل پیش بینی که از وراثت چندگانه تعاونی "
"پشتیبانی می کند، انجام می دهد. بر این اساس، :func:`super` برای جستجوهای ضمنی "
"با استفاده از عبارات یا عملگرهایی مانند ``super()[name]`` تعریف نشده است."

#: ../../library/functions.rst:1838
msgid ""
"Also note that, aside from the zero argument form, :func:`super` is not "
"limited to use inside methods.  The two argument form specifies the "
"arguments exactly and makes the appropriate references.  The zero argument "
"form only works inside a class definition, as the compiler fills in the "
"necessary details to correctly retrieve the class being defined, as well as "
"accessing the current instance for ordinary methods."
msgstr ""
"همچنین توجه داشته باشید که به غیر از حالت بدون آرگومان، :func:`super` محدود "
"به استفاده درون متدها نیست. حالت دو آرگومانی دقیقاً آرگومان ها را مشخص کرده و "
"ارجاعات مناسب را انجام می دهد. فرم بدون آرگومان تنها درون تعریف کلاس کار می "
"کند، چرا که کامپایلر جزئیات لازم را برای بازیابی صحیح کلاس تعریف شده و "
"همچنین دسترسی به نمونه فعلی برای متدهای معمولی کامل می کند."

#: ../../library/functions.rst:1845
msgid ""
"For practical suggestions on how to design cooperative classes using :func:"
"`super`, see `guide to using super() <https://rhettinger.wordpress."
"com/2011/05/26/super-considered-super/>`_."
msgstr ""
"برای پیشنهادهای عملی در مورد نحوه طراحی کلاس های همکار با استفاده از :func:"
"`super`، به `guide to using super() <https://rhettinger.wordpress."
"com/2011/05/26/super-considered-super/>`_ مراجعه کنید."

#: ../../library/functions.rst:1855
msgid ""
"Rather than being a function, :class:`tuple` is actually an immutable "
"sequence type, as documented in :ref:`typesseq-tuple` and :ref:`typesseq`."
msgstr ""
"به جای اینکه یک تابع باشد، :class:`tuple` در واقع یک نوع دنباله غیرقابل "
"تغییر است، همان طور که در :ref:`typesseq-tuple` و :ref:`typesseq` مستند شده "
"است."

#: ../../library/functions.rst:1864
msgid ""
"With one argument, return the type of an *object*.  The return value is a "
"type object and generally the same object as returned by :attr:`object."
"__class__ <instance.__class__>`."
msgstr ""

#: ../../library/functions.rst:1868
msgid ""
"The :func:`isinstance` built-in function is recommended for testing the type "
"of an object, because it takes subclasses into account."
msgstr ""
"تابع داخلی :func:`isinstance` برای آزمایش نوع یک شی توصیه می شود، زیرا "
"زیرکلاس ها را نیز در نظر می گیرد."

#: ../../library/functions.rst:1872
msgid ""
"With three arguments, return a new type object.  This is essentially a "
"dynamic form of the :keyword:`class` statement. The *name* string is the "
"class name and becomes the :attr:`~definition.__name__` attribute. The "
"*bases* tuple contains the base classes and becomes the :attr:`~class."
"__bases__` attribute; if empty, :class:`object`, the ultimate base of all "
"classes, is added.  The *dict* dictionary contains attribute and method "
"definitions for the class body; it may be copied or wrapped before becoming "
"the :attr:`~object.__dict__` attribute. The following two statements create "
"identical :class:`type` objects:"
msgstr ""

#: ../../library/functions.rst:1887
msgid "See also :ref:`bltin-type-objects`."
msgstr ""

#: ../../library/functions.rst:1889
msgid ""
"Keyword arguments provided to the three argument form are passed to the "
"appropriate metaclass machinery (usually :meth:`~object.__init_subclass__`) "
"in the same way that keywords in a class definition (besides *metaclass*) "
"would."
msgstr ""
"آرگومان های کلیدی که به فرم سه  آرگومانی ارائه می شوند، به ماشین مرتبط با "
"فرامتناظر مناسب (معمولاً :meth:`~object.__init_subclass__`) به همان صورتی که "
"کلمات کلیدی در تعریف یک کلاس (به جز *metaclass*) منتقل می شوند، پاس داده می "
"شوند."

#: ../../library/functions.rst:1894
msgid "See also :ref:`class-customization`."
msgstr "همچنین ببینید :ref:`class-customization`."

#: ../../library/functions.rst:1896
msgid ""
"Subclasses of :class:`type` which don't override ``type.__new__`` may no "
"longer use the one-argument form to get the type of an object."
msgstr ""

#: ../../library/functions.rst:1903
msgid ""
"Return the :attr:`~object.__dict__` attribute for a module, class, instance, "
"or any other object with a :attr:`~object.__dict__` attribute."
msgstr ""

#: ../../library/functions.rst:1906
msgid ""
"Objects such as modules and instances have an updateable :attr:`~object."
"__dict__` attribute; however, other objects may have write restrictions on "
"their :attr:`~object.__dict__` attributes (for example, classes use a :class:"
"`types.MappingProxyType` to prevent direct dictionary updates)."
msgstr ""

#: ../../library/functions.rst:1911
msgid ""
"Without an argument, :func:`vars` acts like :func:`locals`.  Note, the "
"locals dictionary is only useful for reads since updates to the locals "
"dictionary are ignored."
msgstr ""

#: ../../library/functions.rst:1915
msgid ""
"A :exc:`TypeError` exception is raised if an object is specified but it "
"doesn't have a :attr:`~object.__dict__` attribute (for example, if its class "
"defines the :attr:`~object.__slots__` attribute)."
msgstr ""
"اگر شیء مشخص شود اما ویژگی :attr:`~object.__dict__` نداشته باشد (به عنوان "
"مثال، اگر کلاس آن ویژگی :attr:`~object.__slots__` را تعریف کرده باشد)، یک "
"استثناء :exc:`TypeError` برانگیخته می شود."

#: ../../library/functions.rst:1921
msgid ""
"Iterate over several iterables in parallel, producing tuples with an item "
"from each one."
msgstr ""
"برای تکرار بر روی چندین iterable به صورت موازی و تولید تاپل هایی که شامل "
"آیتمی از هر یک از آن ها باشد."

#: ../../library/functions.rst:1924
msgid "Example::"
msgstr "مثال::"

#: ../../library/functions.rst:1933
msgid ""
"More formally: :func:`zip` returns an iterator of tuples, where the *i*-th "
"tuple contains the *i*-th element from each of the argument iterables."
msgstr ""
"به طور رسمی تر: :func:`zip` یک پیماینده از زوج مرتب ها برمی گرداند، که زوج "
"مرتب *i* شامل عنصر *i* از هر یک از پیمایش پذیرهای آرگومان ها است."

#: ../../library/functions.rst:1936
msgid ""
"Another way to think of :func:`zip` is that it turns rows into columns, and "
"columns into rows.  This is similar to `transposing a matrix <https://en."
"wikipedia.org/wiki/Transpose>`_."
msgstr ""
"راه دیگری برای فکر کردن به :func:`zip` این است که سطرها را به ستون ها و ستون "
"ها را به سطرها تبدیل می کند. این مشابه `transposing a matrix <https://en."
"wikipedia.org/wiki/Transpose>`_ است."

#: ../../library/functions.rst:1940
msgid ""
":func:`zip` is lazy: The elements won't be processed until the iterable is "
"iterated on, e.g. by a :keyword:`!for` loop or by wrapping in a :class:"
"`list`."
msgstr ""
":func:`zip` تنبل است: عناصر تا زمانی که روی iterable تکرار نشود پردازش نمی "
"شوند، به عنوان مثال توسط یک :keyword:`!for` loop یا با قرار دادن در یک :"
"class:`list`."

#: ../../library/functions.rst:1944
msgid ""
"One thing to consider is that the iterables passed to :func:`zip` could have "
"different lengths; sometimes by design, and sometimes because of a bug in "
"the code that prepared these iterables.  Python offers three different "
"approaches to dealing with this issue:"
msgstr ""
"نکته ای که باید در نظر داشته باشید این است که تکرارشونده هایی که به :func:"
"`zip` ارسال می شوند ممکن است طول های متفاوتی داشته باشند؛ گاهی به دلیل طراحی "
"و گاهی به علت وجود اشکالی در کدی که این تکرارشونده ها را آماده کرده است. "
"پایتون سه روش مختلف برای مقابله با این مسئله ارائه می دهد:"

#: ../../library/functions.rst:1949
msgid ""
"By default, :func:`zip` stops when the shortest iterable is exhausted. It "
"will ignore the remaining items in the longer iterables, cutting off the "
"result to the length of the shortest iterable::"
msgstr ""
"به طور پیش فرض، :func:`zip` زمانی متوقف می شود که کوتاه ترین iterable به "
"پایان برسد. آیتم های باقی مانده در iterables بلندتر را نادیده می گیرد و "
"نتیجه را به طول کوتاه ترین iterable محدود می کند::"

#: ../../library/functions.rst:1956
msgid ""
":func:`zip` is often used in cases where the iterables are assumed to be of "
"equal length.  In such cases, it's recommended to use the ``strict=True`` "
"option. Its output is the same as regular :func:`zip`::"
msgstr ""
"اغلباً از :func:`zip` در مواردی استفاده می شود که فرض بر این است که تکرارگرها "
"برابر طول هستند. در چنین مواردی، توصیه می شود از گزینه ``strict=True`` "
"استفاده کنید. خروجی آن همانند :func:`zip` معمولی می باشد::"

#: ../../library/functions.rst:1963
msgid ""
"Unlike the default behavior, it raises a :exc:`ValueError` if one iterable "
"is exhausted before the others:"
msgstr ""
"برخلاف رفتار پیش فرض، اگر یکی از iterableها پیش از دیگری تمام شود، یک :exc:"
"`ValueError` ایجاد می کند:"

#: ../../library/functions.rst:1981
msgid ""
"Without the ``strict=True`` argument, any bug that results in iterables of "
"different lengths will be silenced, possibly manifesting as a hard-to-find "
"bug in another part of the program."
msgstr ""
"بدون آرگومان ``strict=True``، هر باگی که منجر به طول های مختلف در iterable "
"ها شود بدون اعلان باقی می ماند و ممکن است به صورت باگی که سخت پیدا می شود در "
"بخش دیگری از برنامه ظاهر شود."

#: ../../library/functions.rst:1985
msgid ""
"Shorter iterables can be padded with a constant value to make all the "
"iterables have the same length.  This is done by :func:`itertools."
"zip_longest`."
msgstr ""
"می توان برای کوتاه ترهای قابل تکرار از مقدار ثابت استفاده کرد تا همه ی آن ها "
"به طول یکسان برسند. این کار با :func:`itertools.zip_longest` انجام می شود."

#: ../../library/functions.rst:1989
msgid ""
"Edge cases: With a single iterable argument, :func:`zip` returns an iterator "
"of 1-tuples.  With no arguments, it returns an empty iterator."
msgstr ""
"موارد خاص: با یک آرگومان قابل تکرار، :func:`zip` یک تکرارگر از ۱-تاپل ها را "
"بازمی گرداند. بدون هیچ آرگومانی، یک تکرارگر خالی را برمی گرداند."

#: ../../library/functions.rst:1992
msgid "Tips and tricks:"
msgstr "نکات و ترفندها:"

#: ../../library/functions.rst:1994
msgid ""
"The left-to-right evaluation order of the iterables is guaranteed. This "
"makes possible an idiom for clustering a data series into n-length groups "
"using ``zip(*[iter(s)]*n, strict=True)``.  This repeats the *same* iterator "
"``n`` times so that each output tuple has the result of ``n`` calls to the "
"iterator. This has the effect of dividing the input into n-length chunks."
msgstr ""
"ترتیب ارزیابی از چپ به راست برای قابل تکرارها تضمین شده است. این امکان یک "
"رویکرد برای گروه بندی یک سری داده به گروه های n تایی را با استفاده از "
"``zip(*[iter(s)]*n, strict=True)`` فراهم می کند. این فرآیند، تکرارگر *same* "
"را ``n`` بار تکرار می کند تا هر زوج خروجی نتیجه ``n`` فراخوانی از تکرارگر را "
"داشته باشد. این کار اثر تقسیم ورودی به قطعات n تایی را دارد."

#: ../../library/functions.rst:2000
msgid ""
":func:`zip` in conjunction with the ``*`` operator can be used to unzip a "
"list::"
msgstr ""
":func:`zip` همراه با عملگر ``*`` می تواند برای استخراج لیست استفاده شود::"

#: ../../library/functions.rst:2011
msgid "Added the ``strict`` argument."
msgstr "آرگومان ``strict`` اضافه شد."

#: ../../library/functions.rst:2023
msgid ""
"This is an advanced function that is not needed in everyday Python "
"programming, unlike :func:`importlib.import_module`."
msgstr ""
"این یک تابع پیشرفته است که برخلاف :func:`importlib.import_module` در برنامه "
"نویسی روزمره پایتون نیازی به آن نیست."

#: ../../library/functions.rst:2026
msgid ""
"This function is invoked by the :keyword:`import` statement.  It can be "
"replaced (by importing the :mod:`builtins` module and assigning to "
"``builtins.__import__``) in order to change semantics of the :keyword:`!"
"import` statement, but doing so is **strongly** discouraged as it is usually "
"simpler to use import hooks (see :pep:`302`) to attain the same goals and "
"does not cause issues with code which assumes the default import "
"implementation is in use.  Direct use of :func:`__import__` is also "
"discouraged in favor of :func:`importlib.import_module`."
msgstr ""
"این تابع توسط دستور :keyword:`import` فراخوانی می شود. می توان آن را با وارد "
"کردن ماژول :mod:`builtins` و اختصاص دادن به ``builtins.__import__`` جایگزین "
"کرد تا تغییراتی در معناشناسی دستور :keyword:`!import` ایجاد شود، اما انجام "
"این کار به شدت **strongly** توصیه نمی شود زیرا معمولاً استفاده از قلاب های "
"ورود (به :pep:`302` مراجعه کنید) برای دستیابی به همان اهداف ساده تر است و "
"مشکلاتی با کدهایی که فرض می کنند پیاده سازی پیش فرض واردات در حال استفاده "
"است، ایجاد نمی کند. استفاده مستقیم از :func:`__import__` نیز به نفع :func:"
"`importlib.import_module` توصیه نمی شود."

#: ../../library/functions.rst:2035
msgid ""
"The function imports the module *name*, potentially using the given "
"*globals* and *locals* to determine how to interpret the name in a package "
"context. The *fromlist* gives the names of objects or submodules that should "
"be imported from the module given by *name*.  The standard implementation "
"does not use its *locals* argument at all and uses its *globals* only to "
"determine the package context of the :keyword:`import` statement."
msgstr ""
"تابع ماژول *name* را وارد می کند و احتمالاً از *globals* و *locals* داده شده "
"برای تعیین نحوه تفسیر نام در یک زمینه بسته استفاده می کند. *fromlist* نام "
"اشیاء یا زیرماژول هایی را که باید از ماژول *name* وارد شوند، ارائه می دهد. "
"پیاده سازی استاندارد به هیچ وجه از آرگومان *locals* استفاده نمی کند و تنها "
"برای تعیین زمینه بسته عبارت :keyword:`import` از *globals* خود استفاده می "
"کند."

#: ../../library/functions.rst:2042
msgid ""
"*level* specifies whether to use absolute or relative imports. ``0`` (the "
"default) means only perform absolute imports.  Positive values for *level* "
"indicate the number of parent directories to search relative to the "
"directory of the module calling :func:`__import__` (see :pep:`328` for the "
"details)."
msgstr ""
"*level* مشخص می کند که آیا از ایمپورت های مطلق یا نسبی استفاده شود. ``0`` "
"(به طور پیش فرض) به معنای این است که فقط ایمپورت های مطلق انجام شود. مقادیر "
"مثبت برای *level* نشان دهنده تعداد دایرکتوری های والد است که باید نسبت به "
"دایرکتوری ماژولی که :func:`__import__` را فراخوانی می کند جستجو انجام شود "
"(برای جزئیات به :pep:`328` مراجعه کنید)."

#: ../../library/functions.rst:2048
msgid ""
"When the *name* variable is of the form ``package.module``, normally, the "
"top-level package (the name up till the first dot) is returned, *not* the "
"module named by *name*.  However, when a non-empty *fromlist* argument is "
"given, the module named by *name* is returned."
msgstr ""
"هنگامی که متغیر *name* به فرم ``package.module`` باشد، معمولاً بسته سطح بالا "
"(نام تا اولین نقطه) بازگردانده می شود، *not* ماژولی که با *name* نامگذاری "
"شده است. با این حال، هنگامی که یک آرگومان *fromlist* غیر خالی داده شود، "
"ماژول با نام *name* بازگردانده می شود."

#: ../../library/functions.rst:2053
msgid ""
"For example, the statement ``import spam`` results in bytecode resembling "
"the following code::"
msgstr ""
"به عنوان مثال، عبارت ``import spam`` منجر به بایت کدی می شود که مشابه کد زیر "
"است:"

#: ../../library/functions.rst:2058
msgid "The statement ``import spam.ham`` results in this call::"
msgstr "عبارت ``import spam.ham`` منجر به این فراخوانی می شود::"

#: ../../library/functions.rst:2062
msgid ""
"Note how :func:`__import__` returns the toplevel module here because this is "
"the object that is bound to a name by the :keyword:`import` statement."
msgstr ""
"توجه کنید که :func:`__import__` در اینجا ماژول سطح بالا را برمی گرداند زیرا "
"این همان شی ء است که توسط عبارت :keyword:`import` به یک نام متصل شده است."

#: ../../library/functions.rst:2065
msgid ""
"On the other hand, the statement ``from spam.ham import eggs, sausage as "
"saus`` results in ::"
msgstr ""
"از طرف دیگر، دستور ``from spam.ham import eggs, sausage as saus`` به نتیجه "
"می رسد به ::"

#: ../../library/functions.rst:2072
msgid ""
"Here, the ``spam.ham`` module is returned from :func:`__import__`.  From "
"this object, the names to import are retrieved and assigned to their "
"respective names."
msgstr ""
"در اینجا، ماژول ``spam.ham`` از :func:`__import__` بازگردانده می شود. از این "
"شیء، نام هایی که باید وارد شوند جستجو شده و به نام های مربوطه خود اختصاص "
"داده می شوند."

#: ../../library/functions.rst:2076
msgid ""
"If you simply want to import a module (potentially within a package) by "
"name, use :func:`importlib.import_module`."
msgstr ""
"اگر می خواهید تنها یک ماژول (احتمالاً درون یک بسته) را با نام وارد کنید، از :"
"func:`importlib.import_module` استفاده کنید."

#: ../../library/functions.rst:2079
msgid ""
"Negative values for *level* are no longer supported (which also changes the "
"default value to 0)."
msgstr ""
"مقادیر منفی برای *level* دیگر پشتیبانی نمی شوند (که همچنین مقدار پیش فرض را "
"به 0 تغییر می دهد)."

#: ../../library/functions.rst:2083
msgid ""
"When the command line options :option:`-E` or :option:`-I` are being used, "
"the environment variable :envvar:`PYTHONCASEOK` is now ignored."
msgstr ""
"زمانی که گزینه های خط فرمان :option:`-E` یا :option:`-I` استفاده می شوند، "
"متغیر محیطی :envvar:`PYTHONCASEOK` دیگر نادیده گرفته می شود."

#: ../../library/functions.rst:2088
msgid "Footnotes"
msgstr "پاورقی ها"

#: ../../library/functions.rst:2089
msgid ""
"Note that the parser only accepts the Unix-style end of line convention. If "
"you are reading the code from a file, make sure to use newline conversion "
"mode to convert Windows or Mac-style newlines."
msgstr ""
"توجه داشته باشید که مفسر فقط کنوانسیون پایان خط به سبک یونیکس را می پذیرد. "
"اگر کد را از یک فایل می خوانید، مطمئن شوید که از حالت تبدیل خط جدید برای "
"تبدیل خط های جدید به سبک ویندوز یا مک استفاده کنید."

#: ../../library/functions.rst:153
msgid "Boolean"
msgstr "بولی"

#: ../../library/functions.rst:153 ../../library/functions.rst:1862
msgid "type"
msgstr "نوع"

#: ../../library/functions.rst:575
msgid "built-in function"
msgstr "تابع داخلی"

#: ../../library/functions.rst:575
msgid "exec"
msgstr "اجرایی"

#: ../../library/functions.rst:652
msgid "NaN"
msgstr "NaN"

#: ../../library/functions.rst:652
msgid "Infinity"
msgstr "بی نهایت"

#: ../../library/functions.rst:716
msgid "__format__"
msgstr "__format__"

#: ../../library/functions.rst:716 ../../library/functions.rst:1750
msgid "string"
msgstr "رشته"

#: ../../library/functions.rst:716
msgid "format() (built-in function)"
msgstr "format() (تابع داخلی)"

#: ../../library/functions.rst:1164
msgid "file object"
msgstr "شی فایل"

#: ../../library/functions.rst:1164 ../../library/functions.rst:1285
msgid "open() built-in function"
msgstr "تابع داخلی ()open"

#: ../../library/functions.rst:1192
msgid "file"
msgstr "فایل"

#: ../../library/functions.rst:1192
msgid "modes"
msgstr "مدها"

#: ../../library/functions.rst:1285
msgid "universal newlines"
msgstr "خطوط جدید جهانی"

#: ../../library/functions.rst:1346
msgid "line-buffered I/O"
msgstr "ورودی/خروجی بافر خطی"

#: ../../library/functions.rst:1346
msgid "unbuffered I/O"
msgstr "ورودی/خروجی بدون بافر"

#: ../../library/functions.rst:1346
msgid "buffer size, I/O"
msgstr "اندازه بافر، ورودی/خروجی"

#: ../../library/functions.rst:1346
msgid "I/O control"
msgstr "کنترل I/O"

#: ../../library/functions.rst:1346
msgid "buffering"
msgstr "بافر کردن"

#: ../../library/functions.rst:1346
msgid "text mode"
msgstr "حالت متنی"

#: ../../library/functions.rst:1346 ../../library/functions.rst:2017
msgid "module"
msgstr "ماژول"

#: ../../library/functions.rst:1346
msgid "sys"
msgstr "سیستم"

#: ../../library/functions.rst:1750
msgid "str() (built-in function)"
msgstr "(تابع داخلی) ()str"

#: ../../library/functions.rst:1862
msgid "object"
msgstr "شیء"

#: ../../library/functions.rst:2017
msgid "statement"
msgstr "بیانیه"

#: ../../library/functions.rst:2017
msgid "import"
msgstr "واردات"

#: ../../library/functions.rst:2017
msgid "builtins"
msgstr "سازه ها"
