# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-07 20:38+0000\n"
"PO-Revision-Date: 2025-08-02 17:34+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Persian (https://app.transifex.com/python-doc/teams/5390/"
"fa/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fa\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../library/functions.rst:5 ../../library/functions.rst:11
msgid "Built-in Functions"
msgstr "توابع پیش ساخته"

#: ../../library/functions.rst:7
msgid ""
"The Python interpreter has a number of functions and types built into it "
"that are always available.  They are listed here in alphabetical order."
msgstr ""
"مفسر پایتون دارای تعدادی تابع و نوع داده (type) است که در آن بصورت توکار "
"(built-in) همیشه در دسترس می‌باشند. آن‌ها در اینجا به ترتیب حروف الفبا فهرست "
"شده‌اند."

#: ../../library/functions.rst:0
msgid "**A**"
msgstr "**A**"

#: ../../library/functions.rst:0
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: ../../library/functions.rst:0
msgid ":func:`aiter`"
msgstr ":func:`aiter`"

#: ../../library/functions.rst:0
msgid ":func:`all`"
msgstr ":func:`all`"

#: ../../library/functions.rst:0
msgid ":func:`anext`"
msgstr ":func:`anext`"

#: ../../library/functions.rst:0
msgid ":func:`any`"
msgstr ":func:`any`"

#: ../../library/functions.rst:0
msgid ":func:`ascii`"
msgstr ":func:`ascii`"

#: ../../library/functions.rst:0
msgid "**B**"
msgstr "**B**"

#: ../../library/functions.rst:0
msgid ":func:`bin`"
msgstr ":func:`bin`"

#: ../../library/functions.rst:0
msgid ":func:`bool`"
msgstr ":func:`bool`"

#: ../../library/functions.rst:0
msgid ":func:`breakpoint`"
msgstr ":func:`breakpoint`"

#: ../../library/functions.rst:0
msgid "|func-bytearray|_"
msgstr "|func-bytearray|_"

#: ../../library/functions.rst:0
msgid "|func-bytes|_"
msgstr "|func-bytes|_"

#: ../../library/functions.rst:0
msgid "**C**"
msgstr "**C**"

#: ../../library/functions.rst:0
msgid ":func:`callable`"
msgstr ":func:`callable`"

#: ../../library/functions.rst:0
msgid ":func:`chr`"
msgstr ":func:`chr`"

#: ../../library/functions.rst:0
msgid ":func:`classmethod`"
msgstr ":func:`classmethod`"

#: ../../library/functions.rst:0
msgid ":func:`compile`"
msgstr ":func:`compile`"

#: ../../library/functions.rst:0
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: ../../library/functions.rst:0
msgid "**D**"
msgstr "**D**"

#: ../../library/functions.rst:0
msgid ":func:`delattr`"
msgstr ":func:`delattr`"

#: ../../library/functions.rst:0
msgid "|func-dict|_"
msgstr "|func-dict|_"

#: ../../library/functions.rst:0
msgid ":func:`dir`"
msgstr ":func:`dir`"

#: ../../library/functions.rst:0
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: ../../library/functions.rst:0
msgid "**E**"
msgstr "**E**"

#: ../../library/functions.rst:0
msgid ":func:`enumerate`"
msgstr ":func:`enumerate`"

#: ../../library/functions.rst:0
msgid ":func:`eval`"
msgstr ":func:`eval`"

#: ../../library/functions.rst:0
msgid ":func:`exec`"
msgstr ":func:`exec`"

#: ../../library/functions.rst:0
msgid "**F**"
msgstr "**F**"

#: ../../library/functions.rst:0
msgid ":func:`filter`"
msgstr ":func:`filter`"

#: ../../library/functions.rst:0
msgid ":func:`float`"
msgstr ":func:`float`"

#: ../../library/functions.rst:0
msgid ":func:`format`"
msgstr ":func:`format`"

#: ../../library/functions.rst:0
msgid "|func-frozenset|_"
msgstr "|func-frozenset|_"

#: ../../library/functions.rst:0
msgid "**G**"
msgstr "**G**"

#: ../../library/functions.rst:0
msgid ":func:`getattr`"
msgstr ":func:`getattr`"

#: ../../library/functions.rst:0
msgid ":func:`globals`"
msgstr ":func:`globals`"

#: ../../library/functions.rst:0
msgid "**H**"
msgstr "**H**"

#: ../../library/functions.rst:0
msgid ":func:`hasattr`"
msgstr ":func:`hasattr`"

#: ../../library/functions.rst:0
msgid ":func:`hash`"
msgstr ":func:`hash`"

#: ../../library/functions.rst:0
msgid ":func:`help`"
msgstr ":func:`help`"

#: ../../library/functions.rst:0
msgid ":func:`hex`"
msgstr ":func:`hex`"

#: ../../library/functions.rst:0
msgid "**I**"
msgstr "**I**"

#: ../../library/functions.rst:0
msgid ":func:`id`"
msgstr ":func:`id`"

#: ../../library/functions.rst:0
msgid ":func:`input`"
msgstr ":func:`input`"

#: ../../library/functions.rst:0
msgid ":func:`int`"
msgstr ":func:`int`"

#: ../../library/functions.rst:0
msgid ":func:`isinstance`"
msgstr ":func:`isinstance`"

#: ../../library/functions.rst:0
msgid ":func:`issubclass`"
msgstr ":func:`issubclass`"

#: ../../library/functions.rst:0
msgid ":func:`iter`"
msgstr ":func:`iter`"

#: ../../library/functions.rst:0
msgid "**L**"
msgstr "**L**"

#: ../../library/functions.rst:0
msgid ":func:`len`"
msgstr ":func:`len`"

#: ../../library/functions.rst:0
msgid "|func-list|_"
msgstr "|func-list|_"

#: ../../library/functions.rst:0
msgid ":func:`locals`"
msgstr ":func:`locals`"

#: ../../library/functions.rst:0
msgid "**M**"
msgstr "**M**"

#: ../../library/functions.rst:0
msgid ":func:`map`"
msgstr ":func:`map`"

#: ../../library/functions.rst:0
msgid ":func:`max`"
msgstr ":func:`max`"

#: ../../library/functions.rst:0
msgid "|func-memoryview|_"
msgstr "|func-memoryview|_"

#: ../../library/functions.rst:0
msgid ":func:`min`"
msgstr ":func:`min`"

#: ../../library/functions.rst:0
msgid "**N**"
msgstr "**N**"

#: ../../library/functions.rst:0
msgid ":func:`next`"
msgstr ":func:`next`"

#: ../../library/functions.rst:0
msgid "**O**"
msgstr "**O**"

#: ../../library/functions.rst:0
msgid ":func:`object`"
msgstr ":func:`object`"

#: ../../library/functions.rst:0
msgid ":func:`oct`"
msgstr ":func:`oct`"

#: ../../library/functions.rst:0
msgid ":func:`open`"
msgstr ":func:`open`"

#: ../../library/functions.rst:0
msgid ":func:`ord`"
msgstr ":func:`ord`"

#: ../../library/functions.rst:0
msgid "**P**"
msgstr "**P**"

#: ../../library/functions.rst:0
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: ../../library/functions.rst:0
msgid ":func:`print`"
msgstr ":func:`print`"

#: ../../library/functions.rst:0
msgid ":func:`property`"
msgstr ":func:`property`"

#: ../../library/functions.rst:0
msgid "**R**"
msgstr "**R**"

#: ../../library/functions.rst:0
msgid "|func-range|_"
msgstr "|func-range|_"

#: ../../library/functions.rst:0
msgid ":func:`repr`"
msgstr ":func:`repr`"

#: ../../library/functions.rst:0
msgid ":func:`reversed`"
msgstr ":func:`reversed`"

#: ../../library/functions.rst:0
msgid ":func:`round`"
msgstr ":func:`round`"

#: ../../library/functions.rst:0
msgid "**S**"
msgstr "**S**"

#: ../../library/functions.rst:0
msgid "|func-set|_"
msgstr "|func-set|_"

#: ../../library/functions.rst:0
msgid ":func:`setattr`"
msgstr ":func:`setattr`"

#: ../../library/functions.rst:0
msgid ":func:`slice`"
msgstr ":func:`slice`"

#: ../../library/functions.rst:0
msgid ":func:`sorted`"
msgstr ":func:`sorted`"

#: ../../library/functions.rst:0
msgid ":func:`staticmethod`"
msgstr ":func:`staticmethod`"

#: ../../library/functions.rst:0
msgid "|func-str|_"
msgstr "|func-str|_"

#: ../../library/functions.rst:0
msgid ":func:`sum`"
msgstr ":func:`sum`"

#: ../../library/functions.rst:0
msgid ":func:`super`"
msgstr ":func:`super`"

#: ../../library/functions.rst:0
msgid "**T**"
msgstr "**T**"

#: ../../library/functions.rst:0
msgid "|func-tuple|_"
msgstr "|func-tuple|_"

#: ../../library/functions.rst:0
msgid ":func:`type`"
msgstr ":func:`type`"

#: ../../library/functions.rst:0
msgid "**V**"
msgstr "**V**"

#: ../../library/functions.rst:0
msgid ":func:`vars`"
msgstr ":func:`vars`"

#: ../../library/functions.rst:0
msgid "**Z**"
msgstr "**Z**"

#: ../../library/functions.rst:0
msgid ":func:`zip`"
msgstr ":func:`zip`"

#: ../../library/functions.rst:0
msgid "**_**"
msgstr "**_**"

#: ../../library/functions.rst:0
msgid ":func:`__import__`"
msgstr ":func:`__import__`"

#: ../../library/functions.rst:59
msgid ""
"Return the absolute value of a number.  The argument may be an integer, a "
"floating-point number, or an object implementing :meth:`~object.__abs__`. If "
"the argument is a complex number, its magnitude is returned."
msgstr ""
"مقدار قدر مطلق یک عدد را برمی‌گرداند. آرگومان می تواند یک عدد صحیح، یک عدد "
"اعشاری، یا یک شیء که :meth:`~object.__abs__` را پیاده سازی می‌کند، باشد. اگر "
"ارگومان یک عدد مختلط باشد، بزرگی آن بازگردانده می‌شود."

#: ../../library/functions.rst:67
msgid ""
"Return an :term:`asynchronous iterator` for an :term:`asynchronous "
"iterable`. Equivalent to calling ``x.__aiter__()``."
msgstr ""
"بازگرداندن یک :term:`asynchronous iterator` برای یک :term:`asynchronous "
"iterable` معادل فراخوانی ``x.__aiter__()`` است."

#: ../../library/functions.rst:70
msgid "Note: Unlike :func:`iter`, :func:`aiter` has no 2-argument variant."
msgstr "توجه: برخلاف :func:`iter`، :func:`aiter` نسخه دو آرگومانی ندارد."

#: ../../library/functions.rst:76
msgid ""
"Return ``True`` if all elements of the *iterable* are true (or if the "
"iterable is empty).  Equivalent to::"
msgstr ""
"در صورتی که تمام عناصر *iterable* درست باشند (یا اگر iterable خالی باشد)، "
"``True`` را برمی گرداند. معادل با::"

#: ../../library/functions.rst:79
msgid ""
"def all(iterable):\n"
"    for element in iterable:\n"
"        if not element:\n"
"            return False\n"
"    return True"
msgstr ""
"def all(iterable):\n"
"    for element in iterable:\n"
"        if not element:\n"
"            return False\n"
"    return True"

#: ../../library/functions.rst:89
msgid ""
"When awaited, return the next item from the given :term:`asynchronous "
"iterator`, or *default* if given and the iterator is exhausted."
msgstr ""
"هنگام اِنتظار (await)، عنصر بعدی را از :term:`asynchronous iterator` داده شده "
"برمی‌گرداند، یا اگر آرگومان *default* ارائه شده و تکرارکننده به پایان رسیده "
"باشد، مقدار *default* را برمی‌گرداند."

#: ../../library/functions.rst:92
msgid ""
"This is the async variant of the :func:`next` builtin, and behaves similarly."
msgstr ""
"این، نسخه ناهمگامِ تابع داخلی :func:`next` است و به طور مشابه عمل می‌کند."

#: ../../library/functions.rst:95
msgid ""
"This calls the :meth:`~object.__anext__` method of *async_iterator*, "
"returning an :term:`awaitable`. Awaiting this returns the next value of the "
"iterator. If *default* is given, it is returned if the iterator is "
"exhausted, otherwise :exc:`StopAsyncIteration` is raised."
msgstr ""
"این روش(متد) :meth:`~object.__anext__` از *async_iterator* را فراخوانی می "
"کند و یک :term:`awaitable` را برمی گرداند. در انتظار این مقدار بعدی تکرار "
"کننده را برمی گرداند. اگر *default* داده شود، اگر تکرار کننده تمام شده باشد، "
"برگردانده می شود، در غیر این صورت :exc:`StopAsyncIteration` افزایش می یابد."

#: ../../library/functions.rst:104
msgid ""
"Return ``True`` if any element of the *iterable* is true.  If the iterable "
"is empty, return ``False``.  Equivalent to::"
msgstr ""
"اگر هر عنصری از *iterable* درست باشد، ``True`` را برگردانید. اگر iterable "
"خالی باشد، ``False`` را برگردانید. معادل با::"

#: ../../library/functions.rst:107
msgid ""
"def any(iterable):\n"
"    for element in iterable:\n"
"        if element:\n"
"            return True\n"
"    return False"
msgstr ""
"def any(iterable):\n"
"    for element in iterable:\n"
"        if element:\n"
"            return True\n"
"    return False"

#: ../../library/functions.rst:116
msgid ""
"As :func:`repr`, return a string containing a printable representation of an "
"object, but escape the non-ASCII characters in the string returned by :func:"
"`repr` using ``\\x``, ``\\u``, or ``\\U`` escapes.  This generates a string "
"similar to that returned by :func:`repr` in Python 2."
msgstr ""
"مانند تابع :func:`repr`، رشته‌ای حاوی نمایش قابل چاپ یک شیء را برمی‌گرداند، "
"اما کاراکترهای غیر اَسکی (non-ASCII) را در رشته‌ی بازگردانده‌شده توسط تابع :"
"func:`repr`، با استفاده از توالی‌های گریز (escapes) ``\\x``، ``\\u`` یا "
"``\\U`` اِسکِیپ (escape) می‌کند. این عمل، رشته‌ای مشابه آنچه تابع :func:`repr` "
"در پایتون ۲ بازمی‌گرداند، تولید می‌کند."

#: ../../library/functions.rst:124
msgid ""
"Convert an integer number to a binary string prefixed with \"0b\". The "
"result is a valid Python expression. If *x* is not a Python :class:`int` "
"object, it has to define an :meth:`~object.__index__` method that returns an "
"integer. Some examples:"
msgstr ""
"تبدیل یک عدد صحیح به یک رشته باینری که با \"0b\" پیشوند شده است. نتیجه یک "
"عبارت معتبر پایتون خواهد بود. اگر *x* یک شیء پایتون :class:`int` نباشد، لازم "
"است یک روش(متد) :meth:`~object.__index__` تعریف کند که یک عدد صحیح برگرداند. "
"برخی مثال ها:"

#: ../../library/functions.rst:134
msgid ""
"If the prefix \"0b\" is desired or not, you can use either of the following "
"ways."
msgstr ""
"چنانچه پیشوند \"0b\" مطلوب باشد یا نباشد، می‌توانید از یکی از روش‌های زیر "
"استفاده کنید."

#: ../../library/functions.rst:141 ../../library/functions.rst:950
#: ../../library/functions.rst:1335
msgid "See also :func:`format` for more information."
msgstr "همچنین برای اطلاعات بیشتر، به تابع :func:`format` مراجعه کنید."

#: ../../library/functions.rst:146
msgid ""
"Return a Boolean value, i.e. one of ``True`` or ``False``.  The argument is "
"converted using the standard :ref:`truth testing procedure <truth>`. If the "
"argument is false or omitted, this returns ``False``; otherwise, it returns "
"``True``.  The :class:`bool` class is a subclass of :class:`int` (see :ref:"
"`typesnumeric`). It cannot be subclassed further.  Its only instances are "
"``False`` and ``True`` (see :ref:`typebool`)."
msgstr ""
"یک مقدار بولی، یعنی یکی از ``True`` یا ``False`` را برگردانید.  آرگومان با "
"استفاده از استاندارد :ref:`truth testing procedure <truth>` تبدیل می شود. "
"اگر آرگومان نادرست یا حذف شده باشد، ``False`` را برمی گرداند. در غیر این "
"صورت، ``True`` را برمی گرداند.  کلاس :class:`bool` یک زیر کلاس از :class:"
"`int` است (به :ref:`typesnumeric` مراجعه کنید). این کلاس دیگر قابل "
"زیرکلاس‌بندی نیست. تنها نمونه های آن ``False`` و ``True`` هستند (به :ref:"
"`typebool` مراجعه کنید)."

#: ../../library/functions.rst:156 ../../library/functions.rst:815
msgid "The parameter is now positional-only."
msgstr "این آرگومان اکنون صرفاً جایگاهی (positional-only) است."

#: ../../library/functions.rst:161
msgid ""
"This function drops you into the debugger at the call site.  Specifically, "
"it calls :func:`sys.breakpointhook`, passing ``args`` and ``kws`` straight "
"through.  By default, ``sys.breakpointhook()`` calls :func:`pdb.set_trace` "
"expecting no arguments.  In this case, it is purely a convenience function "
"so you don't have to explicitly import :mod:`pdb` or type as much code to "
"enter the debugger.  However, :func:`sys.breakpointhook` can be set to some "
"other function and :func:`breakpoint` will automatically call that, allowing "
"you to drop into the debugger of choice. If :func:`sys.breakpointhook` is "
"not accessible, this function will raise :exc:`RuntimeError`."
msgstr ""
"این تابع، اجرای برنامه را در محل فراخوانی متوقف کرده و شما را وارد محیط "
"اشکال‌زدا (debugger) می‌کند. به طور خاص، این تابع، :func:`sys.breakpointhook` "
"را فراخوانی کرده و مقادیر ``args`` و ``kws`` مستقیماً به آن ارسال (pass) "
"می‌کند. به طور پیش‌فرض، تابع ``sys.breakpointhook()`` بدون نیاز به هیچ "
"آرگومانی :func:`pdb.set_trace` را فراخوانی می کند. در این حالت، این صرفاً یک "
"تابع کمکی (convenience function) است تا مجبور نباشید ماژول :mod:`pdb` را به "
"صراحت ایمپورت (import) کنید یا برای ورود به اشکال‌زدا، کد زیادی بنویسید. با "
"این حال، می‌توان :func:`sys.breakpointhook` را روی تابع دیگری تنظیم کرد و در "
"این صورت، :func:`breakpoint` به طور خودکار آن را فراخوانی می کند و به شما "
"این امکان را می دهد که به اشکال‌زدای مورد نظر خود وارد شوید. اگر :func:`sys."
"breakpointhook` قابل دسترسی نباشد، این تابع، استثنای :exc:`RuntimeError` را "
"ایجاد خواهد کرد."

#: ../../library/functions.rst:173
msgid ""
"By default, the behavior of :func:`breakpoint` can be changed with the :"
"envvar:`PYTHONBREAKPOINT` environment variable. See :func:`sys."
"breakpointhook` for usage details."
msgstr ""
"به طور پیش‌فرض، رفتار تابع :func:`breakpoint` را می‌توان با متغیر محیطی :"
"envvar:`PYTHONBREAKPOINT` تغییر داد. برای جزئیات استفاده، به تابع :func:`sys."
"breakpointhook` مراجعه کنید."

#: ../../library/functions.rst:177
msgid ""
"Note that this is not guaranteed if :func:`sys.breakpointhook` has been "
"replaced."
msgstr ""
"توجه داشته باشید که این امر تضمین نمی‌شود اگر تابع :func:`sys.breakpointhook` "
"جایگزین شده باشد."

#: ../../library/functions.rst:180
msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.breakpoint`` with "
"argument ``breakpointhook``."
msgstr ""
"یک :ref:`auditing event <auditing>` ``builtins.breakpoint`` با آرگومان "
"``breakpointhook`` ایجاد می کند."

#: ../../library/functions.rst:190
msgid ""
"Return a new array of bytes.  The :class:`bytearray` class is a mutable "
"sequence of integers in the range 0 <= x < 256.  It has most of the usual "
"methods of mutable sequences, described in :ref:`typesseq-mutable`, as well "
"as most methods that the :class:`bytes` type has, see :ref:`bytes-methods`."
msgstr ""
"یک آرایه بایتی جدید برمی گرداند. کلاس :class:`bytearray` یک دنباله قابل "
"تغییر از اعداد صحیح در محدوده 0 <= x < 256 است. این کلاس اکثر روش های معمول "
"دنباله های قابل تغییر را دارد که در :ref:`typesseq-mutable` توضیح داده شده "
"اند و همچنین بیشتر روش هایی که نوع :class:`bytes` دارد را داراست، به :ref:"
"`bytes-methods` مراجعه کنید."

#: ../../library/functions.rst:195
msgid ""
"The optional *source* parameter can be used to initialize the array in a few "
"different ways:"
msgstr ""
"از پارامتر اختیاری *source* می‌توان برای مقداردهی اولیه آرایه به چند روش "
"مختلف استفاده کرد:"

#: ../../library/functions.rst:198
msgid ""
"If it is a *string*, you must also give the *encoding* (and optionally, "
"*errors*) parameters; :func:`bytearray` then converts the string to bytes "
"using :meth:`str.encode`."
msgstr ""
"اگر *source* یک *رشته* «*string*» باشد، باید پارامترهای *encoding* و (به‌صورت "
"اختیاری) *errors* را نیز مشخص کنید؛ سپس تابع :func:`bytearray` آن رشته را با "
"استفاده از متد :meth:`str.encode` به بایت‌ها تبدیل می‌کند."

#: ../../library/functions.rst:202
msgid ""
"If it is an *integer*, the array will have that size and will be initialized "
"with null bytes."
msgstr ""
"اگر «*source*» یک *عدد صحیح* «integer» باشد، آرایه به اندازه همان عدد ایجاد "
"شده و با بایت‌های تهی «null byte» مقداردهی اولیه خواهد شد."

#: ../../library/functions.rst:205
msgid ""
"If it is an object conforming to the :ref:`buffer interface "
"<bufferobjects>`, a read-only buffer of the object will be used to "
"initialize the bytes array."
msgstr ""
"اگر «*source*» یک *شیء* باشد که از  \\:ref\\:`buffer interface "
"<bufferobjects>`, رابط بافر پیروی می‌کند، از یک بافر فقط-خواندنیِ آن شیء برای "
"مقداردهی اولیه آرایه بایت‌ها استفاده خواهد شد."

#: ../../library/functions.rst:208
msgid ""
"If it is an *iterable*, it must be an iterable of integers in the range ``0 "
"<= x < 256``, which are used as the initial contents of the array."
msgstr ""
"اگر «*source*» یک *تکرارپذیر* «iterable» باشد، باید یک تکرارپذیر از اعداد "
"صحیح در بازه ``0 <= x < 256`` باشد، که این اعداد به عنوان محتویات اولیه "
"آرایه استفاده می‌شوند."

#: ../../library/functions.rst:211
msgid "Without an argument, an array of size 0 is created."
msgstr "بدون آرگومان، یک آرایه با اندازه صفر «0» ایجاد می شود."

#: ../../library/functions.rst:213
msgid "See also :ref:`binaryseq` and :ref:`typebytearray`."
msgstr "همچنین به :ref:`binaryseq` و :ref:`typebytearray` مراجعه کنید."

#: ../../library/functions.rst:222
msgid ""
"Return a new \"bytes\" object which is an immutable sequence of integers in "
"the range ``0 <= x < 256``.  :class:`bytes` is an immutable version of :"
"class:`bytearray` -- it has the same non-mutating methods and the same "
"indexing and slicing behavior."
msgstr ""
"یک شیء جدید \"bytes\" بازگردانید که دنباله ای غیرقابل تغییر از اعداد صحیح در "
"محدوده ``0 <= x < 256`` است. :class:`bytes` نسخه غیرقابل تغییر از :class:"
"`bytearray` است -- دارای همان روش های غیرقابل تغییر و همان رفتار ایندکس بندی "
"و برش است."

#: ../../library/functions.rst:227
msgid ""
"Accordingly, constructor arguments are interpreted as for :func:`bytearray`."
msgstr "بنابراین، آرگومان های سازنده مثل :func:`bytearray` تفسیر می شوند."

#: ../../library/functions.rst:229
msgid "Bytes objects can also be created with literals, see :ref:`strings`."
msgstr ""
"شیء های بایت همچنین می توانند با استفاده از لیترال ها ایجاد شوند، به :ref:"
"`strings` مراجعه کنید."

#: ../../library/functions.rst:231
msgid "See also :ref:`binaryseq`, :ref:`typebytes`, and :ref:`bytes-methods`."
msgstr ""
"همچنین ببینید :ref:`binaryseq`، :ref:`typebytes`، و :ref:`bytes-methods`."

#: ../../library/functions.rst:236
msgid ""
"Return :const:`True` if the *object* argument appears callable, :const:"
"`False` if not.  If this returns ``True``, it is still possible that a call "
"fails, but if it is ``False``, calling *object* will never succeed. Note "
"that classes are callable (calling a class returns a new instance); "
"instances are callable if their class has a :meth:`~object.__call__` method."
msgstr ""
"برمی گرداند :const:`True` اگر آرگومان *object* قابل فراخوانی به نظر برسد، :"
"const:`False` اگر نه. اگر این ``True`` برگرداند، هنوز ممکن است که یک "
"فراخوانی شکست بخورد، اما اگر ``False`` باشد، فراخوانی *object* هرگز موفق "
"نخواهد شد. توجه داشته باشید که کلاس ها قابل فراخوانی هستند (فراخوانی یک کلاس "
"یک نمونه جدید برمی گرداند)؛ نمونه ها قابل فراخوانی هستند اگر کلاس آن ها یک "
"متد :meth:`~object.__call__` داشته باشد."

#: ../../library/functions.rst:242
msgid ""
"This function was first removed in Python 3.0 and then brought back in "
"Python 3.2."
msgstr "این تابع ابتدا در پایتون 3.0 حذف شد و سپس در پایتون 3.2 بازگردانده شد."

#: ../../library/functions.rst:249
msgid ""
"Return the string representing a character whose Unicode code point is the "
"integer *i*.  For example, ``chr(97)`` returns the string ``'a'``, while "
"``chr(8364)`` returns the string ``'€'``. This is the inverse of :func:`ord`."
msgstr ""
"رشته ای را برگردانید که نمایانگر کاراکتری باشد که نقطه کد یونیکد آن عدد صحیح "
"*i* است. به عنوان مثال، ``chr(97)`` رشته ``'a'`` را برمی گرداند، درحالی که "
"``chr(8364)`` رشته ``'€'`` را برمی گرداند. این عملکرد معکوس :func:`ord` است."

#: ../../library/functions.rst:253
msgid ""
"The valid range for the argument is from 0 through 1,114,111 (0x10FFFF in "
"base 16).  :exc:`ValueError` will be raised if *i* is outside that range."
msgstr ""
"محدوده معتبر برای آرگومان از 0 تا 1,114,111 (0x10FFFF در مبنای 16) است. :exc:"
"`ValueError` زمانی که *i* خارج از آن محدوده باشد، ایجاد خواهد شد."

#: ../../library/functions.rst:259
msgid "Transform a method into a class method."
msgstr "تبدیل یک متد به یک متد کلاسی."

#: ../../library/functions.rst:261
msgid ""
"A class method receives the class as an implicit first argument, just like "
"an instance method receives the instance. To declare a class method, use "
"this idiom::"
msgstr ""
"یک متد کلاس، کلاس را به عنوان اولین آرگومان ضمنی دریافت می کند، درست همانطور "
"که یک متد نمونه، نمونه را دریافت می کند. برای اعلام یک متد کلاس از این روش "
"استفاده کنید:"

#: ../../library/functions.rst:265
msgid ""
"class C:\n"
"    @classmethod\n"
"    def f(cls, arg1, arg2): ..."
msgstr ""
"کلاس C:\n"
"    @classmethod\n"
"    def f(cls, arg1, arg2): ..."

#: ../../library/functions.rst:269
msgid ""
"The ``@classmethod`` form is a function :term:`decorator` -- see :ref:"
"`function` for details."
msgstr ""
"فرم ``@classmethod`` یک تابع :term:`decorator` است -- برای جزئیات بیشتر به :"
"ref:`function` مراجعه کنید."

#: ../../library/functions.rst:272
msgid ""
"A class method can be called either on the class (such as ``C.f()``) or on "
"an instance (such as ``C().f()``).  The instance is ignored except for its "
"class. If a class method is called for a derived class, the derived class "
"object is passed as the implied first argument."
msgstr ""
"یک متد کلاسی می تواند یا بر روی کلاس (مانند ``C.f()``) و یا بر روی یک نمونه "
"(مانند ``C().f()``) فراخوانی شود. نمونه نادیده گرفته می شود به جز کلاس آن. "
"اگر یک متد کلاسی برای یک کلاس مشتق شده فراخوانی شود، شیء کلاس مشتق شده به "
"عنوان آرگومان اول ضمنی ارسال می شود."

#: ../../library/functions.rst:277
msgid ""
"Class methods are different than C++ or Java static methods. If you want "
"those, see :func:`staticmethod` in this section. For more information on "
"class methods, see :ref:`types`."
msgstr ""
"متدهای کلاس با متدهای استاتیک C++ یا جاوا متفاوت هستند. اگر به دنبال آن ها "
"هستید، به :func:`staticmethod` در این بخش مراجعه کنید. برای اطلاعات بیشتر در "
"مورد متدهای کلاس، به :ref:`types` مراجعه کنید."

#: ../../library/functions.rst:281
msgid ""
"Class methods can now wrap other :term:`descriptors <descriptor>` such as :"
"func:`property`."
msgstr ""
"متدهای کلاس اکنون می توانند سایر :term:`descriptors <descriptor>` ها مانند :"
"func:`property` را پوشش دهند."

#: ../../library/functions.rst:285
msgid ""
"Class methods now inherit the method attributes (:attr:`~function."
"__module__`, :attr:`~function.__name__`, :attr:`~function.__qualname__`, :"
"attr:`~function.__doc__` and :attr:`~function.__annotations__`) and have a "
"new ``__wrapped__`` attribute."
msgstr ""
"متدهای کلاس اکنون ویژگی های متد (:attr:`~function.__module__`، :attr:"
"`~function.__name__`، :attr:`~function.__qualname__`، :attr:`~function."
"__doc__` و :attr:`~function.__annotations__`) را به ارث می برند و دارای "
"ویژگی جدید ``__wrapped__`` می باشند."

#: ../../library/functions.rst:292
msgid ""
"Class methods can no longer wrap other :term:`descriptors <descriptor>` such "
"as :func:`property`."
msgstr ""
"روش های کلاس دیگر نمی توانند :term:`descriptors <descriptor>` دیگری مانند :"
"func:`property` را بپیچند."

#: ../../library/functions.rst:299
msgid ""
"Compile the *source* into a code or AST object.  Code objects can be "
"executed by :func:`exec` or :func:`eval`.  *source* can either be a normal "
"string, a byte string, or an AST object.  Refer to the :mod:`ast` module "
"documentation for information on how to work with AST objects."
msgstr ""
"*source* را به یک شیء کد یا AST کامپایل کنید. اشیاء کد می توانند توسط :func:"
"`exec` یا :func:`eval` اجرا شوند. *source* می تواند یک رشته معمولی، یک رشته "
"بایت یا یک شیء AST باشد. به مستندات ماژول :mod:`ast` برای اطلاعاتی درباره "
"نحوه کار با اشیاء AST مراجعه کنید."

#: ../../library/functions.rst:304
msgid ""
"The *filename* argument should give the file from which the code was read; "
"pass some recognizable value if it wasn't read from a file (``'<string>'`` "
"is commonly used)."
msgstr ""
"استدلال *filename* باید فایل را که کد از آن خوانده شده است، فراهم کند؛ اگر "
"از یک فایل خوانده نشده است، یک مقدار قابل شناسایی را ارسال کنید (معمولاً "
"``'<string>'`` استفاده می شود)."

#: ../../library/functions.rst:308
msgid ""
"The *mode* argument specifies what kind of code must be compiled; it can be "
"``'exec'`` if *source* consists of a sequence of statements, ``'eval'`` if "
"it consists of a single expression, or ``'single'`` if it consists of a "
"single interactive statement (in the latter case, expression statements that "
"evaluate to something other than ``None`` will be printed)."
msgstr ""
"آرگومان *mode* تعیین می کند که چه نوع کدی باید کامپایل شود؛ می تواند "
"``'exec'`` باشد اگر *source* شامل یک دنباله از دستورها باشد، ``'eval'`` باشد "
"اگر شامل یک عبارت منفرد باشد، یا ``'single'`` باشد اگر که شامل یک دستور "
"تعاملی منفرد باشد (در حالت آخر، عبارت هایی که به چیزی جز ``None`` ارزیابی می "
"شوند چاپ خواهند شد)."

#: ../../library/functions.rst:314
msgid ""
"The optional arguments *flags* and *dont_inherit* control which :ref:"
"`compiler options <ast-compiler-flags>` should be activated and which :ref:"
"`future features <future>` should be allowed. If neither is present (or both "
"are zero) the code is compiled with the same flags that affect the code that "
"is calling :func:`compile`. If the *flags* argument is given and "
"*dont_inherit* is not (or is zero) then the compiler options and the future "
"statements specified by the *flags* argument are used in addition to those "
"that would be used anyway. If *dont_inherit* is a non-zero integer then the "
"*flags* argument is it -- the flags (future features and compiler options) "
"in the surrounding code are ignored."
msgstr ""
"آرگومان های اختیاری *flags* و *dont_inherit* کنترل می کنند که کدام :ref:"
"`compiler options <ast-compiler-flags>` باید فعال شود و کدام :ref:`future "
"features <future>` باید مجاز باشد. اگر هیچ کدام حضور نداشته باشند (یا هر دو "
"صفر باشند) کد با همان پرچم هایی که بر کدی که :func:`compile` را فراخوانی می "
"کند تأثیر می گذارند، کامپایل می شود. اگر آرگومان *flags* داده شود و "
"*dont_inherit* داده نشود (یا صفر باشد) آنگاه گزینه های کامپایلر و دستورات "
"آینده ای که توسط آرگومان *flags* مشخص شده اند، علاوه بر آنهایی که به هر حال "
"استفاده می شوند، به کار می روند. اگر *dont_inherit* عددی غیرصفر باشد، آنگاه "
"آرگومان *flags* آن است -- پرچم های (ویژگی های آینده و گزینه های کامپایلر) در "
"کد اطراف نادیده گرفته می شوند."

#: ../../library/functions.rst:325
msgid ""
"Compiler options and future statements are specified by bits which can be "
"bitwise ORed together to specify multiple options. The bitfield required to "
"specify a given future feature can be found as the :attr:`~__future__."
"_Feature.compiler_flag` attribute on the :class:`~__future__._Feature` "
"instance in the :mod:`__future__` module. :ref:`Compiler flags <ast-compiler-"
"flags>` can be found in :mod:`ast` module, with ``PyCF_`` prefix."
msgstr ""
"گزینه های کامپایلر و بیانیه های آینده با بیت هایی مشخص می شوند که می توان آن "
"ها را با عملگر OR بیتی به هم الحاق کرد تا گزینه های متعددی مشخص شوند. فیلد "
"بیتی موردنیاز برای مشخص کردن یک ویژگی آینده مشخص به صورت خاصیت :attr:"
"`~__future__._Feature.compiler_flag` بر روی نمونه :class:`~__future__."
"_Feature` در ماژول :mod:`__future__` یافت می شود. :ref:`Compiler flags <ast-"
"compiler-flags>` در ماژول :mod:`ast` با پیش وند ``PyCF_`` یافت می شود."

#: ../../library/functions.rst:333
msgid ""
"The argument *optimize* specifies the optimization level of the compiler; "
"the default value of ``-1`` selects the optimization level of the "
"interpreter as given by :option:`-O` options.  Explicit levels are ``0`` (no "
"optimization; ``__debug__`` is true), ``1`` (asserts are removed, "
"``__debug__`` is false) or ``2`` (docstrings are removed too)."
msgstr ""
"*optimize* این پارامتر سطح بهینه سازی کامپایلر را مشخص می کند؛ مقدار پیش فرض "
"``-1`` سطح بهینه سازی مفسر را به روشی که توسط :option:`-O` گزینه ها داده "
"شده، انتخاب می کند. سطوح صریح عبارتند از ``0`` (بدون بهینه سازی؛ "
"``__debug__`` درست است)، ``1`` (assertها حذف شده، ``__debug__`` نادرست است) "
"یا ``2`` (docstrings نیز حذف می شوند)."

#: ../../library/functions.rst:339
msgid ""
"This function raises :exc:`SyntaxError` if the compiled source is invalid, "
"and :exc:`ValueError` if the source contains null bytes."
msgstr ""
"این تابع :exc:`SyntaxError` را در صورتی که کد منبع کامپایل شده نامعتبر باشد، "
"و :exc:`ValueError` را اگر منبع شامل بایت های null باشد، برمی گرداند."

#: ../../library/functions.rst:342
msgid ""
"If you want to parse Python code into its AST representation, see :func:`ast."
"parse`."
msgstr ""
"اگر می خواهید کد پایتون را به نمایش AST آن تجزیه کنید، :func:`ast.parse` را "
"ببینید."

#: ../../library/functions.rst:345 ../../library/functions.rst:347
msgid ""
"Raises an :ref:`auditing event <auditing>` ``compile`` with arguments "
"``source`` and ``filename``. This event may also be raised by implicit "
"compilation."
msgstr ""
"یک :ref:`auditing event <auditing>` ``compile`` با آرگومان های ``source`` و "
"``filename`` مطرح می شود. این رویداد ممکن است توسط کامپایل ضمنی نیز مطرح شود."

#: ../../library/functions.rst:353
msgid ""
"When compiling a string with multi-line code in ``'single'`` or ``'eval'`` "
"mode, input must be terminated by at least one newline character.  This is "
"to facilitate detection of incomplete and complete statements in the :mod:"
"`code` module."
msgstr ""
"هنگام کامپایل کردن یک رشته با کد چندخطی در حالت ``'single'`` یا ``'eval'``، "
"ورودی باید حداقل با یک کاراکتر newline خاتمه یابد. این کار به منظور تسهیل "
"تشخیص جملات ناقص و کامل در ماژول :mod:`code` است."

#: ../../library/functions.rst:360
msgid ""
"It is possible to crash the Python interpreter with a sufficiently large/"
"complex string when compiling to an AST object due to stack depth "
"limitations in Python's AST compiler."
msgstr ""
"ممکن است با یک رشته به اندازه کافی بزرگ/پیچیده، مفسر پایتون را هنگام کامپایل "
"به یک شیء AST به دلیل محدودیت های عمق پشته در کامپایلر AST پایتون از کار "
"بیاندازید."

#: ../../library/functions.rst:364
msgid ""
"Allowed use of Windows and Mac newlines.  Also, input in ``'exec'`` mode "
"does not have to end in a newline anymore.  Added the *optimize* parameter."
msgstr ""
"استفاده از خط جدید ویندوز و مک مجاز است. همچنین، ورودی در حالت ``'exec'`` "
"لازم نیست با یک خط جدید پایان یابد. پارامتر *optimize* اضافه شده است."

#: ../../library/functions.rst:368
msgid ""
"Previously, :exc:`TypeError` was raised when null bytes were encountered in "
"*source*."
msgstr ""
"قبلاً، :exc:`TypeError` زمانی افزایش می یافت که بایت های نال در *source* "
"مشاهده می شدند."

#: ../../library/functions.rst:372
msgid ""
"``ast.PyCF_ALLOW_TOP_LEVEL_AWAIT`` can now be passed in flags to enable "
"support for top-level ``await``, ``async for``, and ``async with``."
msgstr ""
"می توان ``ast.PyCF_ALLOW_TOP_LEVEL_AWAIT`` را اکنون در پرچم ها برای فعال "
"کردن پشتیبانی از ``await``، ``async for``، و ``async with`` در سطح بالا "
"گذراند."

#: ../../library/functions.rst:381
msgid ""
"Convert a single string or number to a complex number, or create a complex "
"number from real and imaginary parts."
msgstr ""
"تبدیل یک رشته یا عدد منفرد به یک عدد مختلط، یا ایجاد یک عدد مختلط از قسمت "
"های حقیقی و موهومی."

#: ../../library/functions.rst:384 ../../library/functions.rst:758
#: ../../library/functions.rst:1006
msgid "Examples:"
msgstr "مثال ها:"

#: ../../library/functions.rst:386
msgid ""
">>> complex('+1.23')\n"
"(1.23+0j)\n"
">>> complex('-4.5j')\n"
"-4.5j\n"
">>> complex('-1.23+4.5j')\n"
"(-1.23+4.5j)\n"
">>> complex('\\t( -1.23+4.5J )\\n')\n"
"(-1.23+4.5j)\n"
">>> complex('-Infinity+NaNj')\n"
"(-inf+nanj)\n"
">>> complex(1.23)\n"
"(1.23+0j)\n"
">>> complex(imag=-4.5)\n"
"-4.5j\n"
">>> complex(-1.23, 4.5)\n"
"(-1.23+4.5j)"
msgstr ""
">>> complex('+1.23')\n"
"(۱.۲۳+۰j)\n"
">>> complex('-4.5j')\n"
"-۴.۵j\n"
">>> complex('-1.23+4.5j')\n"
"(-۱.۲۳+۴.۵j)\n"
">>> complex('\\t( -1.23+4.5J )\\n')\n"
"(-۱.۲۳+۴.۵j)\n"
">>> complex('-Infinity+NaNj')\n"
"(-inf+nanj)\n"
">>> complex(۱.۲۳)\n"
"(۱.۲۳+۰j)\n"
">>> complex(imag=-۴.۵)\n"
"-۴.۵j\n"
">>> complex(-۱.۲۳, ۴.۵)\n"
"(-۱.۲۳+۴.۵j)"

#: ../../library/functions.rst:405
msgid ""
"If the argument is a string, it must contain either a real part (in the same "
"format as for :func:`float`) or an imaginary part (in the same format but "
"with a ``'j'`` or ``'J'`` suffix), or both real and imaginary parts (the "
"sign of the imaginary part is mandatory in this case). The string can "
"optionally be surrounded by whitespaces and the round parentheses ``'('`` "
"and ``')'``, which are ignored. The string must not contain whitespace "
"between ``'+'``, ``'-'``, the ``'j'`` or ``'J'`` suffix, and the decimal "
"number. For example, ``complex('1+2j')`` is fine, but ``complex('1 + 2j')`` "
"raises :exc:`ValueError`. More precisely, the input must conform to the :"
"token:`~float:complexvalue` production rule in the following grammar, after "
"parentheses and leading and trailing whitespace characters are removed:"
msgstr ""
"اگر آرگومان یک رشته باشد، باید حاوی یک بخش حقیقی (در همان قالب :func:"
"`float`) یا یک بخش موهومی (با همان قالب اما با پسوند ``'j'`` یا ``'J'``) و "
"یا هر دو بخش حقیقی و موهومی (علامت بخش موهومی در این حالت الزامی است) باشد. "
"رشته می تواند به صورت اختیاری با فاصله و پرانتزهای گرد ``'('`` و ``')'`` "
"احاطه شده باشد که نادیده گرفته می شوند. رشته نباید شامل فاصله بین ``'+'``، "
"``'-'``، پسوند ``'j'`` یا ``'J'`` و عدد اعشاری باشد. به عنوان مثال، "
"``complex('1+2j')`` صحیح است، اما ``complex('1 + 2j')`` خطای :exc:"
"`ValueError` ایجاد می کند. به طور دقیق تر، ورودی باید با قاعده تولید :token:"
"`~float:complexvalue` در دستور زبان زیر مطابقت داشته باشد، پس از حذف "
"پرانتزها و فاصله های ابتدایی و انتهایی:"

#: ../../library/functions.rst:424
msgid ""
"If the argument is a number, the constructor serves as a numeric conversion "
"like :class:`int` and :class:`float`. For a general Python object ``x``, "
"``complex(x)`` delegates to ``x.__complex__()``. If :meth:`~object."
"__complex__` is not defined then it falls back to :meth:`~object.__float__`. "
"If :meth:`!__float__` is not defined then it falls back to :meth:`~object."
"__index__`."
msgstr ""
"اگر آرگومان یک عدد باشد، سازنده به عنوان یک تبدیل عددی مانند :class:`int` و :"
"class:`float` عمل می کند. برای یک شئ عمومی پایتون ``x``، ``complex(x)`` به "
"``x.__complex__()`` محول می شود. اگر :meth:`~object.__complex__` تعریف نشده "
"باشد، سپس به :meth:`~object.__float__` بازمی گردد. اگر :meth:`!__float__` "
"تعریف نشده باشد، سپس به :meth:`~object.__index__` بازمی گردد."

#: ../../library/functions.rst:433
msgid ""
"If two arguments are provided or keyword arguments are used, each argument "
"may be any numeric type (including complex). If both arguments are real "
"numbers, return a complex number with the real component *real* and the "
"imaginary component *imag*. If both arguments are complex numbers, return a "
"complex number with the real component ``real.real-imag.imag`` and the "
"imaginary component ``real.imag+imag.real``. If one of arguments is a real "
"number, only its real component is used in the above expressions."
msgstr ""
"اگر دو آرگومان ارائه شده یا آرگومان های کلیدی استفاده شوند، هر آرگومان می "
"تواند هر نوع عددی (از جمله مختلط) باشد. اگر هر دو آرگومان اعداد حقیقی باشند، "
"یک عدد مختلط با مؤلفه حقیقی *real* و مؤلفه موهومی *imag* برگردانده می شود. "
"اگر هر دو آرگومان اعداد مختلط باشند، یک عدد مختلط با مؤلفه حقیقی ``real.real-"
"imag.imag`` و مؤلفه موهومی ``real.imag+imag.real`` برگردانده می شود. اگر یکی "
"از آرگومان ها عدد حقیقی باشد، فقط مؤلفه حقیقی آن در عبارات فوق استفاده می "
"شود."

#: ../../library/functions.rst:443
msgid ""
"See also :meth:`complex.from_number` which only accepts a single numeric "
"argument."
msgstr ""

#: ../../library/functions.rst:445
msgid "If all arguments are omitted, returns ``0j``."
msgstr "اگر همهٔ آرگومان ها حذف شده باشند، ``0j`` را برمی گرداند."

#: ../../library/functions.rst:447
msgid "The complex type is described in :ref:`typesnumeric`."
msgstr "نوع complex در :ref:`typesnumeric` توضیح داده شده است."

#: ../../library/functions.rst:449 ../../library/functions.rst:812
#: ../../library/functions.rst:1054
msgid "Grouping digits with underscores as in code literals is allowed."
msgstr "از خط تیره برای جداسازی اعداد در نمایه های کد می توان استفاده کرد."

#: ../../library/functions.rst:452
msgid ""
"Falls back to :meth:`~object.__index__` if :meth:`~object.__complex__` and :"
"meth:`~object.__float__` are not defined."
msgstr ""
"به :meth:`~object.__index__` برمی گردد اگر :meth:`~object.__complex__` و :"
"meth:`~object.__float__` تعریف نشده باشند."

#: ../../library/functions.rst:456
msgid ""
"Passing a complex number as the *real* or *imag* argument is now deprecated; "
"it should only be passed as a single positional argument."
msgstr ""

#: ../../library/functions.rst:463
msgid ""
"This is a relative of :func:`setattr`.  The arguments are an object and a "
"string.  The string must be the name of one of the object's attributes.  The "
"function deletes the named attribute, provided the object allows it.  For "
"example, ``delattr(x, 'foobar')`` is equivalent to ``del x.foobar``. *name* "
"need not be a Python identifier (see :func:`setattr`)."
msgstr ""
"این یک خویشاوند از :func:`setattr` است. آرگومان ها یک شیء و یک رشته هستند. "
"رشته باید نام یکی از ویژگی های شیء باشد. تابع ویژگی نام گذاری شده را حذف می "
"کند، به شرطی که شیء این اجازه را بدهد. به عنوان مثال، ``delattr(x, "
"'foobar')`` معادل ``del x.foobar`` است.  *name* نیازی نیست که یک شناسگر "
"پایتون باشد (به :func:`setattr` مراجعه کنید)."

#: ../../library/functions.rst:476
msgid ""
"Create a new dictionary.  The :class:`dict` object is the dictionary class. "
"See :class:`dict` and :ref:`typesmapping` for documentation about this class."
msgstr ""
"یک دیکشنری جدید ایجاد کنید. شیء :class:`dict` کلاس دیکشنری است. برای مستندات "
"مربوط به این کلاس به :class:`dict` و :ref:`typesmapping` مراجعه کنید."

#: ../../library/functions.rst:479
msgid ""
"For other containers see the built-in :class:`list`, :class:`set`, and :"
"class:`tuple` classes, as well as the :mod:`collections` module."
msgstr ""
"برای سایر کانتینرها به کلاس های داخلی :class:`list`، :class:`set` و :class:"
"`tuple`، و همچنین ماژول :mod:`collections` مراجعه کنید."

#: ../../library/functions.rst:486
msgid ""
"Without arguments, return the list of names in the current local scope.  "
"With an argument, attempt to return a list of valid attributes for that "
"object."
msgstr ""
"اگر بدون آرگومان استفاده شود، لیستی از نام ها در حوزه محلی جاری را برمی "
"گرداند. اگر با یک آرگومان استفاده شود، تلاش می کند تا لیستی از ویژگی های "
"معتبر برای آن شی را برگرداند."

#: ../../library/functions.rst:489
msgid ""
"If the object has a method named :meth:`~object.__dir__`, this method will "
"be called and must return the list of attributes. This allows objects that "
"implement a custom :func:`~object.__getattr__` or :func:`~object."
"__getattribute__` function to customize the way :func:`dir` reports their "
"attributes."
msgstr ""
"اگر شیء دارای متدی به نام :meth:`~object.__dir__` باشد، این متد فراخوانی شده "
"و باید لیستی از ویژگی ها را برگرداند. این امکان را فراهم می کند که اشیایی که "
"یک تابع :func:`~object.__getattr__` یا :func:`~object.__getattribute__` "
"سفارشی را پیاده سازی کرده اند، بتوانند نحوه گزارش ویژگی های خود توسط :func:"
"`dir` را سفارشی سازی کنند."

#: ../../library/functions.rst:496
msgid ""
"If the object does not provide :meth:`~object.__dir__`, the function tries "
"its best to gather information from the object's :attr:`~object.__dict__` "
"attribute, if defined, and from its type object.  The resulting list is not "
"necessarily complete and may be inaccurate when the object has a custom :"
"func:`~object.__getattr__`."
msgstr ""
"اگر شیء :meth:`~object.__dir__` را ارائه ندهد، تابع تمام تلاش خود را می کند "
"تا اطلاعات لازم را از ویژگی :attr:`~object.__dict__` شیء، در صورتی که تعریف "
"شده باشد، و از شیء نوع آن جمع آوری کند. لیستی که به دست می آید لزوماً کامل "
"نیست و ممکن است زمانی که شیء دارای :func:`~object.__getattr__` سفارشی باشد، "
"نادرست باشد."

#: ../../library/functions.rst:502
msgid ""
"The default :func:`dir` mechanism behaves differently with different types "
"of objects, as it attempts to produce the most relevant, rather than "
"complete, information:"
msgstr ""
"مکانیسم پیش فرض :func:`dir` با انواع مختلف اشیا به گونه ای متفاوت رفتار می "
"کند، زیرا سعی دارد اطلاعات مرتبط تر (و نه کامل) را تولید کند:"

#: ../../library/functions.rst:506
msgid ""
"If the object is a module object, the list contains the names of the "
"module's attributes."
msgstr "اگر شیء یک شیء ماژول باشد، لیست شامل نام های ویژگی های ماژول است."

#: ../../library/functions.rst:509
msgid ""
"If the object is a type or class object, the list contains the names of its "
"attributes, and recursively of the attributes of its bases."
msgstr ""
"اگر شیء یک نوع یا شیء کلاس باشد، لیست شامل نام های ویژگی های آن و به صورت "
"بازگشتی شامل ویژگی های مبناهای آن می باشد."

#: ../../library/functions.rst:512
msgid ""
"Otherwise, the list contains the object's attributes' names, the names of "
"its class's attributes, and recursively of the attributes of its class's "
"base classes."
msgstr ""
"در غیر این صورت، فهرست شامل نام های ویژگی های شئ، نام های ویژگی های کلاس آن، "
"و به صورت بازگشتی ویژگی های کلاس های پایه آن کلاس خواهد بود."

#: ../../library/functions.rst:516
msgid "The resulting list is sorted alphabetically.  For example:"
msgstr "لیست نهایی به صورت حروف الفبا مرتب می شود. برای مثال:"

#: ../../library/functions.rst:536
msgid ""
"Because :func:`dir` is supplied primarily as a convenience for use at an "
"interactive prompt, it tries to supply an interesting set of names more than "
"it tries to supply a rigorously or consistently defined set of names, and "
"its detailed behavior may change across releases.  For example, metaclass "
"attributes are not in the result list when the argument is a class."
msgstr ""
"از آنجا که :func:`dir` به  طور عمده برای استفاده در یک پرامپت تعاملی ارائه  "
"می شود، سعی دارد تا مجموعه ای جذاب از نام ها را فراهم کند، بیشتر از اینکه "
"سعی کند مجموعه ای به  طور دقیق یا پیوسته تعریف  شده  از نام ها را ارائه دهد. "
"رفتار دقیق آن ممکن است در نسخه های مختلف تغییر کند. برای مثال، زمانی که "
"آرگومان یک کلاس است، صفات متاکلاس در لیست نتیجه نیستند."

#: ../../library/functions.rst:546
msgid ""
"Take two (non-complex) numbers as arguments and return a pair of numbers "
"consisting of their quotient and remainder when using integer division.  "
"With mixed operand types, the rules for binary arithmetic operators apply.  "
"For integers, the result is the same as ``(a // b, a % b)``. For floating-"
"point numbers the result is ``(q, a % b)``, where *q* is usually ``math."
"floor(a / b)`` but may be 1 less than that.  In any case ``q * b + a % b`` "
"is very close to *a*, if ``a % b`` is non-zero it has the same sign as *b*, "
"and ``0 <= abs(a % b) < abs(b)``."
msgstr ""
"دو عدد (غیر مختلط) را به عنوان آرگومان گرفته و یک جفت عدد که شامل خارج قسمت "
"و باقیمانده آن ها هنگام استفاده از تقسیم صحیح است، برمی گرداند. با انواع "
"عملوندهای مخلوط، قواعد برای عملگرهای حسابی دودویی اعمال می شود. برای اعداد "
"صحیح، نتیجه همان ``(a // b, a % b)`` است. برای اعداد اعشاری نتیجه ``(q, a % "
"b)`` است، که در آن *q* معمولاً ``math.floor(a / b)`` است اما ممکن است 1 کمتر "
"از آن باشد. در هر صورت ``q * b + a % b`` بسیار نزدیک به *a* است، اگر ``a % "
"b`` غیر صفر باشد همان علامت *b* را دارد، و ``0 <= abs(a % b) < abs(b)``."

#: ../../library/functions.rst:558
msgid ""
"Return an enumerate object. *iterable* must be a sequence, an :term:"
"`iterator`, or some other object which supports iteration. The :meth:"
"`~iterator.__next__` method of the iterator returned by :func:`enumerate` "
"returns a tuple containing a count (from *start* which defaults to 0) and "
"the values obtained from iterating over *iterable*."
msgstr ""
"یک شیء شمارشی را برمی گرداند. *iterable* باید یک توالی، یک :term:`iterator`، "
"یا یک شیء دیگر باشد که از تکرارپذیری پشتیبانی می کند. متد :meth:`~iterator."
"__next__` از تکرارگر بازگردانده شده توسط :func:`enumerate` یک تاپل شامل یک "
"شمارشگر (از *start* که به طور پیش فرض صفر است) و مقادیری که از تکرار بر روی "
"*iterable* به دست می آیند را بازمی گرداند."

#: ../../library/functions.rst:570
msgid "Equivalent to::"
msgstr "معادل با:"

#: ../../library/functions.rst:572
msgid ""
"def enumerate(iterable, start=0):\n"
"    n = start\n"
"    for elem in iterable:\n"
"        yield n, elem\n"
"        n += 1"
msgstr ""
"def enumerate(iterable, start=0):\n"
"    n = start\n"
"    for elem in iterable:\n"
"        yield n, elem\n"
"        n += 1"

#: ../../library/functions.rst:0
msgid "Parameters"
msgstr "پارامترها"

#: ../../library/functions.rst:582
msgid "A Python expression."
msgstr "یک عبارت Python."

#: ../../library/functions.rst:586
msgid "The global namespace (default: ``None``)."
msgstr "فضای نام سراسری (پیش فرض: ``None``)."

#: ../../library/functions.rst:590
msgid "The local namespace (default: ``None``)."
msgstr "فضای نام محلی (پیش فرض: ``None``)."

#: ../../library/functions.rst:0
msgid "Returns"
msgstr "بازمی گرداند"

#: ../../library/functions.rst:594
msgid "The result of the evaluated expression."
msgstr "نتیجه ی عبارت ارزیابی شده."

#: ../../library/functions.rst:0
msgid "raises"
msgstr "بالا می برد"

#: ../../library/functions.rst:595
msgid "Syntax errors are reported as exceptions."
msgstr "خطاهای نحوی به صورت استثنا گزارش می شوند."

#: ../../library/functions.rst:599 ../../library/functions.rst:660
msgid ""
"This function executes arbitrary code. Calling it with user-supplied input "
"may lead to security vulnerabilities."
msgstr ""
"این تابع کدهای دلخواه را اجرا می کند. فراخوانی آن با ورودی که توسط کاربر "
"ارائه شده است ممکن است منجر به آسیب پذیری های امنیتی شود."

#: ../../library/functions.rst:602
msgid ""
"The *expression* argument is parsed and evaluated as a Python expression "
"(technically speaking, a condition list) using the *globals* and *locals* "
"mappings as global and local namespace.  If the *globals* dictionary is "
"present and does not contain a value for the key ``__builtins__``, a "
"reference to the dictionary of the built-in module :mod:`builtins` is "
"inserted under that key before *expression* is parsed.  That way you can "
"control what builtins are available to the executed code by inserting your "
"own ``__builtins__`` dictionary into *globals* before passing it to :func:"
"`eval`.  If the *locals* mapping is omitted it defaults to the *globals* "
"dictionary.  If both mappings are omitted, the expression is executed with "
"the *globals* and *locals* in the environment where :func:`eval` is called.  "
"Note, *eval()* will only have access to the :term:`nested scopes <nested "
"scope>` (non-locals) in the enclosing environment if they are already "
"referenced in the scope that is calling :func:`eval` (e.g. via a :keyword:"
"`nonlocal` statement)."
msgstr ""
"آرگومان *expression* به عنوان یک عبارت پایتون (به طور خاص، یک لیست شرایط) با "
"استفاده از نگاشت های *globals* و *locals* به عنوان فضای نام سراسری و محلی "
"پردازش و ارزیابی می شود. اگر دیکشنری *globals* موجود باشد و حاوی مقداری برای "
"کلید ``__builtins__`` نباشد، ارجاعی به دیکشنری ماژول داخلی :mod:`builtins` "
"تحت آن کلید قبل از پردازش *expression* درج می شود. به این ترتیب، شما می "
"توانید با قرار دادن دیکشنری ``__builtins__`` خود در *globals* قبل از ارسال "
"آن به :func:`eval`، کنترل کنید که چه توابع داخلی برای کد اجرا شده در دسترس "
"هستند. اگر نگاشت *locals* حذف شود، به طور پیش فرض به دیکشنری *globals* تنظیم "
"می شود. اگر هر دو نگاشت حذف شوند، عبارت در محیطی با *globals* و *locals* "
"واکاوی می شود که در آنجا :func:`eval` فراخوانی می شود. توجه داشته باشید که "
"*eval()* فقط به :term:`nested scopes <nested scope>` (غیر محلی ها) در محیط "
"احاطه کننده دسترسی خواهد داشت اگر آنها قبلاً به دامنه ای که :func:`eval` را "
"فراخوانی می کند ارجاع داده شده باشند (مثلاً از طریق یک دستور :keyword:"
"`nonlocal`)."

#: ../../library/functions.rst:618
msgid "Example:"
msgstr "مثال:"

#: ../../library/functions.rst:624
msgid ""
"This function can also be used to execute arbitrary code objects (such as "
"those created by :func:`compile`).  In this case, pass a code object instead "
"of a string.  If the code object has been compiled with ``'exec'`` as the "
"*mode* argument, :func:`eval`\\'s return value will be ``None``."
msgstr ""
"این تابع همچنین می تواند برای اجرای اشیاء کد دلخواه (مانند آنهایی که توسط :"
"func:`compile` ایجاد شده اند) استفاده شود. در این حالت، به جای یک رشته، یک "
"شیء کد را وارد کنید. اگر شیء کد با استفاده از ``'exec'`` به عنوان آرگومان "
"*mode* کامپایل شده باشد، مقدار بازگشتی :func:`eval` برابر با ``None`` خواهد "
"بود."

#: ../../library/functions.rst:629
msgid ""
"Hints: dynamic execution of statements is supported by the :func:`exec` "
"function.  The :func:`globals` and :func:`locals` functions return the "
"current global and local dictionary, respectively, which may be useful to "
"pass around for use by :func:`eval` or :func:`exec`."
msgstr ""
"اجرای پویا از جملات توسط تابع :func:`exec` پشتیبانی می شود. توابع :func:"
"`globals` و :func:`locals` به ترتیب دیکشنری های سراسری و محلی فعلی را برمی "
"گردانند که ممکن است برای استفاده توسط :func:`eval` یا :func:`exec` مفید باشد."

#: ../../library/functions.rst:634
msgid ""
"If the given source is a string, then leading and trailing spaces and tabs "
"are stripped."
msgstr ""
"اگر منبع داده شده یک رشته باشد، فضاهای خالی و تب های ابتدای و انتهای آن حذف "
"می شوند."

#: ../../library/functions.rst:637
msgid ""
"See :func:`ast.literal_eval` for a function that can safely evaluate strings "
"with expressions containing only literals."
msgstr ""
"برای مشاهده تابعی که می تواند رشته ها را با عبارات حاوی تنها مقادیر مستقیم "
"به طور امن ارزیابی کند، به :func:`ast.literal_eval` مراجعه کنید."

#: ../../library/functions.rst:640 ../../library/functions.rst:642
#: ../../library/functions.rst:702 ../../library/functions.rst:704
msgid ""
"Raises an :ref:`auditing event <auditing>` ``exec`` with the code object as "
"the argument. Code compilation events may also be raised."
msgstr ""
"یک :ref:`auditing event <auditing>` ``exec`` را با شیء کد به عنوان آرگومان "
"برمی انگیزد. رویدادهای کامپایل کد نیز ممکن است برانگیخته شوند."

#: ../../library/functions.rst:647 ../../library/functions.rst:724
msgid "The *globals* and *locals* arguments can now be passed as keywords."
msgstr ""
"آرگومان های *globals* و *locals* اکنون می توانند به صورت کلیدواژه ها ارسال "
"شوند."

#: ../../library/functions.rst:651 ../../library/functions.rst:728
msgid ""
"The semantics of the default *locals* namespace have been adjusted as "
"described for the :func:`locals` builtin."
msgstr ""
"معانی فضای نام پیش فرض *locals* مطابق با آنچه برای :func:`locals` builtin "
"توصیف شده تعدیل شده است."

#: ../../library/functions.rst:663
msgid ""
"This function supports dynamic execution of Python code. *source* must be "
"either a string or a code object.  If it is a string, the string is parsed "
"as a suite of Python statements which is then executed (unless a syntax "
"error occurs). [#]_ If it is a code object, it is simply executed.  In all "
"cases, the code that's executed is expected to be valid as file input (see "
"the section :ref:`file-input` in the Reference Manual). Be aware that the :"
"keyword:`nonlocal`, :keyword:`yield`,  and :keyword:`return` statements may "
"not be used outside of function definitions even within the context of code "
"passed to the :func:`exec` function. The return value is ``None``."
msgstr ""
"این تابع از اجرای پویا کد پایتون پشتیبانی می کند. *source* باید یا یک رشته "
"باشد یا یک شیء کد. اگر یک رشته باشد، رشته به عنوان مجموعه ای از دستورات "
"پایتون تجزیه می شود که سپس اجرا خواهد شد (مگر اینکه خطای نحوی رخ دهد). [#]_ "
"اگر یک شیء کد باشد، به سادگی اجرا خواهد شد. در تمامی حالات، انتظار می رود "
"کدی که اجرا می شود به عنوان ورودی فایل معتبر باشد (به بخش :ref:`file-input` "
"در راهنمای مرجع مراجعه کنید). توجه داشته باشید که دستورات :keyword:"
"`nonlocal`، :keyword:`yield`،  و :keyword:`return` ممکن است خارج از تعاریف "
"توابع حتی در زمینه کدی که به تابع :func:`exec` فرستاده می شود، استفاده "
"نشوند. مقدار بازگشتی ``None`` است."

#: ../../library/functions.rst:674
msgid ""
"In all cases, if the optional parts are omitted, the code is executed in the "
"current scope.  If only *globals* is provided, it must be a dictionary (and "
"not a subclass of dictionary), which will be used for both the global and "
"the local variables.  If *globals* and *locals* are given, they are used for "
"the global and local variables, respectively.  If provided, *locals* can be "
"any mapping object.  Remember that at the module level, globals and locals "
"are the same dictionary."
msgstr ""
"در همه موارد، اگر بخش های اختیاری حذف شوند، کد در حوزه جاری اجرا می شود. اگر "
"فقط *globals* ارائه شود، باید یک دیکشنری باشد (و نه یک زیرکلاس از دیکشنری)، "
"که هم برای متغیرهای سراسری و هم محلی استفاده خواهد شد. اگر *globals* و "
"*locals* داده شوند، به ترتیب برای متغیرهای سراسری و محلی به کار می روند. اگر "
"ارائه شود، *locals* می تواند هر شئ نگاشت باشد. به خاطر داشته باشید که در سطح "
"ماژول، سراسری ها و محلی ها یک دیکشنری هستند."

#: ../../library/functions.rst:684
msgid ""
"When ``exec`` gets two separate objects as *globals* and *locals*, the code "
"will be executed as if it were embedded in a class definition. This means "
"functions and classes defined in the executed code will not be able to "
"access variables assigned at the top level (as the \"top level\" variables "
"are treated as class variables in a class definition)."
msgstr ""
"زمانی که ``exec`` دو شیء جداگانه به عنوان *globals* و *locals* دریافت می "
"کند، کد به گونه ای اجرا می شود که گویی در تعریف یک کلاس جاسازی شده است. این "
"به این معناست که توابع و کلاس هایی که در کد اجرا شده تعریف می شوند، نمی "
"توانند به متغیرهایی که در سطح بالا اختصاص داده شده اند دسترسی داشته باشند "
"(زیرا متغیرهای \"سطح بالا\" به عنوان متغیرهای کلاس در تعریف کلاس تلقی می "
"شوند)."

#: ../../library/functions.rst:690
msgid ""
"If the *globals* dictionary does not contain a value for the key "
"``__builtins__``, a reference to the dictionary of the built-in module :mod:"
"`builtins` is inserted under that key.  That way you can control what "
"builtins are available to the executed code by inserting your own "
"``__builtins__`` dictionary into *globals* before passing it to :func:`exec`."
msgstr ""
"اگر دیکشنری *globals* حاوی مقداری برای کلید ``__builtins__`` نباشد، یک مرجع "
"به دیکشنری ماژول ساخته شده :mod:`builtins` در زیر آن کلید اضافه می شود. به "
"این ترتیب، می توانید با وارد کردن دیکشنری ``__builtins__`` خودتان در "
"*globals* قبل از اینکه آن را به :func:`exec` بدهید، کنترل کنید که چه "
"ساختارهای داخلی در کد اجرا شده در دسترس هستند."

#: ../../library/functions.rst:696
msgid ""
"The *closure* argument specifies a closure--a tuple of cellvars. It's only "
"valid when the *object* is a code object containing :term:`free (closure) "
"variables <closure variable>`. The length of the tuple must exactly match "
"the length of the code object's :attr:`~codeobject.co_freevars` attribute."
msgstr ""
"آرگومان *closure* یک closure را مشخص می کند--یک تاپل از cellvars. این تنها "
"زمانی معتبر است که *object* یک شی کد حاوی :term:`free (closure) variables "
"<closure variable>` باشد. طول تاپل باید دقیقاً با طول ویژگی :attr:"
"`~codeobject.co_freevars` شی کد مطابقت داشته باشد."

#: ../../library/functions.rst:709
msgid ""
"The built-in functions :func:`globals` and :func:`locals` return the current "
"global and local namespace, respectively, which may be useful to pass around "
"for use as the second and third argument to :func:`exec`."
msgstr ""
"توابع داخلی :func:`globals` و :func:`locals` به ترتیب فضای نام سراسری و محلی "
"فعلی را بازمی گردانند، که ممکن است برای انتقال و استفاده به عنوان آرگومان "
"دوم و سوم به :func:`exec` مفید باشند."

#: ../../library/functions.rst:715
msgid ""
"The default *locals* act as described for function :func:`locals` below. "
"Pass an explicit *locals* dictionary if you need to see effects of the code "
"on *locals* after function :func:`exec` returns."
msgstr ""
"*locals* به صورت پیش فرض به روشی که برای تابع :func:`locals` در زیر توضیح "
"داده شده است عمل می کند. اگر نیاز دارید اثرات کد بر روی *locals* را بعد از "
"بازگشت تابع :func:`exec` ببینید، یک دیکشنری *locals* صریح ارسال کنید."

#: ../../library/functions.rst:719
msgid "Added the *closure* parameter."
msgstr "پارامتر *closure* اضافه شد."

#: ../../library/functions.rst:734
msgid ""
"Construct an iterator from those elements of *iterable* for which *function* "
"is true.  *iterable* may be either a sequence, a container which supports "
"iteration, or an iterator.  If *function* is ``None``, the identity function "
"is assumed, that is, all elements of *iterable* that are false are removed."
msgstr ""
"یک تکرارگر از آن عناصری از *iterable* که برای آن ها *function* درست است، "
"بسازید. *iterable* می تواند یک دنباله، یک ظرف که از تکرار پشتیبانی می کند، "
"یا یک تکرارگر باشد. اگر *function* برابر ``None`` باشد، تابع هویت فرض می "
"شود، یعنی همه عناصر *iterable* که نادرست هستند حذف می شوند."

#: ../../library/functions.rst:740
msgid ""
"Note that ``filter(function, iterable)`` is equivalent to the generator "
"expression ``(item for item in iterable if function(item))`` if function is "
"not ``None`` and ``(item for item in iterable if item)`` if function is "
"``None``."
msgstr ""
"توجه داشته باشید که ``filter(function, iterable)`` معادل عبارت مولد ``(item "
"for item in iterable if function(item))`` است، اگر function برابر با "
"``None`` نباشد و ``(item for item in iterable if item)`` اگر function برابر "
"با ``None`` باشد."

#: ../../library/functions.rst:745
msgid ""
"See :func:`itertools.filterfalse` for the complementary function that "
"returns elements of *iterable* for which *function* is false."
msgstr ""
"متناظر :func:`itertools.filterfalse` را ببینید که عناصری از *iterable* را "
"برمی گرداند که برای آن ها *function* نادرست است."

#: ../../library/functions.rst:756
msgid "Return a floating-point number constructed from a number or a string."
msgstr "بازگشت یک عدد اعشاری که از یک عدد یا یک رشته ساخته شده است."

#: ../../library/functions.rst:760
msgid ""
">>> float('+1.23')\n"
"1.23\n"
">>> float('   -12345\\n')\n"
"-12345.0\n"
">>> float('1e-003')\n"
"0.001\n"
">>> float('+1E6')\n"
"1000000.0\n"
">>> float('-Infinity')\n"
"-inf"
msgstr ""
">>> float('+1.23')\n"
"1.23\n"
">>> float('   -12345\\n')\n"
"-12345.0\n"
">>> float('1e-003')\n"
"0.001\n"
">>> float('+1E6')\n"
"1000000.0\n"
">>> float('-Infinity')\n"
"-inf"

#: ../../library/functions.rst:773
msgid ""
"If the argument is a string, it should contain a decimal number, optionally "
"preceded by a sign, and optionally embedded in whitespace.  The optional "
"sign may be ``'+'`` or ``'-'``; a ``'+'`` sign has no effect on the value "
"produced.  The argument may also be a string representing a NaN (not-a-"
"number), or positive or negative infinity. More precisely, the input must "
"conform to the :token:`~float:floatvalue` production rule in the following "
"grammar, after leading and trailing whitespace characters are removed:"
msgstr ""
"اگر آرگومان یک رشته باشد، باید شامل یک عدد اعشاری باشد که می تواند به صورت "
"اختیاری با یک علامت پیش فرض و همچنین درون فضای خالی قرار گیرد. علامت اختیاری "
"می تواند ``'+'`` یا ``'-'`` باشد؛ علامت ``'+'`` تاثیری بر روی مقداری که "
"تولید می شود ندارد. آرگومان همچنین می تواند رشته ای باشد که یک NaN (نه-عدد) "
"یا بی نهایت مثبت یا منفی را نشان دهد. به طور دقیق تر، ورودی باید مطابق با "
"قانون تولید :token:`~float:floatvalue` در گرامر زیر باشد، پس از این که "
"کاراکترهای فضای خالی اول و آخر حذف شدند:"

#: ../../library/functions.rst:794
msgid ""
"Case is not significant, so, for example, \"inf\", \"Inf\", \"INFINITY\", "
"and \"iNfINity\" are all acceptable spellings for positive infinity."
msgstr ""
"اندازه حروف در اینجا مهم نیست، بنابراین به عنوان مثال، \"inf\"، \"Inf\"، "
"\"INFINITY\" و \"iNfINity\" همگی نگارش های قابل قبول برای بی نهایت مثبت "
"هستند."

#: ../../library/functions.rst:797
msgid ""
"Otherwise, if the argument is an integer or a floating-point number, a "
"floating-point number with the same value (within Python's floating-point "
"precision) is returned.  If the argument is outside the range of a Python "
"float, an :exc:`OverflowError` will be raised."
msgstr ""
"در غیر این صورت، اگر آرگومان یک عدد صحیح یا یک عدد اعشاری باشد، یک عدد "
"اعشاری با همان مقدار (در محدوده دقت اعشاری پایتون) بازگردانده می شود. اگر "
"آرگومان خارج از محدوده یک شناور پایتون باشد، یک :exc:`OverflowError` ایجاد "
"خواهد شد."

#: ../../library/functions.rst:802
msgid ""
"For a general Python object ``x``, ``float(x)`` delegates to ``x."
"__float__()``.  If :meth:`~object.__float__` is not defined then it falls "
"back to :meth:`~object.__index__`."
msgstr ""
"برای یک شیء عمومی پایتون ``x``، ``float(x)`` به ``x.__float__()`` ارجاع می "
"دهد. اگر :meth:`~object.__float__` تعریف نشده باشد، به :meth:`~object."
"__index__` باز می گردد."

#: ../../library/functions.rst:806
msgid ""
"See also :meth:`float.from_number` which only accepts a numeric argument."
msgstr ""

#: ../../library/functions.rst:808
msgid "If no argument is given, ``0.0`` is returned."
msgstr "اگر هیچ آرگومانی داده نشود، ``0.0`` بازگردانده می شود."

#: ../../library/functions.rst:810
msgid "The float type is described in :ref:`typesnumeric`."
msgstr "نوع float در :ref:`typesnumeric` توضیح داده شده است."

#: ../../library/functions.rst:818
msgid ""
"Falls back to :meth:`~object.__index__` if :meth:`~object.__float__` is not "
"defined."
msgstr ""
"در صورتی که :meth:`~object.__float__` تعریف نشده باشد، به :meth:`~object."
"__index__` بازگشت می کند."

#: ../../library/functions.rst:828
msgid ""
"Convert a *value* to a \"formatted\" representation, as controlled by "
"*format_spec*.  The interpretation of *format_spec* will depend on the type "
"of the *value* argument; however, there is a standard formatting syntax that "
"is used by most built-in types: :ref:`formatspec`."
msgstr ""
"تبدیل *value* به نمایشی \"قالب بندی شده\"، همان طور که توسط *format_spec* "
"کنترل می شود. تفسیر *format_spec* وابسته به نوع آرگومان *value* خواهد بود؛ "
"با این حال، یک نگارش استاندارد قالب بندی وجود دارد که توسط اکثر انواع داخلی "
"مورد استفاده قرار می گیرد: :ref:`formatspec`."

#: ../../library/functions.rst:833
msgid ""
"The default *format_spec* is an empty string which usually gives the same "
"effect as calling :func:`str(value) <str>`."
msgstr ""
"پیش فرض *format_spec* یک رشته  خالی است که معمولاً همان اثری را دارد که با "
"فراخوانی :func:`str(value) <str>` به دست می آید."

#: ../../library/functions.rst:836
msgid ""
"A call to ``format(value, format_spec)`` is translated to ``type(value)."
"__format__(value, format_spec)`` which bypasses the instance dictionary when "
"searching for the value's :meth:`~object.__format__` method. A :exc:"
"`TypeError` exception is raised if the method search reaches :mod:`object` "
"and the *format_spec* is non-empty, or if either the *format_spec* or the "
"return value are not strings."
msgstr ""
"فراخوانی به ``format(value, format_spec)`` به ``type(value)."
"__format__(value, format_spec)`` ترجمه می شود که هنگام جست وجوی روش :meth:"
"`~object.__format__` مقدار، از دیکشنری نمونه عبور می کند. یک استثنای :exc:"
"`TypeError` در صورتی پرتاب می شود که جست وجوی روش به :mod:`object` برسد و "
"*format_spec* غیرخالی باشد، یا اگر *format_spec* یا مقدار بازگشتی رشته "
"نباشند."

#: ../../library/functions.rst:843
msgid ""
"``object().__format__(format_spec)`` raises :exc:`TypeError` if "
"*format_spec* is not an empty string."
msgstr ""
"``object().__format__(format_spec)`` خطای :exc:`TypeError` را تولید می کند "
"اگر *format_spec* یک رشته خالی نباشد."

#: ../../library/functions.rst:852
msgid ""
"Return a new :class:`frozenset` object, optionally with elements taken from "
"*iterable*.  ``frozenset`` is a built-in class.  See :class:`frozenset` and :"
"ref:`types-set` for documentation about this class."
msgstr ""
"یک شیء جدید :class:`frozenset` برمی گرداند که اختیاری می تواند عناصری از "
"*iterable* داشته باشد. ``frozenset`` یک کلاس داخلی است. برای مستندات مربوط "
"به این کلاس به :class:`frozenset` و :ref:`types-set` مراجعه کنید."

#: ../../library/functions.rst:856
msgid ""
"For other containers see the built-in :class:`set`, :class:`list`, :class:"
"`tuple`, and :class:`dict` classes, as well as the :mod:`collections` module."
msgstr ""
"برای سایر کانتینرها به کلاس های داخلی :class:`set`، :class:`list`، :class:"
"`tuple` و :class:`dict` و همچنین ماژول :mod:`collections` مراجعه کنید."

#: ../../library/functions.rst:864
msgid ""
"Return the value of the named attribute of *object*.  *name* must be a "
"string. If the string is the name of one of the object's attributes, the "
"result is the value of that attribute.  For example, ``getattr(x, "
"'foobar')`` is equivalent to ``x.foobar``.  If the named attribute does not "
"exist, *default* is returned if provided, otherwise :exc:`AttributeError` is "
"raised. *name* need not be a Python identifier (see :func:`setattr`)."
msgstr ""
"ارزش خصیصه ای به نام *object* را برمی گرداند. *name* باید یک رشته باشد. اگر "
"این رشته نام یکی از خصوصیات شیء باشد، نتیجه مقدار آن خصوصیت خواهد بود. به "
"عنوان مثال، ``getattr(x, 'foobar')`` معادل ``x.foobar`` است. اگر خصیصه مورد "
"نظر وجود نداشته باشد، *default* برگردانده می شود در صورتیکه ارائه شده باشد، "
"در غیر این صورت :exc:`AttributeError` خطا می دهد. *name* لازم نیست یک شناسه "
"پایتون باشد (به :func:`setattr` مراجعه کنید)."

#: ../../library/functions.rst:873
msgid ""
"Since :ref:`private name mangling <private-name-mangling>` happens at "
"compilation time, one must manually mangle a private attribute's (attributes "
"with two leading underscores) name in order to retrieve it with :func:"
"`getattr`."
msgstr ""
"از آنجایی که :ref:`private name mangling <private-name-mangling>` در زمان "
"کامپایل اتفاق می افتد، باید به صورت دستی نام یک ویژگی خصوصی (ویژگی هایی که "
"با دو خط تیره آغاز می شوند) را برای بازیابی با :func:`getattr` تغییر دهید."

#: ../../library/functions.rst:881
msgid ""
"Return the dictionary implementing the current module namespace. For code "
"within functions, this is set when the function is defined and remains the "
"same regardless of where the function is called."
msgstr ""
"دیکشنری ای را که فضای نام فعلی ماژول را پیاده سازی می کند، برگردانید. برای "
"کدی که درون توابع قرار دارد، این دیکشنری در زمان تعریف تابع تنظیم می شود و "
"بدون توجه به محلی که تابع فراخوانی می شود، ثابت می ماند."

#: ../../library/functions.rst:888
msgid ""
"The arguments are an object and a string.  The result is ``True`` if the "
"string is the name of one of the object's attributes, ``False`` if not. "
"(This is implemented by calling ``getattr(object, name)`` and seeing whether "
"it raises an :exc:`AttributeError` or not.)"
msgstr ""
"استدلال ها یک شیء و یک رشته هستند. نتیجه ``True`` است اگر رشته نام یکی از "
"ویژگی های شیء باشد، و ``False`` اگر نباشد. (این با فراخوانی "
"``getattr(object, name)`` پیاده سازی شده و بررسی می کند که آیا :exc:"
"`AttributeError` ایجاد می شود یا خیر.)"

#: ../../library/functions.rst:896
msgid ""
"Return the hash value of the object (if it has one).  Hash values are "
"integers.  They are used to quickly compare dictionary keys during a "
"dictionary lookup.  Numeric values that compare equal have the same hash "
"value (even if they are of different types, as is the case for 1 and 1.0)."
msgstr ""
"بازگرداندن مقدار هش شیء (در صورتی که یکی داشته باشد). مقادیر هش اعداد صحیح "
"هستند. از آنها برای مقایسه سریع کلیدهای دیکشنری در هنگام جستجوی دیکشنری "
"استفاده می شود. مقادیر عددی که برابر مقایسه می شوند دارای مقدار هش یکسانی "
"هستند (حتی اگر از انواع مختلف باشند، مانند 1 و 1.0)."

#: ../../library/functions.rst:903
msgid ""
"For objects with custom :meth:`~object.__hash__` methods, note that :func:"
"`hash` truncates the return value based on the bit width of the host machine."
msgstr ""
"برای اشیائی که دارای متدهای سفارشی :meth:`~object.__hash__` هستند، توجه "
"داشته باشید که :func:`hash` مقدار بازگشتی را بر اساس عرض بیت ماشین میزبان "
"کوتاه می کند."

#: ../../library/functions.rst:910
msgid ""
"Invoke the built-in help system.  (This function is intended for interactive "
"use.)  If no argument is given, the interactive help system starts on the "
"interpreter console.  If the argument is a string, then the string is looked "
"up as the name of a module, function, class, method, keyword, or "
"documentation topic, and a help page is printed on the console.  If the "
"argument is any other kind of object, a help page on the object is generated."
msgstr ""
"سیستم راهنمای داخلی را فراخوانی کنید. (این تابع برای استفاده تعاملی طراحی "
"شده است.) اگر هیچ آرگومانی داده نشود، سیستم راهنمای تعاملی روی کنسول مفسر "
"شروع می شود. اگر آرگومان یک رشته باشد، آن رشته به عنوان نام یک ماژول، تابع، "
"کلاس، متد، کلمه کلیدی یا موضوع مستندات جستجو می شود و یک صفحه راهنما بر روی "
"کنسول چاپ می شود. اگر آرگومان هر نوع شیء دیگری باشد، یک صفحه راهنما درباره "
"آن شیء تولید می شود."

#: ../../library/functions.rst:917
msgid ""
"Note that if a slash(/) appears in the parameter list of a function when "
"invoking :func:`help`, it means that the parameters prior to the slash are "
"positional-only. For more info, see :ref:`the FAQ entry on positional-only "
"parameters <faq-positional-only-arguments>`."
msgstr ""
"توجه داشته باشید که اگر علامت اسلش (/) در لیست پارامترهای یک تابع هنگام "
"فراخوانی :func:`help` ظاهر شود، به این معنی است که پارامترهای قبل از اسلش "
"فقط موقعیتی هستند. برای اطلاعات بیشتر، به :ref:`the FAQ entry on positional-"
"only parameters <faq-positional-only-arguments>` مراجعه کنید."

#: ../../library/functions.rst:922
msgid ""
"This function is added to the built-in namespace by the :mod:`site` module."
msgstr "این تابع توسط ماژول :mod:`site` به فضای نام داخلی اضافه شده است."

#: ../../library/functions.rst:924
msgid ""
"Changes to :mod:`pydoc` and :mod:`inspect` mean that the reported signatures "
"for callables are now more comprehensive and consistent."
msgstr ""
"تغییرات به :mod:`pydoc` و :mod:`inspect` به این معناست که امضاهای گزارش شده "
"برای فراخوان ها اکنون جامع تر و سازگارتر هستند."

#: ../../library/functions.rst:931
msgid ""
"Convert an integer number to a lowercase hexadecimal string prefixed with "
"\"0x\". If *x* is not a Python :class:`int` object, it has to define an :"
"meth:`~object.__index__` method that returns an integer. Some examples:"
msgstr ""
"تبدیل یک عدد صحیح به یک رشته هگزادسیمال با حروف کوچک که با \"0x\" شروع می "
"شود. اگر *x* یک شیء Python :class:`int` نباشد، باید یک متد :meth:`~object."
"__index__` تعریف کند که یک عدد صحیح را برگرداند. چند مثال:"

#: ../../library/functions.rst:940
msgid ""
"If you want to convert an integer number to an uppercase or lower "
"hexadecimal string with prefix or not, you can use either of the following "
"ways:"
msgstr ""
"اگر می خواهید یک عدد صحیح را به یک رشته شانزده شانزدهی بزرگ یا کوچک با "
"پیشوند یا بدون آن تبدیل کنید، می توانید از روش های زیر استفاده کنید:"

#: ../../library/functions.rst:952
msgid ""
"See also :func:`int` for converting a hexadecimal string to an integer using "
"a base of 16."
msgstr ""
"همچنین :func:`int` را ببینید برای تبدیل یک رشته هگزادسیمال به یک عدد صحیح با "
"استفاده از مبنای 16."

#: ../../library/functions.rst:957
msgid ""
"To obtain a hexadecimal string representation for a float, use the :meth:"
"`float.hex` method."
msgstr ""
"برای به دست آوردن یک نمایش رشته ای هگزادسیمال برای یک float، از روش :meth:"
"`float.hex` استفاده کنید."

#: ../../library/functions.rst:963
msgid ""
"Return the \"identity\" of an object.  This is an integer which is "
"guaranteed to be unique and constant for this object during its lifetime. "
"Two objects with non-overlapping lifetimes may have the same :func:`id` "
"value."
msgstr ""
"\"شناسه\" یک شیء را برمی گرداند. این یک عدد صحیح است که تضمین می شود در طول "
"عمر شیء، منحصر به فرد و ثابت باشد. دو شیء که دوره های عمرشان با هم تلاقی "
"ندارند ممکن است مقدار :func:`id` یکسانی داشته باشند."

#: ../../library/functions.rst:968
msgid "This is the address of the object in memory."
msgstr "این آدرس شیء در حافظه است."

#: ../../library/functions.rst:970
msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.id`` with argument "
"``id``."
msgstr ""
"یک :ref:`auditing event <auditing>` ``builtins.id`` با آرگومان ``id`` برمی "
"گرداند."

#: ../../library/functions.rst:976
msgid ""
"If the *prompt* argument is present, it is written to standard output "
"without a trailing newline.  The function then reads a line from input, "
"converts it to a string (stripping a trailing newline), and returns that.  "
"When EOF is read, :exc:`EOFError` is raised.  Example::"
msgstr ""
"اگر آرگومان *prompt* وجود داشته باشد، بدون یک خط جدید به خروجی استاندارد "
"نوشته می شود. سپس تابع یک خط از ورودی می خواند، آن را به رشته تبدیل می کند "
"(خط جدید انتهایی را حذف می کند)، و آن را برمی گرداند. وقتی EOF خوانده شد، :"
"exc:`EOFError` تولید می شود. مثال::"

#: ../../library/functions.rst:981
msgid ""
">>> s = input('--> ')\n"
"--> Monty Python's Flying Circus\n"
">>> s\n"
"\"Monty Python's Flying Circus\""
msgstr ""
">>> s = input('--> ')\n"
"--> Monty Python's Flying Circus\n"
">>> s\n"
"\"Monty Python's Flying Circus\""

#: ../../library/functions.rst:986
msgid ""
"If the :mod:`readline` module was loaded, then :func:`input` will use it to "
"provide elaborate line editing and history features."
msgstr ""
"اگر ماژول :mod:`readline` بارگذاری شده باشد، سپس :func:`input` از آن استفاده "
"خواهد کرد تا ویژگی های ویرایش خط و تاریخچه پیشرفته ای را فراهم کند."

#: ../../library/functions.rst:989 ../../library/functions.rst:991
msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.input`` with argument "
"``prompt`` before reading input"
msgstr ""
"قبل از خواندن ورودی، یک :ref:`auditing event <auditing>` ``builtins.input`` "
"با آرگومان ``prompt`` ایجاد می کند."

#: ../../library/functions.rst:994 ../../library/functions.rst:996
msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.input/result`` with "
"the result after successfully reading input."
msgstr ""
"یک :ref:`auditing event <auditing>` ``builtins.input/result`` را با نتیجه پس "
"از خواندن موفقیت آمیز ورودی ایجاد می کند."

#: ../../library/functions.rst:1003
msgid ""
"Return an integer object constructed from a number or a string, or return "
"``0`` if no arguments are given."
msgstr ""
"یک شیء عدد صحیح بازمی گرداند که از یک عدد یا یک رشته ساخته شده است، یا اگر "
"هیچ آرگومانی داده نشود، ``0`` را بازمی گرداند."

#: ../../library/functions.rst:1008
msgid ""
">>> int(123.45)\n"
"123\n"
">>> int('123')\n"
"123\n"
">>> int('   -12_345\\n')\n"
"-12345\n"
">>> int('FACE', 16)\n"
"64206\n"
">>> int('0xface', 0)\n"
"64206\n"
">>> int('01110011', base=2)\n"
"115"
msgstr ""
">>> int(123.45)\n"
"123\n"
">>> int('123')\n"
"123\n"
">>> int('   -12_345\\n')\n"
"-12345\n"
">>> int('FACE', 16)\n"
"64206\n"
">>> int('0xface', 0)\n"
"64206\n"
">>> int('01110011', base=2)\n"
"115"

#: ../../library/functions.rst:1023
msgid ""
"If the argument defines :meth:`~object.__int__`, ``int(x)`` returns ``x."
"__int__()``.  If the argument defines :meth:`~object.__index__`, it returns "
"``x.__index__()``. For floating-point numbers, this truncates towards zero."
msgstr ""

#: ../../library/functions.rst:1028
msgid ""
"If the argument is not a number or if *base* is given, then it must be a "
"string, :class:`bytes`, or :class:`bytearray` instance representing an "
"integer in radix *base*.  Optionally, the string can be preceded by ``+`` or "
"``-`` (with no space in between), have leading zeros, be surrounded by "
"whitespace, and have single underscores interspersed between digits."
msgstr ""
"اگر آرگومان یک عدد نباشد یا *base* داده شود، در این صورت باید یک رشته، :"
"class:`bytes`، یا نمونه :class:`bytearray` باشد که نمایانگر یک عدد صحیح در "
"مبنای *base* است. به صورت اختیاری، رشته می تواند با ``+`` یا ``-`` (بدون هیچ "
"فاصله ای بین آن ها) آغاز شود، دارای صفرهای ابتدایی باشد، با فاصله های خالی "
"احاطه شده باشد، و خط زیرین های تکی در بین ارقام داشته باشد."

#: ../../library/functions.rst:1034
msgid ""
"A base-n integer string contains digits, each representing a value from 0 to "
"n-1. The values 0--9 can be represented by any Unicode decimal digit. The "
"values 10--35 can be represented by ``a`` to ``z`` (or ``A`` to ``Z``). The "
"default *base* is 10. The allowed bases are 0 and 2--36. Base-2, -8, and -16 "
"strings can be optionally prefixed with ``0b``/``0B``, ``0o``/``0O``, or "
"``0x``/``0X``, as with integer literals in code.  For base 0, the string is "
"interpreted in a similar way to an :ref:`integer literal in code "
"<integers>`, in that the actual base is 2, 8, 10, or 16 as determined by the "
"prefix. Base 0 also disallows leading zeros: ``int('010', 0)`` is not legal, "
"while ``int('010')`` and ``int('010', 8)`` are."
msgstr ""
"یک رشته عدد صحیح مبنای-n شامل ارقامی است که هر یک مقداری از 0 تا n-1 را "
"نمایش می دهد. مقادیر 0--9 می توانند توسط هر رقم اعشاری یونیکد نمایش داده "
"شوند. مقادیر 10--35 می توانند با ``a`` تا ``z`` (یا ``A`` تا ``Z``) نمایش "
"داده شوند. مقدار پیش فرض *base*، 10 است. مبناهای مجاز 0 و 2--36 هستند. رشته "
"های مبنای-2، -8 و -16 می توانند به صورت اختیاری با ``0b``/``0B``، ``0o``/"
"``0O``، یا ``0x``/``0X`` پیشوند شوند، مشابه با عبارت های عددی صحیح در کد. "
"برای مبنای 0، رشته به صورت مشابهی با یک :ref:`integer literal in code "
"<integers>` تفسیر می شود، به گونه ای که مبنای واقعی 2، 8، 10، یا 16 باشد که "
"توسط پیشوند مشخص می شود. مبنای 0 همچنین اجازه استفاده از صفرهای پیش رو را "
"نمی دهد: ``int('010', 0)`` قانونی نیست، در حالی که ``int('010')`` و "
"``int('010', 8)`` قانونی هستند."

#: ../../library/functions.rst:1045
msgid "The integer type is described in :ref:`typesnumeric`."
msgstr "نوع عدد صحیح در :ref:`typesnumeric` توصیف شده است."

#: ../../library/functions.rst:1047
msgid ""
"If *base* is not an instance of :class:`int` and the *base* object has a :"
"meth:`base.__index__ <object.__index__>` method, that method is called to "
"obtain an integer for the base.  Previous versions used :meth:`base.__int__ "
"<object.__int__>` instead of :meth:`base.__index__ <object.__index__>`."
msgstr ""
"اگر *base* یک نمونه از :class:`int` نباشد و شیء *base* یک متد :meth:`base."
"__index__ <object.__index__>` داشته باشد، آن متد برای به دست آوردن یک عدد "
"صحیح برای پایه فراخوانی می شود. نسخه های قبلی از :meth:`base.__int__ <object."
"__int__>` به جای :meth:`base.__index__ <object.__index__>` استفاده می کردند."

#: ../../library/functions.rst:1057
msgid "The first parameter is now positional-only."
msgstr "اولین پارامتر اکنون فقط موقعیتی است."

#: ../../library/functions.rst:1060
msgid ""
"Falls back to :meth:`~object.__index__` if :meth:`~object.__int__` is not "
"defined."
msgstr ""
"اگر :meth:`~object.__int__` تعریف نشده باشد، به :meth:`~object.__index__` "
"بازمی گردد."

#: ../../library/functions.rst:1063
msgid ""
":class:`int` string inputs and string representations can be limited to help "
"avoid denial of service attacks. A :exc:`ValueError` is raised when the "
"limit is exceeded while converting a string to an :class:`int` or when "
"converting an :class:`int` into a string would exceed the limit. See the :"
"ref:`integer string conversion length limitation <int_max_str_digits>` "
"documentation."
msgstr ""
"ورودی ها و نمایش های رشته ای :class:`int` میتوانند برای جلوگیری از حملات DoS "
"محدود شوند. خطای :exc:`ValueError`  هنگامی که در حین تبدیل رشته به :class:"
"`int` یا :class:`int` به رشته از حد مجاز فراتر رود نمایش داده می شود. به "
"مستندات :ref:`integer string conversion length limitation "
"<int_max_str_digits>` مراجعه شود."

#: ../../library/functions.rst:1071
msgid ""
":func:`int` no longer delegates to the :meth:`~object.__trunc__` method."
msgstr ""

#: ../../library/functions.rst:1076
msgid ""
"Return ``True`` if the *object* argument is an instance of the *classinfo* "
"argument, or of a (direct, indirect, or :term:`virtual <abstract base "
"class>`) subclass thereof.  If *object* is not an object of the given type, "
"the function always returns ``False``. If *classinfo* is a tuple of type "
"objects (or recursively, other such tuples) or a :ref:`types-union` of "
"multiple types, return ``True`` if *object* is an instance of any of the "
"types. If *classinfo* is not a type or tuple of types and such tuples, a :"
"exc:`TypeError` exception is raised. :exc:`TypeError` may not be raised for "
"an invalid type if an earlier check succeeds."
msgstr ""
"``True`` را بازگردانید اگر آرگومان *object* یک نمونه از آرگومان *classinfo* "
"باشد، یا یک زیرکلاس (مستقیم، غیرمستقیم یا :term:`virtual <abstract base "
"class>`) آن. اگر *object* شیءای از نوع داده شده نباشد، تابع همیشه ``False`` "
"را برمی گرداند. اگر *classinfo* یک تاپل از اشیاء نوع (یا به صورت بازگشتی، "
"تاپل های دیگر) یا یک :ref:`types-union` از انواع متعدد باشد، ``True`` را "
"بازگردانید اگر *object* یک نمونه از هر یک از انواع باشد. اگر *classinfo* یک "
"نوع یا تاپل از انواع و این گونه تاپل ها نباشد، یک استثنای :exc:`TypeError` "
"ایجاد می شود. :exc:`TypeError` ممکن است برای یک نوع نامعتبر ایجاد نشود اگر "
"بررسی زودتری موفق باشد."

#: ../../library/functions.rst:1087 ../../library/functions.rst:1101
msgid "*classinfo* can be a :ref:`types-union`."
msgstr "*classinfo* می تواند یک :ref:`types-union` باشد."

#: ../../library/functions.rst:1093
msgid ""
"Return ``True`` if *class* is a subclass (direct, indirect, or :term:"
"`virtual <abstract base class>`) of *classinfo*.  A class is considered a "
"subclass of itself. *classinfo* may be a tuple of class objects (or "
"recursively, other such tuples) or a :ref:`types-union`, in which case "
"return ``True`` if *class* is a subclass of any entry in *classinfo*.  In "
"any other case, a :exc:`TypeError` exception is raised."
msgstr ""
"اگر *class* زیرکلاسی (مستقیم، غیرمستقیم، یا :term:`virtual <abstract base "
"class>`) از *classinfo* باشد، ``True`` را برمی گرداند. یک کلاس به عنوان "
"زیرکلاس خودش نیز در نظر گرفته می شود. *classinfo* ممکن است یک جفت از اشیاء "
"کلاس ها (یا به صورت بازگشتی، سایر همچنین جفت ها) یا یک :ref:`types-union` "
"باشد، که در این صورت ``True`` را برمی گرداند، اگر *class* زیرکلاس هر ورودی "
"در *classinfo* باشد. در هر حالت دیگری، یک استثناء :exc:`TypeError` ایجاد می "
"شود."

#: ../../library/functions.rst:1108
msgid ""
"Return an :term:`iterator` object.  The first argument is interpreted very "
"differently depending on the presence of the second argument. Without a "
"second argument, *object* must be a collection object which supports the :"
"term:`iterable` protocol (the :meth:`~object.__iter__` method), or it must "
"support the sequence protocol (the :meth:`~object.__getitem__` method with "
"integer arguments starting at ``0``).  If it does not support either of "
"those protocols, :exc:`TypeError` is raised. If the second argument, "
"*sentinel*, is given, then *object* must be a callable object.  The iterator "
"created in this case will call *object* with no arguments for each call to "
"its :meth:`~iterator.__next__` method; if the value returned is equal to "
"*sentinel*, :exc:`StopIteration` will be raised, otherwise the value will be "
"returned."
msgstr ""
"یک شیء :term:`iterator` بازگشت داده می شود. اولین آرگومان به طور کاملاً "
"متفاوتی بر اساس حضور دومین آرگومان تفسیر می شود. بدون حضور یک آرگومان دوم، "
"*object* باید یک شیء جمع آوری باشد که پروتکل :term:`iterable` (متد :meth:"
"`~object.__iter__`) را پشتیبانی کند، یا باید پروتکل دنباله (متد :meth:"
"`~object.__getitem__` با آرگومان های عدد صحیح که از ``0`` شروع می شود) را "
"پشتیبانی کند. اگر هیچ کدام از این پروتکل ها را پشتیبانی نکند، :exc:"
"`TypeError` ایجاد می شود. اگر آرگومان دوم، *sentinel*، داده شود، آنگاه "
"*object* باید یک شیء قابل فراخوانی باشد. در این حالت، تکرارگر ایجاد شده "
"*object* را بدون هیچ آرگومانی برای هر بار فراخوانی متد :meth:`~iterator."
"__next__` خود فرا می خواند؛ اگر مقداری که بازگردانده می شود برابر با "
"*sentinel* باشد، :exc:`StopIteration` ایجاد خواهد شد، در غیر این صورت مقدار "
"بازگردانده خواهد شد."

#: ../../library/functions.rst:1122
msgid "See also :ref:`typeiter`."
msgstr "همچنین به :ref:`typeiter` مراجعه کنید."

#: ../../library/functions.rst:1124
msgid ""
"One useful application of the second form of :func:`iter` is to build a "
"block-reader. For example, reading fixed-width blocks from a binary database "
"file until the end of file is reached::"
msgstr ""
"یکی از کاربردهای مفید فرم دوم :func:`iter` ساخت یک بلاک خوان است. به عنوان "
"مثال، خواندن بلوک های با عرض ثابت از یک فایل پایگاه داده باینری تا زمانی که "
"به انتهای فایل برسید:"

#: ../../library/functions.rst:1128
msgid ""
"from functools import partial\n"
"with open('mydata.db', 'rb') as f:\n"
"    for block in iter(partial(f.read, 64), b''):\n"
"        process_block(block)"
msgstr ""
"از functools مواردی مانند partial را وارد کنید\n"
"با باز کردن 'mydata.db' به صورت 'rb' به عنوان f:\n"
"    برای block در iter که با استفاده از partial و با مقدار 64 از f.read تا "
"زمانی که b'' خالی برگرداند برابری نکند:\n"
"        process_block را روی block فراخوانی کنید"

#: ../../library/functions.rst:1136
msgid ""
"Return the length (the number of items) of an object.  The argument may be a "
"sequence (such as a string, bytes, tuple, list, or range) or a collection "
"(such as a dictionary, set, or frozen set)."
msgstr ""
"اندازه (تعداد آیتم ها) یک شیء را برمی گرداند. آرگومان می تواند یک توالی "
"(مانند string، bytes، tuple، list، یا range) یا یک مجموعه (مانند dictionary، "
"set، یا frozen set) باشد."

#: ../../library/functions.rst:1142
msgid ""
"``len`` raises :exc:`OverflowError` on lengths larger than :data:`sys."
"maxsize`, such as :class:`range(2 ** 100) <range>`."
msgstr ""
"``len`` خطای :exc:`OverflowError` را برای طول هایی بزرگتر از :data:`sys."
"maxsize`، مانند :class:`range(2 ** 100) <range>`، ایجاد می کند."

#: ../../library/functions.rst:1151
msgid ""
"Rather than being a function, :class:`list` is actually a mutable sequence "
"type, as documented in :ref:`typesseq-list` and :ref:`typesseq`."
msgstr ""
"به جای اینکه یک تابع باشد، :class:`list` در واقع یک نوع توالی تغییرپذیر است، "
"همان طور که در :ref:`typesseq-list` و :ref:`typesseq` مستند شده است."

#: ../../library/functions.rst:1157
msgid ""
"Return a mapping object representing the current local symbol table, with "
"variable names as the keys, and their currently bound references as the "
"values."
msgstr ""
"یک شیء نقشه برداری که جدول نمادهای محلی فعلی را نشان می دهد بازگردانید. در "
"این شیء، نام متغیرها به عنوان کلید و مرجع های مرتبط فعلی آن ها به عنوان "
"مقدارها قرار داده شده اند."

#: ../../library/functions.rst:1161
msgid ""
"At module scope, as well as when using :func:`exec` or :func:`eval` with a "
"single namespace, this function returns the same namespace as :func:"
"`globals`."
msgstr ""
"در سطح ماژول، و همچنین هنگام استفاده از :func:`exec` یا :func:`eval` با یک "
"فضای نام واحد، این تابع همان فضای نام :func:`globals` را برمی گرداند."

#: ../../library/functions.rst:1165
msgid ""
"At class scope, it returns the namespace that will be passed to the "
"metaclass constructor."
msgstr ""
"در سطح کلاس، فضای نامی که به سازنده متاکلاس ارسال خواهد شد را برمی گرداند."

#: ../../library/functions.rst:1168
msgid ""
"When using ``exec()`` or ``eval()`` with separate local and global "
"arguments, it returns the local namespace passed in to the function call."
msgstr ""
"هنگام استفاده از ``exec()`` یا ``eval()`` با آرگومان های محلی و جهانی "
"جداگانه، نام فضای محلی که در فراخوانی تابع ارسال شده است را برمی گرداند."

#: ../../library/functions.rst:1171
msgid ""
"In all of the above cases, each call to ``locals()`` in a given frame of "
"execution will return the *same* mapping object. Changes made through the "
"mapping object returned from ``locals()`` will be visible as assigned, "
"reassigned, or deleted local variables, and assigning, reassigning, or "
"deleting local variables will immediately affect the contents of the "
"returned mapping object."
msgstr ""
"در تمام موارد فوق، هر فراخوانی به ``locals()`` در یک فریم اجرای معین، شیء "
"نگاشت *same* را برمی گرداند. تغییراتی که از طریق شیء نگاشت بازگشت داده شده "
"از ``locals()`` انجام می شوند، به صورت تعیین، مجدد تعیین، یا حذف متغیرهای "
"محلی قابل مشاهده خواهد بود و تعیین، مجدد تعیین یا حذف متغیرهای محلی به "
"محتوای شیء نگاشت بازگشت داده شده فوراً تأثیر می گذارد."

#: ../../library/functions.rst:1178
msgid ""
"In an :term:`optimized scope` (including functions, generators, and "
"coroutines), each call to ``locals()`` instead returns a fresh dictionary "
"containing the current bindings of the function's local variables and any "
"nonlocal cell references. In this case, name binding changes made via the "
"returned dict are *not* written back to the corresponding local variables or "
"nonlocal cell references, and assigning, reassigning, or deleting local "
"variables and nonlocal cell references does *not* affect the contents of "
"previously returned dictionaries."
msgstr ""
"در یک :term:`optimized scope` (شامل توابع، مولدها، و کوروتین ها)، هر "
"فراخوانی به ``locals()`` به جای آن یک دیکشنری جدید که شامل بایندینگ های فعلی "
"متغیرهای محلی تابع و هرگونه ارجاع غیرمحلی سلول است بازمی گرداند. در این "
"حالت، تغییرات بایندینگ نام که از طریق دیکشنری برگشتی انجام می شوند به "
"متغیرهای محلی یا ارجاعات غیرمحلی سلول مربوطه *not* بازنویسی نمی شوند، و "
"تخصیص، انتصاب مجدد، یا حذف متغیرهای محلی و ارجاع های غیرمحلی سلول، بر محتوای "
"دیکشنری های بازگردانده شده قبلی *not* تأثیری نمی گذارد."

#: ../../library/functions.rst:1187
msgid ""
"Calling ``locals()`` as part of a comprehension in a function, generator, or "
"coroutine is equivalent to calling it in the containing scope, except that "
"the comprehension's initialised iteration variables will be included. In "
"other scopes, it behaves as if the comprehension were running as a nested "
"function."
msgstr ""
"فراخوانی ``locals()`` به عنوان بخشی از یک comprehension در یک تابع، ژنراتور "
"یا coroutine معادل با فراخوانی آن در حوزه ی محتوی است، به جز اینکه متغیرهای "
"مقداردهی اولیه شده ی comprehension نیز شامل می شوند. در حوزه های دیگر، رفتار "
"آن به گونه ای است که انگار comprehension به عنوان یک تابع تو در تو اجرا می "
"شود."

#: ../../library/functions.rst:1193
msgid ""
"Calling ``locals()`` as part of a generator expression is equivalent to "
"calling it in a nested generator function."
msgstr ""
"فراخوانی ``locals()`` به عنوان بخشی از یک عبارات مولد برابر است با فراخوانی "
"آن در یک تابع مولد تو در تو."

#: ../../library/functions.rst:1196
msgid ""
"The behaviour of ``locals()`` in a comprehension has been updated as "
"described in :pep:`709`."
msgstr ""
"رفتار ``locals()`` در یک درک مطلب به روز شده است همانطور که در :pep:`709` "
"توضیح داده شده است."

#: ../../library/functions.rst:1200
msgid ""
"As part of :pep:`667`, the semantics of mutating the mapping objects "
"returned from this function are now defined. The behavior in :term:"
"`optimized scopes <optimized scope>` is now as described above. Aside from "
"being defined, the behaviour in other scopes remains unchanged from previous "
"versions."
msgstr ""
"به عنوان بخشی از :pep:`667`، معنای تغییر دادن آبجکت های نگاشت که از این تابع "
"بازگردانده می شوند، اکنون تعریف شده است. رفتار در :term:`optimized scopes "
"<optimized scope>` اکنون همان طور که در بالا توصیف شد می باشد. به غیر از "
"اینکه تعریف شده است، رفتار در سایر حوزه ها همچنان مانند نسخه های قبلی باقی "
"مانده است."

#: ../../library/functions.rst:1210
msgid ""
"Return an iterator that applies *function* to every item of *iterable*, "
"yielding the results.  If additional *iterables* arguments are passed, "
"*function* must take that many arguments and is applied to the items from "
"all iterables in parallel.  With multiple iterables, the iterator stops when "
"the shortest iterable is exhausted.  If *strict* is ``True`` and one of the "
"iterables is exhausted before the others, a :exc:`ValueError` is raised. For "
"cases where the function inputs are already arranged into argument tuples, "
"see :func:`itertools.starmap`."
msgstr ""

#: ../../library/functions.rst:1219
msgid "Added the *strict* parameter."
msgstr ""

#: ../../library/functions.rst:1227
msgid ""
"Return the largest item in an iterable or the largest of two or more "
"arguments."
msgstr ""
"بزرگ ترین عنصر در یک iterable یا بزرگ ترین در میان دو یا چند آرگومان را "
"بازمی گرداند."

#: ../../library/functions.rst:1230
msgid ""
"If one positional argument is provided, it should be an :term:`iterable`. "
"The largest item in the iterable is returned.  If two or more positional "
"arguments are provided, the largest of the positional arguments is returned."
msgstr ""
"اگر یک آرگومان مکانی ارائه شود، باید :term:`iterable` باشد. بزرگترین آیتم در "
"iterable بازگردانده می شود. اگر دو یا چند آرگومان مکانی ارائه شوند، بزرگترین "
"آرگومان مکانی بازگردانده می شود."

#: ../../library/functions.rst:1235 ../../library/functions.rst:1273
msgid ""
"There are two optional keyword-only arguments. The *key* argument specifies "
"a one-argument ordering function like that used for :meth:`list.sort`. The "
"*default* argument specifies an object to return if the provided iterable is "
"empty. If the iterable is empty and *default* is not provided, a :exc:"
"`ValueError` is raised."
msgstr ""
"دو آرگومان اختیاری فقط با کلیدواژه وجود دارد. آرگومان *key* یک تابع مرتب "
"سازی با یک آرگومان مشابه آنچه برای :meth:`list.sort` استفاده می شود را مشخص "
"می کند. آرگومان *default* یک شیء را برای بازگشت مشخص می کند اگر مجموعه ارائه "
"شده خالی باشد. اگر مجموعه خالی باشد و *default* فراهم نشده باشد، یک :exc:"
"`ValueError` ایجاد می شود."

#: ../../library/functions.rst:1241
msgid ""
"If multiple items are maximal, the function returns the first one "
"encountered.  This is consistent with other sort-stability preserving tools "
"such as ``sorted(iterable, key=keyfunc, reverse=True)[0]`` and ``heapq."
"nlargest(1, iterable, key=keyfunc)``."
msgstr ""
"اگر چندین مورد حداکثر باشند، تابع اولین موردی را که پیدا کند برمی گرداند. "
"این با دیگر ابزارهایی که پایداری مرتب سازی را حفظ می کنند، مانند "
"``sorted(iterable, key=keyfunc, reverse=True)[0]`` و ``heapq.nlargest(1, "
"iterable, key=keyfunc)`` سازگار است."

#: ../../library/functions.rst:1246 ../../library/functions.rst:1284
msgid "Added the *default* keyword-only parameter."
msgstr "افزوده شدن پارامتر فقط-کلیدواژه *default*."

#: ../../library/functions.rst:1249 ../../library/functions.rst:1287
msgid "The *key* can be ``None``."
msgstr "  *key* می تواند ``None`` باشد."

#: ../../library/functions.rst:1257
msgid ""
"Return a \"memory view\" object created from the given argument.  See :ref:"
"`typememoryview` for more information."
msgstr ""
"یک شیء \"نمای حافظه\" ایجاد شده از آرگومان داده شده را برگردانید. برای "
"اطلاعات بیشتر به :ref:`typememoryview` مراجعه کنید."

#: ../../library/functions.rst:1265
msgid ""
"Return the smallest item in an iterable or the smallest of two or more "
"arguments."
msgstr ""
"کوچکترین مورد را در یک iterable یا کوچکترینِ دو یا چند آرگومان بازمی گرداند."

#: ../../library/functions.rst:1268
msgid ""
"If one positional argument is provided, it should be an :term:`iterable`. "
"The smallest item in the iterable is returned.  If two or more positional "
"arguments are provided, the smallest of the positional arguments is returned."
msgstr ""
"اگر یک آرگومان موضعی فراهم شود، باید یک :term:`iterable` باشد. کوچک ترین "
"آیتم در iterable بازگردانده می شود. اگر دو یا چند آرگومان موضعی فراهم شوند، "
"کوچک ترین آرگومان موضعی بازگردانده می شود."

#: ../../library/functions.rst:1279
msgid ""
"If multiple items are minimal, the function returns the first one "
"encountered.  This is consistent with other sort-stability preserving tools "
"such as ``sorted(iterable, key=keyfunc)[0]`` and ``heapq.nsmallest(1, "
"iterable, key=keyfunc)``."
msgstr ""
"اگر چندین مورد کوچکترین باشند، تابع اولین موردی را که با آن برخورد می کند "
"برمی گرداند. این با ابزارهای دیگری که پایداری مرتب سازی را حفظ می کنند، "
"مانند ``sorted(iterable, key=keyfunc)[0]`` و ``heapq.nsmallest(1, iterable, "
"key=keyfunc)`` سازگار است."

#: ../../library/functions.rst:1294
msgid ""
"Retrieve the next item from the :term:`iterator` by calling its :meth:"
"`~iterator.__next__` method.  If *default* is given, it is returned if the "
"iterator is exhausted, otherwise :exc:`StopIteration` is raised."
msgstr ""
"بازیابی آیتم بعدی از :term:`iterator` با فراخوانی متد :meth:`~iterator."
"__next__` آن. اگر *default* داده شود، در صورت اینکه تکرارگر تمام شده باشد، "
"بازگردانده می شود، در غیر این صورت :exc:`StopIteration` برافراشته می شود."

#: ../../library/functions.rst:1301
msgid ""
"This is the ultimate base class of all other classes. It has methods that "
"are common to all instances of Python classes. When the constructor is "
"called, it returns a new featureless object. The constructor does not accept "
"any arguments."
msgstr ""
"این کلاس پایه نهایی تمام کلاس های دیگر است. روش هایی دارد که برای تمام نمونه "
"های کلاس های پایتون مشترک هستند. وقتی سازنده فراخوانی می شود، یک شیء جدید "
"بدون ویژگی برمی گرداند. سازنده هیچ آرگومانی را قبول نمی کند."

#: ../../library/functions.rst:1308
msgid ""
":class:`object` instances do *not* have :attr:`~object.__dict__` attributes, "
"so you can't assign arbitrary attributes to an instance of :class:`object`."
msgstr ""
"نمونه های :class:`object` دارای ویژگی های :attr:`~object.__dict__` *نیستند*، "
"بنابراین نمیتوانید ویژگی های دلخواه را به نمونه ای از :class:`object`اختصاص "
"دهید."

#: ../../library/functions.rst:1315
msgid ""
"Convert an integer number to an octal string prefixed with \"0o\".  The "
"result is a valid Python expression. If *x* is not a Python :class:`int` "
"object, it has to define an :meth:`~object.__index__` method that returns an "
"integer. For example:"
msgstr ""
"یک عدد صحیح را به یک رشته هشت هشتی با پیشوند \"0o\" تبدیل میکند.  نتیجه یک "
"عبارت معتبر پایتون است. اگر *x* یک شیء :class:`int` پایتون نباشد، لازم است "
"یک متد :meth:`~object.__index__` تعریف کند که یک عدد صحیح برمی گرداند. به "
"عنوان مثال:"

#: ../../library/functions.rst:1325
msgid ""
"If you want to convert an integer number to an octal string either with the "
"prefix \"0o\" or not, you can use either of the following ways."
msgstr ""
"اگر می خواهید یک عدد صحیح را به رشته هشت هشتی با پیش وند \"0o\" یا بدون آن "
"تبدیل کنید، می توانید از یکی از روش های زیر استفاده کنید."

#: ../../library/functions.rst:1342
msgid ""
"Open *file* and return a corresponding :term:`file object`.  If the file "
"cannot be opened, an :exc:`OSError` is raised. See :ref:`tut-files` for more "
"examples of how to use this function."
msgstr ""
"*file* را باز کرده و :term:`file object` مربوطه را برگردانید. اگر فایل قابل "
"باز شدن نباشد، یک :exc:`OSError` مطرح می شود. برای مثال های بیشتر از نحوه "
"استفاده از این تابع، به :ref:`tut-files` مراجعه کنید."

#: ../../library/functions.rst:1346
msgid ""
"*file* is a :term:`path-like object` giving the pathname (absolute or "
"relative to the current working directory) of the file to be opened or an "
"integer file descriptor of the file to be wrapped.  (If a file descriptor is "
"given, it is closed when the returned I/O object is closed unless *closefd* "
"is set to ``False``.)"
msgstr ""
"*file* یک :term:`path-like object` است که مسیر فایل (به صورت مطلق یا نسبی "
"نسبت به پوشه کاری فعلی) که باید باز شود را یا یک تشخیص گر فایل از نوع عدد "
"صحیح از فایل برای بسته بندی ارائه می دهد. (اگر یک تشخیص گر فایل ارائه شود، "
"وقتی شیء ورودی/خروجی بازگشتی بسته می شود، آن نیز بسته می شود مگر اینکه "
"*closefd* به ``False`` تنظیم شود.)"

#: ../../library/functions.rst:1352
msgid ""
"*mode* is an optional string that specifies the mode in which the file is "
"opened.  It defaults to ``'r'`` which means open for reading in text mode. "
"Other common values are ``'w'`` for writing (truncating the file if it "
"already exists), ``'x'`` for exclusive creation, and ``'a'`` for appending "
"(which on *some* Unix systems, means that *all* writes append to the end of "
"the file regardless of the current seek position).  In text mode, if "
"*encoding* is not specified the encoding used is platform-dependent: :func:"
"`locale.getencoding` is called to get the current locale encoding. (For "
"reading and writing raw bytes use binary mode and leave *encoding* "
"unspecified.)  The available modes are:"
msgstr ""
"*mode* یک رشته اختیاری است که حالت باز شدن فایل را مشخص می کند. به طور پیش "
"فرض، ``'r'`` است که به معنای باز کردن برای خواندن در حالت متنی است. مقادیر "
"رایج دیگر شامل ``'w'`` برای نوشتن (قطع فایل در صورت وجود قبلی)، ``'x'`` برای "
"ایجاد انحصاری، و ``'a'`` برای افزودن (که در سیستم های *some* یونیکس، به این "
"معناست که *all* نوشته ها را به انتهای فایل اضافه می کند، صرف نظر از موقعیت "
"فعلی جستجو). در حالت متنی، اگر *encoding* مشخص نشده باشد، انکودینگ استفاده "
"شده بستگی به پلتفرم دارد: :func:`locale.getencoding` فراخوانی می شود تا "
"انکودینگ محلی فعلی را به دست آورد. (برای خواندن و نوشتن بایت های خام از حالت "
"دودویی استفاده کنید و *encoding* را مشخص نکنید.) حالت های موجود عبارتند از:"

#: ../../library/functions.rst:1369
msgid "Character"
msgstr "کاراکتر"

#: ../../library/functions.rst:1369
msgid "Meaning"
msgstr "معنی"

#: ../../library/functions.rst:1371
msgid "``'r'``"
msgstr "``'r'``"

#: ../../library/functions.rst:1371
msgid "open for reading (default)"
msgstr "باز برای خواندن (پیش فرض)"

#: ../../library/functions.rst:1372
msgid "``'w'``"
msgstr "``'w'``"

#: ../../library/functions.rst:1372
msgid "open for writing, truncating the file first"
msgstr "برای نوشتن، ابتدا فایل را کوتاه کنید."

#: ../../library/functions.rst:1373
msgid "``'x'``"
msgstr "متن مشخص نشده است برای ترجمه. لطفاً متن اصلی را برای ترجمه وارد کنید."

#: ../../library/functions.rst:1373
msgid "open for exclusive creation, failing if the file already exists"
msgstr ""
"برای ایجاد انحصاری باز کنید، اگر فایل از قبل وجود داشته باشد، عملیات ناموفق "
"خواهد بود."

#: ../../library/functions.rst:1374
msgid "``'a'``"
msgstr "``'a'``"

#: ../../library/functions.rst:1374
msgid "open for writing, appending to the end of file if it exists"
msgstr "باز کردن برای نوشتن، افزودن به انتهای فایل در صورت وجود فایل"

#: ../../library/functions.rst:1375
msgid "``'b'``"
msgstr "``'b'``"

#: ../../library/functions.rst:1375 ../../library/functions.rst:1519
msgid "binary mode"
msgstr "حالت دودویی"

#: ../../library/functions.rst:1376
msgid "``'t'``"
msgstr "``'t'``"

#: ../../library/functions.rst:1376
msgid "text mode (default)"
msgstr "حالت متنی (پیش فرض)"

#: ../../library/functions.rst:1377
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/functions.rst:1377
msgid "open for updating (reading and writing)"
msgstr "باز برای به روزرسانی (خواندن و نوشتن)"

#: ../../library/functions.rst:1380
msgid ""
"The default mode is ``'r'`` (open for reading text, a synonym of ``'rt'``). "
"Modes ``'w+'`` and ``'w+b'`` open and truncate the file.  Modes ``'r+'`` and "
"``'r+b'`` open the file with no truncation."
msgstr ""
"حالت پیش فرض ``'r'`` است (باز کردن برای خواندن متن، مترادف ``'rt'``). حالت "
"های ``'w+'`` و ``'w+b'`` فایل را باز کرده و آن را کوتاه می کنند. حالت های "
"``'r+'`` و ``'r+b'`` فایل را بدون کوتاه کردن باز می کنند."

#: ../../library/functions.rst:1384
msgid ""
"As mentioned in the :ref:`io-overview`, Python distinguishes between binary "
"and text I/O.  Files opened in binary mode (including ``'b'`` in the *mode* "
"argument) return contents as :class:`bytes` objects without any decoding.  "
"In text mode (the default, or when ``'t'`` is included in the *mode* "
"argument), the contents of the file are returned as :class:`str`, the bytes "
"having been first decoded using a platform-dependent encoding or using the "
"specified *encoding* if given."
msgstr ""
"همانطور که در :ref:`io-overview` ذکر شد، پایتون بین ورودی/خروجی باینری و "
"متنی تفاوت قائل می شود. فایل های باز شده در حالت باینری (شامل ``'b'`` در "
"آرگومان *mode*) محتوا را به صورت اشیاء :class:`bytes` بدون هیچ گونه رمزگشایی "
"بازمی گردانند. در حالت متنی (پیش فرض یا زمانی که ``'t'`` در آرگومان *mode* "
"قرار می گیرد)، محتوای فایل به صورت :class:`str` بازگردانده می شود، در حالی "
"که بایت ها ابتدا با استفاده از یک کدگذاری وابسته به پلتفرم یا با استفاده از "
"*encoding* مشخص شده، اگر داده شود، رمزگشایی شده اند."

#: ../../library/functions.rst:1394
msgid ""
"Python doesn't depend on the underlying operating system's notion of text "
"files; all the processing is done by Python itself, and is therefore "
"platform-independent."
msgstr ""
"پایتون به مفهوم فایل های متنی سیستم عامل زیربنایی وابسته نیست؛ تمام پردازش "
"ها توسط خود پایتون انجام می شود و بنابراین مستقل از پلتفرم است."

#: ../../library/functions.rst:1398
msgid ""
"*buffering* is an optional integer used to set the buffering policy.  Pass 0 "
"to switch buffering off (only allowed in binary mode), 1 to select line "
"buffering (only usable when writing in text mode), and an integer > 1 to "
"indicate the size in bytes of a fixed-size chunk buffer. Note that "
"specifying a buffer size this way applies for binary buffered I/O, but "
"``TextIOWrapper`` (i.e., files opened with ``mode='r+'``) would have another "
"buffering. To disable buffering in ``TextIOWrapper``, consider using the "
"``write_through`` flag for :func:`io.TextIOWrapper.reconfigure`. When no "
"*buffering* argument is given, the default buffering policy works as follows:"
msgstr ""
"*buffering* یک عدد صحیح اختیاری است که برای تنظیم سیاست بافرینگ استفاده می "
"شود. قرار دادن 0 به منظور خاموش کردن بافرینگ (فقط در حالت باینری مجاز است)، "
"1 برای انتخاب بافرینگ خط (فقط زمانی که در حالت نوشتار متنی است قابل استفاده "
"است)، و هر عدد صحیح بزرگتر از 1 برای نشان دادن اندازه به بایت های یک بافر "
"تکه ای با اندازه ثابت. توجه داشته باشید که مشخص کردن اندازه بافر به این روش "
"برای I/O بافر شده باینری اعمال می شود، اما ``TextIOWrapper`` (یعنی فایل هایی "
"که با ``mode='r+'`` باز شده اند) بافرینگ دیگری خواهند داشت. برای غیرفعال "
"کردن بافرینگ در ``TextIOWrapper``، استفاده از پرچم ``write_through`` برای :"
"func:`io.TextIOWrapper.reconfigure` را در نظر بگیرید. وقتی هیچ آرگومان "
"*buffering* ارائه نشده، سیاست پیش فرض بافرینگ به صورت زیر کار می کند:"

#: ../../library/functions.rst:1408
msgid ""
"Binary files are buffered in fixed-size chunks; the size of the buffer is "
"``max(min(blocksize, 8 MiB), DEFAULT_BUFFER_SIZE)`` when the device block "
"size is available. On most systems, the buffer will typically be 128 "
"kilobytes long."
msgstr ""

#: ../../library/functions.rst:1413
msgid ""
"\"Interactive\" text files (files for which :meth:`~io.IOBase.isatty` "
"returns ``True``) use line buffering.  Other text files use the policy "
"described above for binary files."
msgstr ""
"فایل های متنی \"تعاملی\" (فایل هایی که :meth:`~io.IOBase.isatty` برمی گرداند "
"``True``) از بافر خطی استفاده می کنند. سایر فایل های متنی از سیاستی که در "
"بالا برای فایل های باینری توصیف شد، استفاده می کنند."

#: ../../library/functions.rst:1417
msgid ""
"*encoding* is the name of the encoding used to decode or encode the file. "
"This should only be used in text mode.  The default encoding is platform "
"dependent (whatever :func:`locale.getencoding` returns), but any :term:`text "
"encoding` supported by Python can be used. See the :mod:`codecs` module for "
"the list of supported encodings."
msgstr ""
"*encoding* نام کدگذاری است که برای رمزگشایی یا رمزگذاری فایل استفاده می شود. "
"این فقط باید در حالت متنی استفاده شود. کدگذاری پیش فرض به پلتفرم بستگی دارد "
"(هر چه :func:`locale.getencoding` برمی گرداند)، اما هر :term:`text encoding` "
"که توسط پایتون پشتیبانی می شود، می تواند استفاده شود. برای لیست کدگذاری های "
"پشتیبانی شده به ماژول :mod:`codecs` مراجعه کنید."

#: ../../library/functions.rst:1423
msgid ""
"*errors* is an optional string that specifies how encoding and decoding "
"errors are to be handled—this cannot be used in binary mode. A variety of "
"standard error handlers are available (listed under :ref:`error-handlers`), "
"though any error handling name that has been registered with :func:`codecs."
"register_error` is also valid.  The standard names include:"
msgstr ""
"*errors* یک رشته اختیاری است که مشخص می کند خطاهای رمزگذاری و رمزگشایی چگونه "
"باید مدیریت شوند—این نمی تواند در حالت باینری استفاده شود. یک مجموعه از "
"هندلرهای خطای استاندارد در دسترس هستند (فهرست شده تحت :ref:`error-"
"handlers`)، اگرچه هر نام مدیریت خطایی که با :func:`codecs.register_error` "
"ثبت شده نیز معتبر است. نام های استاندارد شامل:"

#: ../../library/functions.rst:1431
msgid ""
"``'strict'`` to raise a :exc:`ValueError` exception if there is an encoding "
"error.  The default value of ``None`` has the same effect."
msgstr ""
"``'strict'`` برای بالا بردن :exc:`ValueError` استثنا اگر یک خطای encoding "
"وجود داشته باشد. مقدار پیش فرض ``None`` همان اثر را دارد."

#: ../../library/functions.rst:1435
msgid ""
"``'ignore'`` ignores errors.  Note that ignoring encoding errors can lead to "
"data loss."
msgstr ""
"``'ignore'`` خطاها را نادیده می گیرد. توجه داشته باشید که نادیده گرفتن "
"خطاهای رمزگذاری می تواند به از دست رفتن داده ها منجر شود."

#: ../../library/functions.rst:1438
msgid ""
"``'replace'`` causes a replacement marker (such as ``'?'``) to be inserted "
"where there is malformed data."
msgstr ""
"``'replace'`` باعث می شود یک نشانگر جایگزین (مانند ``'?'``) در جایی که داده "
"های ناقص وجود دارد، درج شود."

#: ../../library/functions.rst:1441
msgid ""
"``'surrogateescape'`` will represent any incorrect bytes as low surrogate "
"code units ranging from U+DC80 to U+DCFF. These surrogate code units will "
"then be turned back into the same bytes when the ``surrogateescape`` error "
"handler is used when writing data.  This is useful for processing files in "
"an unknown encoding."
msgstr ""
"``'surrogateescape'`` نشان دهنده هر بایت نادرست به عنوان واحد کد جایگاه "
"پایینی از U+DC80 تا U+DCFF خواهد بود. این واحدهای کد جایگاه سپس به همان بایت "
"ها تبدیل خواهند شد زمانی که از خطایاب ``surrogateescape`` برای نوشتن داده ها "
"استفاده شود. این روش برای پردازش فایل ها در یک کدگذاری ناشناخته مفید است."

#: ../../library/functions.rst:1448
msgid ""
"``'xmlcharrefreplace'`` is only supported when writing to a file. Characters "
"not supported by the encoding are replaced with the appropriate XML "
"character reference :samp:`&#{nnn};`."
msgstr ""
"``'xmlcharrefreplace'`` تنها زمانی که به یک فایل نوشته می شود پشتیبانی می "
"شود. کاراکترهایی که توسط کدگذاری پشتیبانی نمی شوند با مرجع کاراکتر XML مناسب "
"جایگزین می شوند :samp:`&#{nnn};`."

#: ../../library/functions.rst:1452
msgid ""
"``'backslashreplace'`` replaces malformed data by Python's backslashed "
"escape sequences."
msgstr ""
"``'backslashreplace'`` داده های نا درست را با دنباله های فرار پشت پشت شدهٔ "
"پایتون جایگزین می کند."

#: ../../library/functions.rst:1455
msgid ""
"``'namereplace'`` (also only supported when writing) replaces unsupported "
"characters with ``\\N{...}`` escape sequences."
msgstr ""
"``'namereplace'`` (تنها زمانی که نوشتن را پشتیبانی می کند) کاراکترهای "
"پشتیبانی نشده را با توالی فرار ``\\N{...}`` جایگزین می کند."

#: ../../library/functions.rst:1463
msgid ""
"*newline* determines how to parse newline characters from the stream. It can "
"be ``None``, ``''``, ``'\\n'``, ``'\\r'``, and ``'\\r\\n'``.  It works as "
"follows:"
msgstr ""
"*newline* تعیین می کند که چگونه کاراکترهای خط جدید از جریان خوانده شوند. می "
"تواند ``None``، ``''``، ``'\\n'``، ``'\\r'`` و ``'\\r\\n'`` باشد. کارکرد آن "
"به صورت زیر است:"

#: ../../library/functions.rst:1467
msgid ""
"When reading input from the stream, if *newline* is ``None``, universal "
"newlines mode is enabled.  Lines in the input can end in ``'\\n'``, "
"``'\\r'``, or ``'\\r\\n'``, and these are translated into ``'\\n'`` before "
"being returned to the caller.  If it is ``''``, universal newlines mode is "
"enabled, but line endings are returned to the caller untranslated.  If it "
"has any of the other legal values, input lines are only terminated by the "
"given string, and the line ending is returned to the caller untranslated."
msgstr ""
"هنگام خواندن ورودی از جریان، اگر *newline* برابر با ``None`` باشد، حالت خطوط "
"جدید جهانی فعال می شود. خطوط در ورودی می توانند با ``'\\n'``، ``'\\r'`` یا "
"``'\\r\\n'`` پایان یابند و این ها قبل از بازگشت به فراخوان، به ``'\\n'`` "
"تبدیل می شوند. اگر ``''`` باشد، حالت خطوط جدید جهانی فعال است، اما انتهای "
"خطوط بدون ترجمه به فراخوان بازگردانده می شود. اگر دارای هر یک از مقادیر "
"قانونی دیگر باشد، خطوط ورودی تنها با رشته داده شده خاتمه می یابند و انتهای "
"خط بدون ترجمه به فراخوان بازگردانده می شود."

#: ../../library/functions.rst:1475
msgid ""
"When writing output to the stream, if *newline* is ``None``, any ``'\\n'`` "
"characters written are translated to the system default line separator, :"
"data:`os.linesep`.  If *newline* is ``''`` or ``'\\n'``, no translation "
"takes place.  If *newline* is any of the other legal values, any ``'\\n'`` "
"characters written are translated to the given string."
msgstr ""
"هنگام نوشتن خروجی به جریان، اگر *newline* برابر با ``None`` باشد، هر کاراکتر "
"``'\\n'`` نوشته شده به جداکننده خط پیش فرض سیستم، یعنی :data:`os.linesep`، "
"ترجمه می شود. اگر *newline* برابر با ``''`` یا ``'\\n'`` باشد، هیچ ترجمه ای "
"صورت نمی گیرد. اگر *newline* یکی از دیگر مقادیر قانونی باشد، هر کاراکتر "
"``'\\n'`` نوشته شده به رشته داده شده ترجمه می شود."

#: ../../library/functions.rst:1481
msgid ""
"If *closefd* is ``False`` and a file descriptor rather than a filename was "
"given, the underlying file descriptor will be kept open when the file is "
"closed.  If a filename is given *closefd* must be ``True`` (the default); "
"otherwise, an error will be raised."
msgstr ""
"اگر *closefd* برابر با ``False`` باشد و به جای یک نام فایل، یک شناسه فایل "
"داده شده باشد، زمانی که فایل بسته می شود، شناسه فایل اصلی باز خواهد ماند. "
"اگر یک نام فایل داده شود، *closefd* باید برابر با ``True`` باشد (به صورت پیش "
"فرض)؛ در غیر این صورت، خطا ایجاد خواهد شد."

#: ../../library/functions.rst:1486
msgid ""
"A custom opener can be used by passing a callable as *opener*. The "
"underlying file descriptor for the file object is then obtained by calling "
"*opener* with (*file*, *flags*). *opener* must return an open file "
"descriptor (passing :mod:`os.open` as *opener* results in functionality "
"similar to passing ``None``)."
msgstr ""
"یک گشاینده سفارشی را می توان با ارسال یک callable به عنوان *opener* استفاده "
"کرد. سپس توصیف کننده فایل پایه برای شیء فایل با فراخوانی *opener* با "
"(*file*, *flags*) به دست می آید. *opener* باید یک توصیف کننده فایل باز را "
"برگرداند (ارسال :mod:`os.open` به عنوان *opener* منجر به عملکردی مشابه با "
"ارسال ``None`` می شود)."

#: ../../library/functions.rst:1492
msgid "The newly created file is :ref:`non-inheritable <fd_inheritance>`."
msgstr "فایل تازه ایجاد شده :ref:`non-inheritable <fd_inheritance>` است."

#: ../../library/functions.rst:1494
msgid ""
"The following example uses the :ref:`dir_fd <dir_fd>` parameter of the :func:"
"`os.open` function to open a file relative to a given directory::"
msgstr ""
"مثال زیر از پارامتر :ref:`dir_fd <dir_fd>` تابع :func:`os.open` برای باز "
"کردن یک فایل نسبت به یک دایرکتوری داده شده استفاده می کند::"

#: ../../library/functions.rst:1497
msgid ""
">>> import os\n"
">>> dir_fd = os.open('somedir', os.O_RDONLY)\n"
">>> def opener(path, flags):\n"
"...     return os.open(path, flags, dir_fd=dir_fd)\n"
"...\n"
">>> with open('spamspam.txt', 'w', opener=opener) as f:\n"
"...     print('This will be written to somedir/spamspam.txt', file=f)\n"
"...\n"
">>> os.close(dir_fd)  # don't leak a file descriptor"
msgstr ""
">>> import os\n"
">>> dir_fd = os.open('somedir', os.O_RDONLY)\n"
">>> def opener(path, flags):\n"
"...     return os.open(path, flags, dir_fd=dir_fd)\n"
"...\n"
">>> with open('spamspam.txt', 'w', opener=opener) as f:\n"
"...     print('این به somedir/spamspam.txt نوشته خواهد شد', file=f)\n"
"...\n"
">>> os.close(dir_fd)  # نگذارید یک فایل دیسکریپتور نشت کند"

#: ../../library/functions.rst:1507
msgid ""
"The type of :term:`file object` returned by the :func:`open` function "
"depends on the mode.  When :func:`open` is used to open a file in a text "
"mode (``'w'``, ``'r'``, ``'wt'``, ``'rt'``, etc.), it returns a subclass of :"
"class:`io.TextIOBase` (specifically :class:`io.TextIOWrapper`).  When used "
"to open a file in a binary mode with buffering, the returned class is a "
"subclass of :class:`io.BufferedIOBase`.  The exact class varies: in read "
"binary mode, it returns an :class:`io.BufferedReader`; in write binary and "
"append binary modes, it returns an :class:`io.BufferedWriter`, and in read/"
"write mode, it returns an :class:`io.BufferedRandom`.  When buffering is "
"disabled, the raw stream, a subclass of :class:`io.RawIOBase`, :class:`io."
"FileIO`, is returned."
msgstr ""
"نوع :term:`file object` که توسط تابع :func:`open` برگردانده می شود به حالت "
"بستگی دارد. هنگامی که :func:`open` برای باز کردن یک فایل در حالت متنی "
"(``'w'``، ``'r'``، ``'wt'``، ``'rt'`` و غیره) استفاده می شود، یک زیربخش از :"
"class:`io.TextIOBase` (به طور خاص :class:`io.TextIOWrapper`) برمی گرداند. "
"هنگامی که برای باز کردن یک فایل در حالت دودویی با بافرینگ استفاده می شود، "
"کلاس برگردانده شده یک زیربخش از :class:`io.BufferedIOBase` است. کلاس دقیق "
"متغیر است: در حالت خواندن دودویی، یک :class:`io.BufferedReader` برمی گرداند؛ "
"در حالت نوشتن دودویی و ضمیمه کردن دودویی، یک :class:`io.BufferedWriter` برمی "
"گرداند و در حالت خواندن/نوشتن، یک :class:`io.BufferedRandom` برمی گرداند. "
"وقتی که بافرینگ غیرفعال است، جریان خام، که زیرمجموعه ای از :class:`io."
"RawIOBase`، :class:`io.FileIO` است، بازگردانده می شود."

#: ../../library/functions.rst:1528
msgid ""
"See also the file handling modules, such as :mod:`fileinput`, :mod:`io` "
"(where :func:`open` is declared), :mod:`os`, :mod:`os.path`, :mod:"
"`tempfile`, and :mod:`shutil`."
msgstr ""
"همچنین به ماژول های مدیریت فایل مراجعه کنید، مانند :mod:`fileinput`، :mod:"
"`io` (که در آن :func:`open` تعریف شده است)، :mod:`os`، :mod:`os.path`، :mod:"
"`tempfile` و :mod:`shutil`."

#: ../../library/functions.rst:1532
msgid ""
"Raises an :ref:`auditing event <auditing>` ``open`` with arguments ``path``, "
"``mode``, ``flags``."
msgstr ""
"یک :ref:`auditing event <auditing>` ``open`` با آرگومان های ``path``، "
"``mode``، ``flags`` ایجاد می کند."

#: ../../library/functions.rst:1534
msgid ""
"The ``mode`` and ``flags`` arguments may have been modified or inferred from "
"the original call."
msgstr ""
"ممکن است آرگومان های ``mode`` و ``flags`` از فراخوانی اصلی تغییر کرده یا "
"استنباط شده باشند."

#: ../../library/functions.rst:1539
msgid "The *opener* parameter was added."
msgstr "پارامتر *opener* اضافه شد."

#: ../../library/functions.rst:1540
msgid "The ``'x'`` mode was added."
msgstr "حالت ``'x'`` اضافه شد."

#: ../../library/functions.rst:1541
msgid ":exc:`IOError` used to be raised, it is now an alias of :exc:`OSError`."
msgstr ":exc:`IOError` قبلاً مطرح می شد، اکنون معادل :exc:`OSError` است."

#: ../../library/functions.rst:1542
msgid ""
":exc:`FileExistsError` is now raised if the file opened in exclusive "
"creation mode (``'x'``) already exists."
msgstr ""
"اگر فایلی که در حالت ایجاد انحصاری باز شده است (``'x'``) قبلاً وجود داشته "
"باشد، اکنون :exc:`FileExistsError` برانگیخته می شود."

#: ../../library/functions.rst:1547
msgid "The file is now non-inheritable."
msgstr "فایل اکنون غیرقابل ارث بری است."

#: ../../library/functions.rst:1551
msgid ""
"If the system call is interrupted and the signal handler does not raise an "
"exception, the function now retries the system call instead of raising an :"
"exc:`InterruptedError` exception (see :pep:`475` for the rationale)."
msgstr ""
"اگر فراخوانی سیستم قطع شود و مدیریت کننده سیگنال استثنایی ایجاد نکند، تابع "
"اکنون به جای ایجاد یک استثنای :exc:`InterruptedError` فراخوانی سیستم را "
"مجدداً امتحان می کند (برای دلایل مربوطه، به :pep:`475` مراجعه کنید)."

#: ../../library/functions.rst:1554
msgid "The ``'namereplace'`` error handler was added."
msgstr "مدبر خطای ``'namereplace'`` اضافه شد."

#: ../../library/functions.rst:1558
msgid "Support added to accept objects implementing :class:`os.PathLike`."
msgstr ""
"پشتیبانی برای پذیرش اشیایی که :class:`os.PathLike` را پیاده سازی می کنند "
"اضافه شد."

#: ../../library/functions.rst:1559
msgid ""
"On Windows, opening a console buffer may return a subclass of :class:`io."
"RawIOBase` other than :class:`io.FileIO`."
msgstr ""
"در ویندوز، باز کردن یک بافر کنسول ممکن است زیرکلاسی از :class:`io.RawIOBase` "
"را به جای :class:`io.FileIO` برگرداند."

#: ../../library/functions.rst:1562
msgid "The ``'U'`` mode has been removed."
msgstr "حالت ``'U'`` حذف شده است."

#: ../../library/functions.rst:1567
msgid ""
"Given a string representing one Unicode character, return an integer "
"representing the Unicode code point of that character.  For example, "
"``ord('a')`` returns the integer ``97`` and ``ord('€')`` (Euro sign) returns "
"``8364``.  This is the inverse of :func:`chr`."
msgstr ""
"با دریافت یک رشته که نشان دهنده ی یک نویسه ی یونیکد است، یک عدد صحیح که نشان "
"دهنده ی نقطه ی کد یونیکد آن نویسه است را برمی گرداند. به عنوان مثال، "
"``ord('a')`` عدد صحیح ``97`` را برمی گرداند و ``ord('€')`` (نماد یورو) عدد "
"``8364`` را برمی گرداند. این عملکرد عکس :func:`chr` است."

#: ../../library/functions.rst:1575
msgid ""
"Return *base* to the power *exp*; if *mod* is present, return *base* to the "
"power *exp*, modulo *mod* (computed more efficiently than ``pow(base, exp) % "
"mod``). The two-argument form ``pow(base, exp)`` is equivalent to using the "
"power operator: ``base**exp``."
msgstr ""
"بازگرداندن *base* به توان *exp*؛ اگر *mod* موجود است، بازگرداندن *base* به "
"توان *exp*، مدول *mod* (که به طور موثرتری نسبت به ``pow(base, exp) % mod`` "
"محاسبه می شود). فرم دو آرگومانی ``pow(base, exp)`` معادل استفاده از عملگر "
"توان است: ``base**exp``."

#: ../../library/functions.rst:1580
msgid ""
"The arguments must have numeric types.  With mixed operand types, the "
"coercion rules for binary arithmetic operators apply.  For :class:`int` "
"operands, the result has the same type as the operands (after coercion) "
"unless the second argument is negative; in that case, all arguments are "
"converted to float and a float result is delivered.  For example, ``pow(10, "
"2)`` returns ``100``, but ``pow(10, -2)`` returns ``0.01``.  For a negative "
"base of type :class:`int` or :class:`float` and a non-integral exponent, a "
"complex result is delivered.  For example, ``pow(-9, 0.5)`` returns a value "
"close to ``3j``. Whereas, for a negative base of type :class:`int` or :class:"
"`float` with an integral exponent, a float result is delivered. For example, "
"``pow(-9, 2.0)`` returns ``81.0``."
msgstr ""
"آرگومان ها باید دارای نوع عددی باشند. با انواع عملوند مخلوط، قوانین تبدیل "
"برای عملگرهای حسابی دودویی اعمال می شود. برای عملوندهای :class:`int`، نتیجه "
"دارای همان نوع عملوندها است (پس از تبدیل) مگر اینکه آرگومان دوم منفی باشد؛ "
"در این صورت، تمام آرگومان ها به float تبدیل می شوند و نتیجه ای از نوع float "
"ارائه می شود. به عنوان مثال، ``pow(10, 2)`` نتیجه ``100`` را برمی گرداند، "
"اما ``pow(10, -2)`` نتیجه ``0.01`` را برمی گرداند. برای پایه منفی از نوع :"
"class:`int` یا :class:`float` و توان غیر صحیح، نتیجه ای از نوع عدد مختلط "
"ارائه می شود. به عنوان مثال، ``pow(-9, 0.5)`` مقداری نزدیک به ``3j`` برمی "
"گرداند. در حالی که، برای یک پایه منفی از نوع :class:`int` یا :class:`float` "
"با توان صحیح، نتیجه ای از نوع float ارائه می شود. برای مثال، ``pow(-9, "
"2.0)`` نتیجه ``81.0`` را برمی گرداند."

#: ../../library/functions.rst:1592
msgid ""
"For :class:`int` operands *base* and *exp*, if *mod* is present, *mod* must "
"also be of integer type and *mod* must be nonzero. If *mod* is present and "
"*exp* is negative, *base* must be relatively prime to *mod*. In that case, "
"``pow(inv_base, -exp, mod)`` is returned, where *inv_base* is an inverse to "
"*base* modulo *mod*."
msgstr ""
"برای عملوندهای :class:`int` یعنی *base* و *exp*، اگر *mod* وجود داشته باشد، "
"*mod* نیز باید از نوع عدد صحیح باشد و *mod* نباید صفر باشد. اگر *mod* وجود "
"داشته باشد و *exp* منفی باشد، *base* باید نسبت به *mod* نسبتاً اول باشد. در "
"این صورت، ``pow(inv_base, -exp, mod)`` بازگردانده می شود، جایی که *inv_base* "
"معکوس *base* به پیمانه *mod* است."

#: ../../library/functions.rst:1598
msgid "Here's an example of computing an inverse for ``38`` modulo ``97``::"
msgstr ""
"در اینجا یک مثال از محاسبه معکوس برای ``38`` مدولوی ``97`` ارائه شده است::"

#: ../../library/functions.rst:1600
msgid ""
">>> pow(38, -1, mod=97)\n"
"23\n"
">>> 23 * 38 % 97 == 1\n"
"True"
msgstr ""
">>> pow(38, -1, mod=97)\n"
"23\n"
">>> 23 * 38 % 97 == 1\n"
"True"

#: ../../library/functions.rst:1605
msgid ""
"For :class:`int` operands, the three-argument form of ``pow`` now allows the "
"second argument to be negative, permitting computation of modular inverses."
msgstr ""
"برای عملگرهای :class:`int`، اکنون فرم سه آرگومانی ``pow`` اجازه می دهد که "
"آرگومان دوم منفی باشد، که این به محاسبه معکوس های مدولار کمک می کند."

#: ../../library/functions.rst:1610
msgid ""
"Allow keyword arguments.  Formerly, only positional arguments were supported."
msgstr ""
"اجازه دادن به آرگومان های کلیدواژه ای. قبلاً فقط آرگومان های موقعیتی پشتیبانی "
"می شدند."

#: ../../library/functions.rst:1617
msgid ""
"Print *objects* to the text stream *file*, separated by *sep* and followed "
"by *end*.  *sep*, *end*, *file*, and *flush*, if present, must be given as "
"keyword arguments."
msgstr ""
"*objects* را به جریان متنی *file* چاپ می کند، که توسط *sep* جدا شده و با "
"*end* دنبال می شود. *sep*, *end*, *file*, و *flush*، اگر موجود باشند، باید "
"به عنوان آرگومان های کلیدی ارائه شوند."

#: ../../library/functions.rst:1621
msgid ""
"All non-keyword arguments are converted to strings like :func:`str` does and "
"written to the stream, separated by *sep* and followed by *end*.  Both *sep* "
"and *end* must be strings; they can also be ``None``, which means to use the "
"default values.  If no *objects* are given, :func:`print` will just write "
"*end*."
msgstr ""
"همه آرگومان های غیرکلیدی به رشته ها تبدیل می شوند مانند :func:`str` و به "
"جریان نوشته می شوند، با *sep* از هم جدا شده و به دنبال *end* می آیند. هر دو "
"*sep* و *end* باید رشته باشند؛ آنها می توانند همچنین ``None`` باشند، به این "
"معنی که از مقادیر پیش فرض استفاده می شود. اگر هیچ *objects* داده نشده "
"باشند، :func:`print` فقط *end* را خواهد نوشت."

#: ../../library/functions.rst:1627
msgid ""
"The *file* argument must be an object with a ``write(string)`` method; if it "
"is not present or ``None``, :data:`sys.stdout` will be used.  Since printed "
"arguments are converted to text strings, :func:`print` cannot be used with "
"binary mode file objects.  For these, use ``file.write(...)`` instead."
msgstr ""
"آرگومان *file* باید یک شیء با یک متد ``write(string)`` باشد؛ اگر حضور نداشته "
"باشد یا ``None`` باشد، از :data:`sys.stdout` استفاده خواهد شد. از آنجایی که "
"آرگومان های پرینت شده به رشته های متنی تبدیل می شوند، :func:`print` نمی "
"تواند با اشیای فایل در حالت باینری استفاده شود. برای این موارد، به جای آن از "
"``file.write(...)`` استفاده کنید."

#: ../../library/functions.rst:1632
msgid ""
"Output buffering is usually determined by *file*. However, if *flush* is "
"true, the stream is forcibly flushed."
msgstr ""
"بافر خروجی معمولاً توسط *file* تعیین می شود. با این حال، اگر *flush* صحیح "
"باشد، جریان به طور اجباری تخلیه می شود."

#: ../../library/functions.rst:1636
msgid "Added the *flush* keyword argument."
msgstr "آرگومان کلیدواژه *flush* اضافه شد."

#: ../../library/functions.rst:1642
msgid "Return a property attribute."
msgstr "یک ویژگی property را بازمی گرداند."

#: ../../library/functions.rst:1644
msgid ""
"*fget* is a function for getting an attribute value.  *fset* is a function "
"for setting an attribute value. *fdel* is a function for deleting an "
"attribute value.  And *doc* creates a docstring for the attribute."
msgstr ""
"*fget* یک تابع برای دریافت مقدار یک ویژگی است. *fset* یک تابع برای تنظیم "
"مقدار یک ویژگی است. *fdel* یک تابع برای حذف مقدار یک ویژگی است. و *doc* یک "
"docstring برای ویژگی ایجاد می کند."

#: ../../library/functions.rst:1648
msgid "A typical use is to define a managed attribute ``x``::"
msgstr "یک استفاده معمول این است که یک ویژگی مدیریت شده ``x`` تعریف کنید::"

#: ../../library/functions.rst:1650
msgid ""
"class C:\n"
"    def __init__(self):\n"
"        self._x = None\n"
"\n"
"    def getx(self):\n"
"        return self._x\n"
"\n"
"    def setx(self, value):\n"
"        self._x = value\n"
"\n"
"    def delx(self):\n"
"        del self._x\n"
"\n"
"    x = property(getx, setx, delx, \"I'm the 'x' property.\")"
msgstr ""
"کلاس C:\n"
"    def __init__(self):\n"
"        self._x = None\n"
"\n"
"    def getx(self):\n"
"        return self._x\n"
"\n"
"    def setx(self, value):\n"
"        self._x = value\n"
"\n"
"    def delx(self):\n"
"        del self._x\n"
"\n"
"    x = property(getx, setx, delx, \"من ویژگی 'x' هستم.\")"

#: ../../library/functions.rst:1665
msgid ""
"If *c* is an instance of *C*, ``c.x`` will invoke the getter, ``c.x = "
"value`` will invoke the setter, and ``del c.x`` the deleter."
msgstr ""
"اگر *c* نمونه ای از *C* باشد، ``c.x`` فراخوانی کنندهٔ getter، ``c.x = value`` "
"فراخوانی کنندهٔ setter و ``del c.x`` فراخوانی کنندهٔ deleter خواهد بود."

#: ../../library/functions.rst:1668
msgid ""
"If given, *doc* will be the docstring of the property attribute. Otherwise, "
"the property will copy *fget*'s docstring (if it exists).  This makes it "
"possible to create read-only properties easily using :func:`property` as a :"
"term:`decorator`::"
msgstr ""
"اگر ارائه شده باشد، *doc* به عنوان docstring ویژگی property خواهد بود. در "
"غیر این صورت، property docstring *fget* را (اگر وجود داشته باشد) کپی خواهد "
"کرد. این امکان را فراهم می کند تا به سادگی از :func:`property` به عنوان یک :"
"term:`decorator` استفاده کنید و ویژگی های فقط خواندنی ایجاد نمایید::"

#: ../../library/functions.rst:1672
msgid ""
"class Parrot:\n"
"    def __init__(self):\n"
"        self._voltage = 100000\n"
"\n"
"    @property\n"
"    def voltage(self):\n"
"        \"\"\"Get the current voltage.\"\"\"\n"
"        return self._voltage"
msgstr ""
"کلاس Parrot:\n"
"    def __init__(self):\n"
"        self._voltage = 100000\n"
"\n"
"    @property\n"
"    def voltage(self):\n"
"        \"\"\"ولتاژ فعلی را دریافت کنید.\"\"\"\n"
"        return self._voltage"

#: ../../library/functions.rst:1681
msgid ""
"The ``@property`` decorator turns the :meth:`!voltage` method into a "
"\"getter\" for a read-only attribute with the same name, and it sets the "
"docstring for *voltage* to \"Get the current voltage.\""
msgstr ""
"دکوراتور ``@property`` متد :meth:`!voltage` را به یک \"getter\" برای یک "
"ویژگی فقط خواندنی با همان نام تبدیل می کند و رشته داکیومنت برای *voltage* را "
"به \"Get the current voltage.\" تنظیم می کند."

#: ../../library/functions.rst:1689
msgid ""
"A property object has ``getter``, ``setter``, and ``deleter`` methods usable "
"as decorators that create a copy of the property with the corresponding "
"accessor function set to the decorated function.  This is best explained "
"with an example:"
msgstr ""
"یک شیء property دارای متدهای ``getter``، ``setter``، و ``deleter`` است که به "
"عنوان تزئین کننده ها استفاده می شوند و یک کپی از property را با تابع دسترسی "
"مربوطه که به تابع تزئین شده تنظیم شده است، ایجاد می کنند. این موضوع با یک "
"مثال بهتر توضیح داده می شود:"

#: ../../library/functions.rst:1694
msgid ""
"class C:\n"
"    def __init__(self):\n"
"        self._x = None\n"
"\n"
"    @property\n"
"    def x(self):\n"
"        \"\"\"I'm the 'x' property.\"\"\"\n"
"        return self._x\n"
"\n"
"    @x.setter\n"
"    def x(self, value):\n"
"        self._x = value\n"
"\n"
"    @x.deleter\n"
"    def x(self):\n"
"        del self._x"
msgstr ""
"class C:\n"
"    def __init__(self):\n"
"        self._x = None\n"
"\n"
"    @property\n"
"    def x(self):\n"
"        \"\"\"من ویژگی 'x' هستم.\"\"\"\n"
"        return self._x\n"
"\n"
"    @x.setter\n"
"    def x(self, value):\n"
"        self._x = value\n"
"\n"
"    @x.deleter\n"
"    def x(self):\n"
"        del self._x"

#: ../../library/functions.rst:1713
msgid ""
"This code is exactly equivalent to the first example.  Be sure to give the "
"additional functions the same name as the original property (``x`` in this "
"case.)"
msgstr ""
"این کد دقیقا معادل با مثال اول است. مطمئن شوید که توابع اضافی همان نام ویژگی "
"اصلی (در اینجا ``x``) را داشته باشند."

#: ../../library/functions.rst:1717
msgid ""
"The returned property object also has the attributes ``fget``, ``fset``, and "
"``fdel`` corresponding to the constructor arguments."
msgstr ""
"شیء ویژگی برگردانده شده همچنین دارای خصوصیات ``fget``، ``fset`` و ``fdel`` "
"است که معادل با آرگومان های سازنده هستند."

#: ../../library/functions.rst:1720
msgid "The docstrings of property objects are now writeable."
msgstr "رشته های مستندات اشیاء ویژگی اکنون قابل نوشتن هستند."

#: ../../library/functions.rst:1725
msgid ""
"Attribute holding the name of the property. The name of the property can be "
"changed at runtime."
msgstr ""
"ویژگی که نام ویژگی را نگه می دارد. نام ویژگی می تواند در زمان اجرای برنامه "
"تغییر کند."

#: ../../library/functions.rst:1736
msgid ""
"Rather than being a function, :class:`range` is actually an immutable "
"sequence type, as documented in :ref:`typesseq-range` and :ref:`typesseq`."
msgstr ""
"به جای اینکه :class:`range` یک تابع باشد، در واقع یک نوع دنباله ثابت است، "
"همان طور که در :ref:`typesseq-range` و :ref:`typesseq` مستند شده است."

#: ../../library/functions.rst:1742
msgid ""
"Return a string containing a printable representation of an object.  For "
"many types, this function makes an attempt to return a string that would "
"yield an object with the same value when passed to :func:`eval`; otherwise, "
"the representation is a string enclosed in angle brackets that contains the "
"name of the type of the object together with additional information often "
"including the name and address of the object.  A class can control what this "
"function returns for its instances by defining a :meth:`~object.__repr__` "
"method. If :func:`sys.displayhook` is not accessible, this function will "
"raise :exc:`RuntimeError`."
msgstr ""
"یک رشته که نمایش قابل چاپ از یک شئ را در بر دارد، بر می گرداند. برای بسیاری "
"از انواع، این تابع سعی می کند رشته ای را برگرداند که به عنوان ورودی :func:"
"`eval` یک شئ با همان مقدار را تولید کند؛ در غیر این صورت، نمایش به صورت یک "
"رشته داخل پرانتزهای زاویه دار است که نام نوع شئ به همراه اطلاعات اضافی که "
"معمولاً شامل نام و آدرس شئ است، می باشد. یک کلاس می تواند مشخص کند که این "
"تابع برای نمونه های خود چه چیزی بر می گرداند، با تعریف متد :meth:`~object."
"__repr__`. اگر :func:`sys.displayhook` قابل دسترسی نباشد، این تابع :exc:"
"`RuntimeError` را ایجاد می کند."

#: ../../library/functions.rst:1753
msgid "This class has a custom representation that can be evaluated::"
msgstr "این کلاس یک نمایش سفارشی دارد که می تواند ارزیابی شود::"

#: ../../library/functions.rst:1755
msgid ""
"class Person:\n"
"   def __init__(self, name, age):\n"
"      self.name = name\n"
"      self.age = age\n"
"\n"
"   def __repr__(self):\n"
"      return f\"Person('{self.name}', {self.age})\""
msgstr ""
"کلاس Person:\n"
"   def __init__(self, name, age):\n"
"      self.name = name\n"
"      self.age = age\n"
"\n"
"   def __repr__(self):\n"
"      return f\"Person('{self.name}', {self.age})\""

#: ../../library/functions.rst:1766
msgid ""
"Return a reverse :term:`iterator`.  *seq* must be an object which has a :"
"meth:`~object.__reversed__` method or supports the sequence protocol (the :"
"meth:`~object.__len__` method and the :meth:`~object.__getitem__` method "
"with integer arguments starting at ``0``)."
msgstr ""
"برمی گرداند یک :term:`iterator` معکوس. *seq* باید یک شی باشد که دارای یک "
"متد :meth:`~object.__reversed__` باشد یا از پروتکل توالی پشتیبانی کند (متد :"
"meth:`~object.__len__` و متد :meth:`~object.__getitem__` با آرگومان های عدد "
"صحیح که از ``0`` شروع می شوند)."

#: ../../library/functions.rst:1774
msgid ""
"Return *number* rounded to *ndigits* precision after the decimal point.  If "
"*ndigits* is omitted or is ``None``, it returns the nearest integer to its "
"input."
msgstr ""
"*number* را به دقت *ndigits* پس از نقطهٔ اعشار گرد می کند. اگر *ndigits* حذف "
"شود یا ``None`` باشد، نزدیک ترین عدد صحیح به ورودی بازگردانده می شود."

#: ../../library/functions.rst:1778
msgid ""
"For the built-in types supporting :func:`round`, values are rounded to the "
"closest multiple of 10 to the power minus *ndigits*; if two multiples are "
"equally close, rounding is done toward the even choice (so, for example, "
"both ``round(0.5)`` and ``round(-0.5)`` are ``0``, and ``round(1.5)`` is "
"``2``).  Any integer value is valid for *ndigits* (positive, zero, or "
"negative).  The return value is an integer if *ndigits* is omitted or "
"``None``. Otherwise, the return value has the same type as *number*."
msgstr ""
"برای انواع داخلی که از :func:`round` پشتیبانی می کنند، مقادیر به نزدیک ترین "
"مضرب 10 به توان منفی *ndigits* گرد می شوند؛ اگر دو مضرب به طور مساوی نزدیک "
"باشند، گرد کردن به سمت گزینه زوج انجام می شود (برای مثال، هر دو "
"``round(0.5)`` و ``round(-0.5)`` برابر با ``0`` هستند، و ``round(1.5)`` "
"برابر با ``2`` است). هر مقدار صحیح برای *ndigits* معتبر است (مثبت، صفر، یا "
"منفی). مقدار بازگشتی یک عدد صحیح است اگر *ndigits* حذف شود یا ``None`` باشد. "
"در غیر این صورت، مقدار بازگشتی از همان نوع *number* خواهد بود."

#: ../../library/functions.rst:1787
msgid ""
"For a general Python object ``number``, ``round`` delegates to ``number."
"__round__``."
msgstr ""
"برای یک شیء عمومی پایتون ``number``، ``round`` به ``number.__round__`` "
"واگذار می شود."

#: ../../library/functions.rst:1792
msgid ""
"The behavior of :func:`round` for floats can be surprising: for example, "
"``round(2.675, 2)`` gives ``2.67`` instead of the expected ``2.68``. This is "
"not a bug: it's a result of the fact that most decimal fractions can't be "
"represented exactly as a float.  See :ref:`tut-fp-issues` for more "
"information."
msgstr ""
"رفتار :func:`round` برای اعشار ممکن است تعجب آور باشد: به عنوان مثال، "
"``round(2.675, 2)`` به جای ``2.68`` مقدار ``2.67`` را می دهد. این یک اشکال "
"نیست: این به دلیل این واقعیت است که بیشتر کسرهای دهدهی نمی توانند به طور "
"دقیق به عنوان یک عدد اعشاری نشان داده شوند. برای اطلاعات بیشتر به :ref:`tut-"
"fp-issues` مراجعه کنید."

#: ../../library/functions.rst:1804
msgid ""
"Return a new :class:`set` object, optionally with elements taken from "
"*iterable*.  ``set`` is a built-in class.  See :class:`set` and :ref:`types-"
"set` for documentation about this class."
msgstr ""
"یک شیء جدید :class:`set` بازمی گرداند، در صورت نیاز با عناصری که از "
"*iterable* گرفته شده اند. ``set`` یک کلاس داخلی است. برای مستندسازی درباره "
"این کلاس به :class:`set` و :ref:`types-set` مراجعه کنید."

#: ../../library/functions.rst:1808
msgid ""
"For other containers see the built-in :class:`frozenset`, :class:`list`, :"
"class:`tuple`, and :class:`dict` classes, as well as the :mod:`collections` "
"module."
msgstr ""
"برای سایر کانتینرها، به کلاس های داخلی :class:`frozenset`، :class:`list`، :"
"class:`tuple`، و :class:`dict` مراجعه کنید، همچنین به ماژول :mod:"
"`collections` مراجعه نمایید."

#: ../../library/functions.rst:1815
msgid ""
"This is the counterpart of :func:`getattr`.  The arguments are an object, a "
"string, and an arbitrary value.  The string may name an existing attribute "
"or a new attribute.  The function assigns the value to the attribute, "
"provided the object allows it.  For example, ``setattr(x, 'foobar', 123)`` "
"is equivalent to ``x.foobar = 123``."
msgstr ""
"این قسمت معادل :func:`getattr` است. آرگومان ها شامل یک شیء، یک رشته و یک "
"مقدار دلخواه هستند. رشته می تواند نام یک ویژگی موجود یا یک ویژگی جدید باشد. "
"این تابع مقدار را به ویژگی تخصیص می دهد، به شرطی که شیء اجازه این کار را "
"بدهد. برای مثال، ``setattr(x, 'foobar', 123)`` معادل با ``x.foobar = 123`` "
"است."

#: ../../library/functions.rst:1821
msgid ""
"*name* need not be a Python identifier as defined in :ref:`identifiers` "
"unless the object chooses to enforce that, for example in a custom :meth:"
"`~object.__getattribute__` or via :attr:`~object.__slots__`. An attribute "
"whose name is not an identifier will not be accessible using the dot "
"notation, but is accessible through :func:`getattr` etc.."
msgstr ""
"*name* نیازی نیست که یک شناسه پایتون باشد همانطور که در :ref:`identifiers` "
"تعریف شده است، مگر اینکه شیء تصمیم بگیرد آن را اعمال کند، به عنوان مثال در "
"یک :meth:`~object.__getattribute__` سفارشی یا از طریق :attr:`~object."
"__slots__`. ویژگی ای که نامش شناسه نیست از طریق نشانه گذاری نقطه قابل دسترسی "
"نخواهد بود، اما از طریق :func:`getattr` و غیره قابل دسترسی است."

#: ../../library/functions.rst:1829
msgid ""
"Since :ref:`private name mangling <private-name-mangling>` happens at "
"compilation time, one must manually mangle a private attribute's (attributes "
"with two leading underscores) name in order to set it with :func:`setattr`."
msgstr ""
"از آنجا که :ref:`private name mangling <private-name-mangling>` در زمان "
"کامپایل رخ می دهد، لازم است که نام یک ویژگی خصوصی (ویژگی هایی با دو خط تیره "
"در ابتدا) را به صورت دستی تغییر دهید تا بتوانید آن را با :func:`setattr` "
"تنظیم کنید."

#: ../../library/functions.rst:1838
msgid ""
"Return a :term:`slice` object representing the set of indices specified by "
"``range(start, stop, step)``.  The *start* and *step* arguments default to "
"``None``."
msgstr ""
"یک شیء :term:`slice` را بازگردانید که مجموعه ای از شاخص های مشخص شده توسط "
"``range(start, stop, step)`` را نشان می دهد. آرگومان های *start* و *step* به "
"صورت پیش فرض به ``None`` تنظیم شده اند."

#: ../../library/functions.rst:1842
msgid ""
"Slice objects have read-only data attributes :attr:`!start`, :attr:`!stop`, "
"and :attr:`!step` which merely return the argument values (or their "
"default).  They have no other explicit functionality; however, they are used "
"by NumPy and other third-party packages."
msgstr ""
"اشیاء Slice دارای ویژگی های داده ای فقط خواندنی :attr:`!start`، :attr:`!"
"stop`، و :attr:`!step` هستند که صرفاً مقادیر آرگومان ها (یا مقدار پیش فرض آن "
"ها) را برمی گردانند. آن ها هیچ کارکرد صریح دیگری ندارند؛ با این حال، توسط "
"NumPy و سایر بسته های شخص ثالث استفاده می شوند."

#: ../../library/functions.rst:1851
msgid ""
"Slice objects are also generated when extended indexing syntax is used.  For "
"example: ``a[start:stop:step]`` or ``a[start:stop, i]``.  See :func:"
"`itertools.islice` for an alternate version that returns an :term:`iterator`."
msgstr ""
"همچنین وقتی از نگارش گسترش یافته ی ایندکس گذاری استفاده می شود، اشیاء برش "
"تولید می شوند. به عنوان مثال: ``a[start:stop:step]`` یا ``a[start:stop, "
"i]``. برای نسخه ای جایگزین که یک :term:`iterator` برمی گرداند، به :func:"
"`itertools.islice` مراجعه کنید."

#: ../../library/functions.rst:1856
msgid ""
"Slice objects are now :term:`hashable` (provided :attr:`~slice.start`, :attr:"
"`~slice.stop`, and :attr:`~slice.step` are hashable)."
msgstr ""
"اشیای Slice اکنون :term:`hashable` هستند (به شرطی که :attr:`~slice.start`، :"
"attr:`~slice.stop` و :attr:`~slice.step` قابل هَش باشند)."

#: ../../library/functions.rst:1862
msgid "Return a new sorted list from the items in *iterable*."
msgstr "یک لیست جدید مرتب شده از آیتم های موجود در *iterable* بازگردانید."

#: ../../library/functions.rst:1864
msgid ""
"Has two optional arguments which must be specified as keyword arguments."
msgstr ""
"دارای دو آرگومان اختیاری است که باید به صورت آرگومان های کلیدی تعیین شوند."

#: ../../library/functions.rst:1866
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each element in *iterable* (for example, ``key=str."
"lower``).  The default value is ``None`` (compare the elements directly)."
msgstr ""
"*key* یک تابع با یک آرگومان را مشخص می کند که برای استخراج یک کلید مقایسه از "
"هر عنصر در *iterable* استفاده می شود (برای مثال، ``key=str.lower``). مقدار "
"پیش فرض ``None`` است (عناصر را مستقیماً مقایسه کنید)."

#: ../../library/functions.rst:1870
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr ""
"*reverse* یک مقدار بولین است. اگر به ``True`` تنظیم شود، عناصر لیست به گونه "
"ای مرتب می شوند که گویی هر مقایسه معکوس شده است."

#: ../../library/functions.rst:1873
msgid ""
"Use :func:`functools.cmp_to_key` to convert an old-style *cmp* function to a "
"*key* function."
msgstr ""
"از :func:`functools.cmp_to_key` استفاده کنید تا یک تابع *cmp* قدیمی را به یک "
"تابع *key* تبدیل کنید."

#: ../../library/functions.rst:1876
msgid ""
"The built-in :func:`sorted` function is guaranteed to be stable. A sort is "
"stable if it guarantees not to change the relative order of elements that "
"compare equal --- this is helpful for sorting in multiple passes (for "
"example, sort by department, then by salary grade)."
msgstr ""
"تابع داخلی :func:`sorted` تضمین شده که پایدار است. یک مرتب سازی زمانی پایدار "
"است که تضمین کند ترتیب نسبی عناصر با مقادیر برابر را تغییر ندهد --- این "
"ویژگی در مرتب سازی در چند مرحله مفید است (برای مثال، ابتدا بر اساس دپارتمان "
"و سپس بر اساس درجه حقوق مرتب سازی شود)."

#: ../../library/functions.rst:1881
msgid ""
"The sort algorithm uses only ``<`` comparisons between items.  While "
"defining an :meth:`~object.__lt__` method will suffice for sorting, :PEP:`8` "
"recommends that all six :ref:`rich comparisons <comparisons>` be "
"implemented.  This will help avoid bugs when using the same data with other "
"ordering tools such as :func:`max` that rely on a different underlying "
"method.  Implementing all six comparisons also helps avoid confusion for "
"mixed type comparisons which can call reflected the :meth:`~object.__gt__` "
"method."
msgstr ""
"الگوریتم مرتب سازی فقط از مقایسه های ``<`` بین آیتم ها استفاده می کند. در "
"حالی که تعریف یک روش :meth:`~object.__lt__` برای مرتب سازی کافی است، :PEP:"
"`8` توصیه می کند که هر شش :ref:`rich comparisons <comparisons>` پیاده سازی "
"شوند. این امر به جلوگیری از باگ ها هنگامی که از همان داده ها با ابزارهای "
"ترتیب دهی دیگر که وابسته به یک روش زیرین متفاوت مانند :func:`max` هستند، کمک "
"می کند. پیاده سازی هر شش مقایسه همچنین به جلوگیری از سردرگمی در مقایسه های "
"نوع مختلط که می توانند روش منعکس شده :meth:`~object.__gt__` را فراخوانی "
"کنند، کمک می کند."

#: ../../library/functions.rst:1890
msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr ""
"برای مثال های مرتب سازی و یک آموزش مختصر مرتب سازی، به :ref:`sortinghowto` "
"مراجعه کنید."

#: ../../library/functions.rst:1894
msgid "Transform a method into a static method."
msgstr "تبدیل یک متد به یک متد ایستا."

#: ../../library/functions.rst:1896
msgid ""
"A static method does not receive an implicit first argument. To declare a "
"static method, use this idiom::"
msgstr ""
"یک متد استاتیک، آرگومان اول اولیه را به صورت ضمنی دریافت نمی کند. برای تعریف "
"یک متد استاتیک از این روش استفاده کنید::"

#: ../../library/functions.rst:1899
msgid ""
"class C:\n"
"    @staticmethod\n"
"    def f(arg1, arg2, argN): ..."
msgstr ""
"کلاس C:\n"
"    @staticmethod\n"
"    def f(arg1, arg2, argN): ..."

#: ../../library/functions.rst:1903
msgid ""
"The ``@staticmethod`` form is a function :term:`decorator` -- see :ref:"
"`function` for details."
msgstr ""
"فرم ``@staticmethod`` یک تابع :term:`decorator` است -- برای جزئیات به :ref:"
"`function` مراجعه کنید."

#: ../../library/functions.rst:1906
msgid ""
"A static method can be called either on the class (such as ``C.f()``) or on "
"an instance (such as ``C().f()``). Moreover, the static method :term:"
"`descriptor` is also callable, so it can be used in the class definition "
"(such as ``f()``)."
msgstr ""
"یک متد استاتیک می تواند یا بر روی کلاس (مانند ``C.f()``) یا بر روی یک نمونه "
"(مانند ``C().f()``) فراخوانی شود. علاوه بر این، متد استاتیک :term:"
"`descriptor` نیز قابل فراخوانی است، بنابراین می تواند در تعریف کلاس (مانند "
"``f()``) استفاده شود."

#: ../../library/functions.rst:1911
msgid ""
"Static methods in Python are similar to those found in Java or C++. Also, "
"see :func:`classmethod` for a variant that is useful for creating alternate "
"class constructors."
msgstr ""
"متدهای استاتیک در پایتون شبیه به آن هایی هستند که در جاوا یا C++ یافت می "
"شوند. همچنین، :func:`classmethod` را برای نوعی ببینید که برای ایجاد سازنده "
"های کلاس جایگزین مفید است."

#: ../../library/functions.rst:1915
msgid ""
"Like all decorators, it is also possible to call ``staticmethod`` as a "
"regular function and do something with its result.  This is needed in some "
"cases where you need a reference to a function from a class body and you "
"want to avoid the automatic transformation to instance method.  For these "
"cases, use this idiom::"
msgstr ""
"مانند تمام دکوراتورها، این امکان وجود دارد که ``staticmethod`` را به عنوان "
"یک تابع معمولی فراخوانی کرده و کاری با نتیجه آن انجام دهید. این در مواردی که "
"نیاز به مرجع یک تابع از بدنه یک کلاس دارید و می خواهید از تبدیل خودکار به "
"متد نمونه جلوگیری کنید، لازم است. برای این موارد، از این روش استفاده کنید::"

#: ../../library/functions.rst:1921
msgid ""
"def regular_function():\n"
"    ...\n"
"\n"
"class C:\n"
"    method = staticmethod(regular_function)"
msgstr ""
"تعریف تابع عادی:\n"
"    ...\n"
"\n"
"کلاس C:\n"
"    method = staticmethod(regular_function)"

#: ../../library/functions.rst:1927
msgid "For more information on static methods, see :ref:`types`."
msgstr "برای اطلاعات بیشتر در مورد متدهای ایستا، به :ref:`types` مراجعه کنید."

#: ../../library/functions.rst:1929
msgid ""
"Static methods now inherit the method attributes (:attr:`~function."
"__module__`, :attr:`~function.__name__`, :attr:`~function.__qualname__`, :"
"attr:`~function.__doc__` and :attr:`~function.__annotations__`), have a new "
"``__wrapped__`` attribute, and are now callable as regular functions."
msgstr ""
"متدهای استاتیک اکنون ویژگی های متدها (:attr:`~function.__module__`، :attr:"
"`~function.__name__`، :attr:`~function.__qualname__`، :attr:`~function."
"__doc__` و :attr:`~function.__annotations__`) را به ارث می برند، یک ویژگی "
"جدید به نام ``__wrapped__`` دارند و اکنون به عنوان توابع معمولی قابل "
"فراخوانی هستند."

#: ../../library/functions.rst:1945
msgid ""
"Return a :class:`str` version of *object*.  See :func:`str` for details."
msgstr ""
" یک نسخه :class:`str` از *شیء* برمیگرداند. برای جزئیات بیشتر به :func:"
"`str`مراجعه کنید."

#: ../../library/functions.rst:1947
msgid ""
"``str`` is the built-in string :term:`class`.  For general information about "
"strings, see :ref:`textseq`."
msgstr ""
"``str`` رشته ای داخلی است :term:`class`. برای اطلاعات کلی درباره رشته ها، "
"به :ref:`textseq` مراجعه کنید."

#: ../../library/functions.rst:1953
msgid ""
"Sums *start* and the items of an *iterable* from left to right and returns "
"the total.  The *iterable*'s items are normally numbers, and the start value "
"is not allowed to be a string."
msgstr ""
"مجموع *start* و آیتم های یک *iterable* را از چپ به راست محاسبه کرده و حاصل "
"را برمی گرداند. آیتم های *iterable* معمولاً اعداد هستند و مقدار شروع نمی "
"تواند یک رشته باشد."

#: ../../library/functions.rst:1957
msgid ""
"For some use cases, there are good alternatives to :func:`sum`. The "
"preferred, fast way to concatenate a sequence of strings is by calling ``''."
"join(sequence)``.  To add floating-point values with extended precision, "
"see :func:`math.fsum`\\.  To concatenate a series of iterables, consider "
"using :func:`itertools.chain`."
msgstr ""
"برای برخی موارد استفاده، جایگزین های خوبی برای :func:`sum` وجود دارد. روش "
"سریع و ترجیحی برای متصل کردن دنباله ای از رشته ها، فراخوانی ``''."
"join(sequence)`` است. برای جمع کردن مقادیر شناور با دقت بیشتر، به :func:"
"`math.fsum` مراجعه کنید. برای متصل کردن رشته ای از iterable ها، در نظر داشته "
"باشید که از :func:`itertools.chain` استفاده کنید."

#: ../../library/functions.rst:1963
msgid "The *start* parameter can be specified as a keyword argument."
msgstr "پارامتر *start* می تواند به عنوان یک آرگومان کلیدواژه مشخص شود."

#: ../../library/functions.rst:1966
msgid ""
"Summation of floats switched to an algorithm that gives higher accuracy and "
"better commutativity on most builds."
msgstr ""
"مجموع اعداد اعشاری به الگوریتمی تبدیل شد که دقت بیشتری دارد و در بیشتر ساخت "
"ها قابلیت جایگشت بهتری ارائه می دهد."

#: ../../library/functions.rst:1969
msgid ""
"Added specialization for summation of complexes, using same algorithm as for "
"summation of floats."
msgstr ""

#: ../../library/functions.rst:1977
msgid ""
"Return a proxy object that delegates method calls to a parent or sibling "
"class of *type*.  This is useful for accessing inherited methods that have "
"been overridden in a class."
msgstr ""
"یک شیء نماینده را بازمی گرداند که فراخوانی متدها را به یک کلاس والد یا هم "
"سطح از *type* واگذار می کند. این کار برای دستیابی به متدهای به ارث برده شده "
"که در یک کلاس بازنویسی شده اند مفید است."

#: ../../library/functions.rst:1981
msgid ""
"The *object_or_type* determines the :term:`method resolution order` to be "
"searched.  The search starts from the class right after the *type*."
msgstr ""
"*object_or_type* عامل تعیین کننده :term:`method resolution order` برای جستجو "
"است. جستجو از کلاسی که بلافاصله پس از *type* قرار دارد شروع می شود."

#: ../../library/functions.rst:1985
msgid ""
"For example, if :attr:`~type.__mro__` of *object_or_type* is ``D -> B -> C -"
"> A -> object`` and the value of *type* is ``B``, then :func:`super` "
"searches ``C -> A -> object``."
msgstr ""
"به عنوان مثال، اگر :attr:`~type.__mro__` از *object_or_type* برابر با ``D -> "
"B -> C -> A -> object`` باشد و مقدار *type* برابر ``B`` باشد، سپس :func:"
"`super` به دنبال ``C -> A -> object`` می گردد."

#: ../../library/functions.rst:1989
msgid ""
"The :attr:`~type.__mro__` attribute of the class corresponding to "
"*object_or_type* lists the method resolution search order used by both :func:"
"`getattr` and :func:`super`.  The attribute is dynamic and can change "
"whenever the inheritance hierarchy is updated."
msgstr ""
"ویژگی :attr:`~type.__mro__` کلاس مربوط به *object_or_type*، ترتیب جستجوی حل "
"روش را که توسط :func:`getattr` و :func:`super` استفاده می شود، فهرست می کند. "
"این ویژگی دینامیک است و هر زمان که سلسله مراتب وراثت به روزرسانی شود، می "
"تواند تغییر کند."

#: ../../library/functions.rst:1994
msgid ""
"If the second argument is omitted, the super object returned is unbound.  If "
"the second argument is an object, ``isinstance(obj, type)`` must be true.  "
"If the second argument is a type, ``issubclass(type2, type)`` must be true "
"(this is useful for classmethods)."
msgstr ""
"اگر آرگومان دوم حذف شود، شیء  super برگردانده شده بدون محدودیت خواهد بود. "
"اگر آرگومان دوم یک شیء باشد، ``isinstance(obj, type)`` باید درست باشد. اگر "
"آرگومان دوم یک نوع باشد، ``issubclass(type2, type)`` باید درست باشد (این "
"برای classmethods مفید است)."

#: ../../library/functions.rst:1999
msgid ""
"When called directly within an ordinary method of a class, both arguments "
"may be omitted (\"zero-argument :func:`!super`\"). In this case, *type* will "
"be the enclosing class, and *obj* will be the first argument of the "
"immediately enclosing function (typically ``self``). (This means that zero-"
"argument :func:`!super` will not work as expected within nested functions, "
"including generator expressions, which implicitly create nested functions.)"
msgstr ""
"هنگامی که مستقیماً در یک متد معمولی از یک کلاس فراخوانی شود، هر دو آرگومان "
"ممکن است حذف شوند (\":func:`!super` بدون آرگومان\"). در این حالت، *type* "
"کلاس محصورکننده خواهد بود، و *obj* اولین آرگومان تابع بلافاصله محصورکننده "
"(معمولاً ``self``) خواهد بود. (این بدان معناست که :func:`!super` بدون آرگومان "
"در توابع تو در تو، از جمله عبارت های مولد، که به طور ضمنی توابع تو در تو "
"ایجاد می کنند، به درستی کار نخواهد کرد.)"

#: ../../library/functions.rst:2006
msgid ""
"There are two typical use cases for *super*.  In a class hierarchy with "
"single inheritance, *super* can be used to refer to parent classes without "
"naming them explicitly, thus making the code more maintainable.  This use "
"closely parallels the use of *super* in other programming languages."
msgstr ""
"دو کاربرد معمول برای *super* وجود دارد. در سلسله مراتب کلاس با وراثت تک "
"گانه، *super* می تواند برای ارجاع به کلاس های والد بدون نام گذاری صریح آن ها "
"استفاده شود، و به این ترتیب کد قابل نگهداری تر می شود. این استفاده به طور "
"نزدیک با استفاده از *super* در زبان های برنامه نویسی دیگر مشابه است."

#: ../../library/functions.rst:2011
msgid ""
"The second use case is to support cooperative multiple inheritance in a "
"dynamic execution environment.  This use case is unique to Python and is not "
"found in statically compiled languages or languages that only support single "
"inheritance.  This makes it possible to implement \"diamond diagrams\" where "
"multiple base classes implement the same method.  Good design dictates that "
"such implementations have the same calling signature in every case (because "
"the order of calls is determined at runtime, because that order adapts to "
"changes in the class hierarchy, and because that order can include sibling "
"classes that are unknown prior to runtime)."
msgstr ""
"مورد استفاده دوم برای پشتیبانی از ارث بری چندگانه تعاونی در یک محیط اجرای "
"پویا است. این مورد استفاده به طور منحصر به فرد به پایتون تعلق دارد و در زبان "
"های که به صورت ایستا کامپایل می شوند یا تنها از ارث بری تکی پشتیبانی می "
"کنند، یافت نمی شود. این امکان را فراهم می کند تا \"نمودارهای الماس\" پیاده "
"سازی شود، جایی که کلاس های پایه متعدد یک روش یکسان را پیاده سازی می کنند. "
"طراحی خوب ایجاب می کند که چنین پیاده سازی هایی در هر مورد امضای یکسانی برای "
"فراخوانی داشته باشند (زیرا ترتیب فراخوانی ها در زمان اجرا تعیین می شود، زیرا "
"آن ترتیب با تغییرات در سلسله مراتب کلاس تطابق می یابد، و زیرا آن ترتیب می "
"تواند شامل کلاس های هم رده ای باشد که قبل از زمان اجرا ناشناخته هستند)."

#: ../../library/functions.rst:2021
msgid "For both use cases, a typical superclass call looks like this::"
msgstr ""
"برای هر دو مورد استفاده، یک فراخوانی معمولی به ابرکلاس به این صورت است::"

#: ../../library/functions.rst:2023
msgid ""
"class C(B):\n"
"    def method(self, arg):\n"
"        super().method(arg)    # This does the same thing as:\n"
"                               # super(C, self).method(arg)"
msgstr ""
"کلاس C(B):\n"
"    def method(self, arg):\n"
"        super().method(arg)    # این همان کاری را انجام می دهد که:\n"
"                               # super(C, self).method(arg)"

#: ../../library/functions.rst:2028
msgid ""
"In addition to method lookups, :func:`super` also works for attribute "
"lookups.  One possible use case for this is calling :term:`descriptors "
"<descriptor>` in a parent or sibling class."
msgstr ""
"علاوه بر جستجوی متد، :func:`super` همچنین برای جستجوی ویژگی ها نیز کار می "
"کند. یکی از موارد استفاده ممکن برای این کاربرد، فراخوانی :term:`descriptors "
"<descriptor>` در یک کلاس والد یا خواهر و برادر است."

#: ../../library/functions.rst:2032
msgid ""
"Note that :func:`super` is implemented as part of the binding process for "
"explicit dotted attribute lookups such as ``super().__getitem__(name)``. It "
"does so by implementing its own :meth:`~object.__getattribute__` method for "
"searching classes in a predictable order that supports cooperative multiple "
"inheritance. Accordingly, :func:`super` is undefined for implicit lookups "
"using statements or operators such as ``super()[name]``."
msgstr ""
"توجه داشته باشید که :func:`super` به عنوان بخشی از فرآیند اتصال برای جستجوی "
"صریح ویژگی های نقطه گذاری شده، مانند ``super().__getitem__(name)``، پیاده "
"سازی شده است. این کار را با پیاده سازی روش :meth:`~object.__getattribute__` "
"خود برای جستجوی کلاس ها به روشی قابل پیش بینی که از وراثت چندگانه تعاونی "
"پشتیبانی می کند، انجام می دهد. بر این اساس، :func:`super` برای جستجوهای ضمنی "
"با استفاده از عبارات یا عملگرهایی مانند ``super()[name]`` تعریف نشده است."

#: ../../library/functions.rst:2040
msgid ""
"Also note that, aside from the zero argument form, :func:`super` is not "
"limited to use inside methods.  The two argument form specifies the "
"arguments exactly and makes the appropriate references.  The zero argument "
"form only works inside a class definition, as the compiler fills in the "
"necessary details to correctly retrieve the class being defined, as well as "
"accessing the current instance for ordinary methods."
msgstr ""
"همچنین توجه داشته باشید که به غیر از حالت بدون آرگومان، :func:`super` محدود "
"به استفاده درون متدها نیست. حالت دو آرگومانی دقیقاً آرگومان ها را مشخص کرده و "
"ارجاعات مناسب را انجام می دهد. فرم بدون آرگومان تنها درون تعریف کلاس کار می "
"کند، چرا که کامپایلر جزئیات لازم را برای بازیابی صحیح کلاس تعریف شده و "
"همچنین دسترسی به نمونه فعلی برای متدهای معمولی کامل می کند."

#: ../../library/functions.rst:2047
msgid ""
"For practical suggestions on how to design cooperative classes using :func:"
"`super`, see `guide to using super() <https://rhettinger.wordpress."
"com/2011/05/26/super-considered-super/>`_."
msgstr ""
"برای پیشنهادهای عملی در مورد نحوه طراحی کلاس های همکار با استفاده از :func:"
"`super`، به `guide to using super() <https://rhettinger.wordpress."
"com/2011/05/26/super-considered-super/>`_ مراجعه کنید."

#: ../../library/functions.rst:2051
msgid ""
":class:`super` objects are now :mod:`pickleable <pickle>` and  :mod:"
"`copyable <copy>`."
msgstr ""

#: ../../library/functions.rst:2061
msgid ""
"Rather than being a function, :class:`tuple` is actually an immutable "
"sequence type, as documented in :ref:`typesseq-tuple` and :ref:`typesseq`."
msgstr ""
"به جای اینکه یک تابع باشد، :class:`tuple` در واقع یک نوع دنباله غیرقابل "
"تغییر است، همان طور که در :ref:`typesseq-tuple` و :ref:`typesseq` مستند شده "
"است."

#: ../../library/functions.rst:2070
msgid ""
"With one argument, return the type of an *object*.  The return value is a "
"type object and generally the same object as returned by :attr:`object."
"__class__`."
msgstr ""
"با یک آرگومان، نوع یک *object* را برمی گرداند. مقدار بازگشتی یک شیء از نوع "
"است و به طور عمومی همان شیء است که توسط :attr:`object.__class__` برگردانده "
"می شود."

#: ../../library/functions.rst:2074
msgid ""
"The :func:`isinstance` built-in function is recommended for testing the type "
"of an object, because it takes subclasses into account."
msgstr ""
"تابع داخلی :func:`isinstance` برای آزمایش نوع یک شی توصیه می شود، زیرا "
"زیرکلاس ها را نیز در نظر می گیرد."

#: ../../library/functions.rst:2077
msgid ""
"With three arguments, return a new type object.  This is essentially a "
"dynamic form of the :keyword:`class` statement. The *name* string is the "
"class name and becomes the :attr:`~type.__name__` attribute. The *bases* "
"tuple contains the base classes and becomes the :attr:`~type.__bases__` "
"attribute; if empty, :class:`object`, the ultimate base of all classes, is "
"added.  The *dict* dictionary contains attribute and method definitions for "
"the class body; it may be copied or wrapped before becoming the :attr:`~type."
"__dict__` attribute. The following two statements create identical :class:`!"
"type` objects:"
msgstr ""
"با سه آرگومان، یک شیء نوع جدید برمی گرداند. این در واقع یک فرم پویا از بیان :"
"keyword:`class` است. رشته *name* نام کلاس است و به عنوان ویژگی :attr:`~type."
"__name__` می شود. *bases* یک تاپل شامل کلاس های پایه است و به عنوان ویژگی :"
"attr:`~type.__bases__` می شود؛ اگر خالی باشد، :class:`object`، که پایه نهایت "
"تمام کلاس ها است، اضافه می شود. دیکشنری *dict* شامل تعاریف ویژگی ها و متدها "
"برای بدنه کلاس است؛ ممکن است قبل از اینکه به ویژگی :attr:`~type.__dict__` "
"تبدیل شود، کپی یا پیچیده شود. دو جمله زیر اشیاء :class:`!type` یکسانی ایجاد "
"می کنند:"

#: ../../library/functions.rst:2092
msgid "See also:"
msgstr "همچنین ببینید:"

#: ../../library/functions.rst:2094
msgid ""
":ref:`Documentation on attributes and methods on classes <class-attrs-and-"
"methods>`."
msgstr ""
":ref:`Documentation on attributes and methods on classes <class-attrs-and-"
"methods>`."

#: ../../library/functions.rst:2095
msgid ":ref:`bltin-type-objects`"
msgstr ":ref:`bltin-type-objects`"

#: ../../library/functions.rst:2097
msgid ""
"Keyword arguments provided to the three argument form are passed to the "
"appropriate metaclass machinery (usually :meth:`~object.__init_subclass__`) "
"in the same way that keywords in a class definition (besides *metaclass*) "
"would."
msgstr ""
"آرگومان های کلیدی که به فرم سه  آرگومانی ارائه می شوند، به ماشین مرتبط با "
"فرامتناظر مناسب (معمولاً :meth:`~object.__init_subclass__`) به همان صورتی که "
"کلمات کلیدی در تعریف یک کلاس (به جز *metaclass*) منتقل می شوند، پاس داده می "
"شوند."

#: ../../library/functions.rst:2102
msgid "See also :ref:`class-customization`."
msgstr "همچنین ببینید :ref:`class-customization`."

#: ../../library/functions.rst:2104
msgid ""
"Subclasses of :class:`!type` which don't override ``type.__new__`` may no "
"longer use the one-argument form to get the type of an object."
msgstr ""
"زیرکلاس های :class:`!type` که ``type.__new__`` را تغییر نمی دهند ممکن است "
"دیگر نتوانند از فرم یک پارامتری برای گرفتن نوع یک شیء استفاده کنند."

#: ../../library/functions.rst:2111
msgid ""
"Return the :attr:`~object.__dict__` attribute for a module, class, instance, "
"or any other object with a :attr:`!__dict__` attribute."
msgstr ""
"ویژگی :attr:`~object.__dict__` را برای یک ماژول، کلاس، نمونه، یا هر شیء "
"دیگری که ویژگی :attr:`!__dict__` را دارد، بازگردانید."

#: ../../library/functions.rst:2114
msgid ""
"Objects such as modules and instances have an updateable :attr:`~object."
"__dict__` attribute; however, other objects may have write restrictions on "
"their :attr:`!__dict__` attributes (for example, classes use a :class:`types."
"MappingProxyType` to prevent direct dictionary updates)."
msgstr ""
"اشیایی مانند ماژول ها و نمونه ها دارای خاصیت :attr:`~object.__dict__` قابل "
"به روزرسانی هستند؛ با این حال، ممکن است سایر اشیا محدودیت های نوشتن بر روی "
"ویژگی های :attr:`!__dict__` خود داشته باشند (به عنوان مثال، کلاس ها از یک :"
"class:`types.MappingProxyType` استفاده می کنند تا از به روزرسانی مستقیم "
"دیکشنری جلوگیری کنند)."

#: ../../library/functions.rst:2119
msgid "Without an argument, :func:`vars` acts like :func:`locals`."
msgstr "بدون آرگومان، :func:`vars` به صورت :func:`locals` عمل می کند."

#: ../../library/functions.rst:2121
msgid ""
"A :exc:`TypeError` exception is raised if an object is specified but it "
"doesn't have a :attr:`~object.__dict__` attribute (for example, if its class "
"defines the :attr:`~object.__slots__` attribute)."
msgstr ""
"اگر شیء مشخص شود اما ویژگی :attr:`~object.__dict__` نداشته باشد (به عنوان "
"مثال، اگر کلاس آن ویژگی :attr:`~object.__slots__` را تعریف کرده باشد)، یک "
"استثناء :exc:`TypeError` برانگیخته می شود."

#: ../../library/functions.rst:2127
msgid ""
"The result of calling this function without an argument has been updated as "
"described for the :func:`locals` builtin."
msgstr ""
"نتیجه فراخوانی این تابع بدون آرگومان به روزرسانی شده است همان طور که برای :"
"func:`locals` builtin توصیف شد."

#: ../../library/functions.rst:2133
msgid ""
"Iterate over several iterables in parallel, producing tuples with an item "
"from each one."
msgstr ""
"برای تکرار بر روی چندین iterable به صورت موازی و تولید تاپل هایی که شامل "
"آیتمی از هر یک از آن ها باشد."

#: ../../library/functions.rst:2136
msgid "Example::"
msgstr "مثال::"

#: ../../library/functions.rst:2138
msgid ""
">>> for item in zip([1, 2, 3], ['sugar', 'spice', 'everything nice']):\n"
"...     print(item)\n"
"...\n"
"(1, 'sugar')\n"
"(2, 'spice')\n"
"(3, 'everything nice')"
msgstr ""
">>> برای آیتم در zip([1, 2, 3], ['sugar', 'spice', 'everything nice']):\n"
"...     print(آیتم)\n"
"...\n"
"(1, 'sugar')\n"
"(2, 'spice')\n"
"(3, 'everything nice')"

#: ../../library/functions.rst:2145
msgid ""
"More formally: :func:`zip` returns an iterator of tuples, where the *i*-th "
"tuple contains the *i*-th element from each of the argument iterables."
msgstr ""
"به طور رسمی تر: :func:`zip` یک پیماینده از زوج مرتب ها برمی گرداند، که زوج "
"مرتب *i* شامل عنصر *i* از هر یک از پیمایش پذیرهای آرگومان ها است."

#: ../../library/functions.rst:2148
msgid ""
"Another way to think of :func:`zip` is that it turns rows into columns, and "
"columns into rows.  This is similar to `transposing a matrix <https://en."
"wikipedia.org/wiki/Transpose>`_."
msgstr ""
"راه دیگری برای فکر کردن به :func:`zip` این است که سطرها را به ستون ها و ستون "
"ها را به سطرها تبدیل می کند. این مشابه `transposing a matrix <https://en."
"wikipedia.org/wiki/Transpose>`_ است."

#: ../../library/functions.rst:2152
msgid ""
":func:`zip` is lazy: The elements won't be processed until the iterable is "
"iterated on, e.g. by a :keyword:`!for` loop or by wrapping in a :class:"
"`list`."
msgstr ""
":func:`zip` تنبل است: عناصر تا زمانی که روی iterable تکرار نشود پردازش نمی "
"شوند، به عنوان مثال توسط یک :keyword:`!for` loop یا با قرار دادن در یک :"
"class:`list`."

#: ../../library/functions.rst:2156
msgid ""
"One thing to consider is that the iterables passed to :func:`zip` could have "
"different lengths; sometimes by design, and sometimes because of a bug in "
"the code that prepared these iterables.  Python offers three different "
"approaches to dealing with this issue:"
msgstr ""
"نکته ای که باید در نظر داشته باشید این است که تکرارشونده هایی که به :func:"
"`zip` ارسال می شوند ممکن است طول های متفاوتی داشته باشند؛ گاهی به دلیل طراحی "
"و گاهی به علت وجود اشکالی در کدی که این تکرارشونده ها را آماده کرده است. "
"پایتون سه روش مختلف برای مقابله با این مسئله ارائه می دهد:"

#: ../../library/functions.rst:2161
msgid ""
"By default, :func:`zip` stops when the shortest iterable is exhausted. It "
"will ignore the remaining items in the longer iterables, cutting off the "
"result to the length of the shortest iterable::"
msgstr ""
"به طور پیش فرض، :func:`zip` زمانی متوقف می شود که کوتاه ترین iterable به "
"پایان برسد. آیتم های باقی مانده در iterables بلندتر را نادیده می گیرد و "
"نتیجه را به طول کوتاه ترین iterable محدود می کند::"

#: ../../library/functions.rst:2165
msgid ""
">>> list(zip(range(3), ['fee', 'fi', 'fo', 'fum']))\n"
"[(0, 'fee'), (1, 'fi'), (2, 'fo')]"
msgstr ""
">>> list(zip(range(3), ['fee', 'fi', 'fo', 'fum']))\n"
"[(0, 'fee'), (1, 'fi'), (2, 'fo')]"

#: ../../library/functions.rst:2168
msgid ""
":func:`zip` is often used in cases where the iterables are assumed to be of "
"equal length.  In such cases, it's recommended to use the ``strict=True`` "
"option. Its output is the same as regular :func:`zip`::"
msgstr ""
"اغلباً از :func:`zip` در مواردی استفاده می شود که فرض بر این است که تکرارگرها "
"برابر طول هستند. در چنین مواردی، توصیه می شود از گزینه ``strict=True`` "
"استفاده کنید. خروجی آن همانند :func:`zip` معمولی می باشد::"

#: ../../library/functions.rst:2172
msgid ""
">>> list(zip(('a', 'b', 'c'), (1, 2, 3), strict=True))\n"
"[('a', 1), ('b', 2), ('c', 3)]"
msgstr ""
">>> list(zip(('a', 'b', 'c'), (1, 2, 3), strict=True))\n"
"[('a', 1), ('b', 2), ('c', 3)]"

#: ../../library/functions.rst:2175
msgid ""
"Unlike the default behavior, it raises a :exc:`ValueError` if one iterable "
"is exhausted before the others:"
msgstr ""
"برخلاف رفتار پیش فرض، اگر یکی از iterableها پیش از دیگری تمام شود، یک :exc:"
"`ValueError` ایجاد می کند:"

#: ../../library/functions.rst:2193
msgid ""
"Without the ``strict=True`` argument, any bug that results in iterables of "
"different lengths will be silenced, possibly manifesting as a hard-to-find "
"bug in another part of the program."
msgstr ""
"بدون آرگومان ``strict=True``، هر باگی که منجر به طول های مختلف در iterable "
"ها شود بدون اعلان باقی می ماند و ممکن است به صورت باگی که سخت پیدا می شود در "
"بخش دیگری از برنامه ظاهر شود."

#: ../../library/functions.rst:2197
msgid ""
"Shorter iterables can be padded with a constant value to make all the "
"iterables have the same length.  This is done by :func:`itertools."
"zip_longest`."
msgstr ""
"می توان برای کوتاه ترهای قابل تکرار از مقدار ثابت استفاده کرد تا همه ی آن ها "
"به طول یکسان برسند. این کار با :func:`itertools.zip_longest` انجام می شود."

#: ../../library/functions.rst:2201
msgid ""
"Edge cases: With a single iterable argument, :func:`zip` returns an iterator "
"of 1-tuples.  With no arguments, it returns an empty iterator."
msgstr ""
"موارد خاص: با یک آرگومان قابل تکرار، :func:`zip` یک تکرارگر از ۱-تاپل ها را "
"بازمی گرداند. بدون هیچ آرگومانی، یک تکرارگر خالی را برمی گرداند."

#: ../../library/functions.rst:2204
msgid "Tips and tricks:"
msgstr "نکات و ترفندها:"

#: ../../library/functions.rst:2206
msgid ""
"The left-to-right evaluation order of the iterables is guaranteed. This "
"makes possible an idiom for clustering a data series into n-length groups "
"using ``zip(*[iter(s)]*n, strict=True)``.  This repeats the *same* iterator "
"``n`` times so that each output tuple has the result of ``n`` calls to the "
"iterator. This has the effect of dividing the input into n-length chunks."
msgstr ""
"ترتیب ارزیابی از چپ به راست برای قابل تکرارها تضمین شده است. این امکان یک "
"رویکرد برای گروه بندی یک سری داده به گروه های n تایی را با استفاده از "
"``zip(*[iter(s)]*n, strict=True)`` فراهم می کند. این فرآیند، تکرارگر *same* "
"را ``n`` بار تکرار می کند تا هر زوج خروجی نتیجه ``n`` فراخوانی از تکرارگر را "
"داشته باشد. این کار اثر تقسیم ورودی به قطعات n تایی را دارد."

#: ../../library/functions.rst:2212
msgid ""
":func:`zip` in conjunction with the ``*`` operator can be used to unzip a "
"list::"
msgstr ""
":func:`zip` همراه با عملگر ``*`` می تواند برای استخراج لیست استفاده شود::"

#: ../../library/functions.rst:2215
msgid ""
">>> x = [1, 2, 3]\n"
">>> y = [4, 5, 6]\n"
">>> list(zip(x, y))\n"
"[(1, 4), (2, 5), (3, 6)]\n"
">>> x2, y2 = zip(*zip(x, y))\n"
">>> x == list(x2) and y == list(y2)\n"
"True"
msgstr ""
">>> x = [1, 2, 3]\n"
">>> y = [4, 5, 6]\n"
">>> list(zip(x, y))\n"
"[(1, 4), (2, 5), (3, 6)]\n"
">>> x2, y2 = zip(*zip(x, y))\n"
">>> x == list(x2) and y == list(y2)\n"
"True"

#: ../../library/functions.rst:2223
msgid "Added the ``strict`` argument."
msgstr "آرگومان ``strict`` اضافه شد."

#: ../../library/functions.rst:2235
msgid ""
"This is an advanced function that is not needed in everyday Python "
"programming, unlike :func:`importlib.import_module`."
msgstr ""
"این یک تابع پیشرفته است که برخلاف :func:`importlib.import_module` در برنامه "
"نویسی روزمره پایتون نیازی به آن نیست."

#: ../../library/functions.rst:2238
msgid ""
"This function is invoked by the :keyword:`import` statement.  It can be "
"replaced (by importing the :mod:`builtins` module and assigning to "
"``builtins.__import__``) in order to change semantics of the :keyword:`!"
"import` statement, but doing so is **strongly** discouraged as it is usually "
"simpler to use import hooks (see :pep:`302`) to attain the same goals and "
"does not cause issues with code which assumes the default import "
"implementation is in use.  Direct use of :func:`__import__` is also "
"discouraged in favor of :func:`importlib.import_module`."
msgstr ""
"این تابع توسط دستور :keyword:`import` فراخوانی می شود. می توان آن را با وارد "
"کردن ماژول :mod:`builtins` و اختصاص دادن به ``builtins.__import__`` جایگزین "
"کرد تا تغییراتی در معناشناسی دستور :keyword:`!import` ایجاد شود، اما انجام "
"این کار به شدت **strongly** توصیه نمی شود زیرا معمولاً استفاده از قلاب های "
"ورود (به :pep:`302` مراجعه کنید) برای دستیابی به همان اهداف ساده تر است و "
"مشکلاتی با کدهایی که فرض می کنند پیاده سازی پیش فرض واردات در حال استفاده "
"است، ایجاد نمی کند. استفاده مستقیم از :func:`__import__` نیز به نفع :func:"
"`importlib.import_module` توصیه نمی شود."

#: ../../library/functions.rst:2247
msgid ""
"The function imports the module *name*, potentially using the given "
"*globals* and *locals* to determine how to interpret the name in a package "
"context. The *fromlist* gives the names of objects or submodules that should "
"be imported from the module given by *name*.  The standard implementation "
"does not use its *locals* argument at all and uses its *globals* only to "
"determine the package context of the :keyword:`import` statement."
msgstr ""
"تابع ماژول *name* را وارد می کند و احتمالاً از *globals* و *locals* داده شده "
"برای تعیین نحوه تفسیر نام در یک زمینه بسته استفاده می کند. *fromlist* نام "
"اشیاء یا زیرماژول هایی را که باید از ماژول *name* وارد شوند، ارائه می دهد. "
"پیاده سازی استاندارد به هیچ وجه از آرگومان *locals* استفاده نمی کند و تنها "
"برای تعیین زمینه بسته عبارت :keyword:`import` از *globals* خود استفاده می "
"کند."

#: ../../library/functions.rst:2254
msgid ""
"*level* specifies whether to use absolute or relative imports. ``0`` (the "
"default) means only perform absolute imports.  Positive values for *level* "
"indicate the number of parent directories to search relative to the "
"directory of the module calling :func:`__import__` (see :pep:`328` for the "
"details)."
msgstr ""
"*level* مشخص می کند که آیا از ایمپورت های مطلق یا نسبی استفاده شود. ``0`` "
"(به طور پیش فرض) به معنای این است که فقط ایمپورت های مطلق انجام شود. مقادیر "
"مثبت برای *level* نشان دهنده تعداد دایرکتوری های والد است که باید نسبت به "
"دایرکتوری ماژولی که :func:`__import__` را فراخوانی می کند جستجو انجام شود "
"(برای جزئیات به :pep:`328` مراجعه کنید)."

#: ../../library/functions.rst:2260
msgid ""
"When the *name* variable is of the form ``package.module``, normally, the "
"top-level package (the name up till the first dot) is returned, *not* the "
"module named by *name*.  However, when a non-empty *fromlist* argument is "
"given, the module named by *name* is returned."
msgstr ""
"هنگامی که متغیر *name* به فرم ``package.module`` باشد، معمولاً بسته سطح بالا "
"(نام تا اولین نقطه) بازگردانده می شود، *not* ماژولی که با *name* نامگذاری "
"شده است. با این حال، هنگامی که یک آرگومان *fromlist* غیر خالی داده شود، "
"ماژول با نام *name* بازگردانده می شود."

#: ../../library/functions.rst:2265
msgid ""
"For example, the statement ``import spam`` results in bytecode resembling "
"the following code::"
msgstr ""
"به عنوان مثال، عبارت ``import spam`` منجر به بایت کدی می شود که مشابه کد زیر "
"است:"

#: ../../library/functions.rst:2268
msgid "spam = __import__('spam', globals(), locals(), [], 0)"
msgstr "spam = __import__('spam', globals(), locals(), [], 0)"

#: ../../library/functions.rst:2270
msgid "The statement ``import spam.ham`` results in this call::"
msgstr "عبارت ``import spam.ham`` منجر به این فراخوانی می شود::"

#: ../../library/functions.rst:2272
msgid "spam = __import__('spam.ham', globals(), locals(), [], 0)"
msgstr "spam = __import__('spam.ham', globals(), locals(), [], 0)"

#: ../../library/functions.rst:2274
msgid ""
"Note how :func:`__import__` returns the toplevel module here because this is "
"the object that is bound to a name by the :keyword:`import` statement."
msgstr ""
"توجه کنید که :func:`__import__` در اینجا ماژول سطح بالا را برمی گرداند زیرا "
"این همان شی ء است که توسط عبارت :keyword:`import` به یک نام متصل شده است."

#: ../../library/functions.rst:2277
msgid ""
"On the other hand, the statement ``from spam.ham import eggs, sausage as "
"saus`` results in ::"
msgstr ""
"از طرف دیگر، دستور ``from spam.ham import eggs, sausage as saus`` به نتیجه "
"می رسد به ::"

#: ../../library/functions.rst:2280
msgid ""
"_temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], 0)\n"
"eggs = _temp.eggs\n"
"saus = _temp.sausage"
msgstr ""
"_temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], 0)\n"
"eggs = _temp.eggs\n"
"saus = _temp.sausage"

#: ../../library/functions.rst:2284
msgid ""
"Here, the ``spam.ham`` module is returned from :func:`__import__`.  From "
"this object, the names to import are retrieved and assigned to their "
"respective names."
msgstr ""
"در اینجا، ماژول ``spam.ham`` از :func:`__import__` بازگردانده می شود. از این "
"شیء، نام هایی که باید وارد شوند جستجو شده و به نام های مربوطه خود اختصاص "
"داده می شوند."

#: ../../library/functions.rst:2288
msgid ""
"If you simply want to import a module (potentially within a package) by "
"name, use :func:`importlib.import_module`."
msgstr ""
"اگر می خواهید تنها یک ماژول (احتمالاً درون یک بسته) را با نام وارد کنید، از :"
"func:`importlib.import_module` استفاده کنید."

#: ../../library/functions.rst:2291
msgid ""
"Negative values for *level* are no longer supported (which also changes the "
"default value to 0)."
msgstr ""
"مقادیر منفی برای *level* دیگر پشتیبانی نمی شوند (که همچنین مقدار پیش فرض را "
"به 0 تغییر می دهد)."

#: ../../library/functions.rst:2295
msgid ""
"When the command line options :option:`-E` or :option:`-I` are being used, "
"the environment variable :envvar:`PYTHONCASEOK` is now ignored."
msgstr ""
"زمانی که گزینه های خط فرمان :option:`-E` یا :option:`-I` استفاده می شوند، "
"متغیر محیطی :envvar:`PYTHONCASEOK` دیگر نادیده گرفته می شود."

#: ../../library/functions.rst:2300
msgid "Footnotes"
msgstr "پاورقی ها"

#: ../../library/functions.rst:2301
msgid ""
"Note that the parser only accepts the Unix-style end of line convention. If "
"you are reading the code from a file, make sure to use newline conversion "
"mode to convert Windows or Mac-style newlines."
msgstr ""
"توجه داشته باشید که مفسر فقط کنوانسیون پایان خط به سبک یونیکس را می پذیرد. "
"اگر کد را از یک فایل می خوانید، مطمئن شوید که از حالت تبدیل خط جدید برای "
"تبدیل خط های جدید به سبک ویندوز یا مک استفاده کنید."

#: ../../library/functions.rst:154
msgid "Boolean"
msgstr "بولین"

#: ../../library/functions.rst:154 ../../library/functions.rst:2068
msgid "type"
msgstr "نوع"

#: ../../library/functions.rst:654
msgid "built-in function"
msgstr "تابع داخلی"

#: ../../library/functions.rst:654
msgid "exec"
msgstr "اجرا کردن"

#: ../../library/functions.rst:752
msgid "NaN"
msgstr "NaN"

#: ../../library/functions.rst:752
msgid "Infinity"
msgstr "بی نهایت"

#: ../../library/functions.rst:822
msgid "__format__"
msgstr "__format__"

#: ../../library/functions.rst:822 ../../library/functions.rst:1937
msgid "string"
msgstr "رشته"

#: ../../library/functions.rst:822
msgid "format() (built-in function)"
msgstr "(تابع داخلی) ()format"

#: ../../library/functions.rst:1337
msgid "file object"
msgstr "شیء پرونده"

#: ../../library/functions.rst:1337 ../../library/functions.rst:1458
msgid "open() built-in function"
msgstr "تابع داخلی ()open"

#: ../../library/functions.rst:1365
msgid "file"
msgstr "فایل"

#: ../../library/functions.rst:1365
msgid "modes"
msgstr "مدها"

#: ../../library/functions.rst:1458
msgid "universal newlines"
msgstr "خطوط جدید جهانی"

#: ../../library/functions.rst:1519
msgid "line-buffered I/O"
msgstr "ورودی/خروجی بافر خطی"

#: ../../library/functions.rst:1519
msgid "unbuffered I/O"
msgstr "ورودی/خروجی بدون بافر"

#: ../../library/functions.rst:1519
msgid "buffer size, I/O"
msgstr "اندازه بافر، ورودی/خروجی"

#: ../../library/functions.rst:1519
msgid "I/O control"
msgstr "کنترل I/O"

#: ../../library/functions.rst:1519
msgid "buffering"
msgstr "بافرینگ"

#: ../../library/functions.rst:1519
msgid "text mode"
msgstr "حالت متنی"

#: ../../library/functions.rst:1519 ../../library/functions.rst:2229
msgid "module"
msgstr "ماژول"

#: ../../library/functions.rst:1519
msgid "sys"
msgstr "سیستم"

#: ../../library/functions.rst:1937
msgid "str() (built-in function)"
msgstr "(تابع داخلی) ()str"

#: ../../library/functions.rst:2068
msgid "object"
msgstr "شیء"

#: ../../library/functions.rst:2229
msgid "statement"
msgstr "بیانیه"

#: ../../library/functions.rst:2229
msgid "import"
msgstr "وارد کردن"

#: ../../library/functions.rst:2229
msgid "builtins"
msgstr "توکارها"
