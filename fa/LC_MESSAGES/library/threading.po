# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 15:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Persian (https://app.transifex.com/python-doc/teams/5390/"
"fa/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fa\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../library/threading.rst:2
msgid ":mod:`!threading` --- Thread-based parallelism"
msgstr ":mod:`!threading` --- Потоковый параллелизм"

#: ../../library/threading.rst:7
msgid "**Source code:** :source:`Lib/threading.py`"
msgstr "**Kod źródłowy:** :source:`Lib/threading.py`"

#: ../../library/threading.rst:11
msgid ""
"This module constructs higher-level threading interfaces on top of the lower "
"level :mod:`_thread` module."
msgstr ""
"Этот модуль создает интерфейсы потоков более высокого уровня поверх модуля "
"нижнего уровня :mod:`_thread`."

#: ../../library/threading.rst:194 ../../library/threading.rst:293
#: ../../library/threading.rst:641 ../../includes/wasm-notavail.rst:3
msgid "Availability"
msgstr "Dostępność"

#: ../../includes/wasm-notavail.rst:5
msgid ""
"This module does not work or is not available on WebAssembly. See :ref:`wasm-"
"availability` for more information."
msgstr ""
"Этот модуль не работает или недоступен в WebAssembly. См. :ref:`wasm-"
"availability` для получения дополнительной информации."

#: ../../library/threading.rst:17
msgid "Introduction"
msgstr "مقدمه"

#: ../../library/threading.rst:19
msgid ""
"The :mod:`!threading` module provides a way to run multiple `threads "
"<https://en.wikipedia.org/wiki/Thread_(computing)>`_ (smaller units of a "
"process) concurrently within a single process. It allows for the creation "
"and management of threads, making it possible to execute tasks in parallel, "
"sharing memory space. Threads are particularly useful when tasks are I/O "
"bound, such as file operations or making network requests, where much of the "
"time is spent waiting for external resources."
msgstr ""
"O módulo :mod:`!threading` fornece uma maneira de executar múltiplas "
"`threads <https://en.wikipedia.org/wiki/Thread_(computing)>`_ (unidades "
"menores de um processo) simultaneamente dentro de um único processo. Ele "
"permite a criação e o gerenciamento de threads, possibilitando a execução de "
"tarefas em paralelo, compartilhando espaço de memória. Threads são "
"particularmente úteis quando tarefas são limitadas por E/S, como operações "
"de arquivo ou solicitações de rede, onde grande parte do tempo é gasto "
"aguardando recursos externos."

#: ../../library/threading.rst:27
msgid ""
"A typical use case for :mod:`!threading` includes managing a pool of worker "
"threads that can process multiple tasks concurrently.  Here's a basic "
"example of creating and starting threads using :class:`~threading.Thread`::"
msgstr ""
"Um caso de uso típico para :mod:`!threading` inclui o gerenciamento de um "
"conjunto de threads de trabalho que podem processar múltiplas tarefas "
"simultaneamente. Aqui está um exemplo básico de criação e inicialização de "
"threads usando :class:`~threading.Thread`::"

#: ../../library/threading.rst:31
msgid ""
"import threading\n"
"import time\n"
"\n"
"def crawl(link, delay=3):\n"
"    print(f\"crawl started for {link}\")\n"
"    time.sleep(delay)  # Blocking I/O (simulating a network request)\n"
"    print(f\"crawl ended for {link}\")\n"
"\n"
"links = [\n"
"    \"https://python.org\",\n"
"    \"https://docs.python.org\",\n"
"    \"https://peps.python.org\",\n"
"]\n"
"\n"
"# Start threads for each link\n"
"threads = []\n"
"for link in links:\n"
"    # Using `args` to pass positional arguments and `kwargs` for keyword "
"arguments\n"
"    t = threading.Thread(target=crawl, args=(link,), kwargs={\"delay\": 2})\n"
"    threads.append(t)\n"
"\n"
"# Start each thread\n"
"for t in threads:\n"
"    t.start()\n"
"\n"
"# Wait for all threads to finish\n"
"for t in threads:\n"
"    t.join()"
msgstr ""
"import threading\n"
"import time\n"
"\n"
"def crawl(link, delay=3):\n"
"print(f\"crawl started for {link}\")\n"
"time.sleep(delay) # 阻塞 I/O (模拟网络请求)\n"
"print(f\"crawl ended for {link}\")\n"
"\n"
"links = [\n"
"\"https://python.org\",\n"
"\"https://docs.python.org\",\n"
"\"https://peps.python.org\",\n"
"]\n"
"\n"
"# 针对每个链接启动线程\n"
"threads = []\n"
"for link in links:\n"
"# 使用 `args` 传入位置参数并使用 `kwargs` 传入关键字参数\n"
"t = threading.Thread(target=crawl, args=(link,), kwargs={\"delay\": 2})\n"
"threads.append(t)\n"
"\n"
"# 启动每个线程\n"
"for t in threads:\n"
"t.start()\n"
"\n"
"# 等待所有线程结束\n"
"for t in threads:\n"
"t.join()"

#: ../../library/threading.rst:60
msgid "This module used to be optional, it is now always available."
msgstr "Раніше цей модуль був необов’язковим, тепер він доступний завжди."

#: ../../library/threading.rst:65
msgid ""
":class:`concurrent.futures.ThreadPoolExecutor` offers a higher level "
"interface to push tasks to a background thread without blocking execution of "
"the calling thread, while still being able to retrieve their results when "
"needed."
msgstr ""
":class:`concurrent.futures.ThreadPoolExecutor` предлагает интерфейс более "
"высокого уровня для передачи задач в фоновый поток без блокировки выполнения "
"вызывающего потока, но при этом с возможностью получения их результатов при "
"необходимости."

#: ../../library/threading.rst:69
msgid ""
":mod:`queue` provides a thread-safe interface for exchanging data between "
"running threads."
msgstr ""
":mod:`queue` предоставляет потокобезопасный интерфейс для обмена данными "
"между запущенными потоками."

#: ../../library/threading.rst:72
msgid ""
":mod:`asyncio` offers an alternative approach to achieving task level "
"concurrency without requiring the use of multiple operating system threads."
msgstr ""
":mod:`asyncio` предлагает альтернативный подход к достижению параллелизма на "
"уровне задач без необходимости использования нескольких потоков операционной "
"системы."

#: ../../library/threading.rst:77
msgid ""
"In the Python 2.x series, this module contained ``camelCase`` names for some "
"methods and functions. These are deprecated as of Python 3.10, but they are "
"still supported for compatibility with Python 2.5 and lower."
msgstr ""
"У серії Python 2.x цей модуль містив назви ``camelCase`` для деяких методів "
"і функцій. Вони застаріли з Python 3.10, але вони все ще підтримуються для "
"сумісності з Python 2.5 і старішими."

#: ../../library/threading.rst:84
msgid ""
"In CPython, due to the :term:`Global Interpreter Lock <global interpreter "
"lock>`, only one thread can execute Python code at once (even though certain "
"performance-oriented libraries might overcome this limitation). If you want "
"your application to make better use of the computational resources of multi-"
"core machines, you are advised to use :mod:`multiprocessing` or :class:"
"`concurrent.futures.ProcessPoolExecutor`. However, threading is still an "
"appropriate model if you want to run multiple I/O-bound tasks simultaneously."
msgstr ""
"У CPython, завдяки :term:`Global Interpreter Lock <global interpreter "
"lock>`, лише один потік може виконувати код Python одночасно (навіть якщо "
"певні бібліотеки, орієнтовані на продуктивність, можуть подолати це "
"обмеження). Якщо ви хочете, щоб ваша програма краще використовувала "
"обчислювальні ресурси багатоядерних машин, радимо використовувати :mod:"
"`multiprocessing` або :class:`concurrent.futures.ProcessPoolExecutor`. Однак "
"потокова розв’язка все ще є відповідною моделлю, якщо ви хочете одночасно "
"запускати кілька завдань, пов’язаних із вводом-виводом."

#: ../../library/threading.rst:95
msgid "GIL and performance considerations"
msgstr "GIL 和性能的考量"

#: ../../library/threading.rst:97
msgid ""
"Unlike the :mod:`multiprocessing` module, which uses separate processes to "
"bypass the :term:`global interpreter lock` (GIL), the threading module "
"operates within a single process, meaning that all threads share the same "
"memory space. However, the GIL limits the performance gains of threading "
"when it comes to CPU-bound tasks, as only one thread can execute Python "
"bytecode at a time. Despite this, threads remain a useful tool for achieving "
"concurrency in many scenarios."
msgstr ""
"与使用多个进程来绕过 :term:`global interpreter lock` (GIL) 的 :mod:"
"`multiprocessing` 模块不同，threading 模块是在单个进程内部操作的，这意味着所"
"有线程共享相同的内存空间。 不过，对于 CPU 密集型任务来说 GIL 会限制 "
"threading 带来的性能提升，因为在同一时刻只有一个线程能执行 Python 字节码。 尽"
"管如此，在许多场景中线程仍然是实现并发的有用工具。"

#: ../../library/threading.rst:105
msgid ""
"As of Python 3.13, experimental :term:`free-threaded <free threading>` "
"builds can disable the GIL, enabling true parallel execution of threads, but "
"this feature is not available by default (see :pep:`703`)."
msgstr ""

#: ../../library/threading.rst:112
msgid "Reference"
msgstr "Referensi"

#: ../../library/threading.rst:114
msgid "This module defines the following functions:"
msgstr "Цей модуль визначає такі функції:"

#: ../../library/threading.rst:119
msgid ""
"Return the number of :class:`Thread` objects currently alive.  The returned "
"count is equal to the length of the list returned by :func:`.enumerate`."
msgstr ""
"Повертає кількість активних об’єктів :class:`Thread`. Повернена кількість "
"дорівнює довжині списку, повернутого :func:`.enumerate`."

#: ../../library/threading.rst:122
msgid "The function ``activeCount`` is a deprecated alias for this function."
msgstr "Функція ``activeCount`` є застарілим псевдонімом для цієї функції."

#: ../../library/threading.rst:127
msgid ""
"Return the current :class:`Thread` object, corresponding to the caller's "
"thread of control.  If the caller's thread of control was not created "
"through the :mod:`!threading` module, a dummy thread object with limited "
"functionality is returned."
msgstr ""
"返回当前 :class:`Thread` 对象，与调用方的控制线程。 如果调用方的控制线程不是"
"通过 :mod:`!threading` 模块创建的，则会返回一个功能受限的假线程对象。"

#: ../../library/threading.rst:132
msgid "The function ``currentThread`` is a deprecated alias for this function."
msgstr "Функція ``currentThread`` є застарілим псевдонімом для цієї функції."

#: ../../library/threading.rst:137
msgid "Handle uncaught exception raised by :func:`Thread.run`."
msgstr "Обробляти неперехоплений виняток, викликаний :func:`Thread.run`."

#: ../../library/threading.rst:139
msgid "The *args* argument has the following attributes:"
msgstr "Аргумент *args* має такі атрибути:"

#: ../../library/threading.rst:141
msgid "*exc_type*: Exception type."
msgstr "*exc_type*: Тип винятку."

#: ../../library/threading.rst:142
msgid "*exc_value*: Exception value, can be ``None``."
msgstr "*exc_value*: значення винятку, може бути ``None``."

#: ../../library/threading.rst:143
msgid "*exc_traceback*: Exception traceback, can be ``None``."
msgstr "*exc_traceback*: Зворотне відстеження винятків, може бути ``None``."

#: ../../library/threading.rst:144
msgid "*thread*: Thread which raised the exception, can be ``None``."
msgstr "*потік*: Потік, який викликав виняток, може бути ``None``."

#: ../../library/threading.rst:146
msgid ""
"If *exc_type* is :exc:`SystemExit`, the exception is silently ignored. "
"Otherwise, the exception is printed out on :data:`sys.stderr`."
msgstr ""
"Якщо *exc_type* дорівнює :exc:`SystemExit`, виняток мовчки ігнорується. В "
"іншому випадку виняток друкується на :data:`sys.stderr`."

#: ../../library/threading.rst:149
msgid ""
"If  this function raises an exception, :func:`sys.excepthook` is called to "
"handle it."
msgstr ""
"Якщо ця функція викликає виняткову ситуацію, для її обробки викликається :"
"func:`sys.excepthook`."

#: ../../library/threading.rst:152
msgid ""
":func:`threading.excepthook` can be overridden to control how uncaught "
"exceptions raised by :func:`Thread.run` are handled."
msgstr ""
":func:`threading.excepthook` можна перевизначити, щоб контролювати, як "
"обробляються неперехоплені винятки, викликані :func:`Thread.run`."

#: ../../library/threading.rst:155
msgid ""
"Storing *exc_value* using a custom hook can create a reference cycle. It "
"should be cleared explicitly to break the reference cycle when the exception "
"is no longer needed."
msgstr ""
"Зберігання *exc_value* за допомогою спеціального хука може створити "
"еталонний цикл. Його слід явно очистити, щоб розірвати цикл посилання, коли "
"виняток більше не потрібен."

#: ../../library/threading.rst:159
msgid ""
"Storing *thread* using a custom hook can resurrect it if it is set to an "
"object which is being finalized. Avoid storing *thread* after the custom "
"hook completes to avoid resurrecting objects."
msgstr ""
"Зберігання *потоку* за допомогою спеціального хука може відновити його, якщо "
"він встановлений для об’єкта, який завершується. Уникайте зберігання "
"*thread* після завершення власного хука, щоб уникнути відновлення об’єктів."

#: ../../library/threading.rst:164
msgid ":func:`sys.excepthook` handles uncaught exceptions."
msgstr ":func:`sys.excepthook` обробляє неперехоплені винятки."

#: ../../library/threading.rst:170
msgid ""
"Holds the original value of :func:`threading.excepthook`. It is saved so "
"that the original value can be restored in case they happen to get replaced "
"with broken or alternative objects."
msgstr ""
"Зберігає вихідне значення :func:`threading.excepthook`. Він зберігається, "
"щоб можна було відновити початкове значення у випадку, якщо вони заміняться "
"зламаними або альтернативними об’єктами."

#: ../../library/threading.rst:178
msgid ""
"Return the 'thread identifier' of the current thread.  This is a nonzero "
"integer.  Its value has no direct meaning; it is intended as a magic cookie "
"to be used e.g. to index a dictionary of thread-specific data.  Thread "
"identifiers may be recycled when a thread exits and another thread is "
"created."
msgstr ""
"Повертає \"ідентифікатор потоку\" поточного потоку. Це ненульове ціле число. "
"Його значення не має прямого значення; воно призначене як магічне печиво, "
"яке можна використовувати, наприклад. щоб індексувати словник даних, що "
"стосуються потоку. Ідентифікатори потоку можуть бути перероблені, коли потік "
"завершується та створюється інший."

#: ../../library/threading.rst:189
msgid ""
"Return the native integral Thread ID of the current thread assigned by the "
"kernel. This is a non-negative integer. Its value may be used to uniquely "
"identify this particular thread system-wide (until the thread terminates, "
"after which the value may be recycled by the OS)."
msgstr ""
"Повертає власний інтегральний ідентифікатор потоку поточного потоку, "
"призначеного ядром. Це невід’ємне ціле число. Його значення може "
"використовуватися для однозначної ідентифікації цього конкретного потоку в "
"системі (до завершення роботи потоку, після чого значення може бути повторно "
"використано ОС)."

#: ../../library/threading.rst:198
msgid "Added support for GNU/kFreeBSD."
msgstr "Добавлена ​​поддержка GNU/kFreeBSD."

#: ../../library/threading.rst:204
msgid ""
"Return a list of all :class:`Thread` objects currently active.  The list "
"includes daemonic threads and dummy thread objects created by :func:"
"`current_thread`.  It excludes terminated threads and threads that have not "
"yet been started.  However, the main thread is always part of the result, "
"even when terminated."
msgstr ""
"Повертає список усіх активних наразі об’єктів :class:`Thread`. Список "
"включає демонічні потоки та об’єкти-фіктивні потоки, створені :func:"
"`current_thread`. Він виключає завершені потоки та потоки, які ще не "
"розпочато. Однак основний потік завжди є частиною результату, навіть якщо "
"він завершується."

#: ../../library/threading.rst:213
msgid ""
"Return the main :class:`Thread` object.  In normal conditions, the main "
"thread is the thread from which the Python interpreter was started."
msgstr ""
"Повертає головний об’єкт :class:`Thread`. У нормальних умовах основний потік "
"— це потік, з якого було запущено інтерпретатор Python."

#: ../../library/threading.rst:224
msgid ""
"Set a trace function for all threads started from the :mod:`!threading` "
"module. The *func* will be passed to  :func:`sys.settrace` for each thread, "
"before its :meth:`~Thread.run` method is called."
msgstr ""
"为所有从 :mod:`!threading` 模块启动的线程设置追踪函数，在每个线程的 :meth:"
"`~Thread.run` 方法被调用前，*func* 会被传递给 :func:`sys.settrace`。"

#: ../../library/threading.rst:230
msgid ""
"Set a trace function for all threads started from the :mod:`!threading` "
"module and all Python threads that are currently executing."
msgstr ""
"为从 :mod:`!threading` 模块启动的所有线程以及当前正在执行的所有 Python 线程设"
"置追踪函数。"

#: ../../library/threading.rst:233
msgid ""
"The *func* will be passed to  :func:`sys.settrace` for each thread, before "
"its :meth:`~Thread.run` method is called."
msgstr ""
"*func* будет передана в :func:`sys.settrace` для каждого потока перед "
"вызовом его метода :meth:`~Thread.run`."

#: ../../library/threading.rst:244
msgid "Get the trace function as set by :func:`settrace`."
msgstr "Отримайте функцію трасування, встановлену :func:`settrace`."

#: ../../library/threading.rst:253
msgid ""
"Set a profile function for all threads started from the :mod:`!threading` "
"module. The *func* will be passed to  :func:`sys.setprofile` for each "
"thread, before its :meth:`~Thread.run` method is called."
msgstr ""
"为从 :mod:`!threading` 模块启动的所有线程设置性能分析函数。 在每个线程的 :"
"meth:`~Thread.run` 方法被调用前，*func* 会被传递给 :func:`sys.setprofile`。"

#: ../../library/threading.rst:259
msgid ""
"Set a profile function for all threads started from the :mod:`!threading` "
"module and all Python threads that are currently executing."
msgstr ""
"为从 :mod:`!threading` 模块启动的所有线程和当前正在执行和的所有 Python 线程设"
"置性能分析函数。"

#: ../../library/threading.rst:262
msgid ""
"The *func* will be passed to  :func:`sys.setprofile` for each thread, before "
"its :meth:`~Thread.run` method is called."
msgstr ""
"*func* будет передаваться в :func:`sys.setprofile` для каждого потока перед "
"вызовом его метода :meth:`~Thread.run`."

#: ../../library/threading.rst:271
msgid "Get the profiler function as set by :func:`setprofile`."
msgstr "Отримайте функцію профайлера, встановлену :func:`setprofile`."

#: ../../library/threading.rst:278
msgid ""
"Return the thread stack size used when creating new threads.  The optional "
"*size* argument specifies the stack size to be used for subsequently created "
"threads, and must be 0 (use platform or configured default) or a positive "
"integer value of at least 32,768 (32 KiB). If *size* is not specified, 0 is "
"used.  If changing the thread stack size is unsupported, a :exc:"
"`RuntimeError` is raised.  If the specified stack size is invalid, a :exc:"
"`ValueError` is raised and the stack size is unmodified.  32 KiB is "
"currently the minimum supported stack size value to guarantee sufficient "
"stack space for the interpreter itself.  Note that some platforms may have "
"particular restrictions on values for the stack size, such as requiring a "
"minimum stack size > 32 KiB or requiring allocation in multiples of the "
"system memory page size - platform documentation should be referred to for "
"more information (4 KiB pages are common; using multiples of 4096 for the "
"stack size is the suggested approach in the absence of more specific "
"information)."
msgstr ""
"Повертає розмір стека потоків, який використовувався під час створення нових "
"потоків. Необов’язковий аргумент *size* визначає розмір стека, який буде "
"використовуватися для згодом створених потоків, і має дорівнювати 0 "
"(використовувати платформу або налаштоване за замовчуванням) або додатне "
"ціле значення принаймні 32 768 (32 КіБ). Якщо *size* не вказано, "
"використовується 0. Якщо зміна розміру стека потоку не підтримується, "
"виникає :exc:`RuntimeError`. Якщо вказаний розмір стека недійсний, виникає "
"помилка :exc:`ValueError` і розмір стека не змінюється. 32 КіБ наразі є "
"мінімальним підтримуваним значенням розміру стеку, щоб гарантувати достатній "
"простір стеку для самого інтерпретатора. Зауважте, що деякі платформи можуть "
"мати певні обмеження щодо значень розміру стека, як-от вимагати мінімальний "
"розмір стека > 32 КБ або вимагати виділення кратного розміру сторінки "
"системної пам’яті – для отримання додаткової інформації слід звернутися до "
"документації платформи (сторінки 4 КБ є поширеними; використання кратних "
"4096 для розміру стека є запропонованим підходом за відсутності більш "
"конкретної інформації)."

#: ../../library/threading.rst:295
msgid "Unix platforms with POSIX threads support."
msgstr "Платформы Unix с поддержкой потоков POSIX."

#: ../../library/threading.rst:298
msgid "This module also defines the following constant:"
msgstr "Цей модуль також визначає таку константу:"

#: ../../library/threading.rst:302
msgid ""
"The maximum value allowed for the *timeout* parameter of blocking functions "
"(:meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Condition.wait`, etc.). "
"Specifying a timeout greater than this value will raise an :exc:"
"`OverflowError`."
msgstr ""
"Максимально допустиме значення для параметра *timeout* функцій блокування (:"
"meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Condition.wait` тощо). "
"Якщо вказати час очікування, більший за це значення, виникне :exc:"
"`OverflowError`."

#: ../../library/threading.rst:310
msgid ""
"This module defines a number of classes, which are detailed in the sections "
"below."
msgstr "Цей модуль визначає ряд класів, які детально описані в розділах нижче."

#: ../../library/threading.rst:313
msgid ""
"The design of this module is loosely based on Java's threading model. "
"However, where Java makes locks and condition variables basic behavior of "
"every object, they are separate objects in Python.  Python's :class:`Thread` "
"class supports a subset of the behavior of Java's Thread class; currently, "
"there are no priorities, no thread groups, and threads cannot be destroyed, "
"stopped, suspended, resumed, or interrupted.  The static methods of Java's "
"Thread class, when implemented, are mapped to module-level functions."
msgstr ""
"Конструкція цього модуля базується на моделі потоків Java. Однак, коли Java "
"робить блокування та змінні умови базовою поведінкою кожного об’єкта, у "
"Python вони є окремими об’єктами. Клас :class:`Thread` Python підтримує "
"підмножину поведінки класу Thread Java; на даний момент немає пріоритетів, "
"немає груп потоків, і потоки не можна знищити, зупинити, призупинити, "
"відновити або перервати. Статичні методи класу Thread Java, коли вони "
"реалізовані, відображаються на функції рівня модуля."

#: ../../library/threading.rst:321
msgid "All of the methods described below are executed atomically."
msgstr "Усі методи, описані нижче, виконуються атомарно."

#: ../../library/threading.rst:325
msgid "Thread-local data"
msgstr "线程局部数据"

#: ../../library/threading.rst:327
msgid ""
"Thread-local data is data whose values are thread specific. If you have data "
"that you want to be local to a thread, create a :class:`local` object and "
"use its attributes::"
msgstr ""
"线程局部数据是指具有线程专属值的数据。 如果你希望某些数据是线程局部数据，则创"
"建一个 :class:`local` 对象并使用其属性::"

#: ../../library/threading.rst:331
msgid ""
">>> mydata = local()\n"
">>> mydata.number = 42\n"
">>> mydata.number\n"
"42"
msgstr ""
">>> mydata = local()\n"
">>> mydata.number = 42\n"
">>> mydata.number\n"
"42"

#: ../../library/threading.rst:336
msgid "You can also access the :class:`local`-object's dictionary::"
msgstr "你也可以访问 :class:`local` 对象的字典::"

#: ../../library/threading.rst:338
msgid ""
">>> mydata.__dict__\n"
"{'number': 42}\n"
">>> mydata.__dict__.setdefault('widgets', [])\n"
"[]\n"
">>> mydata.widgets\n"
"[]"
msgstr ""
">>> mydata.__dict__\n"
"{'number': 42}\n"
">>> mydata.__dict__.setdefault('widgets', [])\n"
"[]\n"
">>> mydata.widgets\n"
"[]"

#: ../../library/threading.rst:345
msgid "If we access the data in a different thread::"
msgstr "如果我们在另一个线程中访问此数据::"

#: ../../library/threading.rst:347
msgid ""
">>> log = []\n"
">>> def f():\n"
"...     items = sorted(mydata.__dict__.items())\n"
"...     log.append(items)\n"
"...     mydata.number = 11\n"
"...     log.append(mydata.number)\n"
"\n"
">>> import threading\n"
">>> thread = threading.Thread(target=f)\n"
">>> thread.start()\n"
">>> thread.join()\n"
">>> log\n"
"[[], 11]"
msgstr ""
">>> log = []\n"
">>> def f():\n"
"...     items = sorted(mydata.__dict__.items())\n"
"...     log.append(items)\n"
"...     mydata.number = 11\n"
"...     log.append(mydata.number)\n"
"\n"
">>> import threading\n"
">>> thread = threading.Thread(target=f)\n"
">>> thread.start()\n"
">>> thread.join()\n"
">>> log\n"
"[[], 11]"

#: ../../library/threading.rst:361
msgid ""
"we get different data.  Furthermore, changes made in the other thread don't "
"affect data seen in this thread::"
msgstr ""
"我们将得到不同的数据。 此外，在其他线程中进行的修改也不会影响在本线程中看到的"
"数据::"

#: ../../library/threading.rst:364
msgid ""
">>> mydata.number\n"
"42"
msgstr ""
">>> mydata.number\n"
"42"

#: ../../library/threading.rst:367
msgid ""
"Of course, values you get from a :class:`local` object, including their :"
"attr:`~object.__dict__` attribute, are for whatever thread was current at "
"the time the attribute was read.  For that reason, you generally don't want "
"to save these values across threads, as they apply only to the thread they "
"came from."
msgstr ""
"当然，你从 :class:`local` 对象获取的值，包括其 :attr:`~object.__dict__` 属"
"性，都只针对属性被读取时的当前线程。 出于此理由，通常你不会跨线程保存这些值，"
"因为它们仅适用于它们所在的线程。"

#: ../../library/threading.rst:373
msgid ""
"You can create custom :class:`local` objects by subclassing the :class:"
"`local` class::"
msgstr "你可以通过子类化 :class:`local` 类来创建自定义的 :class:`local` 对象::"

#: ../../library/threading.rst:376
msgid ""
">>> class MyLocal(local):\n"
"...     number = 2\n"
"...     def __init__(self, /, **kw):\n"
"...         self.__dict__.update(kw)\n"
"...     def squared(self):\n"
"...         return self.number ** 2"
msgstr ""
">>> class MyLocal(local):\n"
"...     number = 2\n"
"...     def __init__(self, /, **kw):\n"
"...         self.__dict__.update(kw)\n"
"...     def squared(self):\n"
"...         return self.number ** 2"

#: ../../library/threading.rst:383
msgid ""
"This can be useful to support default values, methods and initialization.  "
"Note that if you define an :py:meth:`~object.__init__` method, it will be "
"called each time the :class:`local` object is used in a separate thread.  "
"This is necessary to initialize each thread's dictionary."
msgstr ""
"这适用于提供默认值、方法和初始化支持。 请注意如果你定义了 :py:meth:`~object."
"__init__` 方法，则每当该 :class:`local` 对象在不同线程中被使用时都将调用它。 "
"这对于初始化每个线程的字典是必要的。"

#: ../../library/threading.rst:389
msgid "Now if we create a :class:`local` object::"
msgstr "现在如果我们创建一个 :class:`local` 对象::"

#: ../../library/threading.rst:391
msgid ">>> mydata = MyLocal(color='red')"
msgstr ">>> mydata = MyLocal(color='red')"

#: ../../library/threading.rst:393
msgid "we have a default number::"
msgstr "我们将有一个默认的 number 值::"

#: ../../library/threading.rst:395
msgid ""
">>> mydata.number\n"
"2"
msgstr ""
">>> mydata.number\n"
"2"

#: ../../library/threading.rst:398
msgid "an initial color::"
msgstr "一个初始的 color 值::"

#: ../../library/threading.rst:400
msgid ""
">>> mydata.color\n"
"'red'\n"
">>> del mydata.color"
msgstr ""
">>> mydata.color\n"
"'red'\n"
">>> del mydata.color"

#: ../../library/threading.rst:404
msgid "And a method that operates on the data::"
msgstr "以及一个操作数据的方法::"

#: ../../library/threading.rst:406
msgid ""
">>> mydata.squared()\n"
"4"
msgstr ""
">>> mydata.squared()\n"
"4"

#: ../../library/threading.rst:409
msgid "As before, we can access the data in a separate thread::"
msgstr "像之前一样，我们可以在不同的线程中访问该数据::"

#: ../../library/threading.rst:411
msgid ""
">>> log = []\n"
">>> thread = threading.Thread(target=f)\n"
">>> thread.start()\n"
">>> thread.join()\n"
">>> log\n"
"[[('color', 'red')], 11]"
msgstr ""
">>> log = []\n"
">>> thread = threading.Thread(target=f)\n"
">>> thread.start()\n"
">>> thread.join()\n"
">>> log\n"
"[[('color', 'red')], 11]"

#: ../../library/threading.rst:418
msgid "without affecting this thread's data::"
msgstr "而不会影响本线程的数据::"

#: ../../library/threading.rst:420
msgid ""
">>> mydata.number\n"
"2\n"
">>> mydata.color\n"
"Traceback (most recent call last):\n"
"...\n"
"AttributeError: 'MyLocal' object has no attribute 'color'"
msgstr ""
">>> mydata.number\n"
"2\n"
">>> mydata.color\n"
"Traceback (most recent call last):\n"
"...\n"
"AttributeError: 'MyLocal' object has no attribute 'color'"

#: ../../library/threading.rst:427
msgid ""
"Note that subclasses can define :term:`__slots__`, but they are not thread "
"local. They are shared across threads::"
msgstr ""
"请注意子类可以定义 :term:`__slots__`，但它们不是线程局部的。 它们会被跨线程共"
"享::"

#: ../../library/threading.rst:430
msgid ""
">>> class MyLocal(local):\n"
"...     __slots__ = 'number'\n"
"\n"
">>> mydata = MyLocal()\n"
">>> mydata.number = 42\n"
">>> mydata.color = 'red'"
msgstr ""
">>> class MyLocal(local):\n"
"...     __slots__ = 'number'\n"
"\n"
">>> mydata = MyLocal()\n"
">>> mydata.number = 42\n"
">>> mydata.color = 'red'"

#: ../../library/threading.rst:437
msgid "So, the separate thread::"
msgstr "因此，不同的线程::"

#: ../../library/threading.rst:439
msgid ""
">>> thread = threading.Thread(target=f)\n"
">>> thread.start()\n"
">>> thread.join()"
msgstr ""
">>> thread = threading.Thread(target=f)\n"
">>> thread.start()\n"
">>> thread.join()"

#: ../../library/threading.rst:443
msgid "affects what we see::"
msgstr "会影响我们的值::"

#: ../../library/threading.rst:445
msgid ""
">>> mydata.number\n"
"11"
msgstr ""
">>> mydata.number\n"
"11"

#: ../../library/threading.rst:451
msgid "A class that represents thread-local data."
msgstr "Клас, який представляє дані локального потоку."

#: ../../library/threading.rst:457
msgid "Thread objects"
msgstr "线程对象"

#: ../../library/threading.rst:459
msgid ""
"The :class:`Thread` class represents an activity that is run in a separate "
"thread of control.  There are two ways to specify the activity: by passing a "
"callable object to the constructor, or by overriding the :meth:`~Thread.run` "
"method in a subclass.  No other methods (except for the constructor) should "
"be overridden in a subclass.  In other words, *only*  override the "
"``__init__()`` and :meth:`~Thread.run` methods of this class."
msgstr ""
"Класс :class:`Thread` представляет собой действие, которое выполняется в "
"отдельном потоке управления. Есть два способа указать действие: передать "
"вызываемый объект конструктору или переопределить метод :meth:`~Thread.run` "
"в подклассе. Никакие другие методы (кроме конструктора) не должны "
"переопределяться в подклассе. Другими словами, *только* переопределяются "
"методы ``__init__()`` и :meth:`~Thread.run` этого класса."

#: ../../library/threading.rst:466
msgid ""
"Once a thread object is created, its activity must be started by calling the "
"thread's :meth:`~Thread.start` method.  This invokes the :meth:`~Thread.run` "
"method in a separate thread of control."
msgstr ""
"Після створення об’єкта потоку його діяльність має бути запущена викликом "
"методу потоку :meth:`~Thread.start`. Це викликає метод :meth:`~Thread.run` в "
"окремому потоці керування."

#: ../../library/threading.rst:470
msgid ""
"Once the thread's activity is started, the thread is considered 'alive'. It "
"stops being alive when its :meth:`~Thread.run` method terminates -- either "
"normally, or by raising an unhandled exception.  The :meth:`~Thread."
"is_alive` method tests whether the thread is alive."
msgstr ""
"Коли активність потоку розпочато, він вважається \"живим\". Він перестає "
"бути живим, коли його метод :meth:`~Thread.run` завершує роботу - або "
"звичайним способом, або шляхом виклику необробленого винятку. Метод :meth:"
"`~Thread.is_alive` перевіряє, чи живий потік."

#: ../../library/threading.rst:475
msgid ""
"Other threads can call a thread's :meth:`~Thread.join` method.  This blocks "
"the calling thread until the thread whose :meth:`~Thread.join` method is "
"called is terminated."
msgstr ""
"Інші потоки можуть викликати метод потоку :meth:`~Thread.join`. Це блокує "
"потік, що викликає, доки не буде завершено потік, чий метод :meth:`~Thread."
"join` викликається."

#: ../../library/threading.rst:479
msgid ""
"A thread has a name.  The name can be passed to the constructor, and read or "
"changed through the :attr:`~Thread.name` attribute."
msgstr ""
"Нитка має назву. Ім’я можна передати конструктору та прочитати або змінити "
"за допомогою атрибута :attr:`~Thread.name`."

#: ../../library/threading.rst:482
msgid ""
"If the :meth:`~Thread.run` method raises an exception, :func:`threading."
"excepthook` is called to handle it. By default, :func:`threading.excepthook` "
"ignores silently :exc:`SystemExit`."
msgstr ""
"Якщо метод :meth:`~Thread.run` викликає виняток, для його обробки "
"викликається :func:`threading.excepthook`. За замовчуванням :func:`threading."
"excepthook` мовчки ігнорує :exc:`SystemExit`."

#: ../../library/threading.rst:486
msgid ""
"A thread can be flagged as a \"daemon thread\".  The significance of this "
"flag is that the entire Python program exits when only daemon threads are "
"left.  The initial value is inherited from the creating thread.  The flag "
"can be set through the :attr:`~Thread.daemon` property or the *daemon* "
"constructor argument."
msgstr ""
"Потік можна позначити як \"потік демона\". Значення цього прапорця полягає в "
"тому, що вся програма Python завершує роботу, коли залишаються лише потоки "
"демона. Початкове значення успадковується від потоку створення. Прапор можна "
"встановити через властивість :attr:`~Thread.daemon` або аргумент "
"конструктора *daemon*."

#: ../../library/threading.rst:493
msgid ""
"Daemon threads are abruptly stopped at shutdown.  Their resources (such as "
"open files, database transactions, etc.) may not be released properly. If "
"you want your threads to stop gracefully, make them non-daemonic and use a "
"suitable signalling mechanism such as an :class:`Event`."
msgstr ""
"Потоки демона раптово зупиняються під час завершення роботи. Їхні ресурси "
"(такі як відкриті файли, транзакції бази даних тощо) можуть не вивільнятися "
"належним чином. Якщо ви хочете, щоб ваші потоки зупинялися акуратно, зробіть "
"їх недемонічними та використовуйте відповідний механізм сигналізації, такий "
"як :class:`Event`."

#: ../../library/threading.rst:498
msgid ""
"There is a \"main thread\" object; this corresponds to the initial thread of "
"control in the Python program.  It is not a daemon thread."
msgstr ""
"Є об’єкт \"основний потік\"; це відповідає початковому потоку керування в "
"програмі Python. Це не потік демона."

#: ../../library/threading.rst:501
msgid ""
"There is the possibility that \"dummy thread objects\" are created. These "
"are thread objects corresponding to \"alien threads\", which are threads of "
"control started outside the threading module, such as directly from C code.  "
"Dummy thread objects have limited functionality; they are always considered "
"alive and daemonic, and cannot be :ref:`joined <meth-thread-join>`.  They "
"are never deleted, since it is impossible to detect the termination of alien "
"threads."
msgstr ""
"Существует вероятность создания «фиктивных объектов потока». Это объекты "
"потоков, соответствующие «чужим потокам», которые представляют собой потоки "
"управления, запускаемые вне модуля потоков, например, непосредственно из "
"кода C. Объекты фиктивного потока имеют ограниченную функциональность; они "
"всегда считаются живыми и демоническими и не могут быть :ref:`присоединены к "
"<meth-thread-join>`. Они никогда не удаляются, так как невозможно обнаружить "
"завершение чужих потоков."

#: ../../library/threading.rst:512
msgid ""
"This constructor should always be called with keyword arguments.  Arguments "
"are:"
msgstr ""
"Цей конструктор слід завжди викликати з ключовими аргументами. Аргументами є:"

#: ../../library/threading.rst:515
msgid ""
"*group* should be ``None``; reserved for future extension when a :class:`!"
"ThreadGroup` class is implemented."
msgstr ""
"*group* должно быть ``None``; зарезервировано для будущего расширения при "
"реализации класса :class:`!ThreadGroup`."

#: ../../library/threading.rst:518
msgid ""
"*target* is the callable object to be invoked by the :meth:`run` method. "
"Defaults to ``None``, meaning nothing is called."
msgstr ""
"*target* — об’єкт, який викликається методом :meth:`run`. За замовчуванням "
"``None``, тобто нічого не викликається."

#: ../../library/threading.rst:521
msgid ""
"*name* is the thread name. By default, a unique name is constructed of the "
"form \"Thread-*N*\" where *N* is a small decimal number, or \"Thread-*N* "
"(target)\" where \"target\" is ``target.__name__`` if the *target* argument "
"is specified."
msgstr ""
"*ім’я* – це ім’я потоку. За замовчуванням унікальне ім’я створюється у формі "
"\"Thread-*N*\", де *N* — маленьке десяткове число, або \"Thread-*N* "
"(target)\", де \"target\" — це ``target.__name__`` якщо вказано аргумент "
"*target*."

#: ../../library/threading.rst:526
msgid ""
"*args* is a list or tuple of arguments for the target invocation.  Defaults "
"to ``()``."
msgstr ""
"*args* — это список или кортеж аргументов для целевого вызова. По умолчанию "
"``()``."

#: ../../library/threading.rst:528
msgid ""
"*kwargs* is a dictionary of keyword arguments for the target invocation. "
"Defaults to ``{}``."
msgstr ""
"*kwargs* — це словник ключових аргументів для цільового виклику. За "
"замовчуванням ``{}``."

#: ../../library/threading.rst:531
msgid ""
"If not ``None``, *daemon* explicitly sets whether the thread is daemonic. If "
"``None`` (the default), the daemonic property is inherited from the current "
"thread."
msgstr ""
"Якщо не ``None``, *daemon* явно встановлює, чи є потік демонічним. Якщо "
"``None`` (за замовчуванням), демонічна властивість успадковується з "
"поточного потоку."

#: ../../library/threading.rst:535
msgid ""
"If the subclass overrides the constructor, it must make sure to invoke the "
"base class constructor (``Thread.__init__()``) before doing anything else to "
"the thread."
msgstr ""
"Якщо підклас перевизначає конструктор, він повинен обов’язково викликати "
"конструктор базового класу (``Thread.__init__()``), перш ніж робити щось "
"інше з потоком."

#: ../../library/threading.rst:539
msgid "Added the *daemon* parameter."
msgstr "Добавлен параметр *daemon*."

#: ../../library/threading.rst:542
msgid "Use the *target* name if *name* argument is omitted."
msgstr "Використовуйте назву *ціль*, якщо аргумент *ім’я* пропущено."

#: ../../library/threading.rst:547
msgid "Start the thread's activity."
msgstr "Розпочати діяльність потоку."

#: ../../library/threading.rst:549
msgid ""
"It must be called at most once per thread object.  It arranges for the "
"object's :meth:`~Thread.run` method to be invoked in a separate thread of "
"control."
msgstr ""
"Він має бути викликаний щонайбільше один раз на об’єкт потоку. Він "
"організовує виклик методу :meth:`~Thread.run` об’єкта в окремому потоці "
"керування."

#: ../../library/threading.rst:553
msgid ""
"This method will raise a :exc:`RuntimeError` if called more than once on the "
"same thread object."
msgstr ""
"Цей метод викличе :exc:`RuntimeError`, якщо викликати кілька разів для того "
"самого об’єкта потоку."

#: ../../library/threading.rst:558
msgid "Method representing the thread's activity."
msgstr "Метод, що представляє діяльність потоку."

#: ../../library/threading.rst:560
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method "
"invokes the callable object passed to the object's constructor as the "
"*target* argument, if any, with positional and keyword arguments taken from "
"the *args* and *kwargs* arguments, respectively."
msgstr ""
"Ви можете перевизначити цей метод у підкласі. Стандартний метод :meth:`run` "
"викликає викликаний об’єкт, який передається конструктору об’єкта як "
"аргумент *target*, якщо такий є, з позиційними аргументами та ключовими "
"аргументами, взятими з аргументів *args* і *kwargs* відповідно."

#: ../../library/threading.rst:565
msgid ""
"Using list or tuple as the *args* argument which passed to the :class:"
"`Thread` could achieve the same effect."
msgstr ""
"Использование списка или кортежа в качестве аргумента *args*, передаваемого "
"в :class:`Thread`, может привести к такому же эффекту."

#: ../../library/threading.rst:568
msgid "Example::"
msgstr "مثال::"

#: ../../library/threading.rst:570
msgid ""
">>> from threading import Thread\n"
">>> t = Thread(target=print, args=[1])\n"
">>> t.run()\n"
"1\n"
">>> t = Thread(target=print, args=(1,))\n"
">>> t.run()\n"
"1"
msgstr ""
">>> from threading import Thread\n"
">>> t = Thread(target=print, args=[1])\n"
">>> t.run()\n"
"1\n"
">>> t = Thread(target=print, args=(1,))\n"
">>> t.run()\n"
"1"

#: ../../library/threading.rst:582
msgid ""
"Wait until the thread terminates. This blocks the calling thread until the "
"thread whose :meth:`~Thread.join` method is called terminates -- either "
"normally or through an unhandled exception -- or until the optional timeout "
"occurs."
msgstr ""
"Зачекайте, поки потік завершиться. Це блокує потік, що викликає, доки потік, "
"чий метод :meth:`~Thread.join` викликається, не завершиться (звичайно або "
"через необроблений виняток), або доки не настане додатковий час очікування."

#: ../../library/threading.rst:587
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating-point number specifying a timeout for the operation in seconds (or "
"fractions thereof). As :meth:`~Thread.join` always returns ``None``, you "
"must call :meth:`~Thread.is_alive` after :meth:`~Thread.join` to decide "
"whether a timeout happened -- if the thread is still alive, the :meth:"
"`~Thread.join` call timed out."
msgstr ""
"Если присутствует аргумент *timeout*, а не ``None``, это должно быть число с "
"плавающей запятой, определяющее таймаут для операции в секундах (или их "
"долях). Поскольку :meth:`~Thread.join` всегда возвращает ``None``, вы должны "
"вызвать :meth:`~Thread.is_alive` после :meth:`~Thread.join`, чтобы "
"определить, произошел ли таймаут - если поток все еще жив, время ожидания "
"вызова :meth:`~Thread.join` истекло."

#: ../../library/threading.rst:594
msgid ""
"When the *timeout* argument is not present or ``None``, the operation will "
"block until the thread terminates."
msgstr ""
"Якщо аргумент *timeout* відсутній або ``None``, операція буде заблокована до "
"завершення потоку."

#: ../../library/threading.rst:597
msgid "A thread can be joined many times."
msgstr "Поток можно объединять много раз."

#: ../../library/threading.rst:599
msgid ""
":meth:`~Thread.join` raises a :exc:`RuntimeError` if an attempt is made to "
"join the current thread as that would cause a deadlock. It is also an error "
"to :meth:`~Thread.join` a thread before it has been started and attempts to "
"do so raise the same exception."
msgstr ""
":meth:`~Thread.join` викликає :exc:`RuntimeError`, якщо робиться спроба "
"приєднатися до поточного потоку, оскільки це призведе до взаємоблокування. "
"Також є помилкою :meth:`~Thread.join` потоку до того, як він був запущений, "
"і спроби зробити це викликають той самий виняток."

#: ../../library/threading.rst:606
msgid ""
"A string used for identification purposes only. It has no semantics. "
"Multiple threads may be given the same name.  The initial name is set by the "
"constructor."
msgstr ""
"Рядок, який використовується лише для ідентифікації. Він не має семантики. "
"Декільком потокам можна присвоїти однакові назви. Початкове ім'я задається "
"конструктором."

#: ../../library/threading.rst:613
msgid ""
"Deprecated getter/setter API for :attr:`~Thread.name`; use it directly as a "
"property instead."
msgstr ""
"Застарілий API отримання/налаштування для :attr:`~Thread.name`; "
"використовуйте його безпосередньо як властивість."

#: ../../library/threading.rst:620
msgid ""
"The 'thread identifier' of this thread or ``None`` if the thread has not "
"been started.  This is a nonzero integer.  See the :func:`get_ident` "
"function.  Thread identifiers may be recycled when a thread exits and "
"another thread is created.  The identifier is available even after the "
"thread has exited."
msgstr ""
"\"Ідентифікатор потоку\" цього потоку або \"Немає\", якщо потік не було "
"запущено. Це ненульове ціле число. Перегляньте функцію :func:`get_ident`. "
"Ідентифікатори потоку можуть бути перероблені, коли потік завершується та "
"створюється інший. Ідентифікатор доступний навіть після завершення потоку."

#: ../../library/threading.rst:628
msgid ""
"The Thread ID (``TID``) of this thread, as assigned by the OS (kernel). This "
"is a non-negative integer, or ``None`` if the thread has not been started. "
"See the :func:`get_native_id` function. This value may be used to uniquely "
"identify this particular thread system-wide (until the thread terminates, "
"after which the value may be recycled by the OS)."
msgstr ""
"Ідентифікатор потоку (``TID``) цього потоку, призначений ОС (ядром). Це "
"невід’ємне ціле число або ``None``, якщо потік не було запущено. Перегляньте "
"функцію :func:`get_native_id`. Це значення може використовуватися для "
"унікальної ідентифікації цього конкретного потоку в усій системі (доки потік "
"не завершиться, після чого значення може бути повторно використано ОС)."

#: ../../library/threading.rst:637
msgid ""
"Similar to Process IDs, Thread IDs are only valid (guaranteed unique system-"
"wide) from the time the thread is created until the thread has been "
"terminated."
msgstr ""
"Подібно до ідентифікаторів процесів, ідентифікатори потоків дійсні "
"(гарантовано унікальні для всієї системи) лише з моменту створення потоку до "
"його завершення."

#: ../../library/threading.rst:647
msgid "Return whether the thread is alive."
msgstr "Повернути, чи живий потік."

#: ../../library/threading.rst:649
msgid ""
"This method returns ``True`` just before the :meth:`~Thread.run` method "
"starts until just after the :meth:`~Thread.run` method terminates.  The "
"module function :func:`.enumerate` returns a list of all alive threads."
msgstr ""
"Цей метод повертає ``True`` безпосередньо перед запуском методу :meth:"
"`~Thread.run` до завершення роботи методу :meth:`~Thread.run`. Функція "
"модуля :func:`.enumerate` повертає список усіх активних потоків."

#: ../../library/threading.rst:655
msgid ""
"A boolean value indicating whether this thread is a daemon thread (``True``) "
"or not (``False``).  This must be set before :meth:`~Thread.start` is "
"called, otherwise :exc:`RuntimeError` is raised.  Its initial value is "
"inherited from the creating thread; the main thread is not a daemon thread "
"and therefore all threads created in the main thread default to :attr:"
"`~Thread.daemon` = ``False``."
msgstr ""
"Логічне значення, яке вказує, чи є цей потік потоком демона (``True``) чи ні "
"(``False``). Це має бути встановлено перед викликом :meth:`~Thread.start`, "
"інакше виникає :exc:`RuntimeError`. Його початкове значення успадковується "
"від потоку створення; основний потік не є потоком демона, тому всі потоки, "
"створені в основному потоці, за замовчуванням мають :attr:`~Thread.daemon` = "
"``False``."

#: ../../library/threading.rst:662
msgid ""
"The entire Python program exits when no alive non-daemon threads are left."
msgstr ""
"Уся програма Python завершує роботу, якщо не залишиться активних потоків, "
"які не є демонами."

#: ../../library/threading.rst:667
msgid ""
"Deprecated getter/setter API for :attr:`~Thread.daemon`; use it directly as "
"a property instead."
msgstr ""
"Застарілий API отримання/налаштування для :attr:`~Thread.daemon`; "
"використовуйте його безпосередньо як властивість."

#: ../../library/threading.rst:676
msgid "Lock objects"
msgstr "Lock 对象"

#: ../../library/threading.rst:678
msgid ""
"A primitive lock is a synchronization primitive that is not owned by a "
"particular thread when locked.  In Python, it is currently the lowest level "
"synchronization primitive available, implemented directly by the :mod:"
"`_thread` extension module."
msgstr ""
"Примітивне блокування — це примітив синхронізації, який не належить певному "
"потоку, коли він заблокований. У Python наразі це найнижчий доступний "
"примітив синхронізації рівня, реалізований безпосередньо модулем розширення :"
"mod:`_thread`."

#: ../../library/threading.rst:683
msgid ""
"A primitive lock is in one of two states, \"locked\" or \"unlocked\". It is "
"created in the unlocked state.  It has two basic methods, :meth:`~Lock."
"acquire` and :meth:`~Lock.release`.  When the state is unlocked, :meth:"
"`~Lock.acquire` changes the state to locked and returns immediately.  When "
"the state is locked, :meth:`~Lock.acquire` blocks until a call to :meth:"
"`~Lock.release` in another thread changes it to unlocked, then the :meth:"
"`~Lock.acquire` call resets it to locked and returns.  The :meth:`~Lock."
"release` method should only be called in the locked state; it changes the "
"state to unlocked and returns immediately. If an attempt is made to release "
"an unlocked lock, a :exc:`RuntimeError` will be raised."
msgstr ""
"Примітивний замок знаходиться в одному з двох станів: \"заблоковано\" або "
"\"розблоковано\". Створюється в розблокованому стані. Він має два основні "
"методи: :meth:`~Lock.acquire` і :meth:`~Lock.release`. Коли стан "
"розблоковано, :meth:`~Lock.acquire` змінює стан на заблокований і повертає "
"негайно. Коли стан заблоковано, :meth:`~Lock.acquire` блокується, доки "
"виклик :meth:`~Lock.release` в іншому потоці не змінить його на "
"розблокований, після чого виклик :meth:`~Lock.acquire` скидається він "
"блокується та повертається. Метод :meth:`~Lock.release` слід викликати лише "
"в заблокованому стані; він змінює стан на розблокований і негайно "
"повертається. Якщо буде зроблена спроба зняти розблоковане блокування, буде "
"викликано :exc:`RuntimeError`."

#: ../../library/threading.rst:694
msgid "Locks also support the :ref:`context management protocol <with-locks>`."
msgstr ""
"Блокування також підтримують :ref:`протокол управління контекстом <with-"
"locks>`."

#: ../../library/threading.rst:696
msgid ""
"When more than one thread is blocked in :meth:`~Lock.acquire` waiting for "
"the state to turn to unlocked, only one thread proceeds when a :meth:`~Lock."
"release` call resets the state to unlocked; which one of the waiting threads "
"proceeds is not defined, and may vary across implementations."
msgstr ""
"Якщо в :meth:`~Lock.acquire` заблоковано більше одного потоку, який очікує, "
"поки стан стане розблокованим, лише один потік продовжує роботу, коли "
"виклик :meth:`~Lock.release` скидає стан до розблокованого; який із потоків, "
"що очікують, продовжується, не визначено та може відрізнятися в різних "
"реалізаціях."

#: ../../library/threading.rst:701
msgid "All methods are executed atomically."
msgstr "Усі методи виконуються атомарно."

#: ../../library/threading.rst:706
msgid ""
"The class implementing primitive lock objects.  Once a thread has acquired a "
"lock, subsequent attempts to acquire it block, until it is released; any "
"thread may release it."
msgstr ""
"Клас, що реалізує примітивні об’єкти блокування. Після того, як потік "
"отримав блокування, наступні спроби отримати його блокуються, доки він не "
"буде звільнений; будь-який потік може його звільнити."

#: ../../library/threading.rst:710
msgid ""
"``Lock`` is now a class. In earlier Pythons, ``Lock`` was a factory function "
"which returned an instance of the underlying private lock type."
msgstr ""
"``Lock`` теперь является классом. В более ранних версиях Python Lock была "
"фабричной функцией, которая возвращала экземпляр базового типа частной "
"блокировки."

#: ../../library/threading.rst:718 ../../library/threading.rst:809
msgid "Acquire a lock, blocking or non-blocking."
msgstr "Отримайте блокування, блокування або неблокування."

#: ../../library/threading.rst:720
msgid ""
"When invoked with the *blocking* argument set to ``True`` (the default), "
"block until the lock is unlocked, then set it to locked and return ``True``."
msgstr ""
"При виклику з аргументом *blocking*, встановленим на ``True`` (за "
"замовчуванням), блокувати, доки блокування не буде розблоковано, потім "
"установіть його на locked і поверніть ``True``."

#: ../../library/threading.rst:723
msgid ""
"When invoked with the *blocking* argument set to ``False``, do not block. If "
"a call with *blocking* set to ``True`` would block, return ``False`` "
"immediately; otherwise, set the lock to locked and return ``True``."
msgstr ""
"При виклику з аргументом *blocking*, встановленим на ``False``, не "
"блокувати. Якщо виклик із *блокуванням*, встановленим на ``True``, заблокує, "
"негайно поверніть ``False``; інакше встановіть блокування на locked і "
"поверніть ``True``."

#: ../../library/threading.rst:727
msgid ""
"When invoked with the floating-point *timeout* argument set to a positive "
"value, block for at most the number of seconds specified by *timeout* and as "
"long as the lock cannot be acquired.  A *timeout* argument of ``-1`` "
"specifies an unbounded wait.  It is forbidden to specify a *timeout* when "
"*blocking* is ``False``."
msgstr ""
"Під час виклику з плаваючою комою *timeout* аргументу встановлено додатне "
"значення, блокувати щонайбільше на кількість секунд, визначену *timeout*, і "
"до тих пір, поки блокування не може бути отримано. Аргумент *timeout*, "
"рівний ``-1``, визначає необмежену очікування. Заборонено вказувати *тайм-"
"аут*, якщо *блокування* має значення ``False``."

#: ../../library/threading.rst:733
msgid ""
"The return value is ``True`` if the lock is acquired successfully, ``False`` "
"if not (for example if the *timeout* expired)."
msgstr ""
"Поверненим значенням є ``True``, якщо блокування отримано успішно, "
"``False``, якщо ні (наприклад, якщо минув *тайм-аут*)."

#: ../../library/threading.rst:736 ../../library/threading.rst:847
#: ../../library/threading.rst:1094
msgid "The *timeout* parameter is new."
msgstr "Параметр *timeout* є новим."

#: ../../library/threading.rst:739
msgid ""
"Lock acquisition can now be interrupted by signals on POSIX if the "
"underlying threading implementation supports it."
msgstr ""
"Отримання блокування тепер може бути перервано сигналами на POSIX, якщо це "
"підтримує базова реалізація потоків."

#: ../../library/threading.rst:746
msgid ""
"Release a lock.  This can be called from any thread, not only the thread "
"which has acquired the lock."
msgstr ""
"Відпустіть блокування. Це можна викликати з будь-якого потоку, а не лише з "
"потоку, який отримав блокування."

#: ../../library/threading.rst:749
msgid ""
"When the lock is locked, reset it to unlocked, and return.  If any other "
"threads are blocked waiting for the lock to become unlocked, allow exactly "
"one of them to proceed."
msgstr ""
"Коли замок заблоковано, скиньте його до розблокованого та поверніться. Якщо "
"будь-які інші потоки заблоковано в очікуванні розблокування блокування, "
"дозвольте рівно одному з них продовжити."

#: ../../library/threading.rst:753
msgid "When invoked on an unlocked lock, a :exc:`RuntimeError` is raised."
msgstr ""
"Під час виклику для розблокованого блокування виникає :exc:`RuntimeError`."

#: ../../library/threading.rst:755 ../../library/threading.rst:863
msgid "There is no return value."
msgstr "Поверненого значення немає."

#: ../../library/threading.rst:759
msgid "Return ``True`` if the lock is acquired."
msgstr "Повертає ``True``, якщо блокування отримано."

#: ../../library/threading.rst:766
msgid "RLock objects"
msgstr "RLock 对象"

#: ../../library/threading.rst:768
msgid ""
"A reentrant lock is a synchronization primitive that may be acquired "
"multiple times by the same thread.  Internally, it uses the concepts of "
"\"owning thread\" and \"recursion level\" in addition to the locked/unlocked "
"state used by primitive locks.  In the locked state, some thread owns the "
"lock; in the unlocked state, no thread owns it."
msgstr ""
"Блокування повторного входу — це примітив синхронізації, який може бути "
"отриманий кілька разів одним потоком. Внутрішньо він використовує поняття "
"\"володіння потоком\" і \"рівень рекурсії\" на додаток до заблокованого/"
"розблокованого стану, який використовується примітивними блокуваннями. У "
"заблокованому стані деякий потік володіє блокуванням; у розблокованому стані "
"жоден потік не володіє ним."

#: ../../library/threading.rst:774
msgid ""
"Threads call a lock's :meth:`~RLock.acquire` method to lock it, and its :"
"meth:`~Lock.release` method to unlock it."
msgstr ""
"Потоки вызывают метод блокировки :meth:`~RLock.acquire` для ее блокировки и "
"метод :meth:`~Lock.release` для ее разблокировки."

#: ../../library/threading.rst:779
msgid ""
"Reentrant locks support the :ref:`context management protocol <with-locks>`, "
"so it is recommended to use :keyword:`with` instead of manually calling :"
"meth:`~RLock.acquire` and :meth:`~RLock.release` to handle acquiring and "
"releasing the lock for a block of code."
msgstr ""
"Реентерабельные блокировки поддерживают :ref:`протокол управления контекстом "
"<with-locks>`, поэтому рекомендуется использовать :keyword:`with` вместо "
"ручного вызова :meth:`~RLock.acquire` и :meth:`~RLock .release` для "
"обработки получения и снятия блокировки блока кода."

#: ../../library/threading.rst:784
msgid ""
"RLock's :meth:`~RLock.acquire`/:meth:`~RLock.release` call pairs may be "
"nested, unlike Lock's :meth:`~Lock.acquire`/:meth:`~Lock.release`. Only the "
"final :meth:`~RLock.release` (the :meth:`~Lock.release` of the outermost "
"pair) resets the lock to an unlocked state and allows another thread blocked "
"in :meth:`~RLock.acquire` to proceed."
msgstr ""
"Пары вызовов :meth:`~RLock.acquire`/:meth:`~RLock.release` RLock могут быть "
"вложенными, в отличие от :meth:`~Lock.acquire`/:meth:`~Lock.release` RLock. "
"Только последний :meth:`~RLock.release` (:meth:`~Lock.release` самой внешней "
"пары) сбрасывает блокировку в разблокированное состояние и разрешает "
"блокировку другого потока в :meth:`~RLock.acquire` продолжить."

#: ../../library/threading.rst:790
msgid ""
":meth:`~RLock.acquire`/:meth:`~RLock.release` must be used in pairs: each "
"acquire must have a release in the thread that has acquired the lock. "
"Failing to call release as many times the lock has been acquired can lead to "
"deadlock."
msgstr ""
":meth:`~RLock.acquire`/:meth:`~RLock.release` необходимо использовать "
"парами: каждое получение должно иметь освобождение в потоке, получившем "
"блокировку. Если не вызвать освобождение столько раз, сколько была получена "
"блокировка, это может привести к взаимоблокировке."

#: ../../library/threading.rst:797
msgid ""
"This class implements reentrant lock objects.  A reentrant lock must be "
"released by the thread that acquired it.  Once a thread has acquired a "
"reentrant lock, the same thread may acquire it again without blocking; the "
"thread must release it once for each time it has acquired it."
msgstr ""
"Цей клас реалізує об’єкти повторного входу. Блокування повторного входу має "
"бути звільнено потоком, який його отримав. Як тільки потік отримав "
"блокування повторного входу, той самий потік може отримати його знову без "
"блокування; потік повинен звільнити його один раз за кожен раз, коли він "
"його отримав."

#: ../../library/threading.rst:802
msgid ""
"Note that ``RLock`` is actually a factory function which returns an instance "
"of the most efficient version of the concrete RLock class that is supported "
"by the platform."
msgstr ""
"Зауважте, що ``RLock`` насправді є фабричною функцією, яка повертає "
"екземпляр найефективнішої версії конкретного класу RLock, який підтримується "
"платформою."

#: ../../library/threading.rst:813
msgid ":ref:`Using RLock as a context manager <with-locks>`"
msgstr ":ref:`Использование RLock в качестве менеджера контекста <with-locks>`"

#: ../../library/threading.rst:814
msgid ""
"Recommended over manual :meth:`!acquire` and :meth:`release` calls whenever "
"practical."
msgstr ""
"Рекомендуется вместо ручных вызовов :meth:`!acquire` и :meth:`release`, "
"когда это возможно."

#: ../../library/threading.rst:818
msgid ""
"When invoked with the *blocking* argument set to ``True`` (the default):"
msgstr ""
"При вызове с аргументом *blocking*, установленным в ``True`` (по умолчанию):"

#: ../../library/threading.rst:820 ../../library/threading.rst:832
msgid "If no thread owns the lock, acquire the lock and return immediately."
msgstr ""
"Если ни один поток не владеет блокировкой, получите блокировку и немедленно "
"вернитесь."

#: ../../library/threading.rst:822
msgid ""
"If another thread owns the lock, block until we are able to acquire lock, or "
"*timeout*, if set to a positive float value."
msgstr ""
"Если другой поток владеет блокировкой, блокируйте ее до тех пор, пока мы не "
"сможем получить блокировку, или *timeout*, если установлено положительное "
"значение с плавающей запятой."

#: ../../library/threading.rst:825
msgid ""
"If the same thread owns the lock, acquire the lock again, and return "
"immediately. This is the difference between :class:`Lock` and :class:`!"
"RLock`; :class:`Lock` handles this case the same as the previous, blocking "
"until the lock can be acquired."
msgstr ""
"Если тот же поток владеет блокировкой, получите блокировку снова и "
"немедленно вернитесь. В этом разница между :class:`Lock` и :class:`!RLock`; :"
"class:`Lock` обрабатывает этот случай так же, как и предыдущий, блокируя до "
"тех пор, пока не будет получена блокировка."

#: ../../library/threading.rst:830
msgid "When invoked with the *blocking* argument set to ``False``:"
msgstr "При вызове с аргументом *blocking*, установленным в значение «False»:"

#: ../../library/threading.rst:834
msgid "If another thread owns the lock, return immediately."
msgstr "Если другой поток владеет блокировкой, немедленно вернитесь."

#: ../../library/threading.rst:836
msgid ""
"If the same thread owns the lock, acquire the lock again and return "
"immediately."
msgstr ""
"Если тот же поток владеет блокировкой, получите блокировку снова и "
"немедленно вернитесь."

#: ../../library/threading.rst:839
msgid ""
"In all cases, if the thread was able to acquire the lock, return ``True``. "
"If the thread was unable to acquire the lock (i.e. if not blocking or the "
"timeout was reached) return ``False``."
msgstr ""
"Во всех случаях, если поток смог получить блокировку, верните ``True``. Если "
"поток не смог получить блокировку (т. е. не блокировался или истек тайм-"
"аут), верните ``False``."

#: ../../library/threading.rst:843
msgid ""
"If called multiple times, failing to call :meth:`~RLock.release` as many "
"times may lead to deadlock. Consider using :class:`!RLock` as a context "
"manager rather than calling acquire/release directly."
msgstr ""
"Если вызывается несколько раз, невызов :meth:`~RLock.release` столько раз "
"может привести к взаимоблокировке. Рассмотрите возможность использования :"
"class:`!RLock` в качестве менеджера контекста, а не напрямую вызывайте "
"процесс получения/выпуска."

#: ../../library/threading.rst:853
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement it "
"is zero, reset the lock to unlocked (not owned by any thread), and if any "
"other threads are blocked waiting for the lock to become unlocked, allow "
"exactly one of them to proceed.  If after the decrement the recursion level "
"is still nonzero, the lock remains locked and owned by the calling thread."
msgstr ""
"Зніміть блокування, зменшивши рівень рекурсії. Якщо після декремента він "
"дорівнює нулю, скиньте блокування до розблокованого (не належить жодному "
"потоку), і якщо будь-які інші потоки заблоковані в очікуванні розблокування "
"блокування, дозвольте рівно одному з них продовжити. Якщо після декременту "
"рівень рекурсії все ще ненульовий, блокування залишається заблокованим і "
"належить потоку, що викликає."

#: ../../library/threading.rst:859
msgid ""
"Only call this method when the calling thread owns the lock. A :exc:"
"`RuntimeError` is raised if this method is called when the lock is not "
"acquired."
msgstr ""
"Вызывайте этот метод только в том случае, если вызывающий поток владеет "
"блокировкой. Ошибка :exc:`RuntimeError` возникает, если этот метод "
"вызывается, когда блокировка не получена."

#: ../../library/threading.rst:869
msgid "Condition objects"
msgstr "Condition 对象"

#: ../../library/threading.rst:871
msgid ""
"A condition variable is always associated with some kind of lock; this can "
"be passed in or one will be created by default.  Passing one in is useful "
"when several condition variables must share the same lock.  The lock is part "
"of the condition object: you don't have to track it separately."
msgstr ""
"Змінна умови завжди асоціюється з якимось блокуванням; це можна передати, "
"або він буде створений за замовчуванням. Передача одного корисна, коли "
"кілька змінних умови повинні використовувати один і той же блокування. "
"Блокування є частиною об’єкта умови: вам не потрібно відстежувати його "
"окремо."

#: ../../library/threading.rst:876
msgid ""
"A condition variable obeys the :ref:`context management protocol <with-"
"locks>`: using the ``with`` statement acquires the associated lock for the "
"duration of the enclosed block.  The :meth:`~Condition.acquire` and :meth:"
"`~Condition.release` methods also call the corresponding methods of the "
"associated lock."
msgstr ""
"Змінна умови підпорядковується :ref:`протоколу керування контекстом <with-"
"locks>`: використання оператора ``with`` отримує пов’язане блокування "
"протягом тривалості включеного блоку. Методи :meth:`~Condition.acquire` і :"
"meth:`~Condition.release` також викликають відповідні методи пов’язаного "
"блокування."

#: ../../library/threading.rst:882
msgid ""
"Other methods must be called with the associated lock held.  The :meth:"
"`~Condition.wait` method releases the lock, and then blocks until another "
"thread awakens it by calling :meth:`~Condition.notify` or :meth:`~Condition."
"notify_all`.  Once awakened, :meth:`~Condition.wait` re-acquires the lock "
"and returns.  It is also possible to specify a timeout."
msgstr ""
"Інші методи повинні викликатися з відповідним блокуванням. Метод :meth:"
"`~Condition.wait` знімає блокування, а потім блокує, доки інший потік не "
"розбудить його, викликавши :meth:`~Condition.notify` або :meth:`~Condition."
"notify_all`. Після пробудження :meth:`~Condition.wait` знову отримує "
"блокування та повертається. Також можна вказати тайм-аут."

#: ../../library/threading.rst:888
msgid ""
"The :meth:`~Condition.notify` method wakes up one of the threads waiting for "
"the condition variable, if any are waiting.  The :meth:`~Condition."
"notify_all` method wakes up all threads waiting for the condition variable."
msgstr ""
"Метод :meth:`~Condition.notify` активує один із потоків, які очікують на "
"змінну умови, якщо такі очікують. Метод :meth:`~Condition.notify_all` "
"активує всі потоки, які очікують на змінну умови."

#: ../../library/threading.rst:892
msgid ""
"Note: the :meth:`~Condition.notify` and :meth:`~Condition.notify_all` "
"methods don't release the lock; this means that the thread or threads "
"awakened will not return from their :meth:`~Condition.wait` call "
"immediately, but only when the thread that called :meth:`~Condition.notify` "
"or :meth:`~Condition.notify_all` finally relinquishes ownership of the lock."
msgstr ""
"Примітка: методи :meth:`~Condition.notify` і :meth:`~Condition.notify_all` "
"не знімають блокування; це означає, що активований потік або потоки не "
"повернеться зі свого виклику :meth:`~Condition.wait` негайно, а лише тоді, "
"коли потік, який викликав :meth:`~Condition.notify` або :meth:`~Condition."
"notify_all` остаточно відмовляється від власності на замок."

#: ../../library/threading.rst:898
msgid ""
"The typical programming style using condition variables uses the lock to "
"synchronize access to some shared state; threads that are interested in a "
"particular change of state call :meth:`~Condition.wait` repeatedly until "
"they see the desired state, while threads that modify the state call :meth:"
"`~Condition.notify` or :meth:`~Condition.notify_all` when they change the "
"state in such a way that it could possibly be a desired state for one of the "
"waiters.  For example, the following code is a generic producer-consumer "
"situation with unlimited buffer capacity::"
msgstr ""
"Типовий стиль програмування з використанням умовних змінних використовує "
"блокування для синхронізації доступу до деякого спільного стану; потоки, які "
"зацікавлені в певній зміні стану, викликають :meth:`~Condition.wait` "
"неодноразово, доки не побачать бажаний стан, тоді як потоки, які змінюють "
"стан, викликають :meth:`~Condition.notify` або :meth:`~Condition."
"notify_all`, коли вони змінюють стан таким чином, що це може бути бажаним "
"станом для одного з офіціантів. Наприклад, наступний код є загальною "
"ситуацією виробник-споживач з необмеженою ємністю буфера:"

#: ../../library/threading.rst:907
msgid ""
"# Consume one item\n"
"with cv:\n"
"    while not an_item_is_available():\n"
"        cv.wait()\n"
"    get_an_available_item()\n"
"\n"
"# Produce one item\n"
"with cv:\n"
"    make_an_item_available()\n"
"    cv.notify()"
msgstr ""
"# Consume one item\n"
"with cv:\n"
"    while not an_item_is_available():\n"
"        cv.wait()\n"
"    get_an_available_item()\n"
"\n"
"# Produce one item\n"
"with cv:\n"
"    make_an_item_available()\n"
"    cv.notify()"

#: ../../library/threading.rst:918
msgid ""
"The ``while`` loop checking for the application's condition is necessary "
"because :meth:`~Condition.wait` can return after an arbitrary long time, and "
"the condition which prompted the :meth:`~Condition.notify` call may no "
"longer hold true.  This is inherent to multi-threaded programming.  The :"
"meth:`~Condition.wait_for` method can be used to automate the condition "
"checking, and eases the computation of timeouts::"
msgstr ""
"Цикл ``while`` для перевірки умови програми необхідний, оскільки :meth:"
"`~Condition.wait` може повернутися через довільний тривалий час, а умова, "
"яка спонукала до виклику :meth:`~Condition.notify`, може не довше "
"зберігаються. Це властиво багатопоточному програмуванню. Метод :meth:"
"`~Condition.wait_for` можна використовувати для автоматизації перевірки умов "
"і полегшує обчислення тайм-аутів::"

#: ../../library/threading.rst:925
msgid ""
"# Consume an item\n"
"with cv:\n"
"    cv.wait_for(an_item_is_available)\n"
"    get_an_available_item()"
msgstr ""
"# Consume an item\n"
"with cv:\n"
"    cv.wait_for(an_item_is_available)\n"
"    get_an_available_item()"

#: ../../library/threading.rst:930
msgid ""
"To choose between :meth:`~Condition.notify` and :meth:`~Condition."
"notify_all`, consider whether one state change can be interesting for only "
"one or several waiting threads.  E.g. in a typical producer-consumer "
"situation, adding one item to the buffer only needs to wake up one consumer "
"thread."
msgstr ""
"Щоб вибрати між :meth:`~Condition.notify` і :meth:`~Condition.notify_all`, "
"подумайте, чи одна зміна стану може бути цікавою лише для одного чи кількох "
"потоків, що очікують. наприклад у типовій ситуації виробник-споживач "
"додавання одного елемента до буфера потребує лише пробудження одного потоку "
"споживача."

#: ../../library/threading.rst:938
msgid ""
"This class implements condition variable objects.  A condition variable "
"allows one or more threads to wait until they are notified by another thread."
msgstr ""
"Цей клас реалізує об’єкти умовної змінної. Змінна умови дозволяє одному або "
"декільком потокам чекати, поки вони не будуть сповіщені іншим потоком."

#: ../../library/threading.rst:941
msgid ""
"If the *lock* argument is given and not ``None``, it must be a :class:`Lock` "
"or :class:`RLock` object, and it is used as the underlying lock.  Otherwise, "
"a new :class:`RLock` object is created and used as the underlying lock."
msgstr ""
"Якщо вказано аргумент *lock*, а не ``None``, це має бути об’єкт :class:"
"`Lock` або :class:`RLock`, і він використовується як основний блокування. В "
"іншому випадку створюється новий об’єкт :class:`RLock`, який "
"використовується як основний блокування."

#: ../../library/threading.rst:945 ../../library/threading.rst:1069
#: ../../library/threading.rst:1115 ../../library/threading.rst:1167
#: ../../library/threading.rst:1235
msgid "changed from a factory function to a class."
msgstr "змінено з функції фабрики на клас."

#: ../../library/threading.rst:950
msgid ""
"Acquire the underlying lock. This method calls the corresponding method on "
"the underlying lock; the return value is whatever that method returns."
msgstr ""
"Отримайте основний замок. Цей метод викликає відповідний метод основного "
"блокування; значення, що повертається, є тим, що повертає цей метод."

#: ../../library/threading.rst:955
msgid ""
"Release the underlying lock. This method calls the corresponding method on "
"the underlying lock; there is no return value."
msgstr ""
"Звільніть базовий замок. Цей метод викликає відповідний метод основного "
"блокування; немає зворотного значення."

#: ../../library/threading.rst:960
msgid ""
"Wait until notified or until a timeout occurs. If the calling thread has not "
"acquired the lock when this method is called, a :exc:`RuntimeError` is "
"raised."
msgstr ""
"Зачекайте, поки не буде сповіщено або поки не настане час очікування. Якщо "
"потік, що викликає, не отримав блокування під час виклику цього методу, "
"виникає :exc:`RuntimeError`."

#: ../../library/threading.rst:964
msgid ""
"This method releases the underlying lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notify_all` call for the same "
"condition variable in another thread, or until the optional timeout occurs.  "
"Once awakened or timed out, it re-acquires the lock and returns."
msgstr ""
"Цей метод знімає основне блокування, а потім блокує, доки його не розбудить "
"виклик :meth:`notify` або :meth:`notify_all` для тієї самої змінної умови в "
"іншому потоці, або доки не настане додатковий тайм-аут. Після пробудження "
"або вичерпання часу блокування знову блокується та повертається."

#: ../../library/threading.rst:969
msgid ""
"When the *timeout* argument is present and not ``None``, it should be a "
"floating-point number specifying a timeout for the operation in seconds (or "
"fractions thereof)."
msgstr ""
"Если присутствует аргумент *timeout*, а не ``None``, это должно быть число с "
"плавающей запятой, определяющее таймаут для операции в секундах (или их "
"долях)."

#: ../../library/threading.rst:973
msgid ""
"When the underlying lock is an :class:`RLock`, it is not released using its :"
"meth:`release` method, since this may not actually unlock the lock when it "
"was acquired multiple times recursively.  Instead, an internal interface of "
"the :class:`RLock` class is used, which really unlocks it even when it has "
"been recursively acquired several times. Another internal interface is then "
"used to restore the recursion level when the lock is reacquired."
msgstr ""
"Якщо основним блокуванням є :class:`RLock`, він не звільняється за допомогою "
"свого методу :meth:`release`, оскільки це може не розблокувати блокування, "
"якщо його було отримано кілька разів рекурсивно. Замість цього "
"використовується внутрішній інтерфейс класу :class:`RLock`, який справді "
"розблоковує його, навіть якщо він був рекурсивно отриманий кілька разів. "
"Інший внутрішній інтерфейс потім використовується для відновлення рівня "
"рекурсії, коли блокування знову отримано."

#: ../../library/threading.rst:981
msgid ""
"The return value is ``True`` unless a given *timeout* expired, in which case "
"it is ``False``."
msgstr ""
"Поверненим значенням є ``True``, якщо не минув заданий *тайм-аут*, у такому "
"випадку воно має значення ``False``."

#: ../../library/threading.rst:984 ../../library/threading.rst:1200
msgid "Previously, the method always returned ``None``."
msgstr "Раніше метод завжди повертав ``None``."

#: ../../library/threading.rst:989
msgid ""
"Wait until a condition evaluates to true.  *predicate* should be a callable "
"which result will be interpreted as a boolean value. A *timeout* may be "
"provided giving the maximum time to wait."
msgstr ""
"Зачекайте, поки умова оціниться як істинна. *предикат* має бути викликаним, "
"результат якого буде інтерпретуватися як логічне значення. Може бути надано "
"*тайм-аут*, що дає максимальний час очікування."

#: ../../library/threading.rst:993
msgid ""
"This utility method may call :meth:`wait` repeatedly until the predicate is "
"satisfied, or until a timeout occurs. The return value is the last return "
"value of the predicate and will evaluate to ``False`` if the method timed "
"out."
msgstr ""
"Цей допоміжний метод може викликати :meth:`wait` неодноразово, доки предикат "
"не буде задоволено або поки не настане час очікування. Значення, що "
"повертається, є останнім значенням, що повертається предикатом, і оцінюється "
"як ``False``, якщо час очікування методу минув."

#: ../../library/threading.rst:998
msgid ""
"Ignoring the timeout feature, calling this method is roughly equivalent to "
"writing::"
msgstr ""
"Ігноруючи функцію тайм-ауту, виклик цього методу приблизно еквівалентний "
"написанню::"

#: ../../library/threading.rst:1001
msgid ""
"while not predicate():\n"
"    cv.wait()"
msgstr ""
"while not predicate():\n"
"    cv.wait()"

#: ../../library/threading.rst:1004
msgid ""
"Therefore, the same rules apply as with :meth:`wait`: The lock must be held "
"when called and is re-acquired on return.  The predicate is evaluated with "
"the lock held."
msgstr ""
"Таким чином, застосовуються ті самі правила, що й для :meth:`wait`: "
"блокування має бути утримано під час виклику та повторно отримане після "
"повернення. Предикат обчислюється з утриманим блокуванням."

#: ../../library/threading.rst:1012
msgid ""
"By default, wake up one thread waiting on this condition, if any.  If the "
"calling thread has not acquired the lock when this method is called, a :exc:"
"`RuntimeError` is raised."
msgstr ""
"За замовчуванням активувати один потік, який очікує за цієї умови, якщо "
"такий є. Якщо потік, що викликає, не отримав блокування під час виклику "
"цього методу, виникає :exc:`RuntimeError`."

#: ../../library/threading.rst:1016
msgid ""
"This method wakes up at most *n* of the threads waiting for the condition "
"variable; it is a no-op if no threads are waiting."
msgstr ""
"Цей метод активує щонайбільше *n* потоків, які очікують змінної умови; це "
"безопераційний режим, якщо немає потоків, що очікують."

#: ../../library/threading.rst:1019
msgid ""
"The current implementation wakes up exactly *n* threads, if at least *n* "
"threads are waiting.  However, it's not safe to rely on this behavior. A "
"future, optimized implementation may occasionally wake up more than *n* "
"threads."
msgstr ""
"Поточна реалізація активує рівно *n* потоків, якщо принаймні *n* потоків "
"очікують. Однак покладатися на таку поведінку небезпечно. Майбутня "
"оптимізована реалізація може час від часу запускати більше ніж *n* потоків."

#: ../../library/threading.rst:1024
msgid ""
"Note: an awakened thread does not actually return from its :meth:`wait` call "
"until it can reacquire the lock.  Since :meth:`notify` does not release the "
"lock, its caller should."
msgstr ""
"Примітка: пробуджений потік фактично не повертається після свого виклику :"
"meth:`wait`, доки він не зможе повторно отримати блокування. Оскільки :meth:"
"`notify` не знімає блокування, його виклик повинен це зробити."

#: ../../library/threading.rst:1030
msgid ""
"Wake up all threads waiting on this condition.  This method acts like :meth:"
"`notify`, but wakes up all waiting threads instead of one. If the calling "
"thread has not acquired the lock when this method is called, a :exc:"
"`RuntimeError` is raised."
msgstr ""
"Розбудити всі потоки, що очікують за цією умовою. Цей метод діє як :meth:"
"`notify`, але активує всі потоки, що очікують, а не один. Якщо потік, що "
"викликає, не отримав блокування під час виклику цього методу, виникає :exc:"
"`RuntimeError`."

#: ../../library/threading.rst:1035
msgid "The method ``notifyAll`` is a deprecated alias for this method."
msgstr "Метод ``notifyAll`` є застарілим псевдонімом для цього методу."

#: ../../library/threading.rst:1041
msgid "Semaphore objects"
msgstr "Semaphore 对象"

#: ../../library/threading.rst:1043
msgid ""
"This is one of the oldest synchronization primitives in the history of "
"computer science, invented by the early Dutch computer scientist Edsger W. "
"Dijkstra (he used the names ``P()`` and ``V()`` instead of :meth:`~Semaphore."
"acquire` and :meth:`~Semaphore.release`)."
msgstr ""
"Це один із найстаріших примітивів синхронізації в історії інформатики, "
"винайдений першим голландським комп’ютерним науковцем Едсгером В. Дейкстрою "
"(він використовував імена ``P()`` і ``V()`` замість :meth:`~Semaphore."
"acquire` і :meth:`~Semaphore.release`)."

#: ../../library/threading.rst:1048
msgid ""
"A semaphore manages an internal counter which is decremented by each :meth:"
"`~Semaphore.acquire` call and incremented by each :meth:`~Semaphore.release` "
"call.  The counter can never go below zero; when :meth:`~Semaphore.acquire` "
"finds that it is zero, it blocks, waiting until some other thread calls :"
"meth:`~Semaphore.release`."
msgstr ""
"Семафор керує внутрішнім лічильником, який зменшується при кожному виклику :"
"meth:`~Semaphore.acquire` і збільшується при кожному виклику :meth:"
"`~Semaphore.release`. Лічильник ніколи не може опускатися нижче нуля; коли :"
"meth:`~Semaphore.acquire` виявляє, що він дорівнює нулю, він блокується, "
"чекаючи, поки інший потік викличе :meth:`~Semaphore.release`."

#: ../../library/threading.rst:1054
msgid ""
"Semaphores also support the :ref:`context management protocol <with-locks>`."
msgstr ""
"Семафори також підтримують :ref:`протокол управління контекстом <with-"
"locks>`."

#: ../../library/threading.rst:1059
msgid ""
"This class implements semaphore objects.  A semaphore manages an atomic "
"counter representing the number of :meth:`release` calls minus the number "
"of :meth:`acquire` calls, plus an initial value.  The :meth:`acquire` method "
"blocks if necessary until it can return without making the counter negative. "
"If not given, *value* defaults to 1."
msgstr ""
"Цей клас реалізує семафорні об’єкти. Семафор керує атомарним лічильником, "
"який представляє кількість викликів :meth:`release` мінус кількість "
"викликів :meth:`acquire` плюс початкове значення. Метод :meth:`acquire` "
"блокує, якщо необхідно, доки не зможе повернутися, не зробивши лічильник "
"негативним. Якщо не вказано, *значення* за замовчуванням дорівнює 1."

#: ../../library/threading.rst:1065
msgid ""
"The optional argument gives the initial *value* for the internal counter; it "
"defaults to ``1``. If the *value* given is less than 0, :exc:`ValueError` is "
"raised."
msgstr ""
"Необов'язковий аргумент дає початкове *значення* для внутрішнього "
"лічильника; за замовчуванням ``1``. Якщо задане *значення* менше 0, виникає :"
"exc:`ValueError`."

#: ../../library/threading.rst:1074
msgid "Acquire a semaphore."
msgstr "Придбайте семафор."

#: ../../library/threading.rst:1076
msgid "When invoked without arguments:"
msgstr "При виклику без аргументів:"

#: ../../library/threading.rst:1078
msgid ""
"If the internal counter is larger than zero on entry, decrement it by one "
"and return ``True`` immediately."
msgstr ""
"Якщо внутрішній лічильник більше нуля під час входу, зменште його на одиницю "
"та негайно поверніть ``True``."

#: ../../library/threading.rst:1080
msgid ""
"If the internal counter is zero on entry, block until awoken by a call to :"
"meth:`~Semaphore.release`.  Once awoken (and the counter is greater than 0), "
"decrement the counter by 1 and return ``True``.  Exactly one thread will be "
"awoken by each call to :meth:`~Semaphore.release`.  The order in which "
"threads are awoken should not be relied on."
msgstr ""
"Якщо внутрішній лічильник дорівнює нулю під час входу, блокуйте, доки не "
"пробудите виклик :meth:`~Semaphore.release`. Після пробудження (і лічильник "
"більше 0), зменшіть лічильник на 1 і поверніть ``True``. Кожен виклик :meth:"
"`~Semaphore.release` пробуджуватиме рівно один потік. Не слід покладатися на "
"порядок, у якому пробуджуються потоки."

#: ../../library/threading.rst:1086
msgid ""
"When invoked with *blocking* set to ``False``, do not block.  If a call "
"without an argument would block, return ``False`` immediately; otherwise, do "
"the same thing as when called without arguments, and return ``True``."
msgstr ""
"При виклику з *blocking* встановленим на ``False`` не блокувати. Якщо виклик "
"без аргументу буде заблокований, негайно поверніть ``False``; в іншому "
"випадку виконайте те ж саме, що й під час виклику без аргументів, і "
"поверніть ``True``."

#: ../../library/threading.rst:1090
msgid ""
"When invoked with a *timeout* other than ``None``, it will block for at most "
"*timeout* seconds.  If acquire does not complete successfully in that "
"interval, return ``False``.  Return ``True`` otherwise."
msgstr ""
"При виклику з *timeout*, відмінним від ``None``, він блокуватиметься "
"щонайбільше на *timeout* секунд. Якщо отримання не завершується успішно "
"протягом цього інтервалу, повертається ``False``. В іншому випадку поверніть "
"``True``."

#: ../../library/threading.rst:1099
msgid ""
"Release a semaphore, incrementing the internal counter by *n*.  When it was "
"zero on entry and other threads are waiting for it to become larger than "
"zero again, wake up *n* of those threads."
msgstr ""
"Відпустіть семафор, збільшивши внутрішній лічильник на *n*. Коли він був "
"нульовим під час входу, а інші потоки чекають, коли він знову стане більшим "
"за нуль, розбудіть *n* з цих потоків."

#: ../../library/threading.rst:1103
msgid "Added the *n* parameter to release multiple waiting threads at once."
msgstr ""
"Додано параметр *n*, щоб одночасно звільнити кілька потоків, що очікують."

#: ../../library/threading.rst:1109
msgid ""
"Class implementing bounded semaphore objects.  A bounded semaphore checks to "
"make sure its current value doesn't exceed its initial value.  If it does, :"
"exc:`ValueError` is raised. In most situations semaphores are used to guard "
"resources with limited capacity.  If the semaphore is released too many "
"times it's a sign of a bug.  If not given, *value* defaults to 1."
msgstr ""
"Клас, що реалізує обмежені семафорні об’єкти. Обмежений семафор перевіряє, "
"чи його поточне значення не перевищує початкове значення. Якщо це так, "
"виникає :exc:`ValueError`. У більшості ситуацій семафори використовуються "
"для захисту ресурсів з обмеженою ємністю. Якщо семафор запускається занадто "
"багато разів, це ознака помилки. Якщо не вказано, *значення* за "
"замовчуванням дорівнює 1."

#: ../../library/threading.rst:1122
msgid ":class:`Semaphore` example"
msgstr ":class:`Semaphore` 示例"

#: ../../library/threading.rst:1124
msgid ""
"Semaphores are often used to guard resources with limited capacity, for "
"example, a database server.  In any situation where the size of the resource "
"is fixed, you should use a bounded semaphore.  Before spawning any worker "
"threads, your main thread would initialize the semaphore::"
msgstr ""
"Семафори часто використовуються для захисту ресурсів з обмеженою потужністю, "
"наприклад, сервера бази даних. У будь-якій ситуації, коли розмір ресурсу "
"фіксований, ви повинні використовувати обмежений семафор. Перед створенням "
"будь-яких робочих потоків ваш головний потік ініціалізує семафор::"

#: ../../library/threading.rst:1129
msgid ""
"maxconnections = 5\n"
"# ...\n"
"pool_sema = BoundedSemaphore(value=maxconnections)"
msgstr ""
"maxconnections = 5\n"
"# ...\n"
"pool_sema = BoundedSemaphore(value=maxconnections)"

#: ../../library/threading.rst:1133
msgid ""
"Once spawned, worker threads call the semaphore's acquire and release "
"methods when they need to connect to the server::"
msgstr ""
"Після створення робочі потоки викликають методи отримання та випуску "
"семафора, коли їм потрібно підключитися до сервера::"

#: ../../library/threading.rst:1136
msgid ""
"with pool_sema:\n"
"    conn = connectdb()\n"
"    try:\n"
"        # ... use connection ...\n"
"    finally:\n"
"        conn.close()"
msgstr ""
"with pool_sema:\n"
"    conn = connectdb()\n"
"    try:\n"
"        # ... use connection ...\n"
"    finally:\n"
"        conn.close()"

#: ../../library/threading.rst:1143
msgid ""
"The use of a bounded semaphore reduces the chance that a programming error "
"which causes the semaphore to be released more than it's acquired will go "
"undetected."
msgstr ""
"Використання обмеженого семафора зменшує ймовірність того, що програмна "
"помилка, через яку семафор буде звільнено більше, ніж отримано, залишиться "
"непоміченою."

#: ../../library/threading.rst:1150
msgid "Event objects"
msgstr "Event 对象"

#: ../../library/threading.rst:1152
msgid ""
"This is one of the simplest mechanisms for communication between threads: "
"one thread signals an event and other threads wait for it."
msgstr ""
"Це один із найпростіших механізмів зв’язку між потоками: один потік "
"сигналізує про подію, а інші потоки чекають її."

#: ../../library/threading.rst:1155
msgid ""
"An event object manages an internal flag that can be set to true with the :"
"meth:`~Event.set` method and reset to false with the :meth:`~Event.clear` "
"method.  The :meth:`~Event.wait` method blocks until the flag is true."
msgstr ""
"Об’єкт події керує внутрішнім прапором, який можна встановити на true за "
"допомогою методу :meth:`~Event.set` і скинути на false за допомогою методу :"
"meth:`~Event.clear`. Метод :meth:`~Event.wait` блокує, доки прапор не стане "
"істинним."

#: ../../library/threading.rst:1162
msgid ""
"Class implementing event objects.  An event manages a flag that can be set "
"to true with the :meth:`~Event.set` method and reset to false with the :meth:"
"`clear` method.  The :meth:`wait` method blocks until the flag is true. The "
"flag is initially false."
msgstr ""
"Клас, що реалізує об'єкти подій. Подія керує прапором, який можна встановити "
"на true за допомогою методу :meth:`~Event.set` і скинути на false за "
"допомогою методу :meth:`clear`. Метод :meth:`wait` блокує, доки прапор не "
"стане істинним. Прапор спочатку фальшивий."

#: ../../library/threading.rst:1172
msgid "Return ``True`` if and only if the internal flag is true."
msgstr ""
"Повертає ``True`` тоді і тільки тоді, коли внутрішній прапор має значення "
"true."

#: ../../library/threading.rst:1174
msgid "The method ``isSet`` is a deprecated alias for this method."
msgstr "Метод ``isSet`` є застарілим псевдонімом для цього методу."

#: ../../library/threading.rst:1178
msgid ""
"Set the internal flag to true. All threads waiting for it to become true are "
"awakened. Threads that call :meth:`wait` once the flag is true will not "
"block at all."
msgstr ""
"Встановіть для внутрішнього прапора значення true. Усі нитки, які чекають, "
"коли це стане правдою, пробуджуються. Потоки, які викликають :meth:`wait`, "
"коли прапор встановлено як true, взагалі не блокуватимуться."

#: ../../library/threading.rst:1184
msgid ""
"Reset the internal flag to false. Subsequently, threads calling :meth:`wait` "
"will block until :meth:`.set` is called to set the internal flag to true "
"again."
msgstr ""
"Скиньте внутрішній прапор на false. Згодом потоки, що викликають :meth:"
"`wait`, блокуватимуться, доки не буде викликано :meth:`.set`, щоб знову "
"встановити внутрішній прапор на true."

#: ../../library/threading.rst:1190
msgid ""
"Block as long as the internal flag is false and the timeout, if given, has "
"not expired. The return value represents the reason that this blocking "
"method returned; ``True`` if returning because the internal flag is set to "
"true, or ``False`` if a timeout is given and the internal flag did not "
"become true within the given wait time."
msgstr ""
"Блокировать до тех пор, пока внутренний флаг имеет значение false и время "
"ожидания, если оно задано, не истекло. Возвращаемое значение представляет "
"причину возврата этого метода блокировки; ``True``, если возвращается, "
"потому что внутренний флаг установлен в true, или ``False``, если задан тайм-"
"аут и внутренний флаг не стал истинным в течение заданного времени ожидания."

#: ../../library/threading.rst:1196
msgid ""
"When the timeout argument is present and not ``None``, it should be a "
"floating-point number specifying a timeout for the operation in seconds, or "
"fractions thereof."
msgstr ""
"Если аргумент таймаута присутствует, а не ``Нет``, он должен быть числом с "
"плавающей запятой, указывающим таймаут для операции в секундах или их долях."

#: ../../library/threading.rst:1207
msgid "Timer objects"
msgstr "Timer 对象"

#: ../../library/threading.rst:1209
msgid ""
"This class represents an action that should be run only after a certain "
"amount of time has passed --- a timer.  :class:`Timer` is a subclass of :"
"class:`Thread` and as such also functions as an example of creating custom "
"threads."
msgstr ""
"Цей клас представляє дію, яку слід запускати лише після того, як мине певний "
"час --- таймер. :class:`Timer` є підкласом :class:`Thread` і як такий також "
"функціонує як приклад створення власних потоків."

#: ../../library/threading.rst:1213
msgid ""
"Timers are started, as with threads, by calling their :meth:`Timer.start "
"<Thread.start>` method.  The timer can be stopped (before its action has "
"begun) by calling the :meth:`~Timer.cancel` method.  The interval the timer "
"will wait before executing its action may not be exactly the same as the "
"interval specified by the user."
msgstr ""
"Таймеры запускаются, как и потоки, вызовом их метода :meth:`Timer.start "
"<Thread.start>`. Таймер можно остановить (до начала его действия), вызвав "
"метод :meth:`~Timer.cancel`. Интервал, который таймер будет ждать перед "
"выполнением своего действия, может не совпадать с интервалом, указанным "
"пользователем."

#: ../../library/threading.rst:1219
msgid "For example::"
msgstr "به عنوان مثال::"

#: ../../library/threading.rst:1221
msgid ""
"def hello():\n"
"    print(\"hello, world\")\n"
"\n"
"t = Timer(30.0, hello)\n"
"t.start()  # after 30 seconds, \"hello, world\" will be printed"
msgstr ""
"def hello():\n"
"    print(\"hello, world\")\n"
"\n"
"t = Timer(30.0, hello)\n"
"t.start()  # after 30 seconds, \"hello, world\" will be printed"

#: ../../library/threading.rst:1230
msgid ""
"Create a timer that will run *function* with arguments *args* and  keyword "
"arguments *kwargs*, after *interval* seconds have passed. If *args* is "
"``None`` (the default) then an empty list will be used. If *kwargs* is "
"``None`` (the default) then an empty dict will be used."
msgstr ""
"Створіть таймер, який запускатиме *функцію* з аргументами *args* і "
"аргументами ключового слова *kwargs* після закінчення *інтервалу* секунд. "
"Якщо *args* має значення ``None`` (за замовчуванням), тоді "
"використовуватиметься порожній список. Якщо *kwargs* має значення ``None`` "
"(за замовчуванням), тоді використовуватиметься порожній dict."

#: ../../library/threading.rst:1240
msgid ""
"Stop the timer, and cancel the execution of the timer's action.  This will "
"only work if the timer is still in its waiting stage."
msgstr ""
"Зупиніть таймер і скасуйте виконання дії таймера. Це спрацює, лише якщо "
"таймер все ще перебуває в стадії очікування."

#: ../../library/threading.rst:1245
msgid "Barrier objects"
msgstr "Barrier 对象"

#: ../../library/threading.rst:1249
msgid ""
"This class provides a simple synchronization primitive for use by a fixed "
"number of threads that need to wait for each other.  Each of the threads "
"tries to pass the barrier by calling the :meth:`~Barrier.wait` method and "
"will block until all of the threads have made their :meth:`~Barrier.wait` "
"calls. At this point, the threads are released simultaneously."
msgstr ""
"Цей клас забезпечує простий примітив синхронізації для використання "
"фіксованою кількістю потоків, які повинні чекати один одного. Кожен із "
"потоків намагається подолати бар’єр, викликаючи метод :meth:`~Barrier.wait` "
"і блокуватиметься, доки всі потоки не виконають свої виклики :meth:`~Barrier."
"wait`. У цей момент потоки звільняються одночасно."

#: ../../library/threading.rst:1255
msgid ""
"The barrier can be reused any number of times for the same number of threads."
msgstr ""
"Бар'єр можна повторно використовувати будь-яку кількість разів для однакової "
"кількості потоків."

#: ../../library/threading.rst:1257
msgid ""
"As an example, here is a simple way to synchronize a client and server "
"thread::"
msgstr ""
"Як приклад, ось простий спосіб синхронізації потоку клієнта та сервера:"

#: ../../library/threading.rst:1259
msgid ""
"b = Barrier(2, timeout=5)\n"
"\n"
"def server():\n"
"    start_server()\n"
"    b.wait()\n"
"    while True:\n"
"        connection = accept_connection()\n"
"        process_server_connection(connection)\n"
"\n"
"def client():\n"
"    b.wait()\n"
"    while True:\n"
"        connection = make_connection()\n"
"        process_client_connection(connection)"
msgstr ""
"b = Barrier(2, timeout=5)\n"
"\n"
"def server():\n"
"    start_server()\n"
"    b.wait()\n"
"    while True:\n"
"        connection = accept_connection()\n"
"        process_server_connection(connection)\n"
"\n"
"def client():\n"
"    b.wait()\n"
"    while True:\n"
"        connection = make_connection()\n"
"        process_client_connection(connection)"

#: ../../library/threading.rst:1277
msgid ""
"Create a barrier object for *parties* number of threads.  An *action*, when "
"provided, is a callable to be called by one of the threads when they are "
"released.  *timeout* is the default timeout value if none is specified for "
"the :meth:`wait` method."
msgstr ""
"Створіть бар'єрний об'єкт для *сторон* кількості потоків. *Action*, якщо "
"надається, є викликом, який викликається одним із потоків, коли вони "
"звільняються. *timeout* — це значення часу очікування за замовчуванням, якщо "
"для методу :meth:`wait` його не вказано."

#: ../../library/threading.rst:1284
msgid ""
"Pass the barrier.  When all the threads party to the barrier have called "
"this function, they are all released simultaneously.  If a *timeout* is "
"provided, it is used in preference to any that was supplied to the class "
"constructor."
msgstr ""
"Пройти шлагбаум. Коли всі потоки, які є стороною бар’єру, викличуть цю "
"функцію, усі вони звільняються одночасно. Якщо надається *тайм-аут*, він "
"використовується замість будь-якого, який було надано конструктору класу."

#: ../../library/threading.rst:1289
msgid ""
"The return value is an integer in the range 0 to *parties* -- 1, different "
"for each thread.  This can be used to select a thread to do some special "
"housekeeping, e.g.::"
msgstr ""
"Повернене значення є цілим числом у діапазоні від 0 до *parties* -- 1, різне "
"для кожного потоку. Це можна використати для вибору потоку для виконання "
"деяких спеціальних завдань, наприклад::"

#: ../../library/threading.rst:1293
msgid ""
"i = barrier.wait()\n"
"if i == 0:\n"
"    # Only one thread needs to print this\n"
"    print(\"passed the barrier\")"
msgstr ""
"i = barrier.wait()\n"
"if i == 0:\n"
"    # Only one thread needs to print this\n"
"    print(\"passed the barrier\")"

#: ../../library/threading.rst:1298
msgid ""
"If an *action* was provided to the constructor, one of the threads will have "
"called it prior to being released.  Should this call raise an error, the "
"barrier is put into the broken state."
msgstr ""
"Якщо *дія* була надана конструктору, один із потоків викликатиме її до того, "
"як буде звільнено. Якщо цей виклик викликає помилку, шлагбаум переходить у "
"несправний стан."

#: ../../library/threading.rst:1302
msgid "If the call times out, the barrier is put into the broken state."
msgstr "Якщо виклик закінчився, шлагбаум переходить у несправний стан."

#: ../../library/threading.rst:1304
msgid ""
"This method may raise a :class:`BrokenBarrierError` exception if the barrier "
"is broken or reset while a thread is waiting."
msgstr ""
"Цей метод може викликати виключення :class:`BrokenBarrierError`, якщо бар’єр "
"зламано або скинуто під час очікування потоку."

#: ../../library/threading.rst:1309
msgid ""
"Return the barrier to the default, empty state.  Any threads waiting on it "
"will receive the :class:`BrokenBarrierError` exception."
msgstr ""
"Поверніть бар'єр до стандартного порожнього стану. Будь-які потоки, які "
"очікують на нього, отримають виняток :class:`BrokenBarrierError`."

#: ../../library/threading.rst:1312
msgid ""
"Note that using this function may require some external synchronization if "
"there are other threads whose state is unknown.  If a barrier is broken it "
"may be better to just leave it and create a new one."
msgstr ""
"Зауважте, що використання цієї функції може потребувати певної зовнішньої "
"синхронізації, якщо існують інші потоки, стан яких невідомий. Якщо бар’єр "
"зламано, можливо, краще залишити його та створити новий."

#: ../../library/threading.rst:1318
msgid ""
"Put the barrier into a broken state.  This causes any active or future calls "
"to :meth:`wait` to fail with the :class:`BrokenBarrierError`.  Use this for "
"example if one of the threads needs to abort, to avoid deadlocking the "
"application."
msgstr ""
"Переведіть шлагбаум в зламаний стан. Це призводить до того, що будь-які "
"активні або майбутні виклики :meth:`wait` завершуються помилкою з :class:"
"`BrokenBarrierError`. Використовуйте це, наприклад, якщо один із потоків "
"потрібно перервати, щоб уникнути блокування програми."

#: ../../library/threading.rst:1323
msgid ""
"It may be preferable to simply create the barrier with a sensible *timeout* "
"value to automatically guard against one of the threads going awry."
msgstr ""
"Можливо, буде краще просто створити бар’єр із розумним значенням *timeout*, "
"щоб автоматично захистити один із потоків від збою."

#: ../../library/threading.rst:1329
msgid "The number of threads required to pass the barrier."
msgstr "Кількість потоків, необхідних для проходження бар'єру."

#: ../../library/threading.rst:1333
msgid "The number of threads currently waiting in the barrier."
msgstr "Кількість потоків, які зараз очікують у бар'єрі."

#: ../../library/threading.rst:1337
msgid "A boolean that is ``True`` if the barrier is in the broken state."
msgstr ""
"Логічне значення, яке має значення ``True``, якщо бар’єр знаходиться в "
"зламаному стані."

#: ../../library/threading.rst:1342
msgid ""
"This exception, a subclass of :exc:`RuntimeError`, is raised when the :class:"
"`Barrier` object is reset or broken."
msgstr ""
"Цей виняток, підклас :exc:`RuntimeError`, виникає, коли об’єкт :class:"
"`Barrier` скидається або зламано."

#: ../../library/threading.rst:1349
msgid ""
"Using locks, conditions, and semaphores in the :keyword:`!with` statement"
msgstr "Використання блокувань, умов і семафорів у операторі :keyword:`!with`"

#: ../../library/threading.rst:1351
msgid ""
"All of the objects provided by this module that have ``acquire`` and "
"``release`` methods can be used as context managers for a :keyword:`with` "
"statement.  The ``acquire`` method will be called when the block is entered, "
"and ``release`` will be called when the block is exited.  Hence, the "
"following snippet::"
msgstr ""
"Все объекты, предоставляемые этим модулем и имеющие методы acquire и "
"Release, могут использоваться в качестве менеджеров контекста для оператора :"
"keyword:`with`. Метод acquire будет вызываться при входе в блок, а метод "
"Release будет вызываться при выходе из блока. Следовательно, следующий "
"фрагмент:"

#: ../../library/threading.rst:1357
msgid ""
"with some_lock:\n"
"    # do something..."
msgstr ""
"with some_lock:\n"
"    # do something..."

#: ../../library/threading.rst:1360
msgid "is equivalent to::"
msgstr "setara dengan::"

#: ../../library/threading.rst:1362
msgid ""
"some_lock.acquire()\n"
"try:\n"
"    # do something...\n"
"finally:\n"
"    some_lock.release()"
msgstr ""
"some_lock.acquire()\n"
"try:\n"
"    # do something...\n"
"finally:\n"
"    some_lock.release()"

#: ../../library/threading.rst:1368
msgid ""
"Currently, :class:`Lock`, :class:`RLock`, :class:`Condition`, :class:"
"`Semaphore`, and :class:`BoundedSemaphore` objects may be used as :keyword:"
"`with` statement context managers."
msgstr ""
"Наразі об’єкти :class:`Lock`, :class:`RLock`, :class:`Condition`, :class:"
"`Semaphore` і :class:`BoundedSemaphore` можна використовувати як контекст "
"оператора :keyword:`with` менеджери."

#: ../../library/threading.rst:222 ../../library/threading.rst:240
msgid "trace function"
msgstr "trace function"

#: ../../library/threading.rst:240
msgid "debugger"
msgstr "debugger"

#: ../../library/threading.rst:251 ../../library/threading.rst:269
msgid "profile function"
msgstr "profile function"
