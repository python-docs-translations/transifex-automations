# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2023
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 15:26+0000\n"
"PO-Revision-Date: 2023-05-24 02:10+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2023\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../extending/building.rst:7
msgid "Building C and C++ Extensions"
msgstr "Створення розширень C і C++"

#: ../../extending/building.rst:9
msgid ""
"A C extension for CPython is a shared library (e.g. a ``.so`` file on Linux, "
"``.pyd`` on Windows), which exports an *initialization function*."
msgstr ""
"Розширення C для CPython — це спільна бібліотека (наприклад, файл ``.so`` у "
"Linux, ``.pyd`` у Windows), яка експортує *функцію ініціалізації*."

#: ../../extending/building.rst:12
msgid ""
"To be importable, the shared library must be available on :envvar:"
"`PYTHONPATH`, and must be named after the module name, with an appropriate "
"extension. When using distutils, the correct filename is generated "
"automatically."
msgstr ""
"Щоб бути імпортованою, спільна бібліотека має бути доступною на :envvar:"
"`PYTHONPATH` і мати назву за назвою модуля з відповідним розширенням. Під "
"час використання distutils правильна назва файлу генерується автоматично."

#: ../../extending/building.rst:16
msgid "The initialization function has the signature:"
msgstr "Функція ініціалізації має сигнатуру:"

#: ../../extending/building.rst:20
msgid ""
"It returns either a fully initialized module, or a :c:type:`PyModuleDef` "
"instance. See :ref:`initializing-modules` for details."
msgstr ""

#: ../../extending/building.rst:25
msgid ""
"For modules with ASCII-only names, the function must be named "
"``PyInit_<modulename>``, with ``<modulename>`` replaced by the name of the "
"module. When using :ref:`multi-phase-initialization`, non-ASCII module names "
"are allowed. In this case, the initialization function name is "
"``PyInitU_<modulename>``, with ``<modulename>`` encoded using Python's "
"*punycode* encoding with hyphens replaced by underscores. In Python::"
msgstr ""
"Для модулів із іменами лише у форматі ASCII функція має мати назву ``PyInit_ "
"<modulename>``, при цьому ``<modulename>`` замінюється назвою модуля. При "
"використанні :ref:`multi-phase-initialization` дозволені назви модулів, "
"відмінні від ASCII. У цьому випадку ім’я функції ініціалізації – ``PyInitU_ "
"<modulename>``, де ``<modulename>`` закодовано з використанням *punycode* "
"кодування Python із дефісами, заміненими підкресленням. У Python::"

#: ../../extending/building.rst:39
msgid ""
"It is possible to export multiple modules from a single shared library by "
"defining multiple initialization functions. However, importing them requires "
"using symbolic links or a custom importer, because by default only the "
"function corresponding to the filename is found. See the *\"Multiple modules "
"in one library\"* section in :pep:`489` for details."
msgstr ""
"Можна експортувати кілька модулів з однієї спільної бібліотеки, визначивши "
"кілька функцій ініціалізації. Однак для їх імпортування потрібно "
"використовувати символічні посилання або спеціальний імпортер, оскільки за "
"замовчуванням знайдено лише функцію, яка відповідає назві файлу. Подробиці "
"див. у розділі *\"Кілька модулів в одній бібліотеці\"* у :pep:`489`."

#: ../../extending/building.rst:49
msgid "Building C and C++ Extensions with distutils"
msgstr "Створення розширень C і C++ за допомогою distutils"

#: ../../extending/building.rst:53
msgid ""
"Extension modules can be built using distutils,  which is included in "
"Python. Since distutils also supports creation of binary packages, users "
"don't necessarily need a compiler and distutils to install the extension."
msgstr ""
"Модулі розширення можна створити за допомогою distutils, який входить до "
"складу Python. Оскільки distutils також підтримує створення двійкових "
"пакетів, користувачам не обов’язково потрібен компілятор і distutils для "
"встановлення розширення."

#: ../../extending/building.rst:57
msgid ""
"A distutils package contains a driver script, :file:`setup.py`. This is a "
"plain Python file, which, in the most simple case, could look like this:"
msgstr ""
"Пакет distutils містить сценарій драйвера :file:`setup.py`. Це звичайний "
"файл Python, який у найпростішому випадку може виглядати так:"

#: ../../extending/building.rst:73
msgid "With this :file:`setup.py`, and a file :file:`demo.c`, running ::"
msgstr "З цим :file:`setup.py` і файлом :file:`demo.c`, запускаючи ::"

#: ../../extending/building.rst:77
msgid ""
"will compile :file:`demo.c`, and produce an extension module named ``demo`` "
"in the :file:`build` directory. Depending on the system, the module file "
"will end up in a subdirectory :file:`build/lib.system`, and may have a name "
"like :file:`demo.so` or :file:`demo.pyd`."
msgstr ""
"скомпілює :file:`demo.c` і створить модуль розширення під назвою ``demo`` у "
"каталозі :file:`build`. Залежно від системи, файл модуля буде розміщено в "
"підкаталозі :file:`build/lib.system` і може мати таку назву, як :file:`demo."
"so` або :file:`demo.pyd`."

#: ../../extending/building.rst:82
msgid ""
"In the :file:`setup.py`, all execution is performed by calling the ``setup`` "
"function. This takes a variable number of keyword arguments, of which the "
"example above uses only a subset. Specifically, the example specifies meta-"
"information to build packages, and it specifies the contents of the "
"package.  Normally, a package will contain additional modules, like Python "
"source modules, documentation, subpackages, etc. Please refer to the "
"distutils documentation in :ref:`distutils-index` to learn more about the "
"features of distutils; this section explains building extension modules only."
msgstr ""
"У :file:`setup.py` все виконання виконується шляхом виклику функції "
"``setup``. Це вимагає змінної кількості аргументів ключових слів, з яких у "
"прикладі вище використовується лише підмножина. Зокрема, у прикладі "
"вказується мета-інформація для створення пакетів і вказується вміст пакета. "
"Зазвичай пакунок містить додаткові модулі, як-от вихідні модулі Python, "
"документацію, підпакунки тощо. Будь ласка, зверніться до документації "
"distutils у :ref:`distutils-index`, щоб дізнатися більше про функції "
"distutils; у цьому розділі пояснюється лише створення модулів розширення."

#: ../../extending/building.rst:91
msgid ""
"It is common to pre-compute arguments to :func:`setup`, to better structure "
"the driver script. In the example above, the ``ext_modules`` argument to :"
"func:`~distutils.core.setup` is a list of extension modules, each of which "
"is an instance of the :class:`~distutils.extension.Extension`. In the "
"example, the instance defines an extension named ``demo`` which is build by "
"compiling a single source file, :file:`demo.c`."
msgstr ""
"Зазвичай попередньо обчислюють аргументи :func:`setup`, щоб краще "
"структурувати сценарій драйвера. У наведеному вище прикладі аргумент "
"``ext_modules`` для :func:`~distutils.core.setup` є списком модулів "
"розширення, кожен з яких є екземпляром :class:`~distutils.extension."
"Extension` . У цьому прикладі примірник визначає розширення під назвою "
"``demo``, яке створюється шляхом компіляції єдиного вихідного файлу :file:"
"`demo.c`."

#: ../../extending/building.rst:99
msgid ""
"In many cases, building an extension is more complex, since additional "
"preprocessor defines and libraries may be needed. This is demonstrated in "
"the example below."
msgstr ""
"У багатьох випадках створення розширення є більш складним, оскільки можуть "
"знадобитися додаткові визначення препроцесора та бібліотеки. Це показано на "
"прикладі нижче."

#: ../../extending/building.rst:127
msgid ""
"In this example, :func:`~distutils.core.setup` is called with additional "
"meta-information, which is recommended when distribution packages have to be "
"built. For the extension itself, it specifies preprocessor defines, include "
"directories, library directories, and libraries. Depending on the compiler, "
"distutils passes this information in different ways to the compiler. For "
"example, on Unix, this may result in the compilation commands ::"
msgstr ""
"У цьому прикладі :func:`~distutils.core.setup` викликається з додатковою "
"мета-інформацією, яку рекомендується використовувати, коли потрібно створити "
"дистрибутивні пакунки. Для самого розширення воно вказує визначення "
"препроцесора, включає каталоги, каталоги бібліотек і бібліотеки. Залежно від "
"компілятора distutils передає цю інформацію компілятору різними способами. "
"Наприклад, в Unix це може призвести до команд компіляції:"

#: ../../extending/building.rst:139
msgid ""
"These lines are for demonstration purposes only; distutils users should "
"trust that distutils gets the invocations right."
msgstr ""
"Ці рядки призначені лише для демонстрації; Користувачі distutils повинні "
"вірити, що distutils виконує правильні виклики."

#: ../../extending/building.rst:146
msgid "Distributing your extension modules"
msgstr "Розповсюдження ваших модулів розширення"

#: ../../extending/building.rst:148
msgid ""
"When an extension has been successfully built, there are three ways to use "
"it."
msgstr "Якщо розширення успішно створено, є три способи його використання."

#: ../../extending/building.rst:150
msgid ""
"End-users will typically want to install the module, they do so by running ::"
msgstr ""
"Кінцеві користувачі зазвичай хочуть встановити модуль, вони роблять це, "
"запустивши ::"

#: ../../extending/building.rst:154
msgid ""
"Module maintainers should produce source packages; to do so, they run ::"
msgstr ""
"Супроводжувачі модулів повинні створювати пакети вихідних кодів; для цього "
"вони запускають ::"

#: ../../extending/building.rst:158
msgid ""
"In some cases, additional files need to be included in a source "
"distribution; this is done through a :file:`MANIFEST.in` file; see :ref:"
"`manifest` for details."
msgstr ""
"У деяких випадках додаткові файли потрібно включити до вихідного "
"дистрибутива; це робиться через файл :file:`MANIFEST.in`; подробиці див. :"
"ref:`manifest`."

#: ../../extending/building.rst:161
msgid ""
"If the source distribution has been built successfully, maintainers can also "
"create binary distributions. Depending on the platform, one of the following "
"commands can be used to do so. ::"
msgstr ""
"Якщо вихідний дистрибутив було створено успішно, супроводжувачі також можуть "
"створювати двійкові дистрибутиви. Залежно від платформи для цього можна "
"використати одну з наведених нижче команд. ::"
