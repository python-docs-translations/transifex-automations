# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# python-doc bot, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-22 21:56+0000\n"
"PO-Revision-Date: 2025-09-22 17:56+0000\n"
"Last-Translator: python-doc bot, 2025\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../reference/compound_stmts.rst:5
msgid "Compound statements"
msgstr "Складені висловлювання"

#: ../../reference/compound_stmts.rst:9
msgid ""
"Compound statements contain (groups of) other statements; they affect or "
"control the execution of those other statements in some way.  In general, "
"compound statements span multiple lines, although in simple incarnations a "
"whole compound statement may be contained in one line."
msgstr ""
"Складені висловлювання містять (групи) інші висловлювання; вони певним чином "
"впливають або контролюють виконання цих інших операторів. Загалом складені "
"висловлювання охоплюють кілька рядків, хоча в простих варіантах ціле "
"складене висловлювання може міститися в одному рядку."

#: ../../reference/compound_stmts.rst:14
msgid ""
"The :keyword:`if`, :keyword:`while` and :keyword:`for` statements implement "
"traditional control flow constructs.  :keyword:`try` specifies exception "
"handlers and/or cleanup code for a group of statements, while the :keyword:"
"`with` statement allows the execution of initialization and finalization "
"code around a block of code.  Function and class definitions are also "
"syntactically compound statements."
msgstr ""
"Оператори :keyword:`if`, :keyword:`while` і :keyword:`for` реалізують "
"традиційні конструкції потоку керування. :keyword:`try` визначає обробники "
"винятків та/або код очищення для групи операторів, тоді як оператор :keyword:"
"`with` дозволяє виконувати код ініціалізації та фіналізації навколо блоку "
"коду. Визначення функцій і класів також є синтаксично складеними "
"висловлюваннями."

#: ../../reference/compound_stmts.rst:26
msgid ""
"A compound statement consists of one or more 'clauses.'  A clause consists "
"of a header and a 'suite.'  The clause headers of a particular compound "
"statement are all at the same indentation level. Each clause header begins "
"with a uniquely identifying keyword and ends with a colon.  A suite is a "
"group of statements controlled by a clause.  A suite can be one or more "
"semicolon-separated simple statements on the same line as the header, "
"following the header's colon, or it can be one or more indented statements "
"on subsequent lines.  Only the latter form of a suite can contain nested "
"compound statements; the following is illegal, mostly because it wouldn't be "
"clear to which :keyword:`if` clause a following :keyword:`else` clause would "
"belong::"
msgstr ""
"Складений оператор складається з одного або кількох \"речень\". Речення "
"складається із заголовка та \"набору\". Усі заголовки речень певного "
"складеного оператора мають однаковий рівень відступу. Кожен заголовок "
"пропозиції починається з унікального ключового слова та закінчується "
"двокрапкою. Набір — це група висловлювань, керованих реченням. Набір може "
"складатися з одного або кількох простих операторів, розділених крапкою з "
"комою, у тому самому рядку, що й заголовок, після двокрапки заголовка, або "
"це може бути один чи більше операторів із відступом у наступних рядках. Лише "
"остання форма набору може містити вкладені складені оператори; наступне є "
"незаконним, здебільшого тому, що було б незрозуміло, до якого пункту :"
"keyword:`if` належало б таке положення :keyword:`else`::"

#: ../../reference/compound_stmts.rst:39
msgid ""
"Also note that the semicolon binds tighter than the colon in this context, "
"so that in the following example, either all or none of the :func:`print` "
"calls are executed::"
msgstr ""
"Також зауважте, що в цьому контексті крапка з комою зв’язується сильніше, "
"ніж двокрапка, тому в наступному прикладі виконуються або всі, або жоден із "
"викликів :func:`print`::"

#: ../../reference/compound_stmts.rst:45
msgid "Summarizing:"
msgstr "Підведення підсумків:"

#: ../../reference/compound_stmts.rst:68
msgid ""
"Note that statements always end in a ``NEWLINE`` possibly followed by a "
"``DEDENT``.  Also note that optional continuation clauses always begin with "
"a keyword that cannot start a statement, thus there are no ambiguities (the "
"'dangling :keyword:`else`' problem is solved in Python by requiring nested :"
"keyword:`if` statements to be indented)."
msgstr ""
"Зауважте, що оператори завжди закінчуються на ``NEWLINE``, після якого, "
"можливо, йде ``DEDENT``. Також зауважте, що необов’язкові речення "
"продовження завжди починаються з ключового слова, яке не може розпочинати "
"оператор, тому немає ніяких двозначностей (проблему \"висячих :keyword:"
"`else`\" вирішено в Python, вимагаючи вкладених операторів :keyword:`if` з "
"відступом)."

#: ../../reference/compound_stmts.rst:74
msgid ""
"The formatting of the grammar rules in the following sections places each "
"clause on a separate line for clarity."
msgstr ""
"Форматування правил граматики в наступних розділах розміщує кожне речення в "
"окремому рядку для ясності."

#: ../../reference/compound_stmts.rst:83
msgid "The :keyword:`!if` statement"
msgstr "Оператор :keyword:`!if`"

#: ../../reference/compound_stmts.rst:91
msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr "Оператор :keyword:`if` використовується для умовного виконання:"

#: ../../reference/compound_stmts.rst:98
msgid ""
"It selects exactly one of the suites by evaluating the expressions one by "
"one until one is found to be true (see section :ref:`booleans` for the "
"definition of true and false); then that suite is executed (and no other "
"part of the :keyword:`if` statement is executed or evaluated).  If all "
"expressions are false, the suite of the :keyword:`else` clause, if present, "
"is executed."
msgstr ""
"Він вибирає точно один із наборів, обчислюючи вирази один за іншим, доки "
"один не буде визнаний істинним (див. розділ :ref:`booleans` для визначення "
"істинного та хибного); тоді цей набір виконується (і жодна інша частина "
"оператора :keyword:`if` не виконується і не оцінюється). Якщо всі вирази "
"хибні, виконується набір пропозиції :keyword:`else`, якщо вона є."

#: ../../reference/compound_stmts.rst:108
msgid "The :keyword:`!while` statement"
msgstr "Оператор :keyword:`!while`"

#: ../../reference/compound_stmts.rst:116
msgid ""
"The :keyword:`while` statement is used for repeated execution as long as an "
"expression is true:"
msgstr ""
"Інструкція :keyword:`while` використовується для повторного виконання, доки "
"вираз є істинним:"

#: ../../reference/compound_stmts.rst:123
msgid ""
"This repeatedly tests the expression and, if it is true, executes the first "
"suite; if the expression is false (which may be the first time it is tested) "
"the suite of the :keyword:`!else` clause, if present, is executed and the "
"loop terminates."
msgstr ""
"Це багаторазово перевіряє вираз і, якщо воно вірне, виконує перший набір; "
"якщо вираз є хибним (що може бути першим, коли його перевіряють), набір "
"пропозиції :keyword:`!else` виконується, і цикл припиняється."

#: ../../reference/compound_stmts.rst:132
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and goes back to testing the expression."
msgstr ""
"Інструкція :keyword:`break`, виконана в першому наборі, завершує цикл без "
"виконання набору речень :keyword:`!else`. Інструкція :keyword:`continue`, "
"виконана в першому наборі, пропускає решту пакета і повертається до "
"перевірки виразу."

#: ../../reference/compound_stmts.rst:141
msgid "The :keyword:`!for` statement"
msgstr "Оператор :keyword:`!for`"

#: ../../reference/compound_stmts.rst:152
msgid ""
"The :keyword:`for` statement is used to iterate over the elements of a "
"sequence (such as a string, tuple or list) or other iterable object:"
msgstr ""
"Оператор :keyword:`for` використовується для повторення елементів "
"послідовності (таких як рядок, кортеж або список) або іншого ітерованого "
"об’єкта:"

#: ../../reference/compound_stmts.rst:159
msgid ""
"The expression list is evaluated once; it should yield an iterable object.  "
"An iterator is created for the result of the ``expression_list``.  The suite "
"is then executed once for each item provided by the iterator, in the order "
"returned by the iterator.  Each item in turn is assigned to the target list "
"using the standard rules for assignments (see :ref:`assignment`), and then "
"the suite is executed.  When the items are exhausted (which is immediately "
"when the sequence is empty or an iterator raises a :exc:`StopIteration` "
"exception), the suite in the :keyword:`!else` clause, if present, is "
"executed, and the loop terminates."
msgstr ""
"Список виразів обчислюється один раз; він повинен давати ітерований об’єкт. "
"Для результату ``expression_list`` створюється ітератор. Потім набір "
"виконується один раз для кожного елемента, наданого ітератором, у порядку, "
"який повертає ітератор. Кожен елемент по черзі призначається цільовому "
"списку за допомогою стандартних правил призначення (див. :ref:`assignment`), "
"а потім набір виконується. Коли елементи вичерпуються (тобто відразу, коли "
"послідовність стає порожньою або ітератор викликає виняткову ситуацію :exc:"
"`StopIteration`), виконується набір у реченні :keyword:`!else`, якщо він "
"присутній, і цикл припиняється."

#: ../../reference/compound_stmts.rst:172
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the loop "
"without executing the :keyword:`!else` clause's suite.  A :keyword:"
"`continue` statement executed in the first suite skips the rest of the suite "
"and continues with the next item, or with the :keyword:`!else` clause if "
"there is no next item."
msgstr ""
"Інструкція :keyword:`break`, виконана в першому наборі, завершує цикл без "
"виконання набору речень :keyword:`!else`. Інструкція :keyword:`continue`, "
"виконана в першому наборі, пропускає решту набору і продовжує з наступним "
"елементом або з пропозицією :keyword:`!else`, якщо наступного елемента немає."

#: ../../reference/compound_stmts.rst:178
msgid ""
"The for-loop makes assignments to the variables in the target list. This "
"overwrites all previous assignments to those variables including those made "
"in the suite of the for-loop::"
msgstr ""
"Цикл for виконує призначення змінним у цільовому списку. Це перезаписує всі "
"попередні призначення цим змінним, включаючи ті, що зроблені в наборі циклу "
"for::"

#: ../../reference/compound_stmts.rst:192
msgid ""
"Names in the target list are not deleted when the loop is finished, but if "
"the sequence is empty, they will not have been assigned to at all by the "
"loop.  Hint: the built-in function :func:`range` returns an iterator of "
"integers suitable to emulate the effect of Pascal's ``for i := a to b do``; "
"e.g., ``list(range(3))`` returns the list ``[0, 1, 2]``."
msgstr ""
"Імена в цільовому списку не видаляються після завершення циклу, але якщо "
"послідовність порожня, вони взагалі не будуть призначені циклом. Підказка: "
"вбудована функція :func:`range` повертає ітератор цілих чисел, придатний для "
"імітації ефекту Pascal ``for i := a to b do``; наприклад, ``list(range(3))`` "
"повертає список ``[0, 1, 2]``."

#: ../../reference/compound_stmts.rst:204
msgid ""
"There is a subtlety when the sequence is being modified by the loop (this "
"can only occur for mutable sequences, e.g. lists).  An internal counter is "
"used to keep track of which item is used next, and this is incremented on "
"each iteration.  When this counter has reached the length of the sequence "
"the loop terminates.  This means that if the suite deletes the current (or a "
"previous) item from the sequence, the next item will be skipped (since it "
"gets the index of the current item which has already been treated).  "
"Likewise, if the suite inserts an item in the sequence before the current "
"item, the current item will be treated again the next time through the loop. "
"This can lead to nasty bugs that can be avoided by making a temporary copy "
"using a slice of the whole sequence, e.g., ::"
msgstr ""

#: ../../reference/compound_stmts.rst:225
msgid "The :keyword:`!try` statement"
msgstr "Оператор :keyword:`!try`"

#: ../../reference/compound_stmts.rst:235
msgid ""
"The :keyword:`try` statement specifies exception handlers and/or cleanup "
"code for a group of statements:"
msgstr ""
"Оператор :keyword:`try` визначає обробники винятків та/або код очищення для "
"групи операторів:"

#: ../../reference/compound_stmts.rst:248
msgid ""
"The :keyword:`except` clause(s) specify one or more exception handlers. When "
"no exception occurs in the :keyword:`try` clause, no exception handler is "
"executed. When an exception occurs in the :keyword:`!try` suite, a search "
"for an exception handler is started.  This search inspects the except "
"clauses in turn until one is found that matches the exception.  An "
"expression-less except clause, if present, must be last; it matches any "
"exception.  For an except clause with an expression, that expression is "
"evaluated, and the clause matches the exception if the resulting object is "
"\"compatible\" with the exception.  An object is compatible with an "
"exception if the object is the class or a :term:`non-virtual base class "
"<abstract base class>` of the exception object, or a tuple containing an "
"item that is the class or a non-virtual base class of the exception object."
msgstr ""
"Умова(и) :keyword:`except` визначає один або більше обробників винятків. "
"Якщо в реченні :keyword:`try` не виникає жодного винятку, обробник винятків "
"не виконується. Коли в наборі :keyword:`!try` виникає виняткова ситуація, "
"починається пошук обробника виняткової ситуації. Цей пошук перевіряє "
"пропозиції винятків по черзі, поки не буде знайдено те, що відповідає "
"винятку. Речення без виразу, крім, якщо воно присутнє, має бути останнім; "
"він відповідає будь-якому винятку. Для речення винятку з виразом цей вираз "
"оцінюється, і речення відповідає винятку, якщо отриманий об’єкт \"сумісний\" "
"з винятком. Об’єкт сумісний із винятком, якщо він є класом або :term:"
"`невіртуальним базовим класом <abstract base class>` об’єкта винятку, або "
"кортежем, що містить елемент, який є класом або невіртуальним базовим класом "
"об'єкт винятку."

#: ../../reference/compound_stmts.rst:261
msgid ""
"If no except clause matches the exception, the search for an exception "
"handler continues in the surrounding code and on the invocation stack.  [#]_"
msgstr ""
"Якщо жоден пункт винятку не відповідає винятку, пошук обробника винятку "
"продовжується в навколишньому коді та в стеку викликів. [#]_"

#: ../../reference/compound_stmts.rst:264
msgid ""
"If the evaluation of an expression in the header of an except clause raises "
"an exception, the original search for a handler is canceled and a search "
"starts for the new exception in the surrounding code and on the call stack "
"(it is treated as if the entire :keyword:`try` statement raised the "
"exception)."
msgstr ""
"Якщо обчислення виразу в заголовку пропозиції винятку викликає виняток, "
"початковий пошук обробника скасовується та починається пошук нового винятку "
"в навколишньому коді та в стеку викликів (це розглядається так, ніби весь "
"оператор :keyword:`try` викликав виняток)."

#: ../../reference/compound_stmts.rst:271
msgid ""
"When a matching except clause is found, the exception is assigned to the "
"target specified after the :keyword:`!as` keyword in that except clause, if "
"present, and the except clause's suite is executed.  All except clauses must "
"have an executable block.  When the end of this block is reached, execution "
"continues normally after the entire try statement.  (This means that if two "
"nested handlers exist for the same exception, and the exception occurs in "
"the try clause of the inner handler, the outer handler will not handle the "
"exception.)"
msgstr ""
"Якщо знайдено відповідне речення, виняток призначається цільовому об’єкту, "
"указаному після ключового слова :keyword:`!as` у цьому речення, якщо воно є, "
"і виконується набір речень. Усі речення, крім, повинні мати виконуваний "
"блок. Коли досягнуто кінця цього блоку, виконання продовжується в звичайному "
"режимі після всього оператора try. (Це означає, що якщо існують два вкладені "
"обробники для одного винятку, і виняток виникає в пропозиції try "
"внутрішнього обробника, зовнішній обробник не оброблятиме виняток.)"

#: ../../reference/compound_stmts.rst:279
msgid ""
"When an exception has been assigned using ``as target``, it is cleared at "
"the end of the except clause.  This is as if ::"
msgstr ""
"Якщо виняток було призначено за допомогою ``as target``, воно очищається в "
"кінці пропозиції винятку. Це ніби ::"

#: ../../reference/compound_stmts.rst:285
msgid "was translated to ::"
msgstr "було перекладено на::"

#: ../../reference/compound_stmts.rst:293
msgid ""
"This means the exception must be assigned to a different name to be able to "
"refer to it after the except clause.  Exceptions are cleared because with "
"the traceback attached to them, they form a reference cycle with the stack "
"frame, keeping all locals in that frame alive until the next garbage "
"collection occurs."
msgstr ""
"Це означає, що винятку потрібно призначити інше ім’я, щоб можна було "
"посилатися на нього після пропозиції винятку. Винятки очищаються, оскільки з "
"підключеною до них трасуванням вони утворюють еталонний цикл із фреймом "
"стека, зберігаючи всіх локальних у цьому фреймі живими до наступного "
"збирання сміття."

#: ../../reference/compound_stmts.rst:302
msgid ""
"Before an except clause's suite is executed, details about the exception are "
"stored in the :mod:`sys` module and can be accessed via :func:`sys."
"exc_info`. :func:`sys.exc_info` returns a 3-tuple consisting of the "
"exception class, the exception instance and a traceback object (see section :"
"ref:`types`) identifying the point in the program where the exception "
"occurred.  :func:`sys.exc_info` values are restored to their previous values "
"(before the call) when returning from a function that handled an exception."
msgstr ""

#: ../../reference/compound_stmts.rst:316
msgid ""
"The optional :keyword:`!else` clause is executed if the control flow leaves "
"the :keyword:`try` suite, no exception was raised, and no :keyword:"
"`return`, :keyword:`continue`, or :keyword:`break` statement was executed.  "
"Exceptions in the :keyword:`!else` clause are not handled by the preceding :"
"keyword:`except` clauses."
msgstr ""
"Необов’язкова пропозиція :keyword:`!else` виконується, якщо потік керування "
"виходить із набору :keyword:`try`, не було викликано винятків і немає :"
"keyword:`return`, :keyword:`continue` або Інструкція :keyword:`break` була "
"виконана. Винятки в пункті :keyword:`!else` не обробляються попередніми "
"пунктами :keyword:`except`."

#: ../../reference/compound_stmts.rst:324
msgid ""
"If :keyword:`finally` is present, it specifies a 'cleanup' handler.  The :"
"keyword:`try` clause is executed, including any :keyword:`except` and :"
"keyword:`!else` clauses.  If an exception occurs in any of the clauses and "
"is not handled, the exception is temporarily saved. The :keyword:`!finally` "
"clause is executed.  If there is a saved exception it is re-raised at the "
"end of the :keyword:`!finally` clause.  If the :keyword:`!finally` clause "
"raises another exception, the saved exception is set as the context of the "
"new exception. If the :keyword:`!finally` clause executes a :keyword:"
"`return`, :keyword:`break` or :keyword:`continue` statement, the saved "
"exception is discarded::"
msgstr ""
"Якщо :keyword:`finally` присутній, він визначає обробник 'очищення'. "
"Речення :keyword:`try` виконується, включаючи будь-які пропозиції :keyword:"
"`except` і :keyword:`!else`. Якщо виняток виникає в будь-якому з пунктів і "
"не обробляється, виняток тимчасово зберігається. Речення :keyword:`!finally` "
"виконується. Якщо є збережений виняток, він повторно викликається в кінці "
"пропозиції :keyword:`!finally`. Якщо речення :keyword:`!finally` викликає "
"інший виняток, збережений виняток встановлюється як контекст нового "
"виключення. Якщо пропозиція :keyword:`!finally` виконує оператор :keyword:"
"`return`, :keyword:`break` або :keyword:`continue`, збережений виняток "
"скидається:"

#: ../../reference/compound_stmts.rst:343
msgid ""
"The exception information is not available to the program during execution "
"of the :keyword:`finally` clause."
msgstr ""
"Інформація про винятки недоступна для програми під час виконання пропозиції :"
"keyword:`finally`."

#: ../../reference/compound_stmts.rst:351
msgid ""
"When a :keyword:`return`, :keyword:`break` or :keyword:`continue` statement "
"is executed in the :keyword:`try` suite of a :keyword:`!try`...\\ :keyword:`!"
"finally` statement, the :keyword:`finally` clause is also executed 'on the "
"way out.'"
msgstr ""
"Коли оператор :keyword:`return`, :keyword:`break` або :keyword:`continue` "
"виконується в наборі :keyword:`try` :keyword:`!try`...\\ оператор :keyword:`!"
"finally`, пункт :keyword:`finally` також виконується \"на виході\"."

#: ../../reference/compound_stmts.rst:355
msgid ""
"The return value of a function is determined by the last :keyword:`return` "
"statement executed.  Since the :keyword:`finally` clause always executes, a :"
"keyword:`!return` statement executed in the :keyword:`!finally` clause will "
"always be the last one executed::"
msgstr ""
"Повернене значення функції визначається останнім виконаним оператором :"
"keyword:`return`. Оскільки пропозиція :keyword:`finally` завжди виконується, "
"оператор :keyword:`!return`, що виконується в пропозиції :keyword:`!"
"finally`, завжди буде виконуватися останнім::"

#: ../../reference/compound_stmts.rst:369
msgid ""
"Additional information on exceptions can be found in section :ref:"
"`exceptions`, and information on using the :keyword:`raise` statement to "
"generate exceptions may be found in section :ref:`raise`."
msgstr ""
"Додаткову інформацію про винятки можна знайти в розділі :ref:`exceptions`, а "
"інформацію про використання оператора :keyword:`raise` для створення "
"винятків можна знайти в розділі :ref:`raise`."

#: ../../reference/compound_stmts.rst:373
msgid ""
"Prior to Python 3.8, a :keyword:`continue` statement was illegal in the :"
"keyword:`finally` clause due to a problem with the implementation."
msgstr ""
"До Python 3.8 оператор :keyword:`continue` був незаконним у пункті :keyword:"
"`finally` через проблему з реалізацією."

#: ../../reference/compound_stmts.rst:382
msgid "The :keyword:`!with` statement"
msgstr "Оператор :keyword:`!with`"

#: ../../reference/compound_stmts.rst:391
msgid ""
"The :keyword:`with` statement is used to wrap the execution of a block with "
"methods defined by a context manager (see section :ref:`context-managers`). "
"This allows common :keyword:`try`...\\ :keyword:`except`...\\ :keyword:"
"`finally` usage patterns to be encapsulated for convenient reuse."
msgstr ""
"Оператор :keyword:`with` використовується для обгортання виконання блоку "
"методами, визначеними контекстним менеджером (див. розділ :ref:`context-"
"managers`). Це дозволяє інкапсулювати загальні :keyword:`try`...\\ :keyword:"
"`except`...\\ :keyword:`finally` моделі використання для зручного повторного "
"використання."

#: ../../reference/compound_stmts.rst:400
msgid ""
"The execution of the :keyword:`with` statement with one \"item\" proceeds as "
"follows:"
msgstr ""
"Виконання оператора :keyword:`with` з одним \"елементом\" відбувається "
"наступним чином:"

#: ../../reference/compound_stmts.rst:402
msgid ""
"The context expression (the expression given in the :token:`with_item`) is "
"evaluated to obtain a context manager."
msgstr ""

#: ../../reference/compound_stmts.rst:405
msgid "The context manager's :meth:`__enter__` is loaded for later use."
msgstr ""
"Менеджер контексту :meth:`__enter__` завантажується для подальшого "
"використання."

#: ../../reference/compound_stmts.rst:407
msgid "The context manager's :meth:`__exit__` is loaded for later use."
msgstr ""
"Менеджер контексту :meth:`__exit__` завантажується для подальшого "
"використання."

#: ../../reference/compound_stmts.rst:409
msgid "The context manager's :meth:`__enter__` method is invoked."
msgstr "Викликається метод :meth:`__enter__` контекстного менеджера."

#: ../../reference/compound_stmts.rst:411
msgid ""
"If a target was included in the :keyword:`with` statement, the return value "
"from :meth:`__enter__` is assigned to it."
msgstr ""
"Якщо мета була включена в оператор :keyword:`with`, їй призначається "
"значення, що повертається з :meth:`__enter__`."

#: ../../reference/compound_stmts.rst:416
msgid ""
"The :keyword:`with` statement guarantees that if the :meth:`__enter__` "
"method returns without an error, then :meth:`__exit__` will always be "
"called. Thus, if an error occurs during the assignment to the target list, "
"it will be treated the same as an error occurring within the suite would be. "
"See step 6 below."
msgstr ""
"Оператор :keyword:`with` гарантує, що якщо метод :meth:`__enter__` повертає "
"без помилки, то :meth:`__exit__` завжди буде викликатися. Таким чином, якщо "
"під час призначення цільового списку виникає помилка, вона розглядатиметься "
"так само, як і помилка, яка сталася в наборі. Дивіться крок 6 нижче."

#: ../../reference/compound_stmts.rst:422
msgid "The suite is executed."
msgstr "Сюїта виконана."

#: ../../reference/compound_stmts.rst:424
msgid ""
"The context manager's :meth:`__exit__` method is invoked.  If an exception "
"caused the suite to be exited, its type, value, and traceback are passed as "
"arguments to :meth:`__exit__`. Otherwise, three :const:`None` arguments are "
"supplied."
msgstr ""
"Викликається метод :meth:`__exit__` контекстного менеджера. Якщо виняткова "
"ситуація призвела до виходу з набору, його тип, значення та відстеження "
"передаються як аргументи :meth:`__exit__`. В іншому випадку надається три "
"аргументи :const:`None`."

#: ../../reference/compound_stmts.rst:429
msgid ""
"If the suite was exited due to an exception, and the return value from the :"
"meth:`__exit__` method was false, the exception is reraised.  If the return "
"value was true, the exception is suppressed, and execution continues with "
"the statement following the :keyword:`with` statement."
msgstr ""
"Якщо набір було закрито через виняток, а значення, яке повертає метод :meth:"
"`__exit__`, було false, виняток створюється повторно. Якщо повернене "
"значення було істинним, виняток пригнічується, і виконання продовжується з "
"оператором, наступним за оператором :keyword:`with`."

#: ../../reference/compound_stmts.rst:434
msgid ""
"If the suite was exited for any reason other than an exception, the return "
"value from :meth:`__exit__` is ignored, and execution proceeds at the normal "
"location for the kind of exit that was taken."
msgstr ""
"Якщо вихід із набору було завершено з будь-якої причини, крім винятку, "
"значення, що повертається з :meth:`__exit__`, ігнорується, і виконання "
"продовжується у звичайному місці для того виду виходу, який було зроблено."

#: ../../reference/compound_stmts.rst:438
#: ../../reference/compound_stmts.rst:815
#: ../../reference/compound_stmts.rst:856
msgid "The following code::"
msgstr "Наступний код::"

#: ../../reference/compound_stmts.rst:443
#: ../../reference/compound_stmts.rst:468
#: ../../reference/compound_stmts.rst:861
msgid "is semantically equivalent to::"
msgstr "семантично еквівалентний::"

#: ../../reference/compound_stmts.rst:462
msgid ""
"With more than one item, the context managers are processed as if multiple :"
"keyword:`with` statements were nested::"
msgstr ""
"З більш ніж одним елементом менеджери контексту обробляються так, ніби "
"кілька операторів :keyword:`with` були вкладеними::"

#: ../../reference/compound_stmts.rst:474
msgid "Support for multiple context expressions."
msgstr "Підтримка кількох контекстних виразів."

#: ../../reference/compound_stmts.rst:480
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - оператор \"з\"."

#: ../../reference/compound_stmts.rst:480
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Специфікація, передумови та приклади оператора Python :keyword:`with`."

#: ../../reference/compound_stmts.rst:490
msgid "Function definitions"
msgstr "Визначення функцій"

#: ../../reference/compound_stmts.rst:505
msgid ""
"A function definition defines a user-defined function object (see section :"
"ref:`types`):"
msgstr ""
"Визначення функції визначає об’єкт функції, визначений користувачем (див. "
"розділ :ref:`types`):"

#: ../../reference/compound_stmts.rst:524
msgid ""
"A function definition is an executable statement.  Its execution binds the "
"function name in the current local namespace to a function object (a wrapper "
"around the executable code for the function).  This function object contains "
"a reference to the current global namespace as the global namespace to be "
"used when the function is called."
msgstr ""
"Визначення функції - це виконуваний оператор. Його виконання прив’язує назву "
"функції в поточному локальному просторі імен до об’єкта функції (обгортка "
"навколо виконуваного коду для функції). Цей об’єкт функції містить посилання "
"на поточний глобальний простір імен як глобальний простір імен, який буде "
"використано під час виклику функції."

#: ../../reference/compound_stmts.rst:530
msgid ""
"The function definition does not execute the function body; this gets "
"executed only when the function is called. [#]_"
msgstr ""
"Визначення функції не виконує тіло функції; це виконується лише під час "
"виклику функції. [#]_"

#: ../../reference/compound_stmts.rst:536
msgid ""
"A function definition may be wrapped by one or more :term:`decorator` "
"expressions. Decorator expressions are evaluated when the function is "
"defined, in the scope that contains the function definition.  The result "
"must be a callable, which is invoked with the function object as the only "
"argument. The returned value is bound to the function name instead of the "
"function object.  Multiple decorators are applied in nested fashion. For "
"example, the following code ::"
msgstr ""
"Визначення функції може бути обгорнуте одним або кількома виразами :term:"
"`decorator`. Вирази декоратора обчислюються, коли функція визначена в "
"області видимості, яка містить визначення функції. Результат має бути "
"викликаним, який викликається з об’єктом функції як єдиним аргументом. "
"Повернене значення прив’язується до імені функції замість об’єкта функції. "
"Кілька декораторів застосовуються вкладеним способом. Наприклад, такий код::"

#: ../../reference/compound_stmts.rst:547
#: ../../reference/compound_stmts.rst:724
msgid "is roughly equivalent to ::"
msgstr "приблизно еквівалентно ::"

#: ../../reference/compound_stmts.rst:552
msgid ""
"except that the original function is not temporarily bound to the name "
"``func``."
msgstr ""
"за винятком того, що вихідна функція тимчасово не прив’язана до імені "
"``func``."

#: ../../reference/compound_stmts.rst:554
msgid ""
"Functions may be decorated with any valid :token:`assignment_expression`. "
"Previously, the grammar was much more restrictive; see :pep:`614` for "
"details."
msgstr ""

#: ../../reference/compound_stmts.rst:564
msgid ""
"When one or more :term:`parameters <parameter>` have the form *parameter* "
"``=`` *expression*, the function is said to have \"default parameter values."
"\"  For a parameter with a default value, the corresponding :term:`argument` "
"may be omitted from a call, in which case the parameter's default value is "
"substituted.  If a parameter has a default value, all following parameters "
"up until the \"``*``\" must also have a default value --- this is a "
"syntactic restriction that is not expressed by the grammar."
msgstr ""
"Коли один або більше :term:`параметрів <parameter>` мають форму *параметр* "
"``=`` *вираз*, кажуть, що функція має \"значення параметрів за "
"замовчуванням\". Для параметра зі значенням за замовчуванням відповідний :"
"term:`argument` може бути пропущений у виклику, у цьому випадку значення "
"параметра за замовчуванням замінюється. Якщо параметр має значення за "
"замовчуванням, усі наступні параметри до \"``*``\" також повинні мати "
"значення за замовчуванням --- це синтаксичне обмеження, яке не виражається "
"граматикою."

#: ../../reference/compound_stmts.rst:572
msgid ""
"**Default parameter values are evaluated from left to right when the "
"function definition is executed.** This means that the expression is "
"evaluated once, when the function is defined, and that the same \"pre-"
"computed\" value is used for each call.  This is especially important to "
"understand when a default parameter is a mutable object, such as a list or a "
"dictionary: if the function modifies the object (e.g. by appending an item "
"to a list), the default value is in effect modified.  This is generally not "
"what was intended.  A way around this is to use ``None`` as the default, and "
"explicitly test for it in the body of the function, e.g.::"
msgstr ""

#: ../../reference/compound_stmts.rst:593
msgid ""
"Function call semantics are described in more detail in section :ref:"
"`calls`. A function call always assigns values to all parameters mentioned "
"in the parameter list, either from positional arguments, from keyword "
"arguments, or from default values.  If the form \"``*identifier``\" is "
"present, it is initialized to a tuple receiving any excess positional "
"parameters, defaulting to the empty tuple. If the form \"``**identifier``\" "
"is present, it is initialized to a new ordered mapping receiving any excess "
"keyword arguments, defaulting to a new empty mapping of the same type.  "
"Parameters after \"``*``\" or \"``*identifier``\" are keyword-only "
"parameters and may only be passed by keyword arguments.  Parameters before "
"\"``/``\" are positional-only parameters and may only be passed by "
"positional arguments."
msgstr ""
"Більш детально семантика виклику функції описана в розділі :ref:`calls`. "
"Виклик функції завжди призначає значення всім параметрам, згаданим у списку "
"параметрів, або з позиційних аргументів, з ключових аргументів, або зі "
"значень за замовчуванням. Якщо присутня форма \"``*identifier``\", вона "
"ініціалізується кортежем, що отримує будь-які надлишкові позиційні "
"параметри, за умовчанням порожній кортеж. Якщо присутня форма "
"\"``*identifier``\", вона ініціалізується новим упорядкованим відображенням, "
"отримуючи будь-які надлишкові аргументи ключового слова, за умовчанням до "
"нового порожнього відображення того самого типу. Параметри після \"``*``\" "
"або \"``*identifier``\" є параметрами лише для ключових слів і можуть "
"передаватися лише аргументами ключових слів. Параметри перед \"``/``\" є "
"лише позиційними параметрами і можуть передаватися лише позиційними "
"аргументами."

#: ../../reference/compound_stmts.rst:605
msgid ""
"The ``/`` function parameter syntax may be used to indicate positional-only "
"parameters. See :pep:`570` for details."
msgstr ""
"Синтаксис параметра функції ``/`` може використовуватися для позначення лише "
"позиційних параметрів. Подробиці див. :pep:`570`."

#: ../../reference/compound_stmts.rst:614
msgid ""
"Parameters may have an :term:`annotation <function annotation>` of the form "
"\"``: expression``\" following the parameter name.  Any parameter may have "
"an annotation, even those of the form ``*identifier`` or ``**identifier``.  "
"Functions may have \"return\" annotation of the form \"``-> expression``\" "
"after the parameter list.  These annotations can be any valid Python "
"expression.  The presence of annotations does not change the semantics of a "
"function.  The annotation values are available as values of a dictionary "
"keyed by the parameters' names in the :attr:`__annotations__` attribute of "
"the function object.  If the ``annotations`` import from :mod:`__future__` "
"is used, annotations are preserved as strings at runtime which enables "
"postponed evaluation.  Otherwise, they are evaluated when the function "
"definition is executed.  In this case annotations may be evaluated in a "
"different order than they appear in the source code."
msgstr ""
"Параметри можуть мати :term:`анотацію <function annotation>` у формі \"``:"
"вираз``\" після імені параметра. Будь-який параметр може мати анотацію, "
"навіть у формі ``*ідентифікатор`` або ``**ідентифікатор``. Функції можуть "
"мати анотацію \"повернення\" у формі \"``-> вираз``\" після списку "
"параметрів. Ці анотації можуть бути будь-яким дійсним виразом Python. "
"Наявність анотацій не змінює семантику функції. Значення анотацій доступні "
"як значення словника, ключ якого містить імена параметрів в атрибуті :attr:"
"`__annotations__` об’єкта функції. Якщо використовується імпорт ``анотацій`` "
"із :mod:`__future__`, анотації зберігаються як рядки під час виконання, що "
"дає змогу відкласти оцінку. В іншому випадку вони оцінюються під час "
"виконання визначення функції. У цьому випадку анотації можуть оцінюватися в "
"іншому порядку, ніж у вихідному коді."

#: ../../reference/compound_stmts.rst:629
msgid ""
"It is also possible to create anonymous functions (functions not bound to a "
"name), for immediate use in expressions.  This uses lambda expressions, "
"described in section :ref:`lambda`.  Note that the lambda expression is "
"merely a shorthand for a simplified function definition; a function defined "
"in a \":keyword:`def`\" statement can be passed around or assigned to "
"another name just like a function defined by a lambda expression.  The \":"
"keyword:`!def`\" form is actually more powerful since it allows the "
"execution of multiple statements and annotations."
msgstr ""
"Також можна створювати анонімні функції (функції, не прив’язані до імені) "
"для негайного використання у виразах. Тут використовуються лямбда-вирази, "
"описані в розділі :ref:`lambda`. Зауважте, що лямбда-вираз — це лише "
"скорочення спрощеного визначення функції; функція, визначена в операторі \":"
"keyword:`def`\", може бути передана або присвоєна іншому імені так само, як "
"функція, визначена лямбда-виразом. Форма \":keyword:`!def`\" насправді є "
"потужнішою, оскільки вона дозволяє виконувати кілька операторів і анотацій."

#: ../../reference/compound_stmts.rst:637
msgid ""
"**Programmer's note:** Functions are first-class objects.  A \"``def``\" "
"statement executed inside a function definition defines a local function "
"that can be returned or passed around.  Free variables used in the nested "
"function can access the local variables of the function containing the def.  "
"See section :ref:`naming` for details."
msgstr ""
"**Примітка програміста:** Функції є об’єктами першого класу. Оператор "
"\"``def``\", який виконується всередині визначення функції, визначає "
"локальну функцію, яку можна повертати або передавати. Вільні змінні, які "
"використовуються у вкладеній функції, можуть отримати доступ до локальних "
"змінних функції, що містить def. Перегляньте розділ :ref:`naming` для "
"деталей."

#: ../../reference/compound_stmts.rst:646
msgid ":pep:`3107` - Function Annotations"
msgstr ":pep:`3107` - Анотації функцій"

#: ../../reference/compound_stmts.rst:646
msgid "The original specification for function annotations."
msgstr "Оригінальна специфікація для анотацій функцій."

#: ../../reference/compound_stmts.rst:649
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - підказки типу"

#: ../../reference/compound_stmts.rst:649
msgid "Definition of a standard meaning for annotations: type hints."
msgstr "Визначення стандартного значення для анотацій: тип підказок."

#: ../../reference/compound_stmts.rst:653
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - Синтаксис для анотацій змінних"

#: ../../reference/compound_stmts.rst:652
msgid ""
"Ability to type hint variable declarations, including class variables and "
"instance variables"
msgstr ""
"Можливість вводити оголошення змінних підказок, включаючи змінні класу та "
"змінні екземпляра"

#: ../../reference/compound_stmts.rst:656
msgid ":pep:`563` - Postponed Evaluation of Annotations"
msgstr ":pep:`563` - Відкладена оцінка анотацій"

#: ../../reference/compound_stmts.rst:656
msgid ""
"Support for forward references within annotations by preserving annotations "
"in a string form at runtime instead of eager evaluation."
msgstr ""
"Підтримка прямих посилань в анотаціях завдяки збереженню анотацій у формі "
"рядка під час виконання замість нетерплячої оцінки."

#: ../../reference/compound_stmts.rst:663
msgid "Class definitions"
msgstr "Визначення класів"

#: ../../reference/compound_stmts.rst:678
msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr "Визначення класу визначає об’єкт класу (див. розділ :ref:`types`):"

#: ../../reference/compound_stmts.rst:685
msgid ""
"A class definition is an executable statement.  The inheritance list usually "
"gives a list of base classes (see :ref:`metaclasses` for more advanced "
"uses), so each item in the list should evaluate to a class object which "
"allows subclassing.  Classes without an inheritance list inherit, by "
"default, from the base class :class:`object`; hence, ::"
msgstr ""
"Визначення класу є виконуваним оператором. Список успадкування зазвичай "
"надає список базових класів (див. :ref:`metaclasses` для більш просунутого "
"використання), тому кожен елемент у списку повинен оцінюватися як об’єкт "
"класу, який дозволяє створювати підкласи. Класи без списку успадкування "
"успадковують, за замовчуванням, від базового класу :class:`object`; отже, ::"

#: ../../reference/compound_stmts.rst:694
msgid "is equivalent to ::"
msgstr "еквівалентно ::"

#: ../../reference/compound_stmts.rst:699
msgid ""
"The class's suite is then executed in a new execution frame (see :ref:"
"`naming`), using a newly created local namespace and the original global "
"namespace. (Usually, the suite contains mostly function definitions.)  When "
"the class's suite finishes execution, its execution frame is discarded but "
"its local namespace is saved. [#]_ A class object is then created using the "
"inheritance list for the base classes and the saved local namespace for the "
"attribute dictionary.  The class name is bound to this class object in the "
"original local namespace."
msgstr ""
"Потім набір класів виконується в новому фреймі виконання (див. :ref:"
"`naming`), використовуючи щойно створений локальний простір імен і "
"оригінальний глобальний простір імен. (Зазвичай набір містить в основному "
"визначення функцій.) Коли набір класу завершує виконання, його кадр "
"виконання відкидається, але його локальний простір імен зберігається. [#]_ "
"Потім створюється об’єкт класу з використанням списку успадкування для "
"базових класів і збереженого локального простору імен для словника "
"атрибутів. Ім'я класу прив'язане до цього об'єкта класу в оригінальному "
"локальному просторі імен."

#: ../../reference/compound_stmts.rst:708
msgid ""
"The order in which attributes are defined in the class body is preserved in "
"the new class's ``__dict__``.  Note that this is reliable only right after "
"the class is created and only for classes that were defined using the "
"definition syntax."
msgstr ""
"Порядок, у якому атрибути визначені в тілі класу, зберігається в "
"``__dict__`` нового класу. Зауважте, що це надійно лише відразу після "
"створення класу та лише для класів, які були визначені за допомогою "
"синтаксису визначення."

#: ../../reference/compound_stmts.rst:713
msgid ""
"Class creation can be customized heavily using :ref:`metaclasses "
"<metaclasses>`."
msgstr ""
"Створення класів можна значно налаштувати за допомогою :ref:`metaclasses "
"<metaclasses>`."

#: ../../reference/compound_stmts.rst:718
msgid "Classes can also be decorated: just like when decorating functions, ::"
msgstr "Класи також можна декорувати: як і при декоруванні функцій, ::"

#: ../../reference/compound_stmts.rst:729
msgid ""
"The evaluation rules for the decorator expressions are the same as for "
"function decorators.  The result is then bound to the class name."
msgstr ""
"Правила оцінки для виразів декоратора такі ж, як і для декораторів функцій. "
"Потім результат прив’язується до імені класу."

#: ../../reference/compound_stmts.rst:732
msgid ""
"Classes may be decorated with any valid :token:`assignment_expression`. "
"Previously, the grammar was much more restrictive; see :pep:`614` for "
"details."
msgstr ""

#: ../../reference/compound_stmts.rst:737
msgid ""
"**Programmer's note:** Variables defined in the class definition are class "
"attributes; they are shared by instances.  Instance attributes can be set in "
"a method with ``self.name = value``.  Both class and instance attributes are "
"accessible through the notation \"``self.name``\", and an instance attribute "
"hides a class attribute with the same name when accessed in this way.  Class "
"attributes can be used as defaults for instance attributes, but using "
"mutable values there can lead to unexpected results.  :ref:`Descriptors "
"<descriptors>` can be used to create instance variables with different "
"implementation details."
msgstr ""
"**Примітка програміста:** Змінні, визначені у визначенні класу, є атрибутами "
"класу; їх ділять інстанції. Атрибути екземпляра можна встановити в методі за "
"допомогою ``self.name = value``. Як атрибути класу, так і атрибути "
"екземпляра доступні через нотацію \"``self.name``\", а атрибут екземпляра "
"приховує атрибут класу з таким самим іменем, коли до нього звертаються таким "
"чином. Атрибути класу можна використовувати як значення за замовчуванням для "
"атрибутів екземплярів, але використання там змінних значень може призвести "
"до неочікуваних результатів. :ref:`Дескриптори <descriptors>` можна "
"використовувати для створення змінних екземпляра з різними деталями "
"реалізації."

#: ../../reference/compound_stmts.rst:752
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - Метакласи в Python 3000"

#: ../../reference/compound_stmts.rst:750
msgid ""
"The proposal that changed the declaration of metaclasses to the current "
"syntax, and the semantics for how classes with metaclasses are constructed."
msgstr ""
"Пропозиція, яка змінила оголошення метакласів на поточний синтаксис і "
"семантику того, як будуються класи з метакласами."

#: ../../reference/compound_stmts.rst:755
msgid ":pep:`3129` - Class Decorators"
msgstr ":pep:`3129` - Декоратори класу"

#: ../../reference/compound_stmts.rst:755
msgid ""
"The proposal that added class decorators.  Function and method decorators "
"were introduced in :pep:`318`."
msgstr ""
"Пропозиція, яка додала декоратори класу. Декоратори функцій і методів були "
"представлені в :pep:`318`."

#: ../../reference/compound_stmts.rst:762
msgid "Coroutines"
msgstr "Співпрограми"

#: ../../reference/compound_stmts.rst:770
msgid "Coroutine function definition"
msgstr "Визначення функції співпрограми"

#: ../../reference/compound_stmts.rst:780
msgid ""
"Execution of Python coroutines can be suspended and resumed at many points "
"(see :term:`coroutine`).  Inside the body of a coroutine function, ``await`` "
"and ``async`` identifiers become reserved keywords; :keyword:`await` "
"expressions, :keyword:`async for` and :keyword:`async with` can only be used "
"in coroutine function bodies."
msgstr ""

#: ../../reference/compound_stmts.rst:786
msgid ""
"Functions defined with ``async def`` syntax are always coroutine functions, "
"even if they do not contain ``await`` or ``async`` keywords."
msgstr ""
"Функції, визначені за допомогою синтаксису ``async def``, завжди є функціями "
"співпрограми, навіть якщо вони не містять ключових слів ``await`` або "
"``async``."

#: ../../reference/compound_stmts.rst:789
msgid ""
"It is a :exc:`SyntaxError` to use a ``yield from`` expression inside the "
"body of a coroutine function."
msgstr ""
"Використання виразу ``yield from`` всередині тіла функції співпрограми є :"
"exc:`SyntaxError`."

#: ../../reference/compound_stmts.rst:792
msgid "An example of a coroutine function::"
msgstr "Приклад функції співпрограми::"

#: ../../reference/compound_stmts.rst:803
msgid "The :keyword:`!async for` statement"
msgstr "Оператор :keyword:`!async for`"

#: ../../reference/compound_stmts.rst:808
msgid ""
"An :term:`asynchronous iterable` provides an ``__aiter__`` method that "
"directly returns an :term:`asynchronous iterator`, which can call "
"asynchronous code in its ``__anext__`` method."
msgstr ""
":term:`asynchronous iterable` надає метод ``__aiter__``, який безпосередньо "
"повертає :term:`asynchronous iterator`, який може викликати асинхронний код "
"у своєму методі ``__anext__``."

#: ../../reference/compound_stmts.rst:812
msgid ""
"The ``async for`` statement allows convenient iteration over asynchronous "
"iterables."
msgstr ""
"Оператор ``async for`` дозволяє зручно виконувати ітерації над асинхронними "
"ітераціями."

#: ../../reference/compound_stmts.rst:822
msgid "Is semantically equivalent to::"
msgstr "Семантично еквівалентний::"

#: ../../reference/compound_stmts.rst:838
msgid "See also :meth:`__aiter__` and :meth:`__anext__` for details."
msgstr "Дивіться також :meth:`__aiter__` і :meth:`__anext__` для деталей."

#: ../../reference/compound_stmts.rst:840
msgid ""
"It is a :exc:`SyntaxError` to use an ``async for`` statement outside the "
"body of a coroutine function."
msgstr ""
"Це :exc:`SyntaxError`, якщо використовувати оператор ``async for`` поза "
"тілом функції співпрограми."

#: ../../reference/compound_stmts.rst:848
msgid "The :keyword:`!async with` statement"
msgstr "Оператор :keyword:`!async with`"

#: ../../reference/compound_stmts.rst:853
msgid ""
"An :term:`asynchronous context manager` is a :term:`context manager` that is "
"able to suspend execution in its *enter* and *exit* methods."
msgstr ""
"Асинхронний менеджер контексту (:term:`asynchronous context manager`) — це "
"менеджер контексту (:term:`context manager`),який може призупинити виконання "
"своїх методів *enter* і *exit*."

#: ../../reference/compound_stmts.rst:880
msgid "See also :meth:`__aenter__` and :meth:`__aexit__` for details."
msgstr "Дивіться також :meth:`__aenter__` і :meth:`__aexit__` для деталей."

#: ../../reference/compound_stmts.rst:882
msgid ""
"It is a :exc:`SyntaxError` to use an ``async with`` statement outside the "
"body of a coroutine function."
msgstr ""
"Це :exc:`SyntaxError`, якщо використовувати оператор ``async with`` поза "
"тілом функції співпрограми."

#: ../../reference/compound_stmts.rst:888
msgid ":pep:`492` - Coroutines with async and await syntax"
msgstr ":pep:`492` - Співпрограми з синтаксисом async і await"

#: ../../reference/compound_stmts.rst:888
msgid ""
"The proposal that made coroutines a proper standalone concept in Python, and "
"added supporting syntax."
msgstr ""
"Пропозиція, яка зробила співпрограми справжньою автономною концепцією в "
"Python і додала допоміжний синтаксис."

#: ../../reference/compound_stmts.rst:893
msgid "Footnotes"
msgstr "Примітки"

#: ../../reference/compound_stmts.rst:894
msgid ""
"The exception is propagated to the invocation stack unless there is a :"
"keyword:`finally` clause which happens to raise another exception. That new "
"exception causes the old one to be lost."
msgstr ""
"Виняток поширюється на стек викликів, якщо немає пункту :keyword:`finally`, "
"який викликає інший виняток. Цей новий виняток призводить до втрати старого."

#: ../../reference/compound_stmts.rst:898
msgid ""
"A string literal appearing as the first statement in the function body is "
"transformed into the function's ``__doc__`` attribute and therefore the "
"function's :term:`docstring`."
msgstr ""
"Рядковий літерал, який з’являється як перший оператор у тілі функції, "
"перетворюється на атрибут функції ``__doc__`` і, отже, функцію :term:"
"`docstring`."

#: ../../reference/compound_stmts.rst:902
msgid ""
"A string literal appearing as the first statement in the class body is "
"transformed into the namespace's ``__doc__`` item and therefore the class's :"
"term:`docstring`."
msgstr ""
"Рядковий літерал, що з’являється як перший оператор у тілі класу, "
"перетворюється на елемент простору імен ``__doc__`` і, отже, на :term:"
"`docstring` класу."
