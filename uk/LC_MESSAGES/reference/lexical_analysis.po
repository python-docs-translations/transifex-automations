# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-21 22:53+0000\n"
"PO-Revision-Date: 2022-11-05 17:23+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../reference/lexical_analysis.rst:6
msgid "Lexical analysis"
msgstr "Лексичний аналіз"

#: ../../reference/lexical_analysis.rst:10
msgid ""
"A Python program is read by a *parser*.  Input to the parser is a stream of "
"*tokens*, generated by the *lexical analyzer*.  This chapter describes how "
"the lexical analyzer breaks a file into tokens."
msgstr ""
"Програма Python читається *парсером*. Вхідними даними для аналізатора є "
"потік *токенів*, згенерованих *лексичним аналізатором*. У цьому розділі "
"описано, як лексичний аналізатор розбиває файл на токени."

#: ../../reference/lexical_analysis.rst:14
msgid ""
"Python reads program text as Unicode code points; the encoding of a source "
"file can be given by an encoding declaration and defaults to UTF-8, see :pep:"
"`3120` for details.  If the source file cannot be decoded, a :exc:"
"`SyntaxError` is raised."
msgstr ""
"Python читає текст програми як кодові точки Unicode; кодування вихідного "
"файлу може бути задано декларацією кодування та за замовчуванням UTF-8, "
"подробиці див. :pep:`3120`. Якщо вихідний файл не може бути декодований, "
"виникає :exc:`SyntaxError`."

#: ../../reference/lexical_analysis.rst:23
msgid "Line structure"
msgstr "Лінійна структура"

#: ../../reference/lexical_analysis.rst:27
msgid "A Python program is divided into a number of *logical lines*."
msgstr "Програма Python розділена на кілька *логічних рядків*."

#: ../../reference/lexical_analysis.rst:33
msgid "Logical lines"
msgstr "Логічні лінії"

#: ../../reference/lexical_analysis.rst:37
msgid ""
"The end of a logical line is represented by the token NEWLINE.  Statements "
"cannot cross logical line boundaries except where NEWLINE is allowed by the "
"syntax (e.g., between statements in compound statements). A logical line is "
"constructed from one or more *physical lines* by following the explicit or "
"implicit *line joining* rules."
msgstr ""
"Кінець логічного рядка представлено маркером NEWLINE. Інструкції не можуть "
"перетинати межі логічного рядка, за винятком випадків, коли синтаксис "
"дозволяє NEWLINE (наприклад, між операторами в складених операторах). "
"Логічна лінія складається з однієї або кількох *фізичних ліній* за "
"дотриманням явних або неявних правил *об’єднання ліній*."

#: ../../reference/lexical_analysis.rst:47
msgid "Physical lines"
msgstr "Фізичні лінії"

#: ../../reference/lexical_analysis.rst:49
msgid ""
"A physical line is a sequence of characters terminated by an end-of-line "
"sequence.  In source files and strings, any of the standard platform line "
"termination sequences can be used - the Unix form using ASCII LF (linefeed), "
"the Windows form using the ASCII sequence CR LF (return followed by "
"linefeed), or the old Macintosh form using the ASCII CR (return) character.  "
"All of these forms can be used equally, regardless of platform. The end of "
"input also serves as an implicit terminator for the final physical line."
msgstr ""
"Фізичний рядок — це послідовність символів, що завершується послідовністю в "
"кінці рядка. У вихідних файлах і рядках можна використовувати будь-яку зі "
"стандартних послідовностей завершення рядків платформи – форму Unix із "
"використанням ASCII LF (переведення рядка), форму Windows із використанням "
"послідовності ASCII CR LF (повернення з наступним переходом рядка) або стару "
"форму Macintosh із використанням символ ASCII CR (повернення). Усі ці форми "
"можна використовувати однаково, незалежно від платформи. Кінець введення "
"також служить неявним термінатором для останнього фізичного рядка."

#: ../../reference/lexical_analysis.rst:57
msgid ""
"When embedding Python, source code strings should be passed to Python APIs "
"using the standard C conventions for newline characters (the ``\\n`` "
"character, representing ASCII LF, is the line terminator)."
msgstr ""
"Під час вбудовування Python рядки вихідного коду слід передавати в API "
"Python, використовуючи стандартні угоди C для символів нового рядка (символ "
"``\\n``, що представляє ASCII LF, є символом закінчення рядка)."

#: ../../reference/lexical_analysis.rst:65
msgid "Comments"
msgstr "Коментарі"

#: ../../reference/lexical_analysis.rst:70
msgid ""
"A comment starts with a hash character (``#``) that is not part of a string "
"literal, and ends at the end of the physical line.  A comment signifies the "
"end of the logical line unless the implicit line joining rules are invoked. "
"Comments are ignored by the syntax."
msgstr ""
"Коментар починається з символу решетки (``#``), який не є частиною рядкового "
"літералу, і закінчується в кінці фізичного рядка. Коментар означає кінець "
"логічного рядка, якщо не викликаються неявні правила з’єднання рядків. "
"Коментарі ігноруються синтаксисом."

#: ../../reference/lexical_analysis.rst:79
msgid "Encoding declarations"
msgstr "Оголошення кодування"

#: ../../reference/lexical_analysis.rst:84
msgid ""
"If a comment in the first or second line of the Python script matches the "
"regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is processed "
"as an encoding declaration; the first group of this expression names the "
"encoding of the source code file. The encoding declaration must appear on a "
"line of its own. If it is the second line, the first line must also be a "
"comment-only line. The recommended forms of an encoding expression are ::"
msgstr ""
"Якщо коментар у першому чи другому рядку сценарію Python відповідає "
"регулярному виразу ``coding[=:]\\s*([-\\w.]+)``, цей коментар обробляється "
"як оголошення кодування; перша група цього виразу називає кодування файлу "
"вихідного коду. Оголошення кодування має з’являтися в окремому рядку. Якщо "
"це другий рядок, перший рядок також має бути рядком лише для коментарів. "
"Рекомендовані форми виразу кодування:"

#: ../../reference/lexical_analysis.rst:93
msgid "which is recognized also by GNU Emacs, and ::"
msgstr "який також розпізнається GNU Emacs і ::"

#: ../../reference/lexical_analysis.rst:97
msgid "which is recognized by Bram Moolenaar's VIM."
msgstr "який розпізнається VIM Брема Муленаара."

#: ../../reference/lexical_analysis.rst:99
msgid ""
"If no encoding declaration is found, the default encoding is UTF-8.  In "
"addition, if the first bytes of the file are the UTF-8 byte-order mark "
"(``b'\\xef\\xbb\\xbf'``), the declared file encoding is UTF-8 (this is "
"supported, among others, by Microsoft's :program:`notepad`)."
msgstr ""
"Якщо кодування не знайдено, кодуванням за замовчуванням є UTF-8. Крім того, "
"якщо перші байти файлу є позначкою порядку байтів UTF-8 "
"(``b'\\xef\\xbb\\xbf''``), заявленим кодуванням файлу є UTF-8 (це "
"підтримується, серед інших :program:`notepad` від Microsoft)."

#: ../../reference/lexical_analysis.rst:104
msgid ""
"If an encoding is declared, the encoding name must be recognized by Python "
"(see :ref:`standard-encodings`). The encoding is used for all lexical "
"analysis, including string literals, comments and identifiers."
msgstr ""
"Якщо оголошено кодування, Python має розпізнавати назву кодування (див. :ref:"
"`standard-encodings`). Кодування використовується для всього лексичного "
"аналізу, включаючи рядкові літерали, коментарі та ідентифікатори."

#: ../../reference/lexical_analysis.rst:113
msgid "Explicit line joining"
msgstr "Явне з'єднання рядків"

#: ../../reference/lexical_analysis.rst:117
msgid ""
"Two or more physical lines may be joined into logical lines using backslash "
"characters (``\\``), as follows: when a physical line ends in a backslash "
"that is not part of a string literal or comment, it is joined with the "
"following forming a single logical line, deleting the backslash and the "
"following end-of-line character.  For example::"
msgstr ""
"Два або більше фізичних рядків можна об’єднати в логічні рядки за допомогою "
"символів зворотної похилої риски (``\\``), таким чином: коли фізичний рядок "
"закінчується зворотною похилою рискою, яка не є частиною рядкового літералу "
"чи коментаря, він об’єднується за допомогою наступного: утворюючи один "
"логічний рядок, видаляючи зворотну косу риску та наступний символ кінця "
"рядка. Наприклад::"

#: ../../reference/lexical_analysis.rst:128
msgid ""
"A line ending in a backslash cannot carry a comment.  A backslash does not "
"continue a comment.  A backslash does not continue a token except for string "
"literals (i.e., tokens other than string literals cannot be split across "
"physical lines using a backslash).  A backslash is illegal elsewhere on a "
"line outside a string literal."
msgstr ""
"Рядок, який закінчується зворотною скісною рискою, не може містити "
"коментаря. Зворотна коса риска не продовжує коментар. Зворотний слеш не "
"продовжує лексему, за винятком рядкових літералів (тобто лексеми, окрім "
"рядкових літералів, не можна розділити на фізичні рядки за допомогою "
"зворотної похилої риски). Зворотний слеш неприпустимий в іншому місці рядка "
"за межами рядкового літералу."

#: ../../reference/lexical_analysis.rst:138
msgid "Implicit line joining"
msgstr "Неявне з'єднання ліній"

#: ../../reference/lexical_analysis.rst:140
msgid ""
"Expressions in parentheses, square brackets or curly braces can be split "
"over more than one physical line without using backslashes. For example::"
msgstr ""
"Вирази в дужках, квадратних або фігурних дужках можна розділити на кілька "
"фізичних рядків без використання зворотних скісних риск. Наприклад::"

#: ../../reference/lexical_analysis.rst:148
msgid ""
"Implicitly continued lines can carry comments.  The indentation of the "
"continuation lines is not important.  Blank continuation lines are allowed. "
"There is no NEWLINE token between implicit continuation lines.  Implicitly "
"continued lines can also occur within triple-quoted strings (see below); in "
"that case they cannot carry comments."
msgstr ""
"Неявно продовжені рядки можуть містити коментарі. Відступ рядків продовження "
"не важливий. Допускаються порожні рядки продовження. Немає маркера NEWLINE "
"між рядками неявного продовження. Неявно продовжені рядки також можуть "
"зустрічатися в рядках із потрійними лапками (див. нижче); у цьому випадку "
"вони не можуть нести коментарі."

#: ../../reference/lexical_analysis.rst:158
msgid "Blank lines"
msgstr "Порожні рядки"

#: ../../reference/lexical_analysis.rst:162
msgid ""
"A logical line that contains only spaces, tabs, formfeeds and possibly a "
"comment, is ignored (i.e., no NEWLINE token is generated).  During "
"interactive input of statements, handling of a blank line may differ "
"depending on the implementation of the read-eval-print loop.  In the "
"standard interactive interpreter, an entirely blank logical line (i.e. one "
"containing not even whitespace or a comment) terminates a multi-line "
"statement."
msgstr ""
"Логічний рядок, який містить лише пробіли, табуляції, канали форми та, "
"можливо, коментар, ігнорується (тобто маркер NEWLINE не генерується). Під "
"час інтерактивного введення операторів обробка порожнього рядка може "
"відрізнятися залежно від реалізації циклу читання-оцінки-друку. У "
"стандартному інтерактивному інтерпретаторі повністю порожній логічний рядок "
"(тобто такий, що не містить навіть пробілів або коментаря) завершує "
"багаторядковий оператор."

#: ../../reference/lexical_analysis.rst:173
msgid "Indentation"
msgstr "Відступ"

#: ../../reference/lexical_analysis.rst:177
msgid ""
"Leading whitespace (spaces and tabs) at the beginning of a logical line is "
"used to compute the indentation level of the line, which in turn is used to "
"determine the grouping of statements."
msgstr ""
"Пробіли (пробіли та табуляції) на початку логічного рядка використовуються "
"для обчислення рівня відступу рядка, який, у свою чергу, використовується "
"для визначення групування операторів."

#: ../../reference/lexical_analysis.rst:181
msgid ""
"Tabs are replaced (from left to right) by one to eight spaces such that the "
"total number of characters up to and including the replacement is a multiple "
"of eight (this is intended to be the same rule as used by Unix).  The total "
"number of spaces preceding the first non-blank character then determines the "
"line's indentation.  Indentation cannot be split over multiple physical "
"lines using backslashes; the whitespace up to the first backslash determines "
"the indentation."
msgstr ""
"Табуляції замінюються (зліва направо) на один-вісім пробілів, щоб загальна "
"кількість символів до заміни включно була кратною восьми (це те саме "
"правило, яке використовується в Unix). Тоді загальна кількість пробілів "
"перед першим символом, що не є пробілом, визначає відступ рядка. Відступи не "
"можна розділити на кілька фізичних рядків за допомогою зворотної косої "
"риски; пробіл до першої зворотної скісної риски визначає відступ."

#: ../../reference/lexical_analysis.rst:189
msgid ""
"Indentation is rejected as inconsistent if a source file mixes tabs and "
"spaces in a way that makes the meaning dependent on the worth of a tab in "
"spaces; a :exc:`TabError` is raised in that case."
msgstr ""
"Відступи відхиляються як непослідовні, якщо вихідний файл змішує табуляції "
"та пробіли таким чином, що робить значення залежним від цінності табуляції в "
"пробілах; У цьому випадку виникає :exc:`TabError`."

#: ../../reference/lexical_analysis.rst:193
msgid ""
"**Cross-platform compatibility note:** because of the nature of text editors "
"on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for "
"the indentation in a single source file.  It should also be noted that "
"different platforms may explicitly limit the maximum indentation level."
msgstr ""
"**Примітка щодо крос-платформної сумісності:** через характер текстових "
"редакторів на платформах, відмінних від UNIX, нерозумно використовувати "
"суміш пробілів і табуляції для відступу в одному вихідному файлі. Слід також "
"зазначити, що різні платформи можуть явно обмежувати максимальний рівень "
"відступу."

#: ../../reference/lexical_analysis.rst:198
msgid ""
"A formfeed character may be present at the start of the line; it will be "
"ignored for the indentation calculations above.  Formfeed characters "
"occurring elsewhere in the leading whitespace have an undefined effect (for "
"instance, they may reset the space count to zero)."
msgstr ""
"Символ переходу форми може бути присутнім на початку рядка; він буде "
"проігнорований для обчислень відступів вище. Символи передачі форми, що "
"зустрічаються в інших місцях у першому пробілі, мають невизначений ефект "
"(наприклад, вони можуть скинути кількість пробілів до нуля)."

#: ../../reference/lexical_analysis.rst:205
msgid ""
"The indentation levels of consecutive lines are used to generate INDENT and "
"DEDENT tokens, using a stack, as follows."
msgstr ""
"Рівні відступів послідовних рядків використовуються для створення токенів "
"INDENT і DEDENT за допомогою стека, як показано нижче."

#: ../../reference/lexical_analysis.rst:208
msgid ""
"Before the first line of the file is read, a single zero is pushed on the "
"stack; this will never be popped off again.  The numbers pushed on the stack "
"will always be strictly increasing from bottom to top.  At the beginning of "
"each logical line, the line's indentation level is compared to the top of "
"the stack. If it is equal, nothing happens. If it is larger, it is pushed on "
"the stack, and one INDENT token is generated.  If it is smaller, it *must* "
"be one of the numbers occurring on the stack; all numbers on the stack that "
"are larger are popped off, and for each number popped off a DEDENT token is "
"generated.  At the end of the file, a DEDENT token is generated for each "
"number remaining on the stack that is larger than zero."
msgstr ""
"Перш ніж буде зчитано перший рядок файлу, у стек вставляється один нуль; це "
"ніколи більше не вискочить. Числа в стеку завжди суворо зростатимуть знизу "
"вгору. На початку кожного логічного рядка рівень відступу рядка порівнюється "
"з верхньою частиною стека. Якщо воно рівне, нічого не відбувається. Якщо він "
"більший, він поміщається в стек і генерується один токен INDENT. Якщо воно "
"менше, воно *повинно* бути одним із чисел, які зустрічаються в стеку; усі "
"номери зі стеку, які є більшими, вилучаються, і для кожного числа, що "
"виривається, генерується маркер DEDENT. У кінці файлу генерується маркер "
"DEDENT для кожного числа, що залишилося в стеку і є більшим за нуль."

#: ../../reference/lexical_analysis.rst:219
msgid ""
"Here is an example of a correctly (though confusingly) indented piece of "
"Python code::"
msgstr ""
"Ось приклад правильного (хоча і заплутаного) фрагмента коду Python з "
"відступом:"

#: ../../reference/lexical_analysis.rst:234
msgid "The following example shows various indentation errors::"
msgstr "У наступному прикладі показано різні помилки відступів:"

#: ../../reference/lexical_analysis.rst:244
msgid ""
"(Actually, the first three errors are detected by the parser; only the last "
"error is found by the lexical analyzer --- the indentation of ``return r`` "
"does not match a level popped off the stack.)"
msgstr ""
"(Насправді, перші три помилки виявляються синтаксичним аналізатором; лише "
"остання помилка знаходить лексичний аналізатор --- відступ ``return r`` не "
"відповідає рівню, витягненому зі стеку.)"

#: ../../reference/lexical_analysis.rst:252
msgid "Whitespace between tokens"
msgstr "Пробіли між маркерами"

#: ../../reference/lexical_analysis.rst:254
msgid ""
"Except at the beginning of a logical line or in string literals, the "
"whitespace characters space, tab and formfeed can be used interchangeably to "
"separate tokens.  Whitespace is needed between two tokens only if their "
"concatenation could otherwise be interpreted as a different token (e.g., ab "
"is one token, but a b is two tokens)."
msgstr ""
"За винятком початку логічного рядка або в рядкових літералах, символи "
"пропуску, символи табуляції та переходу форми можуть використовуватися як "
"взаємозамінні для розділення токенів. Пробіл потрібен між двома лексемами, "
"лише якщо їх конкатенація інакше може бути інтерпретована як інша лексема "
"(наприклад, ab — одна лексема, а b — це дві лексеми)."

#: ../../reference/lexical_analysis.rst:264
msgid "Other tokens"
msgstr "Інші жетони"

#: ../../reference/lexical_analysis.rst:266
msgid ""
"Besides NEWLINE, INDENT and DEDENT, the following categories of tokens "
"exist: *identifiers*, *keywords*, *literals*, *operators*, and *delimiters*. "
"Whitespace characters (other than line terminators, discussed earlier) are "
"not tokens, but serve to delimit tokens. Where ambiguity exists, a token "
"comprises the longest possible string that forms a legal token, when read "
"from left to right."
msgstr ""
"Окрім NEWLINE, INDENT і DEDENT, існують такі категорії токенів: "
"*ідентифікатори*, *ключові слова*, *літерали*, *оператори* та *роздільники*. "
"Пробільні символи (окрім символів закінчення рядків, які обговорювалися "
"раніше) не є маркерами, але служать для розмежування маркерів. Якщо існує "
"неоднозначність, токен містить найдовший можливий рядок, який утворює "
"законний токен, коли читається зліва направо."

#: ../../reference/lexical_analysis.rst:276
msgid "Identifiers and keywords"
msgstr "Ідентифікатори та ключові слова"

#: ../../reference/lexical_analysis.rst:280
msgid ""
"Identifiers (also referred to as *names*) are described by the following "
"lexical definitions."
msgstr ""
"Ідентифікатори (також згадувані як *імена*) описуються наступними лексичними "
"визначеннями."

#: ../../reference/lexical_analysis.rst:283
msgid ""
"The syntax of identifiers in Python is based on the Unicode standard annex "
"UAX-31, with elaboration and changes as defined below; see also :pep:`3131` "
"for further details."
msgstr ""
"Синтаксис ідентифікаторів у Python базується на стандартному додатку Unicode "
"UAX-31 із уточненнями та змінами, як визначено нижче; див. також :pep:`3131` "
"для отримання додаткової інформації."

#: ../../reference/lexical_analysis.rst:287
msgid ""
"Within the ASCII range (U+0001..U+007F), the valid characters for "
"identifiers are the same as in Python 2.x: the uppercase and lowercase "
"letters ``A`` through ``Z``, the underscore ``_`` and, except for the first "
"character, the digits ``0`` through ``9``."
msgstr ""
"У діапазоні ASCII (U+0001..U+007F) дійсні символи для ідентифікаторів такі "
"ж, як і в Python 2.x: великі та малі літери від ``A`` до ``Z``, символ "
"підкреслення ``_`` і, за винятком першого символу, цифри ``0`` до ``9``."

#: ../../reference/lexical_analysis.rst:292
msgid ""
"Python 3.0 introduces additional characters from outside the ASCII range "
"(see :pep:`3131`).  For these characters, the classification uses the "
"version of the Unicode Character Database as included in the :mod:"
"`unicodedata` module."
msgstr ""
"Python 3.0 представляє додаткові символи поза межами діапазону ASCII (див. :"
"pep:`3131`). Для цих символів у класифікації використовується версія бази "
"даних символів Unicode, яка включена в модуль :mod:`unicodedata`."

#: ../../reference/lexical_analysis.rst:296
msgid "Identifiers are unlimited in length.  Case is significant."
msgstr "Довжина ідентифікаторів необмежена. Справа знакова."

#: ../../reference/lexical_analysis.rst:305
msgid "The Unicode category codes mentioned above stand for:"
msgstr "Зазначені вище коди категорій Unicode означають:"

#: ../../reference/lexical_analysis.rst:307
msgid "*Lu* - uppercase letters"
msgstr "*Lu* - великі літери"

#: ../../reference/lexical_analysis.rst:308
msgid "*Ll* - lowercase letters"
msgstr "*Ll* - малі літери"

#: ../../reference/lexical_analysis.rst:309
msgid "*Lt* - titlecase letters"
msgstr "*Lt* - заголовні літери"

#: ../../reference/lexical_analysis.rst:310
msgid "*Lm* - modifier letters"
msgstr "*Lm* - літери-модифікатори"

#: ../../reference/lexical_analysis.rst:311
msgid "*Lo* - other letters"
msgstr "*Lo* - інші букви"

#: ../../reference/lexical_analysis.rst:312
msgid "*Nl* - letter numbers"
msgstr "*Nl* - цифри літер"

#: ../../reference/lexical_analysis.rst:313
msgid "*Mn* - nonspacing marks"
msgstr "*Mn* - непробільні знаки"

#: ../../reference/lexical_analysis.rst:314
msgid "*Mc* - spacing combining marks"
msgstr "*Mc* - знаки поєднання інтервалів"

#: ../../reference/lexical_analysis.rst:315
msgid "*Nd* - decimal numbers"
msgstr "*Nd* - десяткові числа"

#: ../../reference/lexical_analysis.rst:316
msgid "*Pc* - connector punctuations"
msgstr "*Pc* - розділові знаки сполучника"

#: ../../reference/lexical_analysis.rst:317
msgid ""
"*Other_ID_Start* - explicit list of characters in `PropList.txt <https://www."
"unicode.org/Public/13.0.0/ucd/PropList.txt>`_ to support backwards "
"compatibility"
msgstr ""

#: ../../reference/lexical_analysis.rst:320
msgid "*Other_ID_Continue* - likewise"
msgstr "*Other_ID_Continue* - так само"

#: ../../reference/lexical_analysis.rst:322
msgid ""
"All identifiers are converted into the normal form NFKC while parsing; "
"comparison of identifiers is based on NFKC."
msgstr ""
"Під час синтаксичного аналізу всі ідентифікатори перетворюються в нормальну "
"форму NFKC; порівняння ідентифікаторів базується на NFKC."

#: ../../reference/lexical_analysis.rst:325
msgid ""
"A non-normative HTML file listing all valid identifier characters for "
"Unicode 4.1 can be found at https://www.unicode.org/Public/13.0.0/ucd/"
"DerivedCoreProperties.txt"
msgstr ""

#: ../../reference/lexical_analysis.rst:333
msgid "Keywords"
msgstr "Ключові слова"

#: ../../reference/lexical_analysis.rst:339
msgid ""
"The following identifiers are used as reserved words, or *keywords* of the "
"language, and cannot be used as ordinary identifiers.  They must be spelled "
"exactly as written here:"
msgstr ""
"Наступні ідентифікатори використовуються як зарезервовані слова або *ключові "
"слова* мови, і їх не можна використовувати як звичайні ідентифікатори. Вони "
"мають бути написані точно так, як тут написано:"

#: ../../reference/lexical_analysis.rst:357
msgid "Soft Keywords"
msgstr "М'які ключові слова"

#: ../../reference/lexical_analysis.rst:363
msgid ""
"Some identifiers are only reserved under specific contexts. These are known "
"as *soft keywords*.  The identifiers ``match``, ``case`` and ``_`` can "
"syntactically act as keywords in contexts related to the pattern matching "
"statement, but this distinction is done at the parser level, not when "
"tokenizing."
msgstr ""
"Деякі ідентифікатори зарезервовані лише в певних контекстах. Вони відомі як "
"*м’які ключові слова*. Ідентифікатори ``match``, ``case`` і ``_`` можуть "
"синтаксично діяти як ключові слова в контекстах, пов’язаних із оператором "
"відповідності шаблону, але це розрізнення виконується на рівні аналізатора, "
"а не під час токенізації."

#: ../../reference/lexical_analysis.rst:369
msgid ""
"As soft keywords, their use with pattern matching is possible while still "
"preserving compatibility with existing code that uses ``match``, ``case`` "
"and ``_`` as identifier names."
msgstr ""
"Як м’які ключові слова, їх використання зі збігом шаблонів можливе, "
"зберігаючи сумісність із існуючим кодом, який використовує ``match``, "
"``case`` і ``_`` як імена ідентифікаторів."

#: ../../reference/lexical_analysis.rst:380
msgid "Reserved classes of identifiers"
msgstr "Зарезервовані класи ідентифікаторів"

#: ../../reference/lexical_analysis.rst:382
msgid ""
"Certain classes of identifiers (besides keywords) have special meanings.  "
"These classes are identified by the patterns of leading and trailing "
"underscore characters:"
msgstr ""
"Певні класи ідентифікаторів (крім ключових слів) мають спеціальні значення. "
"Ці класи ідентифікуються шаблонами початкових і кінцевих символів "
"підкреслення:"

#: ../../reference/lexical_analysis.rst:387
msgid "``_*``"
msgstr "``_*``"

#: ../../reference/lexical_analysis.rst:387
msgid "Not imported by ``from module import *``."
msgstr "Не імпортовано ``з імпорту модуля *``."

#: ../../reference/lexical_analysis.rst:408
msgid "``_``"
msgstr "``_``"

#: ../../reference/lexical_analysis.rst:390
msgid ""
"In a ``case`` pattern within a :keyword:`match` statement, ``_`` is a :ref:"
"`soft keyword <soft-keywords>` that denotes a :ref:`wildcard <wildcard-"
"patterns>`."
msgstr ""
"У шаблоні ``case`` в операторі :keyword:`match`, ``_`` є :ref:`м'яким "
"ключовим словом <soft-keywords>`, яке позначає :ref:`знак підстановки "
"<wildcard-patterns>`."

#: ../../reference/lexical_analysis.rst:394
msgid ""
"Separately, the interactive interpreter makes the result of the last "
"evaluation available in the variable ``_``. (It is stored in the :mod:"
"`builtins` module, alongside built-in functions like ``print``.)"
msgstr ""
"Окремо інтерактивний інтерпретатор робить результат останньої оцінки "
"доступним у змінній ``_``. (Він зберігається в модулі :mod:`builtins` разом "
"із вбудованими функціями, такими як ``print``.)"

#: ../../reference/lexical_analysis.rst:399
msgid ""
"Elsewhere, ``_`` is a regular identifier. It is often used to name "
"\"special\" items, but it is not special to Python itself."
msgstr ""
"В інших місцях ``_`` є звичайним ідентифікатором. Його часто використовують "
"для назви \"особливих\" елементів, але це не є особливим для самого Python."

#: ../../reference/lexical_analysis.rst:404
msgid ""
"The name ``_`` is often used in conjunction with internationalization; refer "
"to the documentation for the :mod:`gettext` module for more information on "
"this convention."
msgstr ""
"Назва ``_`` часто використовується в поєднанні з інтернаціоналізацією; "
"зверніться до документації для модуля :mod:`gettext` для отримання "
"додаткової інформації про цю угоду."

#: ../../reference/lexical_analysis.rst:408
msgid "It is also commonly used for unused variables."
msgstr "Він також зазвичай використовується для невикористаних змінних."

#: ../../reference/lexical_analysis.rst:416
msgid "``__*__``"
msgstr "``__*__``"

#: ../../reference/lexical_analysis.rst:411
msgid ""
"System-defined names, informally known as \"dunder\" names. These names are "
"defined by the interpreter and its implementation (including the standard "
"library). Current system names are discussed in the :ref:`specialnames` "
"section and elsewhere. More will likely be defined in future versions of "
"Python.  *Any* use of ``__*__`` names, in any context, that does not follow "
"explicitly documented use, is subject to breakage without warning."
msgstr ""
"Імена, визначені системою, неофіційно відомі як імена \"дундерів\". Ці імена "
"визначаються інтерпретатором і його реалізацією (включаючи стандартну "
"бібліотеку). Поточні назви систем обговорюються в розділі :ref:"
"`specialnames` та в інших місцях. Більше можливо буде визначено в майбутніх "
"версіях Python. *Будь-яке* використання імен ``__*__`` у будь-якому "
"контексті, яке не відповідає явно задокументованому використанню, може бути "
"порушено без попередження."

#: ../../reference/lexical_analysis.rst:423
msgid "``__*``"
msgstr "``__*``"

#: ../../reference/lexical_analysis.rst:419
msgid ""
"Class-private names.  Names in this category, when used within the context "
"of a class definition, are re-written to use a mangled form to help avoid "
"name clashes between \"private\" attributes of base and derived classes. See "
"section :ref:`atom-identifiers`."
msgstr ""
"Приватні імена класів. Імена в цій категорії, якщо вони використовуються в "
"контексті визначення класу, переписуються, щоб використовувати спотворену "
"форму, щоб уникнути зіткнень імен між \"приватними\" атрибутами базового та "
"похідних класів. Дивіться розділ :ref:`atom-identifiers`."

#: ../../reference/lexical_analysis.rst:428
msgid "Literals"
msgstr "Літерали"

#: ../../reference/lexical_analysis.rst:432
msgid "Literals are notations for constant values of some built-in types."
msgstr "Літерали — це позначення постійних значень деяких вбудованих типів."

#: ../../reference/lexical_analysis.rst:443
msgid "String and Bytes literals"
msgstr "Рядкові та байтові літерали"

#: ../../reference/lexical_analysis.rst:445
msgid "String literals are described by the following lexical definitions:"
msgstr "Рядкові літерали описуються такими лексичними визначеннями:"

#: ../../reference/lexical_analysis.rst:470
msgid ""
"One syntactic restriction not indicated by these productions is that "
"whitespace is not allowed between the :token:`~python-grammar:stringprefix` "
"or :token:`~python-grammar:bytesprefix` and the rest of the literal. The "
"source character set is defined by the encoding declaration; it is UTF-8 if "
"no encoding declaration is given in the source file; see section :ref:"
"`encodings`."
msgstr ""
"Одне синтаксичне обмеження, яке не вказується цими продуктами, полягає в "
"тому, що пробіли не допускаються між :token:`~python-grammar:stringprefix` "
"або :token:`~python-grammar:bytesprefix` та рештою літералу. Вихідний набір "
"символів визначається оголошенням кодування; це UTF-8, якщо у вихідному "
"файлі не вказано кодування; див. розділ :ref:`encodings`."

#: ../../reference/lexical_analysis.rst:480
msgid ""
"In plain English: Both types of literals can be enclosed in matching single "
"quotes (``'``) or double quotes (``\"``).  They can also be enclosed in "
"matching groups of three single or double quotes (these are generally "
"referred to as *triple-quoted strings*). The backslash (``\\``) character is "
"used to give special meaning to otherwise ordinary characters like ``n``, "
"which means 'newline' when escaped (``\\n``). It can also be used to escape "
"characters that otherwise have a special meaning, such as newline, backslash "
"itself, or the quote character. See :ref:`escape sequences <escape-"
"sequences>` below for examples."
msgstr ""

#: ../../reference/lexical_analysis.rst:493
msgid ""
"Bytes literals are always prefixed with ``'b'`` or ``'B'``; they produce an "
"instance of the :class:`bytes` type instead of the :class:`str` type.  They "
"may only contain ASCII characters; bytes with a numeric value of 128 or "
"greater must be expressed with escapes."
msgstr ""
"Байтові літерали завжди мають префікс ``'b'`` або ``'B'``; вони створюють "
"екземпляр типу :class:`bytes` замість типу :class:`str`. Вони можуть містити "
"лише символи ASCII; байти з числовим значенням 128 або більше повинні бути "
"виражені за допомогою екранованих символів."

#: ../../reference/lexical_analysis.rst:502
msgid ""
"Both string and bytes literals may optionally be prefixed with a letter "
"``'r'`` or ``'R'``; such strings are called :dfn:`raw strings` and treat "
"backslashes as literal characters.  As a result, in string literals, "
"``'\\U'`` and ``'\\u'`` escapes in raw strings are not treated specially. "
"Given that Python 2.x's raw unicode literals behave differently than Python "
"3.x's the ``'ur'`` syntax is not supported."
msgstr ""
"І рядкові, і байтові літерали можуть додатково мати префікс ``'r'`` або "
"``'R'``; такі рядки називаються :dfn:`raw strings` і розглядають зворотні "
"косі риски як буквальні символи. Як наслідок, у рядкових літералах "
"екранування ``'\\U'`` і ``'\\u'`` у необроблених рядках не обробляються "
"спеціально. Враховуючи те, що необроблені літерали Unicode Python 2.x "
"поводяться інакше, ніж Python 3.x, синтаксис ``'ur'`` не підтримується."

#: ../../reference/lexical_analysis.rst:509
msgid ""
"The ``'rb'`` prefix of raw bytes literals has been added as a synonym of "
"``'br'``."
msgstr ""
"Префікс ``'rb`` до літералів із необробленими байтами було додано як синонім "
"``'br'``."

#: ../../reference/lexical_analysis.rst:513
msgid ""
"Support for the unicode legacy literal (``u'value'``) was reintroduced to "
"simplify the maintenance of dual Python 2.x and 3.x codebases. See :pep:"
"`414` for more information."
msgstr ""
"Підтримку застарілого літералу Unicode (``u'value``) було знову запроваджено "
"для спрощення обслуговування подвійних кодових баз Python 2.x і 3.x. "
"Перегляньте :pep:`414` для отримання додаткової інформації."

#: ../../reference/lexical_analysis.rst:522
msgid ""
"A string literal with ``'f'`` or ``'F'`` in its prefix is a :dfn:`formatted "
"string literal`; see :ref:`f-strings`.  The ``'f'`` may be combined with "
"``'r'``, but not with ``'b'`` or ``'u'``, therefore raw formatted strings "
"are possible, but formatted bytes literals are not."
msgstr ""
"Рядковий літерал із ``'f''`` або ``'F''`` у своєму префіксі є :dfn:"
"`formatted string literal`; див. :ref:`f-strings`. ``'f'`` можна поєднувати "
"з ``'r'``, але не з ``'b''`` або ``'u''``, тому можливі необроблені "
"форматовані рядки, але форматовані байтові літерали не є."

#: ../../reference/lexical_analysis.rst:527
msgid ""
"In triple-quoted literals, unescaped newlines and quotes are allowed (and "
"are retained), except that three unescaped quotes in a row terminate the "
"literal.  (A \"quote\" is the character used to open the literal, i.e. "
"either ``'`` or ``\"``.)"
msgstr ""
"У літералах із потрійними лапками дозволені (і зберігаються) неекрановані "
"нові рядки та лапки, за винятком того, що три неекрановані лапки поспіль "
"завершують літерал. (\"Лапка\" - це символ, який використовується для "
"відкриття літералу, тобто ``'`` або ``\"``.)"

#: ../../reference/lexical_analysis.rst:548
msgid ""
"Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in string "
"and bytes literals are interpreted according to rules similar to those used "
"by Standard C.  The recognized escape sequences are:"
msgstr ""
"Якщо немає префікса ``'r'`` або ``'R'``, керуючі послідовності в рядкових і "
"байтових літералах інтерпретуються відповідно до правил, подібних до тих, що "
"використовуються стандартом C. Розпізнаними керуючими послідовностями є:"

#: ../../reference/lexical_analysis.rst:553
#: ../../reference/lexical_analysis.rst:586
msgid "Escape Sequence"
msgstr "Ескейп-послідовність"

#: ../../reference/lexical_analysis.rst:553
#: ../../reference/lexical_analysis.rst:586
msgid "Meaning"
msgstr "Значення"

#: ../../reference/lexical_analysis.rst:553
#: ../../reference/lexical_analysis.rst:586
msgid "Notes"
msgstr "Примітки"

#: ../../reference/lexical_analysis.rst:555
msgid "``\\``\\ <newline>"
msgstr ""

#: ../../reference/lexical_analysis.rst:555
msgid "Backslash and newline ignored"
msgstr "Зворотна коса риска та новий рядок ігноруються"

#: ../../reference/lexical_analysis.rst:555
msgid "\\(1)"
msgstr "\\(1)"

#: ../../reference/lexical_analysis.rst:557
msgid "``\\\\``"
msgstr "``\\\\``"

#: ../../reference/lexical_analysis.rst:557
msgid "Backslash (``\\``)"
msgstr "Зворотна коса риска (``\\``)"

#: ../../reference/lexical_analysis.rst:559
msgid "``\\'``"
msgstr "``\\''``"

#: ../../reference/lexical_analysis.rst:559
msgid "Single quote (``'``)"
msgstr "Одинарні лапки (``'``)"

#: ../../reference/lexical_analysis.rst:561
msgid "``\\\"``"
msgstr "``\\\"``"

#: ../../reference/lexical_analysis.rst:561
msgid "Double quote (``\"``)"
msgstr "Подвійні лапки (``\"``)"

#: ../../reference/lexical_analysis.rst:563
msgid "``\\a``"
msgstr "``\\a``"

#: ../../reference/lexical_analysis.rst:563
msgid "ASCII Bell (BEL)"
msgstr "ASCII Bell (BEL)"

#: ../../reference/lexical_analysis.rst:565
msgid "``\\b``"
msgstr "``\\b``"

#: ../../reference/lexical_analysis.rst:565
msgid "ASCII Backspace (BS)"
msgstr "ASCII Backspace (BS)"

#: ../../reference/lexical_analysis.rst:567
msgid "``\\f``"
msgstr "``\\f``"

#: ../../reference/lexical_analysis.rst:567
msgid "ASCII Formfeed (FF)"
msgstr "ASCII Formfeed (FF)"

#: ../../reference/lexical_analysis.rst:569
msgid "``\\n``"
msgstr "``\\n``"

#: ../../reference/lexical_analysis.rst:569
msgid "ASCII Linefeed (LF)"
msgstr "ASCII Linefeed (LF)"

#: ../../reference/lexical_analysis.rst:571
msgid "``\\r``"
msgstr "``\\r``"

#: ../../reference/lexical_analysis.rst:571
msgid "ASCII Carriage Return (CR)"
msgstr "ASCII повернення каретки (CR)"

#: ../../reference/lexical_analysis.rst:573
msgid "``\\t``"
msgstr "``\\t``"

#: ../../reference/lexical_analysis.rst:573
msgid "ASCII Horizontal Tab (TAB)"
msgstr "Горизонтальна вкладка ASCII (TAB)"

#: ../../reference/lexical_analysis.rst:575
msgid "``\\v``"
msgstr "``\\v``"

#: ../../reference/lexical_analysis.rst:575
msgid "ASCII Vertical Tab (VT)"
msgstr "Вертикальна вкладка ASCII (VT)"

#: ../../reference/lexical_analysis.rst:577
msgid "``\\ooo``"
msgstr "``\\ооо``"

#: ../../reference/lexical_analysis.rst:577
msgid "Character with octal value *ooo*"
msgstr "Символ із вісімковим значенням *ooo*"

#: ../../reference/lexical_analysis.rst:577
msgid "(2,4)"
msgstr ""

#: ../../reference/lexical_analysis.rst:580
msgid "``\\xhh``"
msgstr "``\\xhh``"

#: ../../reference/lexical_analysis.rst:580
msgid "Character with hex value *hh*"
msgstr "Символ із шістнадцятковим значенням *hh*"

#: ../../reference/lexical_analysis.rst:580
msgid "(3,4)"
msgstr ""

#: ../../reference/lexical_analysis.rst:583
msgid "Escape sequences only recognized in string literals are:"
msgstr "Екран-послідовності, розпізнані лише в рядкових літералах:"

#: ../../reference/lexical_analysis.rst:588
msgid "``\\N{name}``"
msgstr "``\\N{name}``"

#: ../../reference/lexical_analysis.rst:588
msgid "Character named *name* in the Unicode database"
msgstr "Символ із назвою *name* у базі даних Unicode"

#: ../../reference/lexical_analysis.rst:588
msgid "\\(5)"
msgstr "\\(5)"

#: ../../reference/lexical_analysis.rst:591
msgid "``\\uxxxx``"
msgstr "``\\uxxxx``"

#: ../../reference/lexical_analysis.rst:591
msgid "Character with 16-bit hex value *xxxx*"
msgstr "Символ із 16-бітним шістнадцятковим значенням *xxxx*"

#: ../../reference/lexical_analysis.rst:591
msgid "\\(6)"
msgstr "\\(6)"

#: ../../reference/lexical_analysis.rst:594
msgid "``\\Uxxxxxxxx``"
msgstr "``\\Uxxxxxxxxx``"

#: ../../reference/lexical_analysis.rst:594
msgid "Character with 32-bit hex value *xxxxxxxx*"
msgstr "Символ із 32-розрядним шістнадцятковим значенням *xxxxxxx*"

#: ../../reference/lexical_analysis.rst:594
msgid "\\(7)"
msgstr "\\(7)"

#: ../../reference/lexical_analysis.rst:598
msgid "Notes:"
msgstr "Примітки:"

#: ../../reference/lexical_analysis.rst:601
msgid "A backslash can be added at the end of a line to ignore the newline::"
msgstr ""

#: ../../reference/lexical_analysis.rst:607
msgid ""
"The same result can be achieved using :ref:`triple-quoted strings "
"<strings>`, or parentheses and :ref:`string literal concatenation <string-"
"concatenation>`."
msgstr ""

#: ../../reference/lexical_analysis.rst:611
msgid "As in Standard C, up to three octal digits are accepted."
msgstr "Як і в стандарті C, допускається до трьох вісімкових цифр."

#: ../../reference/lexical_analysis.rst:614
msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr "На відміну від стандарту C, потрібні рівно дві шістнадцяткові цифри."

#: ../../reference/lexical_analysis.rst:617
msgid ""
"In a bytes literal, hexadecimal and octal escapes denote the byte with the "
"given value. In a string literal, these escapes denote a Unicode character "
"with the given value."
msgstr ""
"У байтовому літералі шістнадцяткове та вісімкове екранування позначають байт "
"із заданим значенням. У рядковому літералі ці екрановані символи позначають "
"символ Unicode із заданим значенням."

#: ../../reference/lexical_analysis.rst:622
msgid "Support for name aliases [#]_ has been added."
msgstr "Додано підтримку псевдонімів [#]_."

#: ../../reference/lexical_analysis.rst:626
msgid "Exactly four hex digits are required."
msgstr "Потрібні рівно чотири шістнадцяткові цифри."

#: ../../reference/lexical_analysis.rst:629
msgid ""
"Any Unicode character can be encoded this way.  Exactly eight hex digits are "
"required."
msgstr ""
"Таким чином можна закодувати будь-який символ Unicode. Необхідно рівно вісім "
"шістнадцяткових цифр."

#: ../../reference/lexical_analysis.rst:635
msgid ""
"Unlike Standard C, all unrecognized escape sequences are left in the string "
"unchanged, i.e., *the backslash is left in the result*.  (This behavior is "
"useful when debugging: if an escape sequence is mistyped, the resulting "
"output is more easily recognized as broken.)  It is also important to note "
"that the escape sequences only recognized in string literals fall into the "
"category of unrecognized escapes for bytes literals."
msgstr ""
"На відміну від стандартного C, усі нерозпізнані керуючі послідовності "
"залишаються в рядку без змін, тобто *зворотний слеш залишається в "
"результаті*. (Ця поведінка корисна під час налагодження: якщо escape-"
"послідовність введена неправильно, результат легше розпізнати як "
"несправний.) Важливо також зазначити, що escape-послідовності, розпізнані "
"лише в рядкових літералах, належать до категорії нерозпізнаних escape-"
"сигналів для байтів. літерали."

#: ../../reference/lexical_analysis.rst:642
msgid ""
"Unrecognized escape sequences produce a :exc:`DeprecationWarning`.  In a "
"future Python version they will be a :exc:`SyntaxWarning` and eventually a :"
"exc:`SyntaxError`."
msgstr ""
"Нерозпізнані керуючі послідовності створюють :exc:`DeprecationWarning`. У "
"майбутній версії Python вони будуть :exc:`SyntaxWarning` і, зрештою, :exc:"
"`SyntaxError`."

#: ../../reference/lexical_analysis.rst:647
msgid ""
"Even in a raw literal, quotes can be escaped with a backslash, but the "
"backslash remains in the result; for example, ``r\"\\\"\"`` is a valid "
"string literal consisting of two characters: a backslash and a double quote; "
"``r\"\\\"`` is not a valid string literal (even a raw string cannot end in "
"an odd number of backslashes).  Specifically, *a raw literal cannot end in a "
"single backslash* (since the backslash would escape the following quote "
"character).  Note also that a single backslash followed by a newline is "
"interpreted as those two characters as part of the literal, *not* as a line "
"continuation."
msgstr ""
"Навіть у необробленому літералі лапки можна екранувати за допомогою "
"зворотної косої риски, але зворотна коса риска залишається в результаті; "
"наприклад, ``r\"\\\"\"`` є дійсним рядковим літералом, що складається з двох "
"символів: зворотної косої риски та подвійних лапок; ``r\"\\\"`` не є дійсним "
"рядковим літералом (навіть необроблений рядок не може закінчуватися у "
"непарній кількості зворотних скісних рисок). Зокрема, *необроблений літерал "
"не може закінчуватися однією зворотною скісною рискою* (оскільки зворотна "
"скісна риска виключатиме наступний символ лапок). Зауважте також, що одна "
"зворотна скісна риска, за якою йде новий рядок, інтерпретується як ці два "
"символи як частина літералу, *не* як продовження рядка."

#: ../../reference/lexical_analysis.rst:660
msgid "String literal concatenation"
msgstr "Конкатенація рядкового літералу"

#: ../../reference/lexical_analysis.rst:662
msgid ""
"Multiple adjacent string or bytes literals (delimited by whitespace), "
"possibly using different quoting conventions, are allowed, and their meaning "
"is the same as their concatenation.  Thus, ``\"hello\" 'world'`` is "
"equivalent to ``\"helloworld\"``.  This feature can be used to reduce the "
"number of backslashes needed, to split long strings conveniently across long "
"lines, or even to add comments to parts of strings, for example::"
msgstr ""
"Кілька суміжних рядкових або байтових літералів (розмежованих пробілами), "
"можливо, з використанням різних угод про цитування, дозволено, і їхнє "
"значення таке ж, як і їх об’єднання. Таким чином, ``\"hello\" 'world'`` "
"еквівалентно ``\"helloworld\"``. Цю функцію можна використати, щоб зменшити "
"кількість потрібних зворотних похилих рис, щоб зручно розділити довгі рядки "
"на довгі рядки або навіть додати коментарі до частин рядків, наприклад::"

#: ../../reference/lexical_analysis.rst:673
msgid ""
"Note that this feature is defined at the syntactical level, but implemented "
"at compile time.  The '+' operator must be used to concatenate string "
"expressions at run time.  Also note that literal concatenation can use "
"different quoting styles for each component (even mixing raw strings and "
"triple quoted strings), and formatted string literals may be concatenated "
"with plain string literals."
msgstr ""
"Зауважте, що ця функція визначена на синтаксичному рівні, але реалізована "
"під час компіляції. Для об’єднання рядкових виразів під час виконання "
"необхідно використовувати оператор \"+\". Також зауважте, що конкатенація "
"літералів може використовувати різні стилі лапок для кожного компонента "
"(навіть змішування необроблених рядків і рядків у потрійних лапках), а "
"форматовані рядкові літерали можуть бути об’єднані з простими рядковими "
"літералами."

#: ../../reference/lexical_analysis.rst:694
msgid "Formatted string literals"
msgstr "Відформатовані рядкові літерали"

#: ../../reference/lexical_analysis.rst:698
msgid ""
"A :dfn:`formatted string literal` or :dfn:`f-string` is a string literal "
"that is prefixed with ``'f'`` or ``'F'``.  These strings may contain "
"replacement fields, which are expressions delimited by curly braces ``{}``. "
"While other string literals always have a constant value, formatted strings "
"are really expressions evaluated at run time."
msgstr ""
":dfn:`formatted string literal` або :dfn:`f-string` — це рядковий літерал, "
"який має префікс ``'f'`` або ``'F'``. Ці рядки можуть містити поля заміни, "
"які є виразами, розділеними фігурними дужками ``{}``. Хоча інші рядкові "
"літерали завжди мають постійне значення, форматовані рядки насправді є "
"виразами, які обчислюються під час виконання."

#: ../../reference/lexical_analysis.rst:704
msgid ""
"Escape sequences are decoded like in ordinary string literals (except when a "
"literal is also marked as a raw string).  After decoding, the grammar for "
"the contents of the string is:"
msgstr ""
"Екран-послідовності декодуються як у звичайних рядкових літералах (за "
"винятком випадків, коли літерал також позначено як необроблений рядок). "
"Після декодування граматика вмісту рядка така:"

#: ../../reference/lexical_analysis.rst:718
msgid ""
"The parts of the string outside curly braces are treated literally, except "
"that any doubled curly braces ``'{{'`` or ``'}}'`` are replaced with the "
"corresponding single curly brace.  A single opening curly bracket ``'{'`` "
"marks a replacement field, which starts with a Python expression. To display "
"both the expression text and its value after evaluation, (useful in "
"debugging), an equal sign ``'='`` may be added after the expression. A "
"conversion field, introduced by an exclamation point ``'!'`` may follow.  A "
"format specifier may also be appended, introduced by a colon ``':'``. A "
"replacement field ends with a closing curly bracket ``'}'``."
msgstr ""
"Частини рядка поза фігурними дужками трактуються буквально, за винятком "
"того, що будь-які подвоєні фігурні дужки ``'{{'`` або ``'}}'`` замінюються "
"відповідною одинарною фігурною дужкою. Одна відкривна фігурна дужка ``'{'`` "
"позначає поле заміни, яке починається з виразу Python. Щоб відобразити як "
"текст виразу, так і його значення після оцінки (корисно під час "
"налагодження), після виразу можна додати знак рівності ``'='``. Поле "
"перетворення, введене знаком оклику ``'!'`` може слідувати за ним. "
"Специфікатор формату також може бути доданий двокрапкою ``':''``. Поле "
"заміни закінчується фігурною дужкою, що закривається, ``'}''``."

#: ../../reference/lexical_analysis.rst:728
msgid ""
"Expressions in formatted string literals are treated like regular Python "
"expressions surrounded by parentheses, with a few exceptions. An empty "
"expression is not allowed, and both :keyword:`lambda`  and assignment "
"expressions ``:=`` must be surrounded by explicit parentheses. Replacement "
"expressions can contain line breaks (e.g. in triple-quoted strings), but "
"they cannot contain comments.  Each expression is evaluated in the context "
"where the formatted string literal appears, in order from left to right."
msgstr ""
"Вирази у форматованих рядкових літералах розглядаються як звичайні вирази "
"Python, оточені дужками, за кількома винятками. Порожній вираз не "
"дозволяється, і як :keyword:`lambda`, так і вирази присвоєння ``:=`` мають "
"бути оточені явними дужками. Вирази заміни можуть містити розриви рядків "
"(наприклад, у рядках у потрійних лапках), але вони не можуть містити "
"коментарів. Кожен вираз обчислюється в контексті, де з’являється "
"відформатований рядковий літерал, у порядку зліва направо."

#: ../../reference/lexical_analysis.rst:737
msgid ""
"Prior to Python 3.7, an :keyword:`await` expression and comprehensions "
"containing an :keyword:`async for` clause were illegal in the expressions in "
"formatted string literals due to a problem with the implementation."
msgstr ""
"До Python 3.7 вираз :keyword:`await` і розуміння, що містять пропозицію :"
"keyword:`async for`, були незаконними у виразах у форматованих рядкових "
"літералах через проблему з реалізацією."

#: ../../reference/lexical_analysis.rst:742
msgid ""
"When the equal sign ``'='`` is provided, the output will have the expression "
"text, the ``'='`` and the evaluated value. Spaces after the opening brace "
"``'{'``, within the expression and after the ``'='`` are all retained in the "
"output. By default, the ``'='`` causes the :func:`repr` of the expression to "
"be provided, unless there is a format specified. When a format is specified "
"it defaults to the :func:`str` of the expression unless a conversion ``'!"
"r'`` is declared."
msgstr ""
"Якщо вказано знак рівності ``'='``, вихідні дані матимуть текст виразу, "
"``'='`` і обчислене значення. Пробіли після відкриваючої фігурної дужки "
"``'{'`` у виразі та після ``'='`` зберігаються у виводі. За замовчуванням "
"``'='`` надає :func:`repr` виразу, якщо не вказано формат. Коли вказано "
"формат, за замовчуванням використовується :func:`str` виразу, якщо не "
"оголошено перетворення ``'!r''``."

#: ../../reference/lexical_analysis.rst:750
msgid "The equal sign ``'='``."
msgstr "Знак рівності ``'='``."

#: ../../reference/lexical_analysis.rst:753
msgid ""
"If a conversion is specified, the result of evaluating the expression is "
"converted before formatting.  Conversion ``'!s'`` calls :func:`str` on the "
"result, ``'!r'`` calls :func:`repr`, and ``'!a'`` calls :func:`ascii`."
msgstr ""
"Якщо вказано перетворення, результат обчислення виразу перетворюється перед "
"форматуванням. Перетворення ``'!s'`` викликає :func:`str` результату, ``'!"
"r''`` викликає :func:`repr`, а ``'!a'`` викликає :func:`ascii`."

#: ../../reference/lexical_analysis.rst:757
msgid ""
"The result is then formatted using the :func:`format` protocol.  The format "
"specifier is passed to the :meth:`__format__` method of the expression or "
"conversion result.  An empty string is passed when the format specifier is "
"omitted.  The formatted result is then included in the final value of the "
"whole string."
msgstr ""
"Потім результат форматується за допомогою протоколу :func:`format`. "
"Специфікатор формату передається в метод :meth:`__format__` виразу або "
"результату перетворення. Порожній рядок передається, якщо специфікатор "
"формату опущено. Потім відформатований результат включається в кінцеве "
"значення всього рядка."

#: ../../reference/lexical_analysis.rst:763
msgid ""
"Top-level format specifiers may include nested replacement fields. These "
"nested fields may include their own conversion fields and :ref:`format "
"specifiers <formatspec>`, but may not include more deeply nested replacement "
"fields. The :ref:`format specifier mini-language <formatspec>` is the same "
"as that used by the :meth:`str.format` method."
msgstr ""

#: ../../reference/lexical_analysis.rst:769
msgid ""
"Formatted string literals may be concatenated, but replacement fields cannot "
"be split across literals."
msgstr ""
"Відформатовані рядкові літерали можуть бути об’єднані, але поля заміни не "
"можуть бути розділені на літерали."

#: ../../reference/lexical_analysis.rst:772
msgid "Some examples of formatted string literals::"
msgstr "Деякі приклади відформатованих рядкових літералів::"

#: ../../reference/lexical_analysis.rst:804
msgid ""
"A consequence of sharing the same syntax as regular string literals is that "
"characters in the replacement fields must not conflict with the quoting used "
"in the outer formatted string literal::"
msgstr ""
"Наслідком спільного використання такого ж синтаксису, як і звичайні рядкові "
"літерали, є те, що символи в полях заміни не повинні конфліктувати з "
"лапками, які використовуються у зовнішньому форматованому рядковому "
"літералі::"

#: ../../reference/lexical_analysis.rst:811
msgid ""
"Backslashes are not allowed in format expressions and will raise an error::"
msgstr ""
"Зворотні скісні риски не дозволені у виразах формату та призведуть до "
"помилки::"

#: ../../reference/lexical_analysis.rst:816
msgid ""
"To include a value in which a backslash escape is required, create a "
"temporary variable."
msgstr ""
"Щоб включити значення, у якому необхідний символ зворотної скісної риски, "
"створіть тимчасову змінну."

#: ../../reference/lexical_analysis.rst:823
msgid ""
"Formatted string literals cannot be used as docstrings, even if they do not "
"include expressions."
msgstr ""
"Відформатовані рядкові літерали не можна використовувати як рядки "
"документації, навіть якщо вони не містять виразів."

#: ../../reference/lexical_analysis.rst:834
msgid ""
"See also :pep:`498` for the proposal that added formatted string literals, "
"and :meth:`str.format`, which uses a related format string mechanism."
msgstr ""
"Дивіться також :pep:`498` для пропозиції, яка додала відформатовані рядкові "
"літерали, і :meth:`str.format`, який використовує пов’язаний механізм "
"форматування рядків."

#: ../../reference/lexical_analysis.rst:841
msgid "Numeric literals"
msgstr "Числові літерали"

#: ../../reference/lexical_analysis.rst:847
msgid ""
"There are three types of numeric literals: integers, floating point numbers, "
"and imaginary numbers.  There are no complex literals (complex numbers can "
"be formed by adding a real number and an imaginary number)."
msgstr ""
"Існує три типи числових літералів: цілі числа, числа з плаваючою комою та "
"уявні числа. Комплексних літералів немає (комплексні числа можна утворити "
"додаванням дійсного числа та уявного числа)."

#: ../../reference/lexical_analysis.rst:851
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator '``-``' and the "
"literal ``1``."
msgstr ""
"Зауважте, що числові літерали не містять знака; така фраза, як ``-1``, "
"насправді є виразом, що складається з унарного оператора '``-``' і літерала "
"``1``."

#: ../../reference/lexical_analysis.rst:865
msgid "Integer literals"
msgstr "Цілі літерали"

#: ../../reference/lexical_analysis.rst:867
msgid "Integer literals are described by the following lexical definitions:"
msgstr "Цілі літерали описуються такими лексичними визначеннями:"

#: ../../reference/lexical_analysis.rst:881
msgid ""
"There is no limit for the length of integer literals apart from what can be "
"stored in available memory."
msgstr ""
"Немає обмежень щодо довжини цілочисельних літералів, крім того, що може "
"зберігатися у доступній пам’яті."

#: ../../reference/lexical_analysis.rst:884
msgid ""
"Underscores are ignored for determining the numeric value of the literal.  "
"They can be used to group digits for enhanced readability.  One underscore "
"can occur between digits, and after base specifiers like ``0x``."
msgstr ""
"Підкреслення ігноруються для визначення числового значення літералу. Їх "
"можна використовувати для групування цифр для кращої читабельності. Одне "
"підкреслення може бути між цифрами та після основних специфікаторів, таких "
"як ``0x``."

#: ../../reference/lexical_analysis.rst:888
msgid ""
"Note that leading zeros in a non-zero decimal number are not allowed. This "
"is for disambiguation with C-style octal literals, which Python used before "
"version 3.0."
msgstr ""
"Зауважте, що нулі на початку ненульового десяткового числа не допускаються. "
"Це для усунення неоднозначності з вісімковими літералами у стилі C, які "
"Python використовував до версії 3.0."

#: ../../reference/lexical_analysis.rst:892
msgid "Some examples of integer literals::"
msgstr "Деякі приклади цілих літералів::"

#: ../../reference/lexical_analysis.rst:898
#: ../../reference/lexical_analysis.rst:930
msgid "Underscores are now allowed for grouping purposes in literals."
msgstr "Підкреслення тепер дозволено для цілей групування в літералах."

#: ../../reference/lexical_analysis.rst:909
msgid "Floating point literals"
msgstr "Літерали з плаваючою комою"

#: ../../reference/lexical_analysis.rst:911
msgid ""
"Floating point literals are described by the following lexical definitions:"
msgstr "Літерали з плаваючою комою описуються такими лексичними визначеннями:"

#: ../../reference/lexical_analysis.rst:921
msgid ""
"Note that the integer and exponent parts are always interpreted using radix "
"10. For example, ``077e010`` is legal, and denotes the same number as "
"``77e10``. The allowed range of floating point literals is implementation-"
"dependent.  As in integer literals, underscores are supported for digit "
"grouping."
msgstr ""
"Зауважте, що ціла та експонента завжди інтерпретуються з використанням "
"основи 10. Наприклад, ``077e010`` є допустимим і позначає те саме число, що "
"``77e10``. Дозволений діапазон літералів із плаваючою комою залежить від "
"реалізації. Як і в цілих літералах, підкреслення підтримуються для "
"групування цифр."

#: ../../reference/lexical_analysis.rst:926
msgid "Some examples of floating point literals::"
msgstr "Деякі приклади літералів з плаваючою комою::"

#: ../../reference/lexical_analysis.rst:939
msgid "Imaginary literals"
msgstr "Уявні літерали"

#: ../../reference/lexical_analysis.rst:941
msgid "Imaginary literals are described by the following lexical definitions:"
msgstr "Уявні літерали описуються такими лексичними визначеннями:"

#: ../../reference/lexical_analysis.rst:946
msgid ""
"An imaginary literal yields a complex number with a real part of 0.0.  "
"Complex numbers are represented as a pair of floating point numbers and have "
"the same restrictions on their range.  To create a complex number with a "
"nonzero real part, add a floating point number to it, e.g., ``(3+4j)``.  "
"Some examples of imaginary literals::"
msgstr ""
"Уявний літерал дає комплексне число з дійсною частиною 0,0. Комплексні числа "
"представлені у вигляді пари чисел з плаваючою комою та мають однакові "
"обмеження щодо свого діапазону. Щоб створити комплексне число з ненульовою "
"дійсною частиною, додайте до нього число з плаваючою комою, наприклад, "
"``(3+4j)``. Деякі приклади уявних літералів:"

#: ../../reference/lexical_analysis.rst:958
msgid "Operators"
msgstr "Оператори"

#: ../../reference/lexical_analysis.rst:962
msgid "The following tokens are operators:"
msgstr "Наступні токени є операторами:"

#: ../../reference/lexical_analysis.rst:975
msgid "Delimiters"
msgstr "Роздільники"

#: ../../reference/lexical_analysis.rst:979
msgid "The following tokens serve as delimiters in the grammar:"
msgstr "Наступні лексеми служать роздільниками в граматиці:"

#: ../../reference/lexical_analysis.rst:988
msgid ""
"The period can also occur in floating-point and imaginary literals.  A "
"sequence of three periods has a special meaning as an ellipsis literal. The "
"second half of the list, the augmented assignment operators, serve lexically "
"as delimiters, but also perform an operation."
msgstr ""
"Крапка також може зустрічатися в літералах із плаваючою комою та уявних "
"літералах. Послідовність із трьох періодів має особливе значення як літерали "
"еліпсису. Друга половина списку, розширені оператори присвоєння, лексично "
"служать роздільниками, але також виконують операції."

#: ../../reference/lexical_analysis.rst:993
msgid ""
"The following printing ASCII characters have special meaning as part of "
"other tokens or are otherwise significant to the lexical analyzer:"
msgstr ""
"Наступні друковані символи ASCII мають спеціальне значення як частина інших "
"токенів або іншим чином важливі для лексичного аналізатора:"

#: ../../reference/lexical_analysis.rst:1000
msgid ""
"The following printing ASCII characters are not used in Python.  Their "
"occurrence outside string literals and comments is an unconditional error:"
msgstr ""
"Наступні друковані символи ASCII не використовуються в Python. Їх поява поза "
"рядковими літералами та коментарями є безумовною помилкою:"

#: ../../reference/lexical_analysis.rst:1009
msgid "Footnotes"
msgstr "Примітки"

#: ../../reference/lexical_analysis.rst:1010
msgid "https://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt"
msgstr "https://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt"
