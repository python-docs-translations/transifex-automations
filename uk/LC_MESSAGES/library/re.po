# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 16:06+0000\n"
"PO-Revision-Date: 2022-11-05 17:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2022\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../library/re.rst:2
msgid ":mod:`re` --- Regular expression operations"
msgstr ":mod:`re` --- Операції регулярних виразів"

#: ../../library/re.rst:10
msgid "**Source code:** :source:`Lib/re.py`"
msgstr ""

#: ../../library/re.rst:14
msgid ""
"This module provides regular expression matching operations similar to those "
"found in Perl."
msgstr ""
"Цей модуль забезпечує операції зіставлення регулярних виразів, подібні до "
"тих, які є в Perl."

#: ../../library/re.rst:17
msgid ""
"Both patterns and strings to be searched can be Unicode strings (:class:"
"`str`) as well as 8-bit strings (:class:`bytes`). However, Unicode strings "
"and 8-bit strings cannot be mixed: that is, you cannot match a Unicode "
"string with a byte pattern or vice-versa; similarly, when asking for a "
"substitution, the replacement string must be of the same type as both the "
"pattern and the search string."
msgstr ""
"І шаблони, і рядки для пошуку можуть бути рядками Unicode (:class:`str`), а "
"також 8-бітовими рядками (:class:`bytes`). Однак рядки Unicode та 8-бітові "
"рядки не можна змішувати: тобто ви не можете зіставити рядок Unicode з "
"шаблоном байтів або навпаки; так само, коли запитується заміна, рядок заміни "
"має бути того самого типу, що й шаблон, і рядок пошуку."

#: ../../library/re.rst:24
msgid ""
"Regular expressions use the backslash character (``'\\'``) to indicate "
"special forms or to allow special characters to be used without invoking "
"their special meaning.  This collides with Python's usage of the same "
"character for the same purpose in string literals; for example, to match a "
"literal backslash, one might have to write ``'\\\\\\\\'`` as the pattern "
"string, because the regular expression must be ``\\\\``, and each backslash "
"must be expressed as ``\\\\`` inside a regular Python string literal. Also, "
"please note that any invalid escape sequences in Python's usage of the "
"backslash in string literals now generate a :exc:`DeprecationWarning` and in "
"the future this will become a :exc:`SyntaxError`. This behaviour will happen "
"even if it is a valid escape sequence for a regular expression."
msgstr ""
"У регулярних виразах використовується символ зворотної косої риски "
"(``'\\'``), щоб позначити спеціальні форми або дозволити використовувати "
"спеціальні символи без виклику їх спеціального значення. Це суперечить "
"використанню Python того самого символу для тієї ж мети в рядкових "
"літералах; наприклад, щоб відповідати буквальному зворотному слешу, можливо, "
"доведеться написати ``'\\\\\\\\'`` як рядок шаблону, оскільки регулярний "
"вираз має бути ``\\\\``, а кожен зворотний слеш має бути виражений як ``\\"
"\\`` всередині звичайного рядкового літералу Python. Також зауважте, що будь-"
"які недійсні керуючі послідовності під час використання Python зворотної "
"косої риски в рядкових літералах тепер генерують :exc:`DeprecationWarning`, "
"а в майбутньому це стане :exc:`SyntaxError`. Така поведінка відбуватиметься, "
"навіть якщо це дійсна керуюча послідовність для регулярного виразу."

#: ../../library/re.rst:36
msgid ""
"The solution is to use Python's raw string notation for regular expression "
"patterns; backslashes are not handled in any special way in a string literal "
"prefixed with ``'r'``.  So ``r\"\\n\"`` is a two-character string containing "
"``'\\'`` and ``'n'``, while ``\"\\n\"`` is a one-character string containing "
"a newline.  Usually patterns will be expressed in Python code using this raw "
"string notation."
msgstr ""
"Рішення полягає у використанні необробленої рядкової нотації Python для "
"шаблонів регулярних виразів; зворотні косі риски не обробляються жодним "
"особливим чином у рядковому літералі з префіксом ``'r'``. Отже, ``r\"\\n\"`` "
"— це двосимвольний рядок, що містить ``'\\'`` і ``'n'``, тоді як ``\"\\n\"`` "
"є односимвольним рядком, що містить новий рядок. Зазвичай шаблони "
"виражаються в коді Python за допомогою цієї необробленої рядкової нотації."

#: ../../library/re.rst:43
msgid ""
"It is important to note that most regular expression operations are "
"available as module-level functions and methods on :ref:`compiled regular "
"expressions <re-objects>`.  The functions are shortcuts that don't require "
"you to compile a regex object first, but miss some fine-tuning parameters."
msgstr ""
"Важливо відзначити, що більшість операцій з регулярними виразами доступні як "
"функції та методи на рівні модуля для :ref:`компільованих регулярних виразів "
"<re-objects>`. Функції — це ярлики, які не потребують компіляції об’єкта "
"регулярного виразу, але пропускають деякі параметри тонкого налаштування."

#: ../../library/re.rst:51
msgid ""
"The third-party `regex <https://pypi.org/project/regex/>`_ module, which has "
"an API compatible with the standard library :mod:`re` module, but offers "
"additional functionality and a more thorough Unicode support."
msgstr ""
"Сторонній модуль `regex <https://pypi.org/project/regex/>`_, який має API, "
"сумісний із модулем стандартної бібліотеки :mod:`re`, але пропонує додаткові "
"функції та більш повну підтримку Unicode."

#: ../../library/re.rst:59
msgid "Regular Expression Syntax"
msgstr "Синтаксис регулярного виразу"

#: ../../library/re.rst:61
msgid ""
"A regular expression (or RE) specifies a set of strings that matches it; the "
"functions in this module let you check if a particular string matches a "
"given regular expression (or if a given regular expression matches a "
"particular string, which comes down to the same thing)."
msgstr ""
"Регулярний вираз (або RE) визначає набір рядків, який йому відповідає; "
"функції в цьому модулі дозволяють вам перевірити, чи збігається певний рядок "
"з даним регулярним виразом (або чи збігається даний регулярний вираз з "
"певним рядком, що зводиться до того самого)."

#: ../../library/re.rst:66
msgid ""
"Regular expressions can be concatenated to form new regular expressions; if "
"*A* and *B* are both regular expressions, then *AB* is also a regular "
"expression. In general, if a string *p* matches *A* and another string *q* "
"matches *B*, the string *pq* will match AB.  This holds unless *A* or *B* "
"contain low precedence operations; boundary conditions between *A* and *B*; "
"or have numbered group references.  Thus, complex expressions can easily be "
"constructed from simpler primitive expressions like the ones described "
"here.  For details of the theory and implementation of regular expressions, "
"consult the Friedl book [Frie09]_, or almost any textbook about compiler "
"construction."
msgstr ""
"Регулярні вирази можна об’єднувати для створення нових регулярних виразів; "
"якщо *A* і *B* є регулярними виразами, то *AB* також є регулярним виразом. "
"Загалом, якщо рядок *p* відповідає *A*, а інший рядок *q* відповідає *B*, "
"рядок *pq* відповідатиме AB. Це справедливо, якщо *A* або *B* не містять "
"операції з низьким пріоритетом; граничні умови між *A* і *B*; або мають "
"пронумеровані посилання на групи. Таким чином, складні вирази можна легко "
"побудувати з простіших примітивних виразів, таких як описані тут. Щоб "
"отримати детальну інформацію про теорію та реалізацію регулярних виразів, "
"зверніться до книги Фрідла [Frie09]_ або майже до будь-якого підручника про "
"побудову компілятора."

#: ../../library/re.rst:76
msgid ""
"A brief explanation of the format of regular expressions follows.  For "
"further information and a gentler presentation, consult the :ref:`regex-"
"howto`."
msgstr ""
"Нижче наведено коротке пояснення формату регулярних виразів. Для отримання "
"додаткової інформації та більш щадної презентації зверніться до :ref:`regex-"
"howto`."

#: ../../library/re.rst:79
msgid ""
"Regular expressions can contain both special and ordinary characters. Most "
"ordinary characters, like ``'A'``, ``'a'``, or ``'0'``, are the simplest "
"regular expressions; they simply match themselves.  You can concatenate "
"ordinary characters, so ``last`` matches the string ``'last'``.  (In the "
"rest of this section, we'll write RE's in ``this special style``, usually "
"without quotes, and strings to be matched ``'in single quotes'``.)"
msgstr ""
"Регулярні вирази можуть містити як спеціальні, так і звичайні символи. "
"Більшість звичайних символів, таких як ``'A'``, ``'a'`` або ``'0'``, є "
"найпростішими регулярними виразами; вони просто збігаються. Ви можете "
"об’єднувати звичайні символи, тому ``last`` збігається з рядком ``'last'``. "
"(У решті цього розділу ми будемо писати RE в ``цим особливим стилі``, як "
"правило, без лапок, а рядки для відповідності ``'в одинарних лапках``.)"

#: ../../library/re.rst:86
msgid ""
"Some characters, like ``'|'`` or ``'('``, are special. Special characters "
"either stand for classes of ordinary characters, or affect how the regular "
"expressions around them are interpreted."
msgstr ""
"Деякі символи, наприклад ``'|'`` або ``'(''``, є спеціальними. Спеціальні "
"символи або позначають класи звичайних символів, або впливають на "
"інтерпретацію регулярних виразів навколо них."

#: ../../library/re.rst:90
msgid ""
"Repetition qualifiers (``*``, ``+``, ``?``, ``{m,n}``, etc) cannot be "
"directly nested. This avoids ambiguity with the non-greedy modifier suffix "
"``?``, and with other modifiers in other implementations. To apply a second "
"repetition to an inner repetition, parentheses may be used. For example, the "
"expression ``(?:a{6})*`` matches any multiple of six ``'a'`` characters."
msgstr ""

#: ../../library/re.rst:97
msgid "The special characters are:"
msgstr "Спеціальними символами є:"

#: ../../library/re.rst:104 ../../library/re.rst:1435
msgid "``.``"
msgstr "``.``"

#: ../../library/re.rst:102
msgid ""
"(Dot.)  In the default mode, this matches any character except a newline.  "
"If the :const:`DOTALL` flag has been specified, this matches any character "
"including a newline."
msgstr ""
"(Точка.) У режимі за замовчуванням це відповідає будь-якому символу, крім "
"символу нового рядка. Якщо вказано прапорець :const:`DOTALL`, він відповідає "
"будь-якому символу, включаючи новий рядок."

#: ../../library/re.rst:110
msgid "``^``"
msgstr "``^``"

#: ../../library/re.rst:109
msgid ""
"(Caret.)  Matches the start of the string, and in :const:`MULTILINE` mode "
"also matches immediately after each newline."
msgstr ""
"(Caret.) Збігається з початком рядка, а в режимі :const:`MULTILINE` також "
"збігається одразу після кожного нового рядка."

#: ../../library/re.rst:121
msgid "``$``"
msgstr "``$``"

#: ../../library/re.rst:115
msgid ""
"Matches the end of the string or just before the newline at the end of the "
"string, and in :const:`MULTILINE` mode also matches before a newline.  "
"``foo`` matches both 'foo' and 'foobar', while the regular expression "
"``foo$`` matches only 'foo'.  More interestingly, searching for ``foo.$`` in "
"``'foo1\\nfoo2\\n'`` matches 'foo2' normally, but 'foo1' in :const:"
"`MULTILINE` mode; searching for a single ``$`` in ``'foo\\n'`` will find two "
"(empty) matches: one just before the newline, and one at the end of the "
"string."
msgstr ""
"Збігається з кінцем рядка або безпосередньо перед символом нового рядка в "
"кінці рядка, а в режимі :const:`MULTILINE` також збігається перед символом "
"нового рядка. ``foo`` відповідає як 'foo', так і 'foobar', тоді як "
"регулярний вираз ``foo$`` відповідає лише 'foo'. Що ще цікавіше, пошук ``foo."
"$`` у ``'foo1\\nfoo2\\n''`` зазвичай відповідає 'foo2', але 'foo1' у режимі :"
"const:`MULTILINE`; пошук одного ``$`` у ``'foo\\n'`` знайде два (порожні) "
"збіги: один безпосередньо перед символом нового рядка та один у кінці рядка."

#: ../../library/re.rst:128
msgid "``*``"
msgstr "``*``"

#: ../../library/re.rst:126
msgid ""
"Causes the resulting RE to match 0 or more repetitions of the preceding RE, "
"as many repetitions as are possible.  ``ab*`` will match 'a', 'ab', or 'a' "
"followed by any number of 'b's."
msgstr ""
"Примушує кінцевий RE відповідати 0 або більше повторень попереднього RE, "
"якомога більше повторень. ``ab*`` відповідатиме 'a', 'ab' або 'a', за якими "
"йде будь-яка кількість 'b'."

#: ../../library/re.rst:135
msgid "``+``"
msgstr "``+``"

#: ../../library/re.rst:133
msgid ""
"Causes the resulting RE to match 1 or more repetitions of the preceding RE. "
"``ab+`` will match 'a' followed by any non-zero number of 'b's; it will not "
"match just 'a'."
msgstr ""
"Примушує кінцевий RE відповідати 1 або більше повторень попереднього RE. "
"``ab+`` відповідатиме 'a', за яким слідує будь-яке ненульове число 'b'; воно "
"не збігатиметься лише з \"а\"."

#: ../../library/re.rst:141
msgid "``?``"
msgstr "``?``"

#: ../../library/re.rst:140
msgid ""
"Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. "
"``ab?`` will match either 'a' or 'ab'."
msgstr ""
"Примушує результуюче RE відповідати 0 або 1 повторенням попереднього RE. "
"``ab?`` відповідатиме або 'a', або 'ab'."

#: ../../library/re.rst:155
msgid "``*?``, ``+?``, ``??``"
msgstr "``*?``, ``+?``, ``??``"

#: ../../library/re.rst:149
msgid ""
"The ``'*'``, ``'+'``, and ``'?'`` qualifiers are all :dfn:`greedy`; they "
"match as much text as possible.  Sometimes this behaviour isn't desired; if "
"the RE ``<.*>`` is matched against ``'<a> b <c>'``, it will match the entire "
"string, and not just ``'<a>'``.  Adding ``?`` after the qualifier makes it "
"perform the match in :dfn:`non-greedy` or :dfn:`minimal` fashion; as *few* "
"characters as possible will be matched.  Using the RE ``<.*?>`` will match "
"only ``'<a>'``."
msgstr ""

#: ../../library/re.rst:163
msgid "``{m}``"
msgstr "``{m}``"

#: ../../library/re.rst:161
msgid ""
"Specifies that exactly *m* copies of the previous RE should be matched; "
"fewer matches cause the entire RE not to match.  For example, ``a{6}`` will "
"match exactly six ``'a'`` characters, but not five."
msgstr ""
"Вказує, що точно *m* копій попереднього RE мають відповідати; менша "
"кількість збігів призводить до того, що весь RE не збігається. Наприклад, "
"``a{6}`` відповідатиме рівно шести символам ``'a'``, але не п’яти."

#: ../../library/re.rst:172
msgid "``{m,n}``"
msgstr "``{m,n}``"

#: ../../library/re.rst:166
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible.  For "
"example, ``a{3,5}`` will match from 3 to 5 ``'a'`` characters.  Omitting *m* "
"specifies a lower bound of zero,  and omitting *n* specifies an infinite "
"upper bound.  As an example, ``a{4,}b`` will match ``'aaaab'`` or a thousand "
"``'a'`` characters followed by a ``'b'``, but not ``'aaab'``. The comma may "
"not be omitted or the modifier would be confused with the previously "
"described form."
msgstr ""
"Примушує результуючий RE відповідати від *m* до *n* повторень попереднього "
"RE, намагаючись зіставити якомога більше повторень. Наприклад, ``a{3,5}`` "
"відповідатиме від 3 до 5 символів ``'a'``. Пропуск *m* визначає нижню межу "
"нуля, а пропуск *n* визначає нескінченну верхню межу. Наприклад, ``a{4,}b`` "
"відповідатиме ``'aaaab'`` або тисячі символів ``'a'``, після яких ``'b'``, "
"але не ``' аааб''``. Кому не можна опускати, інакше модифікатор можна "
"сплутати з попередньо описаною формою."

#: ../../library/re.rst:179
msgid "``{m,n}?``"
msgstr "``{m,n}?``"

#: ../../library/re.rst:175
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as *few* repetitions as possible.  This is "
"the non-greedy version of the previous qualifier.  For example, on the 6-"
"character string ``'aaaaaa'``, ``a{3,5}`` will match 5 ``'a'`` characters, "
"while ``a{3,5}?`` will only match 3 characters."
msgstr ""

#: ../../library/re.rst:194
msgid "``\\``"
msgstr "``\\``"

#: ../../library/re.rst:184
msgid ""
"Either escapes special characters (permitting you to match characters like "
"``'*'``, ``'?'``, and so forth), or signals a special sequence; special "
"sequences are discussed below."
msgstr ""
"Або екранує спеціальні символи (дозволяючи вам зіставляти такі символи, як "
"``'*'``, ``'?''`` і так далі), або сигналізує про спеціальну послідовність; "
"спеціальні послідовності обговорюються нижче."

#: ../../library/re.rst:188
msgid ""
"If you're not using a raw string to express the pattern, remember that "
"Python also uses the backslash as an escape sequence in string literals; if "
"the escape sequence isn't recognized by Python's parser, the backslash and "
"subsequent character are included in the resulting string.  However, if "
"Python would recognize the resulting sequence, the backslash should be "
"repeated twice.  This is complicated and hard to understand, so it's highly "
"recommended that you use raw strings for all but the simplest expressions."
msgstr ""
"Якщо ви не використовуєте необроблений рядок для вираження шаблону, "
"пам’ятайте, що Python також використовує зворотну косу риску як керуючу "
"послідовність у рядкових літералах; якщо escape-послідовність не "
"розпізнається синтаксичним аналізатором Python, зворотна коса риска та "
"наступний символ включаються в результуючий рядок. Однак, якщо Python "
"розпізнає отриману послідовність, зворотну косу риску слід повторити двічі. "
"Це складно і важко зрозуміти, тому настійно рекомендується використовувати "
"необроблені рядки для всіх виразів, крім найпростіших."

#: ../../library/re.rst:255
msgid "``[]``"
msgstr "``[]``"

#: ../../library/re.rst:200
msgid "Used to indicate a set of characters.  In a set:"
msgstr "Використовується для позначення набору символів. В комплекті:"

#: ../../library/re.rst:202
msgid ""
"Characters can be listed individually, e.g. ``[amk]`` will match ``'a'``, "
"``'m'``, or ``'k'``."
msgstr ""
"Символи можуть бути перераховані окремо, напр. \"[amk]\" відповідатиме "
"\"a\", \"m\" або \"k\"."

#: ../../library/re.rst:207
msgid ""
"Ranges of characters can be indicated by giving two characters and "
"separating them by a ``'-'``, for example ``[a-z]`` will match any lowercase "
"ASCII letter, ``[0-5][0-9]`` will match all the two-digits numbers from "
"``00`` to ``59``, and ``[0-9A-Fa-f]`` will match any hexadecimal digit.  If "
"``-`` is escaped (e.g. ``[a\\-z]``) or if it's placed as the first or last "
"character (e.g. ``[-a]`` or ``[a-]``), it will match a literal ``'-'``."
msgstr ""
"Діапазони символів можна вказати, вказавши два символи та розділивши їх "
"символом ``'-'``, наприклад, ``[a-z]`` відповідатиме будь-якій літері ASCII "
"у нижньому регістрі, ``[0-5][0-9]. ]`` відповідатиме всім двозначним числам "
"від ``00`` до ``59``, а ``[0-9A-Fa-f]`` відповідатиме будь-якій "
"шістнадцятковій цифрі. Якщо ``-`` є екранованим (наприклад, ``[a\\-z]``) або "
"якщо він розміщений як перший чи останній символ (наприклад ``[-a]`` або "
"``[a-]`` ), він відповідатиме літералу ``'-'``."

#: ../../library/re.rst:214
msgid ""
"Special characters lose their special meaning inside sets.  For example, "
"``[(+*)]`` will match any of the literal characters ``'('``, ``'+'``, "
"``'*'``, or ``')'``."
msgstr ""
"Спеціальні символи втрачають своє особливе значення в наборах. Наприклад, "
"``[(+*)]`` відповідатиме будь-якому з літеральних символів ``'('``, ``'+'``, "
"``'*'`` або ``')'``."

#: ../../library/re.rst:220
msgid ""
"Character classes such as ``\\w`` or ``\\S`` (defined below) are also "
"accepted inside a set, although the characters they match depends on "
"whether :const:`ASCII` or :const:`LOCALE` mode is in force."
msgstr ""
"Класи символів, такі як ``\\w`` або ``\\S`` (визначені нижче), також "
"приймаються всередині набору, хоча символи, яким вони відповідають, залежать "
"від режиму :const:`ASCII` або :const:`LOCALE` є чинним."

#: ../../library/re.rst:226
msgid ""
"Characters that are not within a range can be matched by :dfn:"
"`complementing` the set.  If the first character of the set is ``'^'``, all "
"the characters that are *not* in the set will be matched.  For example, "
"``[^5]`` will match any character except ``'5'``, and ``[^^]`` will match "
"any character except ``'^'``.  ``^`` has no special meaning if it's not the "
"first character in the set."
msgstr ""
"Символи, які не входять до діапазону, можуть бути зіставлені шляхом :dfn:"
"`complementing` набору. Якщо першим символом набору є ``'^'``, усі символи, "
"яких *не* в наборі, будуть зіставлені. Наприклад, ``[^5]`` відповідатиме "
"будь-якому символу, крім ``'5''``, а ``[^^]`` відповідатиме будь-якому "
"символу, крім ``'^'``. ``^`` не має особливого значення, якщо це не перший "
"символ у наборі."

#: ../../library/re.rst:233
msgid ""
"To match a literal ``']'`` inside a set, precede it with a backslash, or "
"place it at the beginning of the set.  For example, both ``[()[\\]{}]`` and "
"``[]()[{}]`` will match a right bracket, as well as left bracket, braces, "
"and parentheses."
msgstr ""

#: ../../library/re.rst:243
msgid ""
"Support of nested sets and set operations as in `Unicode Technical Standard "
"#18`_ might be added in the future.  This would change the syntax, so to "
"facilitate this change a :exc:`FutureWarning` will be raised in ambiguous "
"cases for the time being. That includes sets starting with a literal ``'['`` "
"or containing literal character sequences ``'--'``, ``'&&'``, ``'~~'``, and "
"``'||'``.  To avoid a warning escape them with a backslash."
msgstr ""
"У майбутньому може бути додано підтримку вкладених наборів і операцій із "
"наборами, як у `технічному стандарті Unicode #18`_. Це призведе до зміни "
"синтаксису, тож для полегшення цієї зміни :exc:`FutureWarning` наразі буде "
"викликано у неоднозначних випадках. Це включає в себе набори, що починаються "
"з літерала ``'['`` або містять літеральні послідовності символів ``'--'``, "
"``'&&'``, ``'~~'`` і ``'| |'``. Щоб уникнути попередження, екрануйте їх "
"зворотною скісною рискою."

#: ../../library/re.rst:253
msgid ""
":exc:`FutureWarning` is raised if a character set contains constructs that "
"will change semantically in the future."
msgstr ""
":exc:`FutureWarning` викликається, якщо набір символів містить конструкції, "
"які семантично зміняться в майбутньому."

#: ../../library/re.rst:268
msgid "``|``"
msgstr "``|``"

#: ../../library/re.rst:260
msgid ""
"``A|B``, where *A* and *B* can be arbitrary REs, creates a regular "
"expression that will match either *A* or *B*.  An arbitrary number of REs "
"can be separated by the ``'|'`` in this way.  This can be used inside groups "
"(see below) as well.  As the target string is scanned, REs separated by "
"``'|'`` are tried from left to right. When one pattern completely matches, "
"that branch is accepted. This means that once *A* matches, *B* will not be "
"tested further, even if it would produce a longer overall match.  In other "
"words, the ``'|'`` operator is never greedy.  To match a literal ``'|'``, "
"use ``\\|``, or enclose it inside a character class, as in ``[|]``."
msgstr ""
"``A|B``, де *A* і *B* можуть бути довільними RE, створює регулярний вираз, "
"який відповідатиме *A* або *B*. Таким чином довільна кількість RE може бути "
"розділена символом ``'|'``. Це також можна використовувати всередині груп "
"(див. нижче). Під час сканування цільового рядка RE, розділені ``'|'``, "
"пробуються зліва направо. Якщо один шаблон повністю збігається, ця гілка "
"приймається. Це означає, що як тільки *A* збігається, *B* більше не "
"перевірятиметься, навіть якщо це призведе до довшого загального збігу. "
"Іншими словами, оператор ``'|''`` ніколи не є жадібним. Щоб відповідати "
"літералу ``'|'``, використовуйте ``\\|`` або вкладіть його в клас символів, "
"як у ``[|]``."

#: ../../library/re.rst:278
msgid "``(...)``"
msgstr "``(...)``"

#: ../../library/re.rst:274
msgid ""
"Matches whatever regular expression is inside the parentheses, and indicates "
"the start and end of a group; the contents of a group can be retrieved after "
"a match has been performed, and can be matched later in the string with the "
"``\\number`` special sequence, described below.  To match the literals "
"``'('`` or ``')'``, use ``\\(`` or ``\\)``, or enclose them inside a "
"character class: ``[(]``, ``[)]``."
msgstr ""
"Збігається з будь-яким регулярним виразом у дужках і вказує на початок і "
"кінець групи; вміст групи може бути отриманий після того, як було виконано "
"збіг, і може бути зіставлений пізніше в рядку за допомогою спеціальної "
"послідовності ``\\number``, описаної нижче. Щоб зіставити літерали ``'('`` "
"або ``')'``, використовуйте ``\\(`` або ``\\)`` або вкладіть їх у клас "
"символів: ``[(]`` , ``[)]``."

#: ../../library/re.rst:287
msgid "``(?...)``"
msgstr "``(?...)``"

#: ../../library/re.rst:283
msgid ""
"This is an extension notation (a ``'?'`` following a ``'('`` is not "
"meaningful otherwise).  The first character after the ``'?'`` determines "
"what the meaning and further syntax of the construct is. Extensions usually "
"do not create a new group; ``(?P<name>...)`` is the only exception to this "
"rule. Following are the currently supported extensions."
msgstr ""
"Це нотація розширення (``'?''`` після ``' (''`` не має значення інакше). "
"Перший символ після ``'?''`` визначає значення та подальший синтаксис "
"Розширення зазвичай не створюють нову групу; ``(?P <name> ...)`` є єдиним "
"винятком із цього правила. Нижче наведено наразі підтримувані розширення."

#: ../../library/re.rst:301
msgid "``(?aiLmsux)``"
msgstr "``(?aiLmsux)``"

#: ../../library/re.rst:290
msgid ""
"(One or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``.)  The group matches the empty string; the letters "
"set the corresponding flags: :const:`re.A` (ASCII-only matching), :const:`re."
"I` (ignore case), :const:`re.L` (locale dependent), :const:`re.M` (multi-"
"line), :const:`re.S` (dot matches all), :const:`re.U` (Unicode matching), "
"and :const:`re.X` (verbose), for the entire regular expression. (The flags "
"are described in :ref:`contents-of-module-re`.) This is useful if you wish "
"to include the flags as part of the regular expression, instead of passing a "
"*flag* argument to the :func:`re.compile` function.  Flags should be used "
"first in the expression string."
msgstr ""
"(Одна або кілька літер із набору ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``.) Група відповідає порожньому рядку; літери "
"встановлюють відповідні позначки: :const:`re.A` (відповідність лише ASCII), :"
"const:`re.I` (ігнорувати регістр), :const:`re.L` (залежно від локалі), :"
"const:`re.M` (багаторядковий), :const:`re.S` (крапка відповідає всім), :"
"const:`re.U` (відповідність Unicode) і :const:`re.X` (дослівний ), для "
"всього регулярного виразу. (Прапори описано в :ref:`contents-of-module-re`.) "
"Це корисно, якщо ви бажаєте включити прапори як частину регулярного виразу "
"замість передачі аргументу *flag* до функція :func:`re.compile`. Прапори "
"слід використовувати першими в рядку виразу."

#: ../../library/re.rst:309
msgid "``(?:...)``"
msgstr "``(?:...)``"

#: ../../library/re.rst:306
msgid ""
"A non-capturing version of regular parentheses.  Matches whatever regular "
"expression is inside the parentheses, but the substring matched by the group "
"*cannot* be retrieved after performing a match or referenced later in the "
"pattern."
msgstr ""
"Версія звичайних круглих дужок без захоплення. Збігається з будь-яким "
"регулярним виразом у дужках, але підрядок, який відповідає групі, "
"*неможливо* отримати після виконання збігу або посилатися на нього пізніше в "
"шаблоні."

#: ../../library/re.rst:335
msgid "``(?aiLmsux-imsx:...)``"
msgstr "``(?aiLmsux-imsx:...)``"

#: ../../library/re.rst:312
msgid ""
"(Zero or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``, optionally followed by ``'-'`` followed by one or "
"more letters from the ``'i'``, ``'m'``, ``'s'``, ``'x'``.) The letters set "
"or remove the corresponding flags: :const:`re.A` (ASCII-only matching), :"
"const:`re.I` (ignore case), :const:`re.L` (locale dependent), :const:`re.M` "
"(multi-line), :const:`re.S` (dot matches all), :const:`re.U` (Unicode "
"matching), and :const:`re.X` (verbose), for the part of the expression. (The "
"flags are described in :ref:`contents-of-module-re`.)"
msgstr ""
"(Нуль або більше літер із набору ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``, необов'язково після ``'-''``, за якою слідує одна "
"або більше літер ``'i'``, ``'m'``, ``'s'``, ``'x'``.) Літери встановлюють "
"або видаляють відповідні позначки: :const:`re.A` (відповідність лише "
"ASCII), :const:`re.I` (ігнорувати регістр ), :const:`re.L` (залежно від "
"локалі), :const:`re.M` (багаторядковий), :const:`re.S` (точка відповідає "
"всім), :const:`re.U` (збіг Юнікоду) і :const:`re.X` (дослівно) для частини "
"виразу. (Прапорці описані в :ref:`contents-of-module-re`.)"

#: ../../library/re.rst:322
msgid ""
"The letters ``'a'``, ``'L'`` and ``'u'`` are mutually exclusive when used as "
"inline flags, so they can't be combined or follow ``'-'``.  Instead, when "
"one of them appears in an inline group, it overrides the matching mode in "
"the enclosing group.  In Unicode patterns ``(?a:...)`` switches to ASCII-"
"only matching, and ``(?u:...)`` switches to Unicode matching (default).  In "
"byte pattern ``(?L:...)`` switches to locale depending matching, and ``(?"
"a:...)`` switches to ASCII-only matching (default). This override is only in "
"effect for the narrow inline group, and the original matching mode is "
"restored outside of the group."
msgstr ""
"Літери ``'a'``, ``'L'`` і ``'u'`` є взаємовиключними, коли використовуються "
"як вбудовані прапорці, тому їх не можна поєднувати або слідувати за "
"``'-'`` . Натомість, коли один із них з’являється у вбудованій групі, він "
"замінює режим відповідності в охоплюючій групі. У шаблонах Unicode ``(?"
"a:...)`` перемикається на відповідність лише ASCII, а ``(?u:...)`` "
"перемикається на відповідність Unicode (за замовчуванням). У шаблоні байтів "
"``(?L:...)`` перемикається на відповідність залежно від локалі, а ``(?"
"a:...)`` перемикається на відповідність лише ASCII (за замовчуванням). Це "
"перевизначення діє лише для вузької вбудованої групи, а вихідний режим "
"відповідності відновлюється за межами групи."

#: ../../library/re.rst:334
msgid "The letters ``'a'``, ``'L'`` and ``'u'`` also can be used in a group."
msgstr "Літери ``'a'``, ``'L'`` і ``'u'`` також можна використовувати в групі."

#: ../../library/re.rst:362
msgid "``(?P<name>...)``"
msgstr "``(?P <name> ...)``"

#: ../../library/re.rst:340
msgid ""
"Similar to regular parentheses, but the substring matched by the group is "
"accessible via the symbolic group name *name*.  Group names must be valid "
"Python identifiers, and each group name must be defined only once within a "
"regular expression.  A symbolic group is also a numbered group, just as if "
"the group were not named."
msgstr ""
"Подібно до звичайних дужок, але підрядок, який відповідає групі, доступний "
"через символічне ім’я групи *name*. Імена груп мають бути дійсними "
"ідентифікаторами Python, і кожне ім’я групи має бути визначено лише один раз "
"у регулярному виразі. Символічна група також є пронумерованою групою, так "
"само, якби група не мала імені."

#: ../../library/re.rst:346
msgid ""
"Named groups can be referenced in three contexts.  If the pattern is ``(?"
"P<quote>['\"]).*?(?P=quote)`` (i.e. matching a string quoted with either "
"single or double quotes):"
msgstr ""
"На іменовані групи можна посилатися в трьох контекстах. Якщо шаблон ``(?P "
"<quote> ['\"]).*?(?P=quote)`` (тобто відповідає рядку в одинарних або "
"подвійних лапках):"

#: ../../library/re.rst:351
msgid "Context of reference to group \"quote\""
msgstr "Контекст посилання на групу \"цитата\""

#: ../../library/re.rst:351
msgid "Ways to reference it"
msgstr "Способи посилання на нього"

#: ../../library/re.rst:353
msgid "in the same pattern itself"
msgstr "за таким самим шаблоном"

#: ../../library/re.rst:353
msgid "``(?P=quote)`` (as shown)"
msgstr "``(?P=quote)`` (як показано)"

#: ../../library/re.rst:354 ../../library/re.rst:361
msgid "``\\1``"
msgstr "``\\1``"

#: ../../library/re.rst:356
msgid "when processing match object *m*"
msgstr "під час обробки відповідного об'єкта *m*"

#: ../../library/re.rst:356
msgid "``m.group('quote')``"
msgstr "``m.group('quote')``"

#: ../../library/re.rst:357
msgid "``m.end('quote')`` (etc.)"
msgstr "``m.end('quote')`` (і т.д.)"

#: ../../library/re.rst:359
msgid "in a string passed to the *repl* argument of ``re.sub()``"
msgstr "у рядку, переданому в аргумент *repl* ``re.sub()``"

#: ../../library/re.rst:359
msgid "``\\g<quote>``"
msgstr "``\\g <quote>``"

#: ../../library/re.rst:360
msgid "``\\g<1>``"
msgstr "``\\g <1>``"

#: ../../library/re.rst:368
msgid "``(?P=name)``"
msgstr "``(?P=name)``"

#: ../../library/re.rst:367
msgid ""
"A backreference to a named group; it matches whatever text was matched by "
"the earlier group named *name*."
msgstr ""
"Зворотне посилання на іменовану групу; він відповідає будь-якому тексту, "
"який відповідав попередній групі під назвою *name*."

#: ../../library/re.rst:373
msgid "``(?#...)``"
msgstr "``(?#...)``"

#: ../../library/re.rst:373
msgid "A comment; the contents of the parentheses are simply ignored."
msgstr "коментар; вміст круглих дужок просто ігнорується."

#: ../../library/re.rst:380
msgid "``(?=...)``"
msgstr "``(?=...)``"

#: ../../library/re.rst:378
msgid ""
"Matches if ``...`` matches next, but doesn't consume any of the string.  "
"This is called a :dfn:`lookahead assertion`.  For example, ``Isaac (?"
"=Asimov)`` will match ``'Isaac '`` only if it's followed by ``'Asimov'``."
msgstr ""
"Збігається, якщо ``...`` збігається наступним, але не споживає жоден рядок. "
"Це називається :dfn:`lookahead assertion`. Наприклад, ``Isaac (?=Azimov)`` "
"відповідатиме ``'Isaac ''``, лише якщо за ним йде ``'Azimov'``."

#: ../../library/re.rst:387
msgid "``(?!...)``"
msgstr "``(?!...)``"

#: ../../library/re.rst:385
msgid ""
"Matches if ``...`` doesn't match next.  This is a :dfn:`negative lookahead "
"assertion`. For example, ``Isaac (?!Asimov)`` will match ``'Isaac '`` only "
"if it's *not* followed by ``'Asimov'``."
msgstr ""
"Збігається, якщо ``...`` не збігається наступним. Це :dfn:`негативне "
"випереджальне твердження`. Наприклад, ``Isaac (?!Azimov)`` відповідатиме "
"``'Isaac ''``, лише якщо за ним *не* йде ``'Azimov'``."

#: ../../library/re.rst:414
msgid "``(?<=...)``"
msgstr "``(?<=...)``"

#: ../../library/re.rst:392
msgid ""
"Matches if the current position in the string is preceded by a match for "
"``...`` that ends at the current position.  This is called a :dfn:`positive "
"lookbehind assertion`. ``(?<=abc)def`` will find a match in ``'abcdef'``, "
"since the lookbehind will back up 3 characters and check if the contained "
"pattern matches. The contained pattern must only match strings of some fixed "
"length, meaning that ``abc`` or ``a|b`` are allowed, but ``a*`` and ``a{3,4}"
"`` are not.  Note that patterns which start with positive lookbehind "
"assertions will not match at the beginning of the string being searched; you "
"will most likely want to use the :func:`search` function rather than the :"
"func:`match` function:"
msgstr ""
"Збігається, якщо поточній позиції в рядку передує відповідність для ``...``, "
"яка закінчується на поточній позиції. Це називається :dfn:`позитивним "
"ретроспективним твердженням`. ``(?<=abc)def`` знайде збіг у ``'abcdef'``, "
"оскільки огляд назад створить резервну копію 3 символів і перевірить, чи "
"збігається шаблон, що міститься. Вміщений шаблон має збігатися лише з "
"рядками певної фіксованої довжини, тобто допустимі ``abc`` або ``a|b``, але "
"``a*`` і ``a{3,4}`` заборонені . Зауважте, що шаблони, які починаються з "
"позитивних ретроспективних тверджень, не збігатимуться на початку рядка, що "
"шукається; швидше за все, ви захочете використовувати функцію :func:"
"`search`, а не функцію :func:`match`:"

#: ../../library/re.rst:407
msgid "This example looks for a word following a hyphen:"
msgstr "У цьому прикладі шукається слово після дефіса:"

#: ../../library/re.rst:413
msgid "Added support for group references of fixed length."
msgstr "Додано підтримку групових посилань фіксованої довжини."

#: ../../library/re.rst:423
msgid "``(?<!...)``"
msgstr "``(?<!...)``"

#: ../../library/re.rst:419
msgid ""
"Matches if the current position in the string is not preceded by a match for "
"``...``.  This is called a :dfn:`negative lookbehind assertion`.  Similar to "
"positive lookbehind assertions, the contained pattern must only match "
"strings of some fixed length.  Patterns which start with negative lookbehind "
"assertions may match at the beginning of the string being searched."
msgstr ""
"Збігається, якщо поточній позиції в рядку не передує збіг для ``...``. Це "
"називається :dfn:`negative lookbehind assertion`. Подібно до позитивних "
"ретроспективних тверджень, шаблон, що міститься, повинен відповідати лише "
"рядкам певної фіксованої довжини. Шаблони, які починаються з негативних "
"ретроспективних тверджень, можуть збігатися на початку рядка, який шукається."

#: ../../library/re.rst:435
msgid "``(?(id/name)yes-pattern|no-pattern)``"
msgstr "``(?(id/name)yes-pattern|no-pattern)``"

#: ../../library/re.rst:429
msgid ""
"Will try to match with ``yes-pattern`` if the group with given *id* or "
"*name* exists, and with ``no-pattern`` if it doesn't. ``no-pattern`` is "
"optional and can be omitted. For example, ``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?"
"(1)>|$)`` is a poor email matching pattern, which will match with "
"``'<user@host.com>'`` as well as ``'user@host.com'``, but not with "
"``'<user@host.com'`` nor ``'user@host.com>'``."
msgstr ""
"Спробує знайти відповідність за допомогою ``yes-pattern``, якщо група з "
"заданим *id* або *name* існує, і за допомогою ``no-pattern``, якщо вона не "
"існує. ``no-pattern`` є необов'язковим і його можна опустити. Наприклад, "
"``( <)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)> |$)`` є поганим шаблоном відповідності "
"електронної пошти, який збігатиметься з ``'<user@host.com>'``, а також "
"``'user@host.com'``, але не з ``'<user@host.com'`` nor ``'user@host.com> '``."

#: ../../library/re.rst:437
msgid ""
"The special sequences consist of ``'\\'`` and a character from the list "
"below. If the ordinary character is not an ASCII digit or an ASCII letter, "
"then the resulting RE will match the second character.  For example, ``\\$`` "
"matches the character ``'$'``."
msgstr ""
"Спеціальні послідовності складаються з ``'\\'`` і символу зі списку нижче. "
"Якщо звичайний символ не є цифрою ASCII або літерою ASCII, тоді результуючий "
"RE відповідатиме другому символу. Наприклад, ``\\$`` відповідає символу "
"``''$'``."

#: ../../library/re.rst:452
msgid "``\\number``"
msgstr "``\\номер``"

#: ../../library/re.rst:445
msgid ""
"Matches the contents of the group of the same number.  Groups are numbered "
"starting from 1.  For example, ``(.+) \\1`` matches ``'the the'`` or ``'55 "
"55'``, but not ``'thethe'`` (note the space after the group).  This special "
"sequence can only be used to match one of the first 99 groups.  If the first "
"digit of *number* is 0, or *number* is 3 octal digits long, it will not be "
"interpreted as a group match, but as the character with octal value "
"*number*. Inside the ``'['`` and ``']'`` of a character class, all numeric "
"escapes are treated as characters."
msgstr ""
"Відповідає вмісту групи з тим самим номером. Групи нумеруються, починаючи з "
"1. Наприклад, ``(.+) \\1`` відповідає ``'the'`` або ``'55 55'``, але не "
"``'thethe'`` (примітка пробіл після групи). Цю спеціальну послідовність "
"можна використовувати лише для відповідності одній із перших 99 груп. Якщо "
"перша цифра *числа* дорівнює 0 або *число* складається з 3 вісімкових цифр, "
"це не буде інтерпретовано як збіг групи, а як символ із вісімковим значенням "
"*число*. Усередині ``'['`` і ``']'`` класу символів усі цифрові екрановані "
"символи розглядаються як символи."

#: ../../library/re.rst:457
msgid "``\\A``"
msgstr "``\\A``"

#: ../../library/re.rst:457
msgid "Matches only at the start of the string."
msgstr "Збігається лише на початку рядка."

#: ../../library/re.rst:473
msgid "``\\b``"
msgstr "``\\b``"

#: ../../library/re.rst:462
msgid ""
"Matches the empty string, but only at the beginning or end of a word. A word "
"is defined as a sequence of word characters.  Note that formally, ``\\b`` is "
"defined as the boundary between a ``\\w`` and a ``\\W`` character (or vice "
"versa), or between ``\\w`` and the beginning/end of the string. This means "
"that ``r'\\bfoo\\b'`` matches ``'foo'``, ``'foo.'``, ``'(foo)'``, ``'bar foo "
"baz'`` but not ``'foobar'`` or ``'foo3'``."
msgstr ""
"Збігається з порожнім рядком, але лише на початку або в кінці слова. Слово "
"визначається як послідовність символів слова. Зауважте, що формально ``\\b`` "
"визначається як межа між символом ``\\w`` і ``\\W`` (або навпаки), або між "
"``\\w`` і початком/ кінець рядка. Це означає, що ``r'\\bfoo\\b'`` відповідає "
"``'foo'``, ``'foo.''``, ``'(foo)'``, ``'bar foo baz'``, але не ``'foobar'`` "
"або ``'foo3'``."

#: ../../library/re.rst:469
msgid ""
"By default Unicode alphanumerics are the ones used in Unicode patterns, but "
"this can be changed by using the :const:`ASCII` flag.  Word boundaries are "
"determined by the current locale if the :const:`LOCALE` flag is used. Inside "
"a character range, ``\\b`` represents the backspace character, for "
"compatibility with Python's string literals."
msgstr ""
"За замовчуванням буквено-цифрові символи Unicode використовуються в шаблонах "
"Unicode, але це можна змінити за допомогою прапорця :const:`ASCII`. Межі "
"слів визначаються поточною мовою, якщо використовується прапорець :const:"
"`LOCALE`. Усередині діапазону символів ``\\b`` представляє символ зворотного "
"пробілу для сумісності з рядковими літералами Python."

#: ../../library/re.rst:484
msgid "``\\B``"
msgstr "``\\B``"

#: ../../library/re.rst:478
msgid ""
"Matches the empty string, but only when it is *not* at the beginning or end "
"of a word.  This means that ``r'py\\B'`` matches ``'python'``, ``'py3'``, "
"``'py2'``, but not ``'py'``, ``'py.'``, or ``'py!'``. ``\\B`` is just the "
"opposite of ``\\b``, so word characters in Unicode patterns are Unicode "
"alphanumerics or the underscore, although this can be changed by using the :"
"const:`ASCII` flag.  Word boundaries are determined by the current locale if "
"the :const:`LOCALE` flag is used."
msgstr ""
"Збігається з порожнім рядком, але лише якщо він *не* на початку або в кінці "
"слова. Це означає, що ``r'py\\B''`` відповідає ``'python'``, ``'py3'``, "
"``'py2'``, але не ``'py'``, ``'py.'`` або ``'py!'``. ``\\B`` є прямою "
"протилежністю ``\\b``, тому символи слів у шаблонах Unicode є буквено-"
"цифровими символами Unicode або підкресленням, хоча це можна змінити за "
"допомогою прапорця :const:`ASCII`. Межі слів визначаються поточною мовою, "
"якщо використовується прапорець :const:`LOCALE`."

#: ../../library/re.rst:496
msgid "``\\d``"
msgstr "``\\d``"

#: ../../library/re.rst:493 ../../library/re.rst:513 ../../library/re.rst:532
msgid "For Unicode (str) patterns:"
msgstr "Для шаблонів Unicode (str):"

#: ../../library/re.rst:490
msgid ""
"Matches any Unicode decimal digit (that is, any character in Unicode "
"character category [Nd]).  This includes ``[0-9]``, and also many other "
"digit characters.  If the :const:`ASCII` flag is used only ``[0-9]`` is "
"matched."
msgstr ""
"Відповідає будь-якій десятковій цифрі Unicode (тобто будь-якому символу в "
"категорії символів Unicode [Nd]). Це включає в себе \"[0-9]\", а також "
"багато інших цифрових символів. Якщо використовується прапорець :const:"
"`ASCII`, збігається лише ``[0-9]``."

#: ../../library/re.rst:496 ../../library/re.rst:517 ../../library/re.rst:538
msgid "For 8-bit (bytes) patterns:"
msgstr "Для 8-бітових (байтових) шаблонів:"

#: ../../library/re.rst:496
msgid "Matches any decimal digit; this is equivalent to ``[0-9]``."
msgstr "Збігається з будь-якою десятковою цифрою; це еквівалентно ``[0-9]``."

#: ../../library/re.rst:503
msgid "``\\D``"
msgstr "``\\D``"

#: ../../library/re.rst:501
msgid ""
"Matches any character which is not a decimal digit. This is the opposite of "
"``\\d``. If the :const:`ASCII` flag is used this becomes the equivalent of "
"``[^0-9]``."
msgstr ""
"Відповідає будь-якому символу, який не є десятковою цифрою. Це протилежність "
"``\\d``. Якщо використовується прапорець :const:`ASCII`, це стає "
"еквівалентом ``[^0-9]``."

#: ../../library/re.rst:517
msgid "``\\s``"
msgstr "``\\s``"

#: ../../library/re.rst:509
msgid ""
"Matches Unicode whitespace characters (which includes "
"``[ \\t\\n\\r\\f\\v]``, and also many other characters, for example the non-"
"breaking spaces mandated by typography rules in many languages). If the :"
"const:`ASCII` flag is used, only ``[ \\t\\n\\r\\f\\v]`` is matched."
msgstr ""
"Відповідає пробілам Юнікоду (зокрема, ``[ \\t\\n\\r\\f\\v]``, а також "
"багатьом іншим символам, наприклад нерозривним пробілам, передбаченим "
"правилами типографіки багатьох мов). Якщо використовується прапорець :const:"
"`ASCII`, збігається лише ``[ \\t\\n\\r\\f\\v]``."

#: ../../library/re.rst:516
msgid ""
"Matches characters considered whitespace in the ASCII character set; this is "
"equivalent to ``[ \\t\\n\\r\\f\\v]``."
msgstr ""
"Відповідає символам, які вважаються пробілами в наборі символів ASCII; це "
"еквівалентно ``[ \\t\\n\\r\\f\\v]``."

#: ../../library/re.rst:524
msgid "``\\S``"
msgstr "``\\S``"

#: ../../library/re.rst:522
msgid ""
"Matches any character which is not a whitespace character. This is the "
"opposite of ``\\s``. If the :const:`ASCII` flag is used this becomes the "
"equivalent of ``[^ \\t\\n\\r\\f\\v]``."
msgstr ""
"Відповідає будь-якому символу, який не є пробілом. Це протилежність ``\\s``. "
"Якщо використовується прапорець :const:`ASCII`, це стає еквівалентом ``[^ "
"\\t\\n\\r\\f\\v]``."

#: ../../library/re.rst:538
msgid "``\\w``"
msgstr "``\\w``"

#: ../../library/re.rst:530
msgid ""
"Matches Unicode word characters; this includes alphanumeric characters (as "
"defined by :meth:`str.isalnum`) as well as the underscore (``_``). If the :"
"const:`ASCII` flag is used, only ``[a-zA-Z0-9_]`` is matched."
msgstr ""

#: ../../library/re.rst:535
msgid ""
"Matches characters considered alphanumeric in the ASCII character set; this "
"is equivalent to ``[a-zA-Z0-9_]``.  If the :const:`LOCALE` flag is used, "
"matches characters considered alphanumeric in the current locale and the "
"underscore."
msgstr ""
"Відповідає символам, які вважаються буквено-цифровими в наборі символів "
"ASCII; це еквівалентно ``[a-zA-Z0-9_]``. Якщо використовується прапорець :"
"const:`LOCALE`, відповідає символам, які вважаються буквено-цифровими в "
"поточній локалі, і підкресленню."

#: ../../library/re.rst:547
msgid "``\\W``"
msgstr "``\\W``"

#: ../../library/re.rst:543
msgid ""
"Matches any character which is not a word character. This is the opposite of "
"``\\w``. If the :const:`ASCII` flag is used this becomes the equivalent of "
"``[^a-zA-Z0-9_]``.  If the :const:`LOCALE` flag is used, matches characters "
"which are neither alphanumeric in the current locale nor the underscore."
msgstr ""
"Відповідає будь-якому символу, який не є символом слова. Це протилежність "
"``\\w``. Якщо використовується прапорець :const:`ASCII`, це стає "
"еквівалентом ``[^a-zA-Z0-9_]``. Якщо використовується прапорець :const:"
"`LOCALE`, відповідає символам, які не є ані буквено-цифровими в поточній "
"локалі, ані підкресленням."

#: ../../library/re.rst:552
msgid "``\\Z``"
msgstr "``\\Z``"

#: ../../library/re.rst:552
msgid "Matches only at the end of the string."
msgstr "Збігається лише в кінці рядка."

#: ../../library/re.rst:568
msgid ""
"Most of the standard escapes supported by Python string literals are also "
"accepted by the regular expression parser::"
msgstr ""
"Більшість стандартних екранованих символів, які підтримуються рядковими "
"літералами Python, також приймаються аналізатором регулярних виразів::"

#: ../../library/re.rst:575
msgid ""
"(Note that ``\\b`` is used to represent word boundaries, and means "
"\"backspace\" only inside character classes.)"
msgstr ""
"(Зауважте, що ``\\b`` використовується для представлення меж слів і означає "
"\"backspace\" лише всередині класів символів.)"

#: ../../library/re.rst:578
msgid ""
"``'\\u'``, ``'\\U'``, and ``'\\N'`` escape sequences are only recognized in "
"Unicode patterns.  In bytes patterns they are errors.  Unknown escapes of "
"ASCII letters are reserved for future use and treated as errors."
msgstr ""
"Екран-послідовності ``'\\u'``, ``'\\U'`` і ``'\\N''`` розпізнаються лише в "
"шаблонах Unicode. У шаблонах байтів це помилки. Невідомі вихідні коди літер "
"ASCII зарезервовано для майбутнього використання та розглядаються як помилки."

#: ../../library/re.rst:582
msgid ""
"Octal escapes are included in a limited form.  If the first digit is a 0, or "
"if there are three octal digits, it is considered an octal escape. "
"Otherwise, it is a group reference.  As for string literals, octal escapes "
"are always at most three digits in length."
msgstr ""
"Вісімкові втечі включені в обмеженій формі. Якщо першою цифрою є 0 або є три "
"вісімкові цифри, це вважається вісімковим екрануванням. В іншому випадку це "
"посилання на групу. Що стосується рядкових літералів, вісімкові символи "
"екранування завжди мають не більше трьох цифр."

#: ../../library/re.rst:587
msgid "The ``'\\u'`` and ``'\\U'`` escape sequences have been added."
msgstr "Було додано керуючі послідовності ``'\\u'`` і ``'\\U'``."

#: ../../library/re.rst:590
msgid ""
"Unknown escapes consisting of ``'\\'`` and an ASCII letter now are errors."
msgstr ""
"Невідомі вихідні символи, що складаються з ``'\\'`` і літери ASCII, тепер є "
"помилками."

#: ../../library/re.rst:593
msgid ""
"The ``'\\N{name}'`` escape sequence has been added. As in string literals, "
"it expands to the named Unicode character (e.g. ``'\\N{EM DASH}'``)."
msgstr ""
"Додано керуючу послідовність ``'\\N{name}''``. Як і в рядкових літералах, "
"він розширюється до названого символу Unicode (наприклад, ``'\\N{EM "
"DASH}''``)."

#: ../../library/re.rst:601
msgid "Module Contents"
msgstr "Зміст модуля"

#: ../../library/re.rst:603
msgid ""
"The module defines several functions, constants, and an exception. Some of "
"the functions are simplified versions of the full featured methods for "
"compiled regular expressions.  Most non-trivial applications always use the "
"compiled form."
msgstr ""
"Модуль визначає кілька функцій, констант і виключення. Деякі функції є "
"спрощеними версіями повнофункціональних методів для скомпільованих "
"регулярних виразів. Більшість нетривіальних програм завжди використовують "
"скомпільовану форму."

#: ../../library/re.rst:610
msgid "Flags"
msgstr "Прапори"

#: ../../library/re.rst:612
msgid ""
"Flag constants are now instances of :class:`RegexFlag`, which is a subclass "
"of :class:`enum.IntFlag`."
msgstr ""
"Константи прапорів тепер є екземплярами :class:`RegexFlag`, який є "
"підкласом :class:`enum.IntFlag`."

#: ../../library/re.rst:621
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` and "
"``\\S`` perform ASCII-only matching instead of full Unicode matching.  This "
"is only meaningful for Unicode patterns, and is ignored for byte patterns. "
"Corresponds to the inline flag ``(?a)``."
msgstr ""
"Зробіть ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` і "
"``\\S`` виконує зіставлення тільки ASCII замість повного зіставлення "
"Unicode. Це має значення лише для шаблонів Unicode та ігнорується для "
"шаблонів байтів. Відповідає вбудованому прапору ``(?a)``."

#: ../../library/re.rst:626
msgid ""
"Note that for backward compatibility, the :const:`re.U` flag still exists "
"(as well as its synonym :const:`re.UNICODE` and its embedded counterpart ``(?"
"u)``), but these are redundant in Python 3 since matches are Unicode by "
"default for strings (and Unicode matching isn't allowed for bytes)."
msgstr ""
"Зауважте, що для зворотної сумісності прапор :const:`re.U` все ще існує (а "
"також його синонім :const:`re.UNICODE` і його вбудований аналог ``(?u)``), "
"але вони зайві. у Python 3, оскільки збіги є Юнікодом за замовчуванням для "
"рядків (і збіги Юнікоду не дозволені для байтів)."

#: ../../library/re.rst:635
msgid ""
"Display debug information about compiled expression. No corresponding inline "
"flag."
msgstr ""
"Відображення налагоджувальної інформації про скомпільований вираз. Немає "
"відповідного вбудованого прапора."

#: ../../library/re.rst:642
msgid ""
"Perform case-insensitive matching; expressions like ``[A-Z]`` will also "
"match lowercase letters.  Full Unicode matching (such as ``Ü`` matching "
"``ü``) also works unless the :const:`re.ASCII` flag is used to disable non-"
"ASCII matches.  The current locale does not change the effect of this flag "
"unless the :const:`re.LOCALE` flag is also used. Corresponds to the inline "
"flag ``(?i)``."
msgstr ""
"Виконуйте зіставлення без урахування регістру; такі вирази, як ``[A-Z]`` "
"також відповідатимуть малим регістрам. Повна відповідність Юнікоду "
"(наприклад, ``Ü``, яка відповідає ``ü``) також працює, якщо не "
"використовується прапор :const:`re.ASCII`, щоб вимкнути збіги, відмінні від "
"ASCII. Поточна локаль не змінює ефект цього прапорця, якщо також не "
"використовується прапорець :const:`re.LOCALE`. Відповідає вбудованому "
"прапору ``(?i)``."

#: ../../library/re.rst:649
msgid ""
"Note that when the Unicode patterns ``[a-z]`` or ``[A-Z]`` are used in "
"combination with the :const:`IGNORECASE` flag, they will match the 52 ASCII "
"letters and 4 additional non-ASCII letters: 'İ' (U+0130, Latin capital "
"letter I with dot above), 'ı' (U+0131, Latin small letter dotless i), "
"'ſ' (U+017F, Latin small letter long s) and 'K' (U+212A, Kelvin sign). If "
"the :const:`ASCII` flag is used, only letters 'a' to 'z' and 'A' to 'Z' are "
"matched."
msgstr ""
"Зауважте, що коли шаблони Unicode ``[a-z]`` або ``[A-Z]`` використовуються в "
"поєднанні з прапором :const:`IGNORECASE`, вони відповідатимуть 52 літерам "
"ASCII і 4 додатковим літерам, які не належать до ASCII: 'İ' (U+0130, "
"латинська велика літера I з крапкою вгорі), 'ı' (U+0131, латинська мала "
"літера i без крапки), 'ſ' (U+017F, латинська мала літера довга s) і "
"'K' (U+212A, знак Кельвіна). Якщо використовується прапорець :const:`ASCII`, "
"збігаються лише літери від 'a' до 'z' і від 'A' до 'Z'."

#: ../../library/re.rst:660
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale.  This flag can be used only with bytes "
"patterns.  The use of this flag is discouraged as the locale mechanism is "
"very unreliable, it only handles one \"culture\" at a time, and it only "
"works with 8-bit locales.  Unicode matching is already enabled by default in "
"Python 3 for Unicode (str) patterns, and it is able to handle different "
"locales/languages. Corresponds to the inline flag ``(?L)``."
msgstr ""
"Зробити ``\\w``, ``\\W``, ``\\b``, ``\\B`` і відповідність без урахування "
"регістру залежно від поточної мови. Цей прапорець можна використовувати лише "
"з шаблонами байтів. Використання цього прапорця не рекомендується, оскільки "
"механізм локалізації є дуже ненадійним, він обробляє лише одну \"культуру\" "
"за раз і працює лише з 8-бітними локалізаціями. Зіставлення Unicode вже "
"ввімкнено за замовчуванням у Python 3 для шаблонів Unicode (str), і він "
"здатний обробляти різні локалі/мови. Відповідає вбудованому прапору ``(?L)``."

#: ../../library/re.rst:669
msgid ""
":const:`re.LOCALE` can be used only with bytes patterns and is not "
"compatible with :const:`re.ASCII`."
msgstr ""
":const:`re.LOCALE` можна використовувати лише з шаблонами байтів і "
"несумісний з :const:`re.ASCII`."

#: ../../library/re.rst:673
msgid ""
"Compiled regular expression objects with the :const:`re.LOCALE` flag no "
"longer depend on the locale at compile time.  Only the locale at matching "
"time affects the result of matching."
msgstr ""
"Зкомпільовані регулярні вирази з прапорцем :const:`re.LOCALE` більше не "
"залежать від локалі під час компіляції. Лише локаль під час зіставлення "
"впливає на результат зіставлення."

#: ../../library/re.rst:682
msgid ""
"When specified, the pattern character ``'^'`` matches at the beginning of "
"the string and at the beginning of each line (immediately following each "
"newline); and the pattern character ``'$'`` matches at the end of the string "
"and at the end of each line (immediately preceding each newline).  By "
"default, ``'^'`` matches only at the beginning of the string, and ``'$'`` "
"only at the end of the string and immediately before the newline (if any) at "
"the end of the string. Corresponds to the inline flag ``(?m)``."
msgstr ""
"Якщо вказано, символ шаблону ``'^'`` збігається на початку рядка та на "
"початку кожного рядка (відразу після кожного нового рядка); і символ шаблону "
"``'$'`` збігається в кінці рядка та в кінці кожного рядка (безпосередньо "
"перед кожним новим рядком). За замовчуванням ``'^'`` збігається лише на "
"початку рядка, а ``'$'`` лише в кінці рядка та безпосередньо перед символом "
"нового рядка (якщо є) у кінці рядка. Відповідає вбудованому прапору ``(?m)``."

#: ../../library/re.rst:694
msgid ""
"Make the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline. "
"Corresponds to the inline flag ``(?s)``."
msgstr ""
"Зробіть так, щоб спеціальний символ ``'.'`` відповідав будь-якому символу "
"взагалі, включаючи новий рядок; без цього прапорця ``'.'`` відповідатиме "
"будь-чому *крім* нового рядка. Відповідає вбудованому прапору ``(?s)``."

#: ../../library/re.rst:704
msgid ""
"This flag allows you to write regular expressions that look nicer and are "
"more readable by allowing you to visually separate logical sections of the "
"pattern and add comments. Whitespace within the pattern is ignored, except "
"when in a character class, or when preceded by an unescaped backslash, or "
"within tokens like ``*?``, ``(?:`` or ``(?P<...>``. For example, ``(? :`` "
"and ``* ?`` are not allowed. When a line contains a ``#`` that is not in a "
"character class and is not preceded by an unescaped backslash, all "
"characters from the leftmost such ``#`` through the end of the line are "
"ignored."
msgstr ""

#: ../../library/re.rst:714
msgid ""
"This means that the two following regular expression objects that match a "
"decimal number are functionally equal::"
msgstr ""
"Це означає, що два наступних об’єкти регулярного виразу, які відповідають "
"десятковому числу, функціонально однакові:"

#: ../../library/re.rst:722
msgid "Corresponds to the inline flag ``(?x)``."
msgstr "Відповідає вбудованому прапору ``(?x)``."

#: ../../library/re.rst:726
msgid "Functions"
msgstr "Функції"

#: ../../library/re.rst:730
msgid ""
"Compile a regular expression pattern into a :ref:`regular expression object "
"<re-objects>`, which can be used for matching using its :func:`~Pattern."
"match`, :func:`~Pattern.search` and other methods, described below."
msgstr ""
"Скомпілюйте шаблон регулярного виразу в :ref:`об’єкт регулярного виразу <re-"
"objects>`, який можна використовувати для зіставлення за допомогою його :"
"func:`~Pattern.match`, :func:`~Pattern.search` та інших методів, описаних "
"нижче ."

#: ../../library/re.rst:735
msgid ""
"The expression's behaviour can be modified by specifying a *flags* value. "
"Values can be any of the following variables, combined using bitwise OR (the "
"``|`` operator)."
msgstr ""
"Поведінку виразу можна змінити, вказавши значення *flags*. Значеннями можуть "
"бути будь-які з наведених нижче змінних, об’єднаних за допомогою побітового "
"АБО (оператор ``|``)."

#: ../../library/re.rst:739
msgid "The sequence ::"
msgstr "Послідовність ::"

#: ../../library/re.rst:744
msgid "is equivalent to ::"
msgstr "еквівалентно ::"

#: ../../library/re.rst:748
msgid ""
"but using :func:`re.compile` and saving the resulting regular expression "
"object for reuse is more efficient when the expression will be used several "
"times in a single program."
msgstr ""
"але використання :func:`re.compile` і збереження отриманого об’єкта "
"регулярного виразу для повторного використання ефективніше, якщо вираз "
"використовуватиметься кілька разів в одній програмі."

#: ../../library/re.rst:754
msgid ""
"The compiled versions of the most recent patterns passed to :func:`re."
"compile` and the module-level matching functions are cached, so programs "
"that use only a few regular expressions at a time needn't worry about "
"compiling regular expressions."
msgstr ""
"Зібрані версії найновіших шаблонів, переданих до :func:`re.compile`, і "
"функції відповідності на рівні модуля кешуються, тому програмам, які "
"використовують лише кілька регулярних виразів одночасно, не потрібно "
"турбуватися про компіляцію регулярних виразів."

#: ../../library/re.rst:762
msgid ""
"Scan through *string* looking for the first location where the regular "
"expression *pattern* produces a match, and return a corresponding :ref:"
"`match object <match-objects>`.  Return ``None`` if no position in the "
"string matches the pattern; note that this is different from finding a zero-"
"length match at some point in the string."
msgstr ""
"Перегляньте *рядок*, шукаючи перше розташування, де регулярний вираз "
"*шаблон* створює збіг, і поверніть відповідний :ref:`об’єкт відповідності "
"<match-objects>`. Повертає ``None``, якщо жодна позиція в рядку не "
"відповідає шаблону; зауважте, що це відрізняється від пошуку збігу нульової "
"довжини в деякій точці рядка."

#: ../../library/re.rst:771
msgid ""
"If zero or more characters at the beginning of *string* match the regular "
"expression *pattern*, return a corresponding :ref:`match object <match-"
"objects>`.  Return ``None`` if the string does not match the pattern; note "
"that this is different from a zero-length match."
msgstr ""
"Якщо нуль або більше символів на початку *string* відповідає регулярному "
"виразу *pattern*, поверніть відповідний :ref:`match object <match-objects>`. "
"Повертає ``None``, якщо рядок не відповідає шаблону; зауважте, що це "
"відрізняється від збігу нульової довжини."

#: ../../library/re.rst:776
msgid ""
"Note that even in :const:`MULTILINE` mode, :func:`re.match` will only match "
"at the beginning of the string and not at the beginning of each line."
msgstr ""
"Зауважте, що навіть у режимі :const:`MULTILINE` :func:`re.match` "
"збігатиметься лише на початку рядка, а не на початку кожного рядка."

#: ../../library/re.rst:779
msgid ""
"If you want to locate a match anywhere in *string*, use :func:`search` "
"instead (see also :ref:`search-vs-match`)."
msgstr ""
"Якщо ви хочете знайти збіг будь-де в *string*, використовуйте натомість :"
"func:`search` (див. також :ref:`search-vs-match`)."

#: ../../library/re.rst:785
msgid ""
"If the whole *string* matches the regular expression *pattern*, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""
"Якщо весь *рядок* відповідає регулярному виразу *шаблону*, поверніть "
"відповідний :ref:`об’єкт відповідності <match-objects>`. Повертає ``None``, "
"якщо рядок не відповідає шаблону; зауважте, що це відрізняється від збігу "
"нульової довжини."

#: ../../library/re.rst:795
msgid ""
"Split *string* by the occurrences of *pattern*.  If capturing parentheses "
"are used in *pattern*, then the text of all groups in the pattern are also "
"returned as part of the resulting list. If *maxsplit* is nonzero, at most "
"*maxsplit* splits occur, and the remainder of the string is returned as the "
"final element of the list. ::"
msgstr ""
"Розділіть *рядок* на входження *шаблону*. Якщо в *шаблоні* використовуються "
"дужки для захоплення, тоді текст усіх груп у шаблоні також повертається як "
"частина результуючого списку. Якщо *maxsplit* відмінний від нуля, "
"відбувається не більше ніж *maxsplit*, а залишок рядка повертається як "
"останній елемент списку. ::"

#: ../../library/re.rst:810
msgid ""
"If there are capturing groups in the separator and it matches at the start "
"of the string, the result will start with an empty string.  The same holds "
"for the end of the string::"
msgstr ""
"Якщо в розділювачі є групи захоплення, і він збігається на початку рядка, "
"результат розпочнеться з порожнього рядка. Те саме стосується кінця рядка::"

#: ../../library/re.rst:817
msgid ""
"That way, separator components are always found at the same relative indices "
"within the result list."
msgstr ""
"Таким чином, компоненти роздільників завжди знаходяться за однаковими "
"відносними індексами в списку результатів."

#: ../../library/re.rst:820
msgid ""
"Empty matches for the pattern split the string only when not adjacent to a "
"previous empty match."
msgstr ""
"Порожні збіги для шаблону розділяють рядок лише тоді, коли вони не суміжні з "
"попереднім порожнім збігом."

#: ../../library/re.rst:830 ../../library/re.rst:920 ../../library/re.rst:944
msgid "Added the optional flags argument."
msgstr "Додано необов’язковий аргумент flags."

#: ../../library/re.rst:833
msgid ""
"Added support of splitting on a pattern that could match an empty string."
msgstr ""
"Додано підтримку розбиття на шаблон, який може відповідати порожньому рядку."

#: ../../library/re.rst:839
msgid ""
"Return all non-overlapping matches of *pattern* in *string*, as a list of "
"strings or tuples.  The *string* is scanned left-to-right, and matches are "
"returned in the order found.  Empty matches are included in the result."
msgstr ""
"Повертає всі неперекриваючі збіги *шаблону* в *рядку* у вигляді списку "
"рядків або кортежів. *Рядок* сканується зліва направо, і збіги повертаються "
"в порядку знайдення. Порожні збіги включаються в результат."

#: ../../library/re.rst:843
msgid ""
"The result depends on the number of capturing groups in the pattern. If "
"there are no groups, return a list of strings matching the whole pattern.  "
"If there is exactly one group, return a list of strings matching that "
"group.  If multiple groups are present, return a list of tuples of strings "
"matching the groups.  Non-capturing groups do not affect the form of the "
"result."
msgstr ""
"Результат залежить від кількості груп захоплення в шаблоні. Якщо груп немає, "
"поверніть список рядків, які відповідають повному шаблону. Якщо існує рівно "
"одна група, поверніть список рядків, які відповідають цій групі. Якщо "
"присутні кілька груп, поверніть список кортежів рядків, які відповідають "
"групам. Незахоплюючі групи не впливають на форму результату."

#: ../../library/re.rst:855 ../../library/re.rst:866
msgid "Non-empty matches can now start just after a previous empty match."
msgstr ""
"Непорожні збіги тепер можуть починатися одразу після попереднього порожнього "
"збігу."

#: ../../library/re.rst:861
msgid ""
"Return an :term:`iterator` yielding :ref:`match objects <match-objects>` "
"over all non-overlapping matches for the RE *pattern* in *string*.  The "
"*string* is scanned left-to-right, and matches are returned in the order "
"found.  Empty matches are included in the result."
msgstr ""
"Повертає :term:`iterator`, що дає :ref:`match об’єкти <match-objects>` над "
"усіма неперекриваючими збігами для *шаблону* RE в *рядку*. *Рядок* "
"сканується зліва направо, і збіги повертаються в порядку знайдення. Порожні "
"збіги включаються в результат."

#: ../../library/re.rst:872
msgid ""
"Return the string obtained by replacing the leftmost non-overlapping "
"occurrences of *pattern* in *string* by the replacement *repl*.  If the "
"pattern isn't found, *string* is returned unchanged.  *repl* can be a string "
"or a function; if it is a string, any backslash escapes in it are "
"processed.  That is, ``\\n`` is converted to a single newline character, "
"``\\r`` is converted to a carriage return, and so forth.  Unknown escapes of "
"ASCII letters are reserved for future use and treated as errors.  Other "
"unknown escapes such as ``\\&`` are left alone. Backreferences, such as "
"``\\6``, are replaced with the substring matched by group 6 in the pattern. "
"For example::"
msgstr ""
"Повертає рядок, отриманий шляхом заміни крайніх лівих неперекриваючих "
"входжень *pattern* у *string* на заміну *repl*. Якщо шаблон не знайдено, "
"*рядок* повертається без змін. *repl* може бути рядком або функцією; якщо це "
"рядок, будь-які вихідні символи зворотної косої риски в ньому обробляються. "
"Тобто ``\\n`` перетворюється на один символ нового рядка, ``\\r`` "
"перетворюється на повернення каретки і так далі. Невідомі вихідні коди літер "
"ASCII зарезервовано для майбутнього використання та розглядаються як "
"помилки. Інші невідомі вихідні сигнали, такі як ``\\&`` залишаються в "
"спокої. Зворотні посилання, такі як ``\\6``, замінюються підрядком, який "
"відповідає групі 6 у шаблоні. Наприклад::"

#: ../../library/re.rst:888
msgid ""
"If *repl* is a function, it is called for every non-overlapping occurrence "
"of *pattern*.  The function takes a single :ref:`match object <match-"
"objects>` argument, and returns the replacement string.  For example::"
msgstr ""
"Якщо *repl* є функцією, вона викликається для кожного неперекриваючого "
"входження *шаблону*. Функція приймає один аргумент :ref:`match object <match-"
"objects>` і повертає рядок заміни. Наприклад::"

#: ../../library/re.rst:900
msgid "The pattern may be a string or a :ref:`pattern object <re-objects>`."
msgstr "Шаблон може бути рядком або :ref:`об’єктом шаблону <re-objects>`."

#: ../../library/re.rst:902
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  If omitted or zero, "
"all occurrences will be replaced. Empty matches for the pattern are replaced "
"only when not adjacent to a previous empty match, so ``sub('x*', '-', "
"'abxd')`` returns ``'-a-b--d-'``."
msgstr ""
"Необов’язковий аргумент *count* — це максимальна кількість шаблонів, які "
"потрібно замінити; *count* має бути невід’ємним цілим числом. Якщо опущено "
"або дорівнює нулю, усі входження буде замінено. Порожні збіги для шаблону "
"замінюються лише тоді, коли вони не суміжні з попереднім порожнім збігом, "
"тому ``sub('x*', '-', 'abxd')`` повертає ``'-a-b--d-'`` ."

#: ../../library/re.rst:910
msgid ""
"In string-type *repl* arguments, in addition to the character escapes and "
"backreferences described above, ``\\g<name>`` will use the substring matched "
"by the group named ``name``, as defined by the ``(?P<name>...)`` syntax. "
"``\\g<number>`` uses the corresponding group number; ``\\g<2>`` is therefore "
"equivalent to ``\\2``, but isn't ambiguous in a replacement such as "
"``\\g<2>0``.  ``\\20`` would be interpreted as a reference to group 20, not "
"a reference to group 2 followed by the literal character ``'0'``.  The "
"backreference ``\\g<0>`` substitutes in the entire substring matched by the "
"RE."
msgstr ""
"В аргументах рядкового типу *repl*, на додаток до екранованих символів і "
"зворотних посилань, описаних вище, ``\\g <name>`` використовуватиме "
"підрядок, який відповідає групі з назвою ``name``, як визначено ``(? P "
"<name> ...)`` синтаксис. ``\\g <number>`` використовує відповідний номер "
"групи; ``\\g <2>``, отже, еквівалентний ``\\2``, але не є неоднозначним у "
"заміні, такій як ``\\g <2> 0``. ``\\20`` інтерпретуватиметься як посилання "
"на групу 20, а не як посилання на групу 2, за якою йде літеральний символ "
"``'0'``. Зворотне посилання ``\\g <0>`` замінює весь підрядок, який "
"відповідає RE."

#: ../../library/re.rst:923 ../../library/re.rst:947 ../../library/re.rst:1181
msgid "Unmatched groups are replaced with an empty string."
msgstr "Невідповідні групи замінюються порожнім рядком."

#: ../../library/re.rst:926
msgid ""
"Unknown escapes in *pattern* consisting of ``'\\'`` and an ASCII letter now "
"are errors."
msgstr ""
"Невідомі вихідні коди в *шаблоні*, що складаються з ``'\\'`` і літери ASCII, "
"тепер є помилками."

#: ../../library/re.rst:930
msgid ""
"Unknown escapes in *repl* consisting of ``'\\'`` and an ASCII letter now are "
"errors."
msgstr ""
"Невідомі вихідні символи в *repl*, які складаються з ``'\\'`` і літери "
"ASCII, тепер є помилками."

#: ../../library/re.rst:934
msgid ""
"Empty matches for the pattern are replaced when adjacent to a previous non-"
"empty match."
msgstr ""
"Порожні збіги для шаблону замінюються, якщо вони суміжні з попереднім "
"непорожнім збігом."

#: ../../library/re.rst:941
msgid ""
"Perform the same operation as :func:`sub`, but return a tuple ``(new_string, "
"number_of_subs_made)``."
msgstr ""
"Виконайте ту саму операцію, що й :func:`sub`, але поверніть кортеж "
"``(new_string, number_of_subs_made)``."

#: ../../library/re.rst:953
msgid ""
"Escape special characters in *pattern*. This is useful if you want to match "
"an arbitrary literal string that may have regular expression metacharacters "
"in it.  For example::"
msgstr ""
"Екранування спеціальних символів у *шаблоні*. Це корисно, якщо ви хочете "
"зіставити довільний рядок літералу, який може містити метасимволи "
"регулярного виразу. Наприклад::"

#: ../../library/re.rst:968
msgid ""
"This function must not be used for the replacement string in :func:`sub` "
"and :func:`subn`, only backslashes should be escaped.  For example::"
msgstr ""
"Цю функцію не можна використовувати для рядка заміни в :func:`sub` і :func:"
"`subn`, слід екранувати лише зворотні косі риски. Наприклад::"

#: ../../library/re.rst:976
msgid "The ``'_'`` character is no longer escaped."
msgstr "Символ \"_\" більше не екранується."

#: ../../library/re.rst:979
msgid ""
"Only characters that can have special meaning in a regular expression are "
"escaped. As a result, ``'!'``, ``'\"'``, ``'%'``, ``\"'\"``, ``','``, "
"``'/'``, ``':'``, ``';'``, ``'<'``, ``'='``, ``'>'``, ``'@'``, and ``\"`\"`` "
"are no longer escaped."
msgstr ""
"Екрануються лише символи, які можуть мати спеціальне значення в регулярному "
"виразі. У результаті ``'!'``, ``'\"'``, ``'%'``, ``\"'\"``, ``','``, ``'/'` "
"`, ``':'``, ``';'``, ``' <'``, ``'='``, ``'> '``, ``'@'`` і ``\"`\"`` більше "
"не екрануються."

#: ../../library/re.rst:988
msgid "Clear the regular expression cache."
msgstr "Очистити кеш регулярних виразів."

#: ../../library/re.rst:992
msgid "Exceptions"
msgstr "Винятки"

#: ../../library/re.rst:996
msgid ""
"Exception raised when a string passed to one of the functions here is not a "
"valid regular expression (for example, it might contain unmatched "
"parentheses) or when some other error occurs during compilation or "
"matching.  It is never an error if a string contains no match for a "
"pattern.  The error instance has the following additional attributes:"
msgstr ""
"Виняток виникає, коли рядок, переданий одній із функцій тут, не є дійсним "
"регулярним виразом (наприклад, він може містити невідповідні дужки) або коли "
"під час компіляції чи зіставлення виникає інша помилка. Ніколи не буде "
"помилкою, якщо рядок не містить збігів для шаблону. Екземпляр помилки має "
"такі додаткові атрибути:"

#: ../../library/re.rst:1004
msgid "The unformatted error message."
msgstr "Неформатне повідомлення про помилку."

#: ../../library/re.rst:1008
msgid "The regular expression pattern."
msgstr "Шаблон регулярного виразу."

#: ../../library/re.rst:1012
msgid "The index in *pattern* where compilation failed (may be ``None``)."
msgstr "Індекс у *шаблоні*, де не вдалося компілювати (може бути ``None``)."

#: ../../library/re.rst:1016
msgid "The line corresponding to *pos* (may be ``None``)."
msgstr "Рядок, що відповідає *pos* (може бути ``None``)."

#: ../../library/re.rst:1020
msgid "The column corresponding to *pos* (may be ``None``)."
msgstr "Стовпець, що відповідає *pos* (може бути ``None``)."

#: ../../library/re.rst:1022
msgid "Added additional attributes."
msgstr "Додані додаткові атрибути."

#: ../../library/re.rst:1028
msgid "Regular Expression Objects"
msgstr "Об’єкти регулярного виразу"

#: ../../library/re.rst:1030
msgid ""
"Compiled regular expression objects support the following methods and "
"attributes:"
msgstr ""
"Зкомпільовані об’єкти регулярного виразу підтримують наступні методи та "
"атрибути:"

#: ../../library/re.rst:1035
msgid ""
"Scan through *string* looking for the first location where this regular "
"expression produces a match, and return a corresponding :ref:`match object "
"<match-objects>`.  Return ``None`` if no position in the string matches the "
"pattern; note that this is different from finding a zero-length match at "
"some point in the string."
msgstr ""
"Проскануйте *рядок*, шукаючи перше місце, де цей регулярний вираз створює "
"збіг, і поверніть відповідний :ref:`об’єкт відповідності <match-objects>`. "
"Повертає ``None``, якщо жодна позиція в рядку не відповідає шаблону; "
"зауважте, що це відрізняється від пошуку збігу нульової довжини в деякій "
"точці рядка."

#: ../../library/re.rst:1041
msgid ""
"The optional second parameter *pos* gives an index in the string where the "
"search is to start; it defaults to ``0``.  This is not completely equivalent "
"to slicing the string; the ``'^'`` pattern character matches at the real "
"beginning of the string and at positions just after a newline, but not "
"necessarily at the index where the search is to start."
msgstr ""
"Необов’язковий другий параметр *pos* дає індекс у рядку, з якого має "
"початися пошук; за замовчуванням ``0``. Це не зовсім еквівалентно нарізанню "
"струни; символ шаблону ``'^'`` збігається на справжньому початку рядка та в "
"позиціях одразу після нового рядка, але не обов’язково в індексі, з якого "
"має початися пошук."

#: ../../library/re.rst:1047
msgid ""
"The optional parameter *endpos* limits how far the string will be searched; "
"it will be as if the string is *endpos* characters long, so only the "
"characters from *pos* to ``endpos - 1`` will be searched for a match.  If "
"*endpos* is less than *pos*, no match will be found; otherwise, if *rx* is a "
"compiled regular expression object, ``rx.search(string, 0, 50)`` is "
"equivalent to ``rx.search(string[:50], 0)``. ::"
msgstr ""
"Необов'язковий параметр *endpos* обмежує, наскільки далеко буде "
"здійснюватися пошук рядка; це буде так, ніби рядок складається з *endpos* "
"символів, тому шукатимуть збіги лише за символами від *pos* до ``endpos - "
"1``. Якщо *endpos* менше ніж *pos*, збіг не знайдено; інакше, якщо *rx* є "
"скомпільованим об’єктом регулярного виразу, ``rx.search(string, 0, 50)`` "
"еквівалентно ``rx.search(string[:50], 0)``. ::"

#: ../../library/re.rst:1062
msgid ""
"If zero or more characters at the *beginning* of *string* match this regular "
"expression, return a corresponding :ref:`match object <match-objects>`. "
"Return ``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr ""
"Якщо цьому регулярному виразу відповідає нуль або більше символів на "
"*початку* *рядка*, повертається відповідний :ref:`об’єкт відповідності "
"<match-objects>`. Повертає ``None``, якщо рядок не відповідає шаблону; "
"зауважте, що це відрізняється від збігу нульової довжини."

#: ../../library/re.rst:1067 ../../library/re.rst:1085
msgid ""
"The optional *pos* and *endpos* parameters have the same meaning as for the :"
"meth:`~Pattern.search` method. ::"
msgstr ""
"Необов’язкові параметри *pos* і *endpos* мають те саме значення, що й для "
"методу :meth:`~Pattern.search`. ::"

#: ../../library/re.rst:1075
msgid ""
"If you want to locate a match anywhere in *string*, use :meth:`~Pattern."
"search` instead (see also :ref:`search-vs-match`)."
msgstr ""
"Якщо ви хочете знайти збіг будь-де в *string*, використовуйте натомість :"
"meth:`~Pattern.search` (див. також :ref:`search-vs-match`)."

#: ../../library/re.rst:1081
msgid ""
"If the whole *string* matches this regular expression, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if the "
"string does not match the pattern; note that this is different from a zero-"
"length match."
msgstr ""
"Якщо весь *рядок* відповідає цьому регулярному виразу, поверніть "
"відповідний :ref:`match object <match-objects>`. Повертає ``None``, якщо "
"рядок не відповідає шаблону; зауважте, що це відрізняється від збігу "
"нульової довжини."

#: ../../library/re.rst:1099
msgid "Identical to the :func:`split` function, using the compiled pattern."
msgstr "Ідентична функції :func:`split`, використовуючи скомпільований шаблон."

#: ../../library/re.rst:1104
msgid ""
"Similar to the :func:`findall` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
"Подібно до функції :func:`findall`, використовує скомпільований шаблон, але "
"також приймає додаткові параметри *pos* і *endpos*, які обмежують область "
"пошуку, як для :meth:`search`."

#: ../../library/re.rst:1111
msgid ""
"Similar to the :func:`finditer` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`search`."
msgstr ""
"Подібно до функції :func:`finditer`, яка використовує скомпільований шаблон, "
"але також приймає додаткові параметри *pos* і *endpos*, які обмежують "
"область пошуку, як для :meth:`search`."

#: ../../library/re.rst:1118
msgid "Identical to the :func:`sub` function, using the compiled pattern."
msgstr "Ідентична функції :func:`sub`, використовуючи скомпільований шаблон."

#: ../../library/re.rst:1123
msgid "Identical to the :func:`subn` function, using the compiled pattern."
msgstr "Ідентична функції :func:`subn`, використовуючи скомпільований шаблон."

#: ../../library/re.rst:1128
msgid ""
"The regex matching flags.  This is a combination of the flags given to :func:"
"`.compile`, any ``(?...)`` inline flags in the pattern, and implicit flags "
"such as :data:`UNICODE` if the pattern is a Unicode string."
msgstr ""
"Прапори відповідності регулярних виразів. Це комбінація прапорів, наданих :"
"func:`.compile`, будь-яких вбудованих прапорів ``(?...)`` у шаблоні та "
"неявних прапорів, таких як :data:`UNICODE`, якщо шаблон є Рядок Unicode."

#: ../../library/re.rst:1135
msgid "The number of capturing groups in the pattern."
msgstr "Кількість груп захоплення в шаблоні."

#: ../../library/re.rst:1140
msgid ""
"A dictionary mapping any symbolic group names defined by ``(?P<id>)`` to "
"group numbers.  The dictionary is empty if no symbolic groups were used in "
"the pattern."
msgstr ""
"Словник, що відображає будь-які символічні назви груп, визначені ``(?P "
"<id> )``, на номери груп. Словник порожній, якщо в шаблоні не "
"використовувалися символічні групи."

#: ../../library/re.rst:1147
msgid "The pattern string from which the pattern object was compiled."
msgstr "Рядок шаблону, з якого було скомпільовано об’єкт шаблону."

#: ../../library/re.rst:1150
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Compiled "
"regular expression objects are considered atomic."
msgstr ""
"Додано підтримку :func:`copy.copy` і :func:`copy.deepcopy`. Зкомпільовані "
"об’єкти регулярного виразу вважаються атомарними."

#: ../../library/re.rst:1158
msgid "Match Objects"
msgstr "Зіставте об’єкти"

#: ../../library/re.rst:1160
msgid ""
"Match objects always have a boolean value of ``True``. Since :meth:`~Pattern."
"match` and :meth:`~Pattern.search` return ``None`` when there is no match, "
"you can test whether there was a match with a simple ``if`` statement::"
msgstr ""
"Об’єкти відповідності завжди мають логічне значення ``True``. Оскільки :meth:"
"`~Pattern.match` і :meth:`~Pattern.search` повертають ``None`` за "
"відсутності збігу, ви можете перевірити, чи був збіг за допомогою простого "
"оператора ``if``: :"

#: ../../library/re.rst:1169
msgid "Match objects support the following methods and attributes:"
msgstr "Об’єкти відповідності підтримують такі методи й атрибути:"

#: ../../library/re.rst:1174
msgid ""
"Return the string obtained by doing backslash substitution on the template "
"string *template*, as done by the :meth:`~Pattern.sub` method. Escapes such "
"as ``\\n`` are converted to the appropriate characters, and numeric "
"backreferences (``\\1``, ``\\2``) and named backreferences (``\\g<1>``, "
"``\\g<name>``) are replaced by the contents of the corresponding group."
msgstr ""
"Повертає рядок, отриманий заміною зворотної похилої риски в рядку шаблону "
"*template*, як це робиться методом :meth:`~Pattern.sub`. Екрани, такі як "
"``\\n``, перетворюються на відповідні символи, а також числові зворотні "
"посилання (``\\1``, ``\\2``) і іменовані зворотні посилання (``\\g <1>``, "
"``\\g <name>``) замінюються вмістом відповідної групи."

#: ../../library/re.rst:1186
msgid ""
"Returns one or more subgroups of the match.  If there is a single argument, "
"the result is a single string; if there are multiple arguments, the result "
"is a tuple with one item per argument. Without arguments, *group1* defaults "
"to zero (the whole match is returned). If a *groupN* argument is zero, the "
"corresponding return value is the entire matching string; if it is in the "
"inclusive range [1..99], it is the string matching the corresponding "
"parenthesized group.  If a group number is negative or larger than the "
"number of groups defined in the pattern, an :exc:`IndexError` exception is "
"raised. If a group is contained in a part of the pattern that did not match, "
"the corresponding result is ``None``. If a group is contained in a part of "
"the pattern that matched multiple times, the last match is returned. ::"
msgstr ""
"Повертає одну або кілька підгруп збігу. Якщо є один аргумент, результатом "
"буде один рядок; якщо є кілька аргументів, результатом є кортеж з одним "
"елементом на аргумент. Без аргументів *group1* за замовчуванням дорівнює "
"нулю (повертається весь збіг). Якщо аргумент *groupN* дорівнює нулю, "
"відповідним значенням, що повертається, є весь відповідний рядок; якщо він "
"знаходиться у включному діапазоні [1..99], це рядок, що відповідає "
"відповідній групі в дужках. Якщо номер групи є від’ємним або перевищує "
"кількість груп, визначених у шаблоні, виникає виняток :exc:`IndexError`. "
"Якщо група міститься в частині шаблону, яка не відповідає, відповідним "
"результатом є ``None``. Якщо група міститься в частині шаблону, яка "
"збігалася кілька разів, повертається останній збіг. ::"

#: ../../library/re.rst:1208
msgid ""
"If the regular expression uses the ``(?P<name>...)`` syntax, the *groupN* "
"arguments may also be strings identifying groups by their group name.  If a "
"string argument is not used as a group name in the pattern, an :exc:"
"`IndexError` exception is raised."
msgstr ""
"Якщо регулярний вираз використовує синтаксис ``(?P <name> ...)``, аргументи "
"*groupN* також можуть бути рядками, що ідентифікують групи за назвою групи. "
"Якщо рядковий аргумент не використовується як ім’я групи в шаблоні, виникає "
"виняток :exc:`IndexError`."

#: ../../library/re.rst:1213
msgid "A moderately complicated example::"
msgstr "Помірно складний приклад:"

#: ../../library/re.rst:1221
msgid "Named groups can also be referred to by their index::"
msgstr "Іменовані групи також можна посилатися за їх індексом::"

#: ../../library/re.rst:1228
msgid "If a group matches multiple times, only the last match is accessible::"
msgstr ""
"Якщо група збігається кілька разів, доступним буде лише останній збіг::"

#: ../../library/re.rst:1237
msgid ""
"This is identical to ``m.group(g)``.  This allows easier access to an "
"individual group from a match::"
msgstr ""
"Це ідентично ``m.group(g)``. Це дозволяє легше отримати доступ до окремої "
"групи з матчу::"

#: ../../library/re.rst:1253
msgid ""
"Return a tuple containing all the subgroups of the match, from 1 up to "
"however many groups are in the pattern.  The *default* argument is used for "
"groups that did not participate in the match; it defaults to ``None``."
msgstr ""
"Повертає кортеж, що містить усі підгрупи відповідності, від 1 до будь-якої "
"кількості груп у шаблоні. Аргумент *default* використовується для груп, які "
"не брали участі в матчі; за замовчуванням ``None``."

#: ../../library/re.rst:1257 ../../library/re.rst:1482
msgid "For example::"
msgstr "Наприклад::"

#: ../../library/re.rst:1263
msgid ""
"If we make the decimal place and everything after it optional, not all "
"groups might participate in the match.  These groups will default to "
"``None`` unless the *default* argument is given::"
msgstr ""
"Якщо ми зробимо знак після коми необов’язковим, не всі групи можуть брати "
"участь у матчі. Для цих груп за замовчуванням буде ``None``, якщо не вказано "
"аргумент *default*::"

#: ../../library/re.rst:1276
msgid ""
"Return a dictionary containing all the *named* subgroups of the match, keyed "
"by the subgroup name.  The *default* argument is used for groups that did "
"not participate in the match; it defaults to ``None``.  For example::"
msgstr ""
"Повертає словник, що містить усі *іменовані* підгрупи збігу, ключ яких "
"містить назву підгрупи. Аргумент *default* використовується для груп, які не "
"брали участі в матчі; за замовчуванням ``None``. Наприклад::"

#: ../../library/re.rst:1288
msgid ""
"Return the indices of the start and end of the substring matched by *group*; "
"*group* defaults to zero (meaning the whole matched substring). Return "
"``-1`` if *group* exists but did not contribute to the match.  For a match "
"object *m*, and a group *g* that did contribute to the match, the substring "
"matched by group *g* (equivalent to ``m.group(g)``) is ::"
msgstr ""
"Повертає індекси початку та кінця підрядка, які відповідають *групі*; "
"*group* за замовчуванням дорівнює нулю (це означає весь відповідний "
"підрядок). Повертає ``-1``, якщо *група* існує, але не брала участі в матчі. "
"Для об’єкта збігу *m* і групи *g*, яка внесла свій внесок у збіг, підрядок, "
"який відповідає групі *g* (еквівалент ``m.group(g)``) є ::"

#: ../../library/re.rst:1296
msgid ""
"Note that ``m.start(group)`` will equal ``m.end(group)`` if *group* matched "
"a null string.  For example, after ``m = re.search('b(c?)', 'cba')``, ``m."
"start(0)`` is 1, ``m.end(0)`` is 2, ``m.start(1)`` and ``m.end(1)`` are both "
"2, and ``m.start(2)`` raises an :exc:`IndexError` exception."
msgstr ""
"Зауважте, що ``m.start(group)`` дорівнюватиме ``m.end(group)``, якщо *group* "
"відповідає нульовому рядку. Наприклад, після ``m = re.search('b(c?)', "
"'cba')``, ``m.start(0)`` дорівнює 1, ``m.end(0)`` дорівнює 2, ``m.start(1)`` "
"і ``m.end(1)`` мають значення 2, а ``m.start(2)`` викликає виняток :exc:"
"`IndexError`."

#: ../../library/re.rst:1301
msgid "An example that will remove *remove_this* from email addresses::"
msgstr "Приклад видалення *remove_this* з електронних адрес::"

#: ../../library/re.rst:1311
msgid ""
"For a match *m*, return the 2-tuple ``(m.start(group), m.end(group))``. Note "
"that if *group* did not contribute to the match, this is ``(-1, -1)``. "
"*group* defaults to zero, the entire match."
msgstr ""
"Для збігу *m* поверніть 2-кортеж ``(m.start(group), m.end(group))``. "
"Зауважте, що якщо *група* не брала участі в матчі, це ``(-1, -1)``. *група* "
"за замовчуванням дорівнює нулю, весь збіг."

#: ../../library/re.rst:1318
msgid ""
"The value of *pos* which was passed to the :meth:`~Pattern.search` or :meth:"
"`~Pattern.match` method of a :ref:`regex object <re-objects>`.  This is the "
"index into the string at which the RE engine started looking for a match."
msgstr ""
"Значення *pos*, яке було передано в метод :meth:`~Pattern.search` або :meth:"
"`~Pattern.match` об’єкта :ref:`regex <re-objects>`. Це індекс у рядку, за "
"яким механізм RE почав шукати збіг."

#: ../../library/re.rst:1325
msgid ""
"The value of *endpos* which was passed to the :meth:`~Pattern.search` or :"
"meth:`~Pattern.match` method of a :ref:`regex object <re-objects>`.  This is "
"the index into the string beyond which the RE engine will not go."
msgstr ""
"Значення *endpos*, яке було передано в метод :meth:`~Pattern.search` або :"
"meth:`~Pattern.match` об’єкта :ref:`regex <re-objects>`. Це індекс у рядку, "
"за який механізм RE не виходить."

#: ../../library/re.rst:1332
msgid ""
"The integer index of the last matched capturing group, or ``None`` if no "
"group was matched at all. For example, the expressions ``(a)b``, ``((a)"
"(b))``, and ``((ab))`` will have ``lastindex == 1`` if applied to the string "
"``'ab'``, while the expression ``(a)(b)`` will have ``lastindex == 2``, if "
"applied to the same string."
msgstr ""
"Цілочисельний індекс останньої відповідної групи захоплення або ``None``, "
"якщо жодна група не була знайдена взагалі. Наприклад, вирази ``(a)b``, ``((a)"
"(b))`` і ``((ab))`` матимуть ``lastindex == 1``, якщо застосувати до рядок "
"``'ab''``, тоді як вираз ``(a)(b)`` матиме ``lastindex == 2``, якщо "
"застосувати до того самого рядка."

#: ../../library/re.rst:1341
msgid ""
"The name of the last matched capturing group, or ``None`` if the group "
"didn't have a name, or if no group was matched at all."
msgstr ""
"Ім’я останньої відповідної групи захоплення або ``None``, якщо група не мала "
"назви, або якщо жодна група не була знайдена взагалі."

#: ../../library/re.rst:1347
msgid ""
"The :ref:`regular expression object <re-objects>` whose :meth:`~Pattern."
"match` or :meth:`~Pattern.search` method produced this match instance."
msgstr ""
"Об’єкт :ref:`регулярного виразу <re-objects>`, чий метод :meth:`~Pattern."
"match` або :meth:`~Pattern.search` створив цей екземпляр відповідності."

#: ../../library/re.rst:1353
msgid "The string passed to :meth:`~Pattern.match` or :meth:`~Pattern.search`."
msgstr ""
"Рядок передається до :meth:`~Pattern.match` або :meth:`~Pattern.search`."

#: ../../library/re.rst:1356
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Match objects "
"are considered atomic."
msgstr ""
"Додано підтримку :func:`copy.copy` і :func:`copy.deepcopy`. Об'єкти "
"відповідності вважаються атомарними."

#: ../../library/re.rst:1364
msgid "Regular Expression Examples"
msgstr "Приклади регулярних виразів"

#: ../../library/re.rst:1368
msgid "Checking for a Pair"
msgstr "Перевірка на пару"

#: ../../library/re.rst:1370
msgid ""
"In this example, we'll use the following helper function to display match "
"objects a little more gracefully::"
msgstr ""
"У цьому прикладі ми використаємо наступну допоміжну функцію, щоб відобразити "
"об’єкти відповідності трохи витонченіше:"

#: ../../library/re.rst:1378
msgid ""
"Suppose you are writing a poker program where a player's hand is represented "
"as a 5-character string with each character representing a card, \"a\" for "
"ace, \"k\" for king, \"q\" for queen, \"j\" for jack, \"t\" for 10, and "
"\"2\" through \"9\" representing the card with that value."
msgstr ""
"Припустімо, що ви пишете покерну програму, де рука гравця представлена у "
"вигляді рядка з 5 символів, де кожен символ представляє карту, \"a\" — туз, "
"\"k\" — король, \"q\" — дама, \"j\" — валет, \"t\" означає 10 і \"2\" - "
"\"9\", що представляють картку з таким значенням."

#: ../../library/re.rst:1383
msgid "To see if a given string is a valid hand, one could do the following::"
msgstr ""
"Щоб перевірити, чи даний рядок є правильною рукою, можна зробити наступне:"

#: ../../library/re.rst:1393
msgid ""
"That last hand, ``\"727ak\"``, contained a pair, or two of the same valued "
"cards. To match this with a regular expression, one could use backreferences "
"as such::"
msgstr ""
"Ця остання роздача, ``\"727ak\"``, містила пару або дві карти однакового "
"значення. Щоб зіставити це з регулярним виразом, можна використовувати "
"зворотні посилання як такі:"

#: ../../library/re.rst:1403
msgid ""
"To find out what card the pair consists of, one could use the :meth:`~Match."
"group` method of the match object in the following manner::"
msgstr ""
"Щоб дізнатися, з якої карти складається пара, можна використати метод :meth:"
"`~Match.group` об’єкта відповідності таким чином:"

#: ../../library/re.rst:1422
msgid "Simulating scanf()"
msgstr "Імітація scanf()"

#: ../../library/re.rst:1426
msgid ""
"Python does not currently have an equivalent to :c:func:`scanf`.  Regular "
"expressions are generally more powerful, though also more verbose, than :c:"
"func:`scanf` format strings.  The table below offers some more-or-less "
"equivalent mappings between :c:func:`scanf` format tokens and regular "
"expressions."
msgstr ""
"Python наразі не має еквівалента :c:func:`scanf`. Регулярні вирази, як "
"правило, потужніші, хоча й більш докладні, ніж рядки формату :c:func:"
"`scanf`. Таблиця нижче пропонує деякі більш-менш еквівалентні відповідності "
"між маркерами формату :c:func:`scanf` і регулярними виразами."

#: ../../library/re.rst:1433
msgid ":c:func:`scanf` Token"
msgstr ":c:func:`scanf` Токен"

#: ../../library/re.rst:1433
msgid "Regular Expression"
msgstr "Регулярний вираз"

#: ../../library/re.rst:1435
msgid "``%c``"
msgstr "``%c``"

#: ../../library/re.rst:1437
msgid "``%5c``"
msgstr "``%5c``"

#: ../../library/re.rst:1437
msgid "``.{5}``"
msgstr "``.{5}``"

#: ../../library/re.rst:1439
msgid "``%d``"
msgstr "``%d``"

#: ../../library/re.rst:1439
msgid "``[-+]?\\d+``"
msgstr "``[-+]?\\d+``"

#: ../../library/re.rst:1441
msgid "``%e``, ``%E``, ``%f``, ``%g``"
msgstr "``%e``, ``%E``, ``%f``, ``%g``"

#: ../../library/re.rst:1441
msgid "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"
msgstr "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"

#: ../../library/re.rst:1443
msgid "``%i``"
msgstr "``%i``"

#: ../../library/re.rst:1443
msgid "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"
msgstr "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"

#: ../../library/re.rst:1445
msgid "``%o``"
msgstr "``%o``"

#: ../../library/re.rst:1445
msgid "``[-+]?[0-7]+``"
msgstr "``[-+]?[0-7]+``"

#: ../../library/re.rst:1447
msgid "``%s``"
msgstr "``%s``"

#: ../../library/re.rst:1447
msgid "``\\S+``"
msgstr "``\\S+``"

#: ../../library/re.rst:1449
msgid "``%u``"
msgstr "``%u``"

#: ../../library/re.rst:1449
msgid "``\\d+``"
msgstr "``\\d+``"

#: ../../library/re.rst:1451
msgid "``%x``, ``%X``"
msgstr "``%x``, ``%X``"

#: ../../library/re.rst:1451
msgid "``[-+]?(0[xX])?[\\dA-Fa-f]+``"
msgstr "``[-+]?(0[xX])?[\\dA-Fa-f]+``"

#: ../../library/re.rst:1454
msgid "To extract the filename and numbers from a string like ::"
msgstr "Щоб витягти назву файлу та номери з рядка на зразок ::"

#: ../../library/re.rst:1458
msgid "you would use a :c:func:`scanf` format like ::"
msgstr "ви б використовували формат :c:func:`scanf`, наприклад ::"

#: ../../library/re.rst:1462
msgid "The equivalent regular expression would be ::"
msgstr "Еквівалентним регулярним виразом буде::"

#: ../../library/re.rst:1470
msgid "search() vs. match()"
msgstr "search() проти match()"

#: ../../library/re.rst:1474
msgid ""
"Python offers different primitive operations based on regular expressions:"
msgstr ""

#: ../../library/re.rst:1476
msgid ":func:`re.match` checks for a match only at the beginning of the string"
msgstr ""

#: ../../library/re.rst:1477
msgid ""
":func:`re.search` checks for a match anywhere in the string (this is what "
"Perl does by default)"
msgstr ""

#: ../../library/re.rst:1479
msgid ":func:`re.fullmatch` checks for entire string to be a match"
msgstr ""

#: ../../library/re.rst:1491
msgid ""
"Regular expressions beginning with ``'^'`` can be used with :func:`search` "
"to restrict the match at the beginning of the string::"
msgstr ""
"Регулярні вирази, що починаються з ``'^'``, можна використовувати з :func:"
"`search`, щоб обмежити збіг на початку рядка::"

#: ../../library/re.rst:1499
msgid ""
"Note however that in :const:`MULTILINE` mode :func:`match` only matches at "
"the beginning of the string, whereas using :func:`search` with a regular "
"expression beginning with ``'^'`` will match at the beginning of each "
"line. ::"
msgstr ""
"Однак зауважте, що в режимі :const:`MULTILINE` :func:`match` збігається лише "
"на початку рядка, тоді як використання :func:`search` із регулярним виразом, "
"що починається з ``'^'`` збігається на початок кожного рядка. ::"

#: ../../library/re.rst:1509
msgid "Making a Phonebook"
msgstr "Створення телефонної книги"

#: ../../library/re.rst:1511
msgid ""
":func:`split` splits a string into a list delimited by the passed pattern.  "
"The method is invaluable for converting textual data into data structures "
"that can be easily read and modified by Python as demonstrated in the "
"following example that creates a phonebook."
msgstr ""
":func:`split` розбиває рядок на список, розділений переданим шаблоном. Цей "
"метод є безцінним для перетворення текстових даних у структури даних, які "
"можна легко читати та змінювати Python, як показано в наступному прикладі "
"створення телефонної книги."

#: ../../library/re.rst:1516
msgid ""
"First, here is the input.  Normally it may come from a file, here we are "
"using triple-quoted string syntax"
msgstr ""
"По-перше, ось вхідні дані. Зазвичай він може надходити з файлу, тут ми "
"використовуємо синтаксис рядка в потрійних лапках"

#: ../../library/re.rst:1529
msgid ""
"The entries are separated by one or more newlines. Now we convert the string "
"into a list with each nonempty line having its own entry:"
msgstr ""
"Записи розділені одним або кількома символами нового рядка. Тепер ми "
"перетворюємо рядок на список, у якому кожен непорожній рядок має окремий "
"запис:"

#: ../../library/re.rst:1542
msgid ""
"Finally, split each entry into a list with first name, last name, telephone "
"number, and address.  We use the ``maxsplit`` parameter of :func:`split` "
"because the address has spaces, our splitting pattern, in it:"
msgstr ""
"Нарешті, розділіть кожен запис на список із іменем, прізвищем, номером "
"телефону та адресою. Ми використовуємо параметр ``maxsplit`` :func:`split`, "
"тому що в адресі є пробіли, наш шаблон поділу:"

#: ../../library/re.rst:1555
msgid ""
"The ``:?`` pattern matches the colon after the last name, so that it does "
"not occur in the result list.  With a ``maxsplit`` of ``4``, we could "
"separate the house number from the street name:"
msgstr ""
"Шаблон ``:?`` відповідає двокрапці після прізвища, щоб він не зустрічався в "
"списку результатів. За допомогою ``maxsplit`` ``4`` ми можемо відокремити "
"номер будинку від назви вулиці:"

#: ../../library/re.rst:1570
msgid "Text Munging"
msgstr "Перебирання тексту"

#: ../../library/re.rst:1572
msgid ""
":func:`sub` replaces every occurrence of a pattern with a string or the "
"result of a function.  This example demonstrates using :func:`sub` with a "
"function to \"munge\" text, or randomize the order of all the characters in "
"each word of a sentence except for the first and last characters::"
msgstr ""
":func:`sub` замінює кожне входження шаблону рядком або результатом функції. "
"У цьому прикладі демонструється використання :func:`sub` із функцією для "
"\"переміщення\" тексту або випадкового порядку всіх символів у кожному слові "
"речення, за винятком першого та останнього символів::"

#: ../../library/re.rst:1589
msgid "Finding all Adverbs"
msgstr "Знайти всі прислівники"

#: ../../library/re.rst:1591
msgid ""
":func:`findall` matches *all* occurrences of a pattern, not just the first "
"one as :func:`search` does.  For example, if a writer wanted to find all of "
"the adverbs in some text, they might use :func:`findall` in the following "
"manner::"
msgstr ""
":func:`findall` відповідає *всім* входженням шаблону, а не лише першому, як "
"це робить :func:`search`. Наприклад, якщо автор хоче знайти всі прислівники "
"в якомусь тексті, він може використати :func:`findall` у такий спосіб:"

#: ../../library/re.rst:1602
msgid "Finding all Adverbs and their Positions"
msgstr "Знайти всі прислівники та їх позиції"

#: ../../library/re.rst:1604
msgid ""
"If one wants more information about all matches of a pattern than the "
"matched text, :func:`finditer` is useful as it provides :ref:`match objects "
"<match-objects>` instead of strings.  Continuing with the previous example, "
"if a writer wanted to find all of the adverbs *and their positions* in some "
"text, they would use :func:`finditer` in the following manner::"
msgstr ""
"Якщо потрібно отримати більше інформації про всі збіги шаблону, ніж "
"відповідний текст, :func:`finditer` буде корисним, оскільки він надає :ref:"
"`match objects <match-objects>` замість рядків. Продовжуючи попередній "
"приклад, якби автор хотів знайти всі прислівники *та їх позиції* в якомусь "
"тексті, він використав би :func:`finditer` таким чином::"

#: ../../library/re.rst:1618
msgid "Raw String Notation"
msgstr "Необроблена рядкова нотація"

#: ../../library/re.rst:1620
msgid ""
"Raw string notation (``r\"text\"``) keeps regular expressions sane.  Without "
"it, every backslash (``'\\'``) in a regular expression would have to be "
"prefixed with another one to escape it.  For example, the two following "
"lines of code are functionally identical::"
msgstr ""
"Необроблена нотація рядка (``r\"текст\"``) зберігає регулярні вирази "
"нормальними. Без нього кожен зворотний слеш (``'\\'``) у регулярному виразі "
"повинен був би мати префікс іншим, щоб уникнути його. Наприклад, два "
"наступних рядки коду функціонально ідентичні:"

#: ../../library/re.rst:1630
msgid ""
"When one wants to match a literal backslash, it must be escaped in the "
"regular expression.  With raw string notation, this means ``r\"\\\\\"``.  "
"Without raw string notation, one must use ``\"\\\\\\\\\"``, making the "
"following lines of code functionally identical::"
msgstr ""
"Якщо потрібно зіставити літеральний зворотний слеш, його потрібно екранувати "
"у регулярному виразі. У необробленому рядковому записі це означає ``r\"\\\\"
"\"``. Без нотації необробленого рядка потрібно використовувати ``\"\\\\\\\\"
"\"``, роблячи наступні рядки коду функціонально ідентичними::"

#: ../../library/re.rst:1642
msgid "Writing a Tokenizer"
msgstr "Написання токенізера"

#: ../../library/re.rst:1644
msgid ""
"A `tokenizer or scanner <https://en.wikipedia.org/wiki/Lexical_analysis>`_ "
"analyzes a string to categorize groups of characters.  This is a useful "
"first step in writing a compiler or interpreter."
msgstr ""
"`Токенизатор або сканер <https://en.wikipedia.org/wiki/Lexical_analysis>`_ "
"аналізує рядок, щоб класифікувати групи символів. Це корисний перший крок у "
"написанні компілятора чи інтерпретатора."

#: ../../library/re.rst:1648
msgid ""
"The text categories are specified with regular expressions.  The technique "
"is to combine those into a single master regular expression and to loop over "
"successive matches::"
msgstr ""
"Текстові категорії вказуються регулярними виразами. Техніка полягає в тому, "
"щоб об’єднати їх у єдиний основний регулярний вираз і виконати цикл "
"послідовних збігів:"

#: ../../library/re.rst:1704
msgid "The tokenizer produces the following output::"
msgstr "Токенізатор видає такий вихід:"

#: ../../library/re.rst:1727
msgid ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, "
"2009. The third edition of the book no longer covers Python at all, but the "
"first edition covered writing good regular expression patterns in great "
"detail."
msgstr ""
"Фрідл, Джеффрі. Освоєння регулярних виразів. 3rd ed., O'Reilly Media, 2009. "
"Третє видання книги більше не охоплює Python взагалі, але перше видання "
"охоплювало написання хороших шаблонів регулярних виразів дуже детально."
