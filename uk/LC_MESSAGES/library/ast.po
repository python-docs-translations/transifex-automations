# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 18:00+0000\n"
"PO-Revision-Date: 2025-07-18 19:17+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../library/ast.rst:2
msgid ":mod:`ast` --- Abstract Syntax Trees"
msgstr ":mod:`ast` --- Абстрактні синтаксичні дерева"

#: ../../library/ast.rst:14
msgid "**Source code:** :source:`Lib/ast.py`"
msgstr "**Вихідний код:** :source:`Lib/ast.py`"

#: ../../library/ast.rst:18
msgid ""
"The :mod:`ast` module helps Python applications to process trees of the "
"Python abstract syntax grammar.  The abstract syntax itself might change "
"with each Python release; this module helps to find out programmatically "
"what the current grammar looks like."
msgstr ""
"Модуль :mod:`ast` допомагає програмам Python обробляти дерева граматики "
"абстрактного синтаксису Python. Сам абстрактний синтаксис може змінюватися з "
"кожним випуском Python; цей модуль допомагає програмно дізнатися, як "
"виглядає поточна граматика."

#: ../../library/ast.rst:23
msgid ""
"An abstract syntax tree can be generated by passing :data:`ast."
"PyCF_ONLY_AST` as a flag to the :func:`compile` built-in function, or using "
"the :func:`parse` helper provided in this module.  The result will be a tree "
"of objects whose classes all inherit from :class:`ast.AST`.  An abstract "
"syntax tree can be compiled into a Python code object using the built-in :"
"func:`compile` function."
msgstr ""
"Абстрактне синтаксичне дерево можна створити, передавши :data:`ast."
"PyCF_ONLY_AST` як прапорець вбудованій функції :func:`compile` або "
"використовуючи помічник :func:`parse`, наданий у цьому модулі. Результатом "
"буде дерево об’єктів, усі класи яких успадковуються від :class:`ast.AST`. "
"Абстрактне синтаксичне дерево можна скомпілювати в об’єкт коду Python за "
"допомогою вбудованої функції :func:`compile`."

#: ../../library/ast.rst:33
msgid "Abstract Grammar"
msgstr "Абстрактна граматика"

#: ../../library/ast.rst:35
msgid "The abstract grammar is currently defined as follows:"
msgstr "Наразі абстрактна граматика визначається наступним чином:"

#: ../../library/ast.rst:42
msgid "Node classes"
msgstr "Класи вузлів"

#: ../../library/ast.rst:46
msgid ""
"This is the base of all AST node classes.  The actual node classes are "
"derived from the :file:`Parser/Python.asdl` file, which is reproduced :ref:"
"`below <abstract-grammar>`.  They are defined in the :mod:`_ast` C module "
"and re-exported in :mod:`ast`."
msgstr ""
"Це основа всіх класів вузлів AST. Фактичні класи вузлів походять із файлу :"
"file:`Parser/Python.asdl`, який відтворюється :ref:`нижче <abstract-"
"grammar>`. Вони визначені в модулі C :mod:`_ast` і повторно експортовані в :"
"mod:`ast`."

#: ../../library/ast.rst:51
msgid ""
"There is one class defined for each left-hand side symbol in the abstract "
"grammar (for example, :class:`ast.stmt` or :class:`ast.expr`).  In addition, "
"there is one class defined for each constructor on the right-hand side; "
"these classes inherit from the classes for the left-hand side trees.  For "
"example, :class:`ast.BinOp` inherits from :class:`ast.expr`.  For production "
"rules with alternatives (aka \"sums\"), the left-hand side class is "
"abstract: only instances of specific constructor nodes are ever created."
msgstr ""
"Для кожного лівого символу в абстрактній граматиці визначено один клас "
"(наприклад, :class:`ast.stmt` або :class:`ast.expr`). Крім того, є один "
"клас, визначений для кожного конструктора в правій частині; ці класи "
"успадковують класи для лівих дерев. Наприклад, :class:`ast.BinOp` "
"успадковується від :class:`ast.expr`. Для виробничих правил з альтернативами "
"(він же \"суми\") лівий клас є абстрактним: створюються лише екземпляри "
"конкретних вузлів конструктора."

#: ../../library/ast.rst:64
msgid ""
"Each concrete class has an attribute :attr:`_fields` which gives the names "
"of all child nodes."
msgstr ""
"Кожен конкретний клас має атрибут :attr:`_fields`, який дає імена всіх "
"дочірніх вузлів."

#: ../../library/ast.rst:67
msgid ""
"Each instance of a concrete class has one attribute for each child node, of "
"the type as defined in the grammar.  For example, :class:`ast.BinOp` "
"instances have an attribute :attr:`left` of type :class:`ast.expr`."
msgstr ""
"Кожен екземпляр конкретного класу має один атрибут для кожного дочірнього "
"вузла типу, визначеного в граматиці. Наприклад, екземпляри :class:`ast."
"BinOp` мають атрибут :attr:`left` типу :class:`ast.expr`."

#: ../../library/ast.rst:71
msgid ""
"If these attributes are marked as optional in the grammar (using a question "
"mark), the value might be ``None``.  If the attributes can have zero-or-more "
"values (marked with an asterisk), the values are represented as Python "
"lists.  All possible attributes must be present and have valid values when "
"compiling an AST with :func:`compile`."
msgstr ""
"Якщо ці атрибути позначені як необов’язкові в граматиці (використовуючи знак "
"питання), значенням може бути ``None``. Якщо атрибути можуть мати нуль або "
"більше значень (позначених зірочкою), значення представлені у вигляді "
"списків Python. Під час компіляції AST за допомогою :func:`compile` усі "
"можливі атрибути повинні бути присутніми та мати дійсні значення."

#: ../../library/ast.rst:82
msgid ""
"Instances of :class:`ast.expr` and :class:`ast.stmt` subclasses have :attr:"
"`lineno`, :attr:`col_offset`, :attr:`end_lineno`, and :attr:`end_col_offset` "
"attributes.  The :attr:`lineno` and :attr:`end_lineno` are the first and "
"last line numbers of the source text span (1-indexed so the first line is "
"line 1), and the :attr:`col_offset` and :attr:`end_col_offset` are the "
"corresponding UTF-8 byte offsets of the first and last tokens that generated "
"the node. The UTF-8 offset is recorded because the parser uses UTF-8 "
"internally."
msgstr ""

#: ../../library/ast.rst:91
msgid ""
"Note that the end positions are not required by the compiler and are "
"therefore optional. The end offset is *after* the last symbol, for example "
"one can get the source segment of a one-line expression node using "
"``source_line[node.col_offset : node.end_col_offset]``."
msgstr ""
"Зауважте, що кінцеві позиції не потрібні компілятору і тому є "
"необов’язковими. Кінцеве зміщення вказується *після* останнього символу, "
"наприклад, можна отримати вихідний сегмент вузла однорядкового виразу за "
"допомогою ``source_line[node.col_offset : node.end_col_offset]``."

#: ../../library/ast.rst:96
msgid ""
"The constructor of a class :class:`ast.T` parses its arguments as follows:"
msgstr ""
"Конструктор класу :class:`ast.T` аналізує його аргументи наступним чином:"

#: ../../library/ast.rst:98
msgid ""
"If there are positional arguments, there must be as many as there are items "
"in :attr:`T._fields`; they will be assigned as attributes of these names."
msgstr ""
"Якщо є позиційні аргументи, їх має бути стільки, скільки елементів у :attr:"
"`T._fields`; вони будуть призначені як атрибути цих імен."

#: ../../library/ast.rst:100
msgid ""
"If there are keyword arguments, they will set the attributes of the same "
"names to the given values."
msgstr ""
"Якщо є ключові аргументи, вони встановлять атрибути з однаковими іменами на "
"задані значення."

#: ../../library/ast.rst:103
msgid ""
"For example, to create and populate an :class:`ast.UnaryOp` node, you could "
"use ::"
msgstr ""
"Наприклад, щоб створити та заповнити вузол :class:`ast.UnaryOp`, ви можете "
"використати ::"

#: ../../library/ast.rst:115
msgid "or the more compact ::"
msgstr "або більш компактний ::"

#: ../../library/ast.rst:122
msgid "Class :class:`ast.Constant` is now used for all constants."
msgstr "Клас :class:`ast.Constant` тепер використовується для всіх констант."

#: ../../library/ast.rst:126
msgid ""
"Simple indices are represented by their value, extended slices are "
"represented as tuples."
msgstr ""
"Прості індекси представлені їх значеннями, розширені зрізи представлені у "
"вигляді кортежів."

#: ../../library/ast.rst:131
msgid ""
"Old classes :class:`ast.Num`, :class:`ast.Str`, :class:`ast.Bytes`, :class:"
"`ast.NameConstant` and :class:`ast.Ellipsis` are still available, but they "
"will be removed in future Python releases.  In the meantime, instantiating "
"them will return an instance of a different class."
msgstr ""
"Старі класи :class:`ast.Num`, :class:`ast.Str`, :class:`ast.Bytes`, :class:"
"`ast.NameConstant` і :class:`ast.Ellipsis` все ще доступні, але їх буде "
"видалено в наступних випусках Python. Тим часом їх створення екземпляра "
"поверне екземпляр іншого класу."

#: ../../library/ast.rst:138
msgid ""
"Old classes :class:`ast.Index` and :class:`ast.ExtSlice` are still "
"available, but they will be removed in future Python releases. In the "
"meantime, instantiating them will return an instance of a different class."
msgstr ""
"Старі класи :class:`ast.Index` і :class:`ast.ExtSlice` все ще доступні, але "
"їх буде видалено в наступних випусках Python. Тим часом їх створення "
"екземпляра поверне екземпляр іншого класу."

#: ../../library/ast.rst:144
msgid ""
"The descriptions of the specific node classes displayed here were initially "
"adapted from the fantastic `Green Tree Snakes <https://greentreesnakes."
"readthedocs.io/en/latest/>`__ project and all its contributors."
msgstr ""
"Описи конкретних класів вузлів, відображені тут, спочатку були адаптовані з "
"фантастичного проекту `Green Tree Snakes <https://greentreesnakes."
"readthedocs.io/en/latest/>`__ та всіх його учасників."

#: ../../library/ast.rst:150
msgid "Literals"
msgstr "Літерали"

#: ../../library/ast.rst:154
msgid ""
"A constant value. The ``value`` attribute of the ``Constant`` literal "
"contains the Python object it represents. The values represented can be "
"simple types such as a number, string or ``None``, but also immutable "
"container types (tuples and frozensets) if all of their elements are "
"constant."
msgstr ""
"Постійне значення. Атрибут ``value`` літералу ``Constant`` містить об’єкт "
"Python, який він представляє. Представлені значення можуть бути простими "
"типами, такими як число, рядок або ``None``, а також незмінними типами "
"контейнерів (кортежі та заморожені набори), якщо всі їхні елементи постійні."

#: ../../library/ast.rst:168
msgid ""
"Node representing a single formatting field in an f-string. If the string "
"contains a single formatting field and nothing else the node can be isolated "
"otherwise it appears in :class:`JoinedStr`."
msgstr ""
"Вузол, що представляє одне поле форматування в f-рядку. Якщо рядок містить "
"одне поле форматування та нічого іншого, вузол можна ізолювати, інакше він "
"з’являється в :class:`JoinedStr`."

#: ../../library/ast.rst:172
msgid ""
"``value`` is any expression node (such as a literal, a variable, or a "
"function call)."
msgstr ""
"``значення`` - будь-який вузол виразу (наприклад, літерал, змінна або виклик "
"функції)."

#: ../../library/ast.rst:174
msgid "``conversion`` is an integer:"
msgstr "``перетворення`` є цілим числом:"

#: ../../library/ast.rst:176
msgid "-1: no formatting"
msgstr "-1: без форматування"

#: ../../library/ast.rst:177
msgid "115: ``!s`` string formatting"
msgstr "115: форматування рядка ``!s``"

#: ../../library/ast.rst:178
msgid "114: ``!r`` repr formatting"
msgstr "114: форматування ``!r`` repr"

#: ../../library/ast.rst:179
msgid "97: ``!a`` ascii formatting"
msgstr "97: ``!a`` форматування ascii"

#: ../../library/ast.rst:181
msgid ""
"``format_spec`` is a :class:`JoinedStr` node representing the formatting of "
"the value, or ``None`` if no format was specified. Both ``conversion`` and "
"``format_spec`` can be set at the same time."
msgstr ""
"``format_spec`` — це вузол :class:`JoinedStr`, який представляє форматування "
"значення, або ``None``, якщо формат не вказано. І ``conversion``, і "
"``format_spec`` можна встановити одночасно."

#: ../../library/ast.rst:188
msgid ""
"An f-string, comprising a series of :class:`FormattedValue` and :class:"
"`Constant` nodes."
msgstr ""
"F-рядок, що містить ряд вузлів :class:`FormattedValue` і :class:`Constant`."

#: ../../library/ast.rst:217
msgid ""
"A list or tuple. ``elts`` holds a list of nodes representing the elements. "
"``ctx`` is :class:`Store` if the container is an assignment target (i.e. "
"``(x,y)=something``), and :class:`Load` otherwise."
msgstr ""
"Список або кортеж. ``elts`` містить список вузлів, що представляють "
"елементи. ``ctx`` є :class:`Store`, якщо контейнер є метою призначення "
"(тобто ``(x,y)=something``), і :class:`Load` інакше."

#: ../../library/ast.rst:243
msgid "A set. ``elts`` holds a list of nodes representing the set's elements."
msgstr ""
"Набір. ``elts`` містить список вузлів, що представляють елементи набору."

#: ../../library/ast.rst:258
msgid ""
"A dictionary. ``keys`` and ``values`` hold lists of nodes representing the "
"keys and the values respectively, in matching order (what would be returned "
"when calling :code:`dictionary.keys()` and :code:`dictionary.values()`)."
msgstr ""
"Словник. ``keys`` і ``values`` містять списки вузлів, що представляють ключі "
"та значення відповідно, у відповідному порядку (те, що буде повернуто під "
"час виклику :code:`dictionary.keys()` і :code:`dictionary. значення()`)."

#: ../../library/ast.rst:262
msgid ""
"When doing dictionary unpacking using dictionary literals the expression to "
"be expanded goes in the ``values`` list, with a ``None`` at the "
"corresponding position in ``keys``."
msgstr ""
"Під час розпакування словника за допомогою словникових літералів вираз, який "
"потрібно розгорнути, потрапляє до списку ``значень`` із ``None`` у "
"відповідній позиції ``ключів``."

#: ../../library/ast.rst:280
msgid "Variables"
msgstr "Змінні"

#: ../../library/ast.rst:284
msgid ""
"A variable name. ``id`` holds the name as a string, and ``ctx`` is one of "
"the following types."
msgstr ""
"Ім'я змінної. ``id`` містить назву як рядок, а ``ctx`` є одним із наступних "
"типів."

#: ../../library/ast.rst:292
msgid ""
"Variable references can be used to load the value of a variable, to assign a "
"new value to it, or to delete it. Variable references are given a context to "
"distinguish these cases."
msgstr ""
"Посилання на змінні можна використовувати, щоб завантажити значення змінної, "
"призначити їй нове значення або видалити її. Посиланням на змінні надається "
"контекст, щоб розрізняти ці випадки."

#: ../../library/ast.rst:325
msgid ""
"A ``*var`` variable reference. ``value`` holds the variable, typically a :"
"class:`Name` node. This type must be used when building a :class:`Call` node "
"with ``*args``."
msgstr ""
"Посилання на змінну ``*var``. ``value`` містить змінну, як правило, вузол :"
"class:`Name`. Цей тип необхідно використовувати під час створення вузла :"
"class:`Call` з ``*args``."

#: ../../library/ast.rst:348
msgid "Expressions"
msgstr "Вирази"

#: ../../library/ast.rst:352
msgid ""
"When an expression, such as a function call, appears as a statement by "
"itself with its return value not used or stored, it is wrapped in this "
"container. ``value`` holds one of the other nodes in this section, a :class:"
"`Constant`, a :class:`Name`, a :class:`Lambda`, a :class:`Yield` or :class:"
"`YieldFrom` node."
msgstr ""
"Коли вираз, як-от виклик функції, з’являється як окремий оператор із "
"невикористаним або збереженим значенням, що повертається, його загортають у "
"цей контейнер. ``value`` містить один із інших вузлів у цьому розділі, :"
"class:`Constant`, :class:`Name`, :class:`Lambda`, :class:`Yield` або :class:"
"`YieldFrom`."

#: ../../library/ast.rst:371
msgid ""
"A unary operation. ``op`` is the operator, and ``operand`` any expression "
"node."
msgstr ""
"Унарна операція. ``op`` є оператором, а ``operand`` будь-яким вузлом виразу."

#: ../../library/ast.rst:380
msgid ""
"Unary operator tokens. :class:`Not` is the ``not`` keyword, :class:`Invert` "
"is the ``~`` operator."
msgstr ""
"Унарні маркери оператора. :class:`Not` - це ключове слово ``not``, :class:"
"`Invert` - це оператор ``~``."

#: ../../library/ast.rst:394
msgid ""
"A binary operation (like addition or division). ``op`` is the operator, and "
"``left`` and ``right`` are any expression nodes."
msgstr ""
"Двійкова операція (наприклад, додавання або ділення). ``op`` є оператором, "
"``left`` і ``right`` є будь-якими вузлами виразу."

#: ../../library/ast.rst:421
msgid "Binary operator tokens."
msgstr "Бінарні операторські токени."

#: ../../library/ast.rst:426
msgid ""
"A boolean operation, 'or' or 'and'. ``op`` is :class:`Or` or :class:`And`. "
"``values`` are the values involved. Consecutive operations with the same "
"operator, such as ``a or b or c``, are collapsed into one node with several "
"values."
msgstr ""
"Логічна операція \"або\" або \"і\". ``op`` - це :class:`Or` або :class:"
"`And`. ``values`` - це значення, які беруть участь. Послідовні операції з "
"тим самим оператором, наприклад ``a або b або c``, згортаються в один вузол "
"з кількома значеннями."

#: ../../library/ast.rst:431
msgid "This doesn't include ``not``, which is a :class:`UnaryOp`."
msgstr "Це не включає ``not``, який є :class:`UnaryOp`."

#: ../../library/ast.rst:447
msgid "Boolean operator tokens."
msgstr "Логічні операторні маркери."

#: ../../library/ast.rst:452
msgid ""
"A comparison of two or more values. ``left`` is the first value in the "
"comparison, ``ops`` the list of operators, and ``comparators`` the list of "
"values after the first element in the comparison."
msgstr ""
"Порівняння двох чи більше значень. ``left`` - це перше значення в "
"порівнянні, ``ops`` - список операторів, ``comparators`` - список значень "
"після першого елемента в порівнянні."

#: ../../library/ast.rst:481
msgid "Comparison operator tokens."
msgstr "Лексими операторів порівняння."

#: ../../library/ast.rst:486
msgid ""
"A function call. ``func`` is the function, which will often be a :class:"
"`Name` or :class:`Attribute` object. Of the arguments:"
msgstr ""
"Виклик функції. ``func`` – це функція, яка часто буде об’єктом :class:`Name` "
"або :class:`Attribute`. З аргументів:"

#: ../../library/ast.rst:489
msgid "``args`` holds a list of the arguments passed by position."
msgstr "``args`` містить список аргументів, переданих за позицією."

#: ../../library/ast.rst:490
msgid ""
"``keywords`` holds a list of :class:`keyword` objects representing arguments "
"passed by keyword."
msgstr ""
"``keywords`` містить список об’єктів :class:`keyword`, що представляють "
"аргументи, передані ключовим словом."

#: ../../library/ast.rst:493
msgid ""
"When creating a ``Call`` node, ``args`` and ``keywords`` are required, but "
"they can be empty lists. ``starargs`` and ``kwargs`` are optional."
msgstr ""
"Під час створення вузла ``Call`` необхідні ``args`` і ``keywords``, але вони "
"можуть бути порожніми списками. ``starargs`` і ``kwargs`` необов'язкові."

#: ../../library/ast.rst:517
msgid ""
"A keyword argument to a function call or class definition. ``arg`` is a raw "
"string of the parameter name, ``value`` is a node to pass in."
msgstr ""
"Аргумент ключового слова для виклику функції або визначення класу. ``arg`` — "
"це необроблений рядок назви параметра, ``value`` — це вузол для передачі."

#: ../../library/ast.rst:523
msgid ""
"An expression such as ``a if b else c``. Each field holds a single node, so "
"in the following example, all three are :class:`Name` nodes."
msgstr ""
"Вираз на зразок \"a if b else c\". Кожне поле містить один вузол, тому в "
"наступному прикладі всі три є вузлами :class:`Name`."

#: ../../library/ast.rst:538
msgid ""
"Attribute access, e.g. ``d.keys``. ``value`` is a node, typically a :class:"
"`Name`. ``attr`` is a bare string giving the name of the attribute, and "
"``ctx`` is :class:`Load`, :class:`Store` or :class:`Del` according to how "
"the attribute is acted on."
msgstr ""
"Доступ до атрибутів, напр. ``d.keys``. ``value`` - це вузол, як правило, :"
"class:`Name`. ``attr`` — це чистий рядок, що дає назву атрибуту, а ``ctx`` — "
"це :class:`Load`, :class:`Store` або :class:`Del` відповідно до того, як діє "
"атрибут на."

#: ../../library/ast.rst:555
msgid ""
"A named expression. This AST node is produced by the assignment expressions "
"operator (also known as the walrus operator). As opposed to the :class:"
"`Assign` node in which the first argument can be multiple nodes, in this "
"case both ``target`` and ``value`` must be single nodes."
msgstr ""
"Іменований вираз. Цей вузол AST створюється оператором виразів присвоєння "
"(також відомим як оператор моржа). На відміну від вузла :class:`Assign`, у "
"якому першим аргументом може бути кілька вузлів, у цьому випадку як "
"``target``, так і ``value`` мають бути окремими вузлами."

#: ../../library/ast.rst:570
msgid "Subscripting"
msgstr "Підписка"

#: ../../library/ast.rst:574
msgid ""
"A subscript, such as ``l[1]``. ``value`` is the subscripted object (usually "
"sequence or mapping). ``slice`` is an index, slice or key. It can be a :"
"class:`Tuple` and contain a :class:`Slice`. ``ctx`` is :class:`Load`, :class:"
"`Store` or :class:`Del` according to the action performed with the subscript."
msgstr ""
"Нижній індекс, наприклад \"l[1]\". ``значення`` - це об'єкт з індексом "
"(зазвичай послідовність або відображення). ``slice`` - це індекс, зріз або "
"ключ. Це може бути :class:`Tuple` і містити :class:`Slice`. ``ctx`` - це :"
"class:`Load`, :class:`Store` або :class:`Del` відповідно до дії, виконаної з "
"нижнім індексом."

#: ../../library/ast.rst:598
msgid ""
"Regular slicing (on the form ``lower:upper`` or ``lower:upper:step``). Can "
"occur only inside the *slice* field of :class:`Subscript`, either directly "
"or as an element of :class:`Tuple`."
msgstr ""
"Звичайна нарізка (за формою ``lower:upper`` або ``lower:upper:step``). Може "
"зустрічатися лише всередині поля *slice* :class:`Subscript`, або "
"безпосередньо, або як елемент :class:`Tuple`."

#: ../../library/ast.rst:615
msgid "Comprehensions"
msgstr "Осягнення"

#: ../../library/ast.rst:622
msgid ""
"List and set comprehensions, generator expressions, and dictionary "
"comprehensions. ``elt`` (or ``key`` and ``value``) is a single node "
"representing the part that will be evaluated for each item."
msgstr ""
"Список і набір розуміння, генератор виразів і словник розуміння. ``elt`` "
"(або ``key`` і ``value``) — це один вузол, що представляє частину, яка буде "
"оцінюватися для кожного елемента."

#: ../../library/ast.rst:626
msgid "``generators`` is a list of :class:`comprehension` nodes."
msgstr "``generators`` - це список вузлів :class:`comprehension`."

#: ../../library/ast.rst:668
msgid ""
"One ``for`` clause in a comprehension. ``target`` is the reference to use "
"for each element - typically a :class:`Name` or :class:`Tuple` node. "
"``iter`` is the object to iterate over. ``ifs`` is a list of test "
"expressions: each ``for`` clause can have multiple ``ifs``."
msgstr ""
"Одне речення ``за`` для розуміння. ``target`` - це посилання для "
"використання для кожного елемента - зазвичай :class:`Name` або :class:"
"`Tuple` вузол. ``iter`` - це об'єкт для повторення. ``ifs`` — це список "
"перевірочних виразів: кожен пункт ``for`` може мати кілька ``ifs``."

#: ../../library/ast.rst:673
msgid ""
"``is_async`` indicates a comprehension is asynchronous (using an ``async "
"for`` instead of ``for``). The value is an integer (0 or 1)."
msgstr ""
"``is_async`` вказує, що розуміння є асинхронним (використовуючи ``async "
"for`` замість ``for``). Значення є цілим числом (0 або 1)."

#: ../../library/ast.rst:739
msgid "Statements"
msgstr "Заяви"

#: ../../library/ast.rst:743
msgid ""
"An assignment. ``targets`` is a list of nodes, and ``value`` is a single "
"node."
msgstr "Доручення. ``targets`` — це список вузлів, а ``value`` — один вузол."

#: ../../library/ast.rst:745
msgid ""
"Multiple nodes in ``targets`` represents assigning the same value to each. "
"Unpacking is represented by putting a :class:`Tuple` or :class:`List` within "
"``targets``."
msgstr ""
"Кілька вузлів у ``цілях`` представляють призначення однакового значення "
"кожному. Розпакування представлено розміщенням :class:`Tuple` або :class:"
"`List` у ``targets``."

#: ../../library/ast.rst:751 ../../library/ast.rst:1038
#: ../../library/ast.rst:1211 ../../library/ast.rst:1264
msgid ""
"``type_comment`` is an optional string with the type annotation as a comment."
msgstr ""
"``type_comment`` – необов’язковий рядок із анотацією типу як коментаря."

#: ../../library/ast.rst:781
msgid ""
"An assignment with a type annotation. ``target`` is a single node and can be "
"a :class:`Name`, a :class:`Attribute` or a :class:`Subscript`. "
"``annotation`` is the annotation, such as a :class:`Constant` or :class:"
"`Name` node. ``value`` is a single optional node. ``simple`` is a boolean "
"integer set to True for a :class:`Name` node in ``target`` that do not "
"appear in between parenthesis and are hence pure names and not expressions."
msgstr ""
"Призначення з анотацією типу. ``target`` є одним вузлом і може бути :class:"
"`Name`, :class:`Attribute` або :class:`Subscript`. ``аннотація`` – це "
"анотація, наприклад вузол :class:`Constant` або :class:`Name`. ``value`` - "
"це один необов'язковий вузол. ``simple`` — це логічне ціле число зі "
"значенням True для вузла :class:`Name` у ``target``, яке не відображається в "
"дужках і, отже, є чистими іменами, а не виразами."

#: ../../library/ast.rst:836
msgid ""
"Augmented assignment, such as ``a += 1``. In the following example, "
"``target`` is a :class:`Name` node for ``x`` (with the :class:`Store` "
"context), ``op`` is :class:`Add`, and ``value`` is a :class:`Constant` with "
"value for 1."
msgstr ""
"Доповнене присвоювання, наприклад ``a += 1``. У наступному прикладі "
"``target`` є вузлом :class:`Name` для ``x`` (з контекстом :class:`Store`), "
"``op`` це :class:`Add`, а ``значення`` є :class:`Constant` зі значенням 1."

#: ../../library/ast.rst:841
msgid ""
"The ``target`` attribute connot be of class :class:`Tuple` or :class:`List`, "
"unlike the targets of :class:`Assign`."
msgstr ""

#: ../../library/ast.rst:858
msgid ""
"A ``raise`` statement. ``exc`` is the exception object to be raised, "
"normally a :class:`Call` or :class:`Name`, or ``None`` for a standalone "
"``raise``. ``cause`` is the optional part for ``y`` in ``raise x from y``."
msgstr ""
"Оператор ``raise``. ``exc`` — це об’єкт винятку, який потрібно викликати, "
"зазвичай це :class:`Call` або :class:`Name`, або ``None`` для окремого "
"``raise``. ``cause`` є необов’язковою частиною для ``y`` у ``raise x from "
"y``."

#: ../../library/ast.rst:875
msgid ""
"An assertion. ``test`` holds the condition, such as a :class:`Compare` node. "
"``msg`` holds the failure message."
msgstr ""
"Твердження. ``test`` містить умову, як-от вузол :class:`Compare`. ``msg`` "
"містить повідомлення про помилку."

#: ../../library/ast.rst:891
msgid ""
"Represents a ``del`` statement. ``targets`` is a list of nodes, such as :"
"class:`Name`, :class:`Attribute` or :class:`Subscript` nodes."
msgstr ""
"Представляє оператор ``del``. ``targets`` – це список вузлів, наприклад "
"вузли :class:`Name`, :class:`Attribute` або :class:`Subscript`."

#: ../../library/ast.rst:909
msgid "A ``pass`` statement."
msgstr "Заява ``pass``."

#: ../../library/ast.rst:920
msgid ""
"Other statements which are only applicable inside functions or loops are "
"described in other sections."
msgstr ""
"Інші оператори, які застосовуються лише всередині функцій або циклів, "
"описані в інших розділах."

#: ../../library/ast.rst:924
msgid "Imports"
msgstr "Імпорт"

#: ../../library/ast.rst:928
msgid "An import statement. ``names`` is a list of :class:`alias` nodes."
msgstr "Заява про імпорт. ``names`` - це список вузлів :class:`alias`."

#: ../../library/ast.rst:945
msgid ""
"Represents ``from x import y``. ``module`` is a raw string of the 'from' "
"name, without any leading dots, or ``None`` for statements such as ``from . "
"import foo``. ``level`` is an integer holding the level of the relative "
"import (0 means absolute import)."
msgstr ""
"Представляє ``from x import y``. ``module`` — це необроблений рядок назви "
"'from' без будь-яких крапок на початку або ``None`` для операторів, таких як "
"``from . імпортувати foo``. ``level`` — це ціле число, що містить рівень "
"відносного імпорту (0 означає абсолютний імпорт)."

#: ../../library/ast.rst:967
msgid ""
"Both parameters are raw strings of the names. ``asname`` can be ``None`` if "
"the regular name is to be used."
msgstr ""
"Обидва параметри є необробленими рядками імен. ``asname`` може бути "
"``None``, якщо має використовуватися звичайна назва."

#: ../../library/ast.rst:984
msgid "Control flow"
msgstr "Контроль потоку"

#: ../../library/ast.rst:987
msgid ""
"Optional clauses such as ``else`` are stored as an empty list if they're not "
"present."
msgstr ""
"Необов’язкові пропозиції, такі як ``else``, зберігаються як порожній список, "
"якщо їх немає."

#: ../../library/ast.rst:992
msgid ""
"An ``if`` statement. ``test`` holds a single node, such as a :class:"
"`Compare` node. ``body`` and ``orelse`` each hold a list of nodes."
msgstr ""
"Оператор ``if``. ``test`` містить один вузол, наприклад вузол :class:"
"`Compare`. ``body`` і ``orelse`` містять список вузлів."

#: ../../library/ast.rst:995
msgid ""
"``elif`` clauses don't have a special representation in the AST, but rather "
"appear as extra :class:`If` nodes within the ``orelse`` section of the "
"previous one."
msgstr ""
"Речення ``elif`` не мають спеціального представлення в AST, а радше "
"з’являються як додаткові вузли :class:`If` у розділі ``orelse`` попереднього."

#: ../../library/ast.rst:1030
msgid ""
"A ``for`` loop. ``target`` holds the variable(s) the loop assigns to, as a "
"single :class:`Name`, :class:`Tuple` or :class:`List` node. ``iter`` holds "
"the item to be looped over, again as a single node. ``body`` and ``orelse`` "
"contain lists of nodes to execute. Those in ``orelse`` are executed if the "
"loop finishes normally, rather than via a ``break`` statement."
msgstr ""
"Цикл ``for``. ``target`` містить змінну(-и), яку призначає цикл, як один "
"вузол :class:`Name`, :class:`Tuple` або :class:`List`. ``iter`` зберігає "
"елемент, який буде проходити в циклі, знову як один вузол. ``body`` і "
"``orelse`` містять списки вузлів для виконання. Ті, що в ``orelse``, "
"виконуються, якщо цикл завершується нормально, а не через оператор ``break``."

#: ../../library/ast.rst:1064
msgid ""
"A ``while`` loop. ``test`` holds the condition, such as a :class:`Compare` "
"node."
msgstr "Цикл ``while``. ``test`` містить умову, як-от вузол :class:`Compare`."

#: ../../library/ast.rst:1091
msgid "The ``break`` and ``continue`` statements."
msgstr "Оператори ``break`` і ``continue``."

#: ../../library/ast.rst:1126
msgid ""
"``try`` blocks. All attributes are list of nodes to execute, except for "
"``handlers``, which is a list of :class:`ExceptHandler` nodes."
msgstr ""
"блоки ``try``. Усі атрибути є списком вузлів для виконання, за винятком "
"``обробників``, який є списком :class:`ExceptHandler` вузлів."

#: ../../library/ast.rst:1172
msgid ""
"A single ``except`` clause. ``type`` is the exception type it will match, "
"typically a :class:`Name` node (or ``None`` for a catch-all ``except:`` "
"clause). ``name`` is a raw string for the name to hold the exception, or "
"``None`` if the clause doesn't have ``as foo``. ``body`` is a list of nodes."
msgstr ""
"Єдине речення ``крім``. ``type`` — це тип винятку, якому він відповідатиме, "
"як правило, вузол :class:`Name` (або ``None`` для речення catch-all ``except:"
"``). ``name`` — це необроблений рядок для імені, який містить виняток, або "
"``None``, якщо в пропозиції немає ``as foo``. ``body`` - це список вузлів."

#: ../../library/ast.rst:1206
msgid ""
"A ``with`` block. ``items`` is a list of :class:`withitem` nodes "
"representing the context managers, and ``body`` is the indented block inside "
"the context."
msgstr ""
"Блок ``with``. ``items`` — це список вузлів :class:`withitem`, що "
"представляють контекстні менеджери, а ``body`` — блок із відступом усередині "
"контексту."

#: ../../library/ast.rst:1216
msgid ""
"A single context manager in a ``with`` block. ``context_expr`` is the "
"context manager, often a :class:`Call` node. ``optional_vars`` is a :class:"
"`Name`, :class:`Tuple` or :class:`List` for the ``as foo`` part, or ``None`` "
"if that isn't used."
msgstr ""
"Єдиний контекстний менеджер у блоці ``with``. ``context_expr`` - це менеджер "
"контексту, часто вузол :class:`Call`. ``optional_vars`` — це :class:`Name`, :"
"class:`Tuple` або :class:`List` для частини ``as foo``, або ``None``, якщо "
"вона не використовується."

#: ../../library/ast.rst:1249
msgid "Function and class definitions"
msgstr "Визначення функцій і класів"

#: ../../library/ast.rst:1253
msgid "A function definition."
msgstr "Визначення функції."

#: ../../library/ast.rst:1255
msgid "``name`` is a raw string of the function name."
msgstr "``name`` - це необроблений рядок назви функції."

#: ../../library/ast.rst:1256
msgid "``args`` is an :class:`arguments` node."
msgstr "``args`` є вузлом :class:`arguments`."

#: ../../library/ast.rst:1257
msgid "``body`` is the list of nodes inside the function."
msgstr "``body`` - це список вузлів усередині функції."

#: ../../library/ast.rst:1258
msgid ""
"``decorator_list`` is the list of decorators to be applied, stored outermost "
"first (i.e. the first in the list will be applied last)."
msgstr ""
"``decorator_list`` — це список декораторів, які будуть застосовані, "
"зберігаються в першу чергу (тобто перший у списку буде застосовано останнім)."

#: ../../library/ast.rst:1260
msgid "``returns`` is the return annotation."
msgstr "``returns`` - це анотація повернення."

#: ../../library/ast.rst:1269
msgid ""
"``lambda`` is a minimal function definition that can be used inside an "
"expression. Unlike :class:`FunctionDef`, ``body`` holds a single node."
msgstr ""
"``лямбда`` - це мінімальне визначення функції, яке можна використовувати "
"всередині виразу. На відміну від :class:`FunctionDef`, ``body`` містить один "
"вузол."

#: ../../library/ast.rst:1293
msgid "The arguments for a function."
msgstr "Аргументи функції."

#: ../../library/ast.rst:1295
msgid ""
"``posonlyargs``, ``args`` and ``kwonlyargs`` are lists of :class:`arg` nodes."
msgstr ""
"``posonlyargs``, ``args`` і ``kwonlyargs`` - це списки вузлів :class:`arg`."

#: ../../library/ast.rst:1296
msgid ""
"``vararg`` and ``kwarg`` are single :class:`arg` nodes, referring to the "
"``*args, **kwargs`` parameters."
msgstr ""
"``vararg`` і ``kwarg`` є окремими вузлами :class:`arg`, які посилаються на "
"параметри ``*args, **kwargs``."

#: ../../library/ast.rst:1298
msgid ""
"``kw_defaults`` is a list of default values for keyword-only arguments. If "
"one is ``None``, the corresponding argument is required."
msgstr ""
"``kw_defaults`` - це список значень за замовчуванням для аргументів, що "
"містять лише ключові слова. Якщо одне значення ``None``, потрібен "
"відповідний аргумент."

#: ../../library/ast.rst:1300
msgid ""
"``defaults`` is a list of default values for arguments that can be passed "
"positionally. If there are fewer defaults, they correspond to the last n "
"arguments."
msgstr ""
"``defaults`` - це список значень за замовчуванням для аргументів, які можна "
"передати позиційно. Якщо стандартних значень менше, вони відповідають "
"останнім n аргументам."

#: ../../library/ast.rst:1307
msgid ""
"A single argument in a list. ``arg`` is a raw string of the argument name, "
"``annotation`` is its annotation, such as a :class:`Str` or :class:`Name` "
"node."
msgstr ""
"Один аргумент у списку. ``arg`` — це необроблений рядок назви аргументу, "
"``annotation`` — це його анотація, наприклад вузол :class:`Str` або :class:"
"`Name`."

#: ../../library/ast.rst:1313
msgid ""
"``type_comment`` is an optional string with the type annotation as a comment"
msgstr "``type_comment`` – необов’язковий рядок із анотацією типу як коментаря"

#: ../../library/ast.rst:1357
msgid "A ``return`` statement."
msgstr "Оператор ``повернення``."

#: ../../library/ast.rst:1372
msgid ""
"A ``yield`` or ``yield from`` expression. Because these are expressions, "
"they must be wrapped in a :class:`Expr` node if the value sent back is not "
"used."
msgstr ""
"Вираз ``yield`` або ``yield from``. Оскільки це вирази, їх потрібно "
"загорнути у вузол :class:`Expr`, якщо надіслане значення не використовується."

#: ../../library/ast.rst:1397
msgid ""
"``global`` and ``nonlocal`` statements. ``names`` is a list of raw strings."
msgstr ""
"``глобальні`` і ``нелокальні`` заяви. ``names`` - це список необроблених "
"рядків."

#: ../../library/ast.rst:1424
msgid "A class definition."
msgstr "Визначення класу."

#: ../../library/ast.rst:1426
msgid "``name`` is a raw string for the class name"
msgstr "``name`` - це необроблений рядок для імені класу"

#: ../../library/ast.rst:1427
msgid "``bases`` is a list of nodes for explicitly specified base classes."
msgstr "``бази`` - це список вузлів для явно визначених базових класів."

#: ../../library/ast.rst:1428
msgid ""
"``keywords`` is a list of :class:`keyword` nodes, principally for "
"'metaclass'. Other keywords will be passed to the metaclass, as per "
"`PEP-3115 <https://www.python.org/dev/peps/pep-3115/>`_."
msgstr ""
"``keywords`` є списком вузлів :class:`keyword`, в основному для 'metaclass'. "
"Інші ключові слова будуть передані до метакласу, згідно з `PEP-3115 <https://"
"www.python.org/dev/peps/pep-3115/>`_."

#: ../../library/ast.rst:1431
msgid ""
"``starargs`` and ``kwargs`` are each a single node, as in a function call. "
"starargs will be expanded to join the list of base classes, and kwargs will "
"be passed to the metaclass."
msgstr ""
"``starargs`` і ``kwargs`` є окремим вузлом, як у виклику функції. starargs "
"буде розширено до списку базових класів, а kwargs буде передано до метакласу."

#: ../../library/ast.rst:1434
msgid ""
"``body`` is a list of nodes representing the code within the class "
"definition."
msgstr "``body`` - це список вузлів, що представляють код у визначенні класу."

#: ../../library/ast.rst:1436
msgid "``decorator_list`` is a list of nodes, as in :class:`FunctionDef`."
msgstr "``decorator_list`` - це список вузлів, як у :class:`FunctionDef`."

#: ../../library/ast.rst:1465
msgid "Async and await"
msgstr "Async і очікування"

#: ../../library/ast.rst:1469
msgid ""
"An ``async def`` function definition. Has the same fields as :class:"
"`FunctionDef`."
msgstr ""
"Визначення функції ``async def``. Має ті самі поля, що й :class:"
"`FunctionDef`."

#: ../../library/ast.rst:1475
msgid ""
"An ``await`` expression. ``value`` is what it waits for. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"Вираз ``очікування``. ``value`` це те, на що він чекає. Дійсний лише в тілі :"
"class:`AsyncFunctionDef`."

#: ../../library/ast.rst:1508
msgid ""
"``async for`` loops and ``async with`` context managers. They have the same "
"fields as :class:`For` and :class:`With`, respectively. Only valid in the "
"body of an :class:`AsyncFunctionDef`."
msgstr ""
"``async for`` цикли ``async with`` контекстні менеджери. Вони мають ті самі "
"поля, що й :class:`For` і :class:`With` відповідно. Дійсний лише в тілі :"
"class:`AsyncFunctionDef`."

#: ../../library/ast.rst:1513
msgid ""
"When a string is parsed by :func:`ast.parse`, operator nodes (subclasses of :"
"class:`ast.operator`, :class:`ast.unaryop`, :class:`ast.cmpop`, :class:`ast."
"boolop` and :class:`ast.expr_context`) on the returned tree will be "
"singletons. Changes to one will be reflected in all other occurrences of the "
"same value (e.g. :class:`ast.Add`)."
msgstr ""
"Коли рядок аналізується :func:`ast.parse`, вузли оператора (підкласи :class:"
"`ast.operator`, :class:`ast.unaryop`, :class:`ast.cmpop`, :class:`ast."
"boolop` і :class:`ast.expr_context`) у повернутому дереві будуть одиночними "
"елементами. Зміни в одному буде відображено в усіх інших входженнях того "
"самого значення (наприклад, :class:`ast.Add`)."

#: ../../library/ast.rst:1521
msgid ":mod:`ast` Helpers"
msgstr ":mod:`ast` Помічники"

#: ../../library/ast.rst:1523
msgid ""
"Apart from the node classes, the :mod:`ast` module defines these utility "
"functions and classes for traversing abstract syntax trees:"
msgstr ""
"Окрім класів вузлів, модуль :mod:`ast` визначає ці службові функції та класи "
"для обходу абстрактних синтаксичних дерев:"

#: ../../library/ast.rst:1528
msgid ""
"Parse the source into an AST node.  Equivalent to ``compile(source, "
"filename, mode, ast.PyCF_ONLY_AST)``."
msgstr ""
"Розберіть джерело на вузол AST. Еквівалент ``compile(source, filename, mode, "
"ast.PyCF_ONLY_AST)``."

#: ../../library/ast.rst:1531
msgid ""
"If ``type_comments=True`` is given, the parser is modified to check and "
"return type comments as specified by :pep:`484` and :pep:`526`. This is "
"equivalent to adding :data:`ast.PyCF_TYPE_COMMENTS` to the flags passed to :"
"func:`compile()`.  This will report syntax errors for misplaced type "
"comments.  Without this flag, type comments will be ignored, and the "
"``type_comment`` field on selected AST nodes will always be ``None``.  In "
"addition, the locations of ``# type: ignore`` comments will be returned as "
"the ``type_ignores`` attribute of :class:`Module` (otherwise it is always an "
"empty list)."
msgstr ""
"Якщо задано ``type_comments=True``, аналізатор змінюється, щоб перевіряти та "
"повертати коментарі типу, як зазначено :pep:`484` і :pep:`526`. Це "
"еквівалентно додаванню :data:`ast.PyCF_TYPE_COMMENTS` до прапорів, переданих "
"у :func:`compile()`. Це повідомить про синтаксичні помилки для коментарів "
"неправильного типу. Без цього прапорця коментарі типу ігноруватимуться, а "
"поле ``type_comment`` на вибраних вузлах AST завжди матиме значення "
"``None``. Крім того, розташування коментарів ``# type: ignore`` "
"повертатиметься як атрибут ``type_ignores`` :class:`Module` (інакше це "
"завжди порожній список)."

#: ../../library/ast.rst:1541
msgid ""
"In addition, if ``mode`` is ``'func_type'``, the input syntax is modified to "
"correspond to :pep:`484` \"signature type comments\", e.g. ``(str, int) -> "
"List[str]``."
msgstr ""
"Крім того, якщо ``mode`` є ``'func_type'``, синтаксис введення змінюється "
"відповідно до :pep:`484` \"коментарів типу підпису\", напр. ``(str, int) -> "
"Список[str]``."

#: ../../library/ast.rst:1545
msgid ""
"Also, setting ``feature_version`` to a tuple ``(major, minor)`` will attempt "
"to parse using that Python version's grammar. Currently ``major`` must equal "
"to ``3``.  For example, setting ``feature_version=(3, 4)`` will allow the "
"use of ``async`` and ``await`` as variable names.  The lowest supported "
"version is ``(3, 4)``; the highest is ``sys.version_info[0:2]``."
msgstr ""
"Крім того, встановлення ``feature_version`` на кортеж ``(major, minor)`` "
"спробує проаналізувати за допомогою граматики цієї версії Python. Наразі "
"``major`` має дорівнювати ``3``. Наприклад, встановлення "
"``feature_version=(3, 4)`` дозволить використовувати ``async`` і ``await`` "
"як імена змінних. Найменша підтримувана версія – ``(3, 4)``; найвищий — "
"``sys.version_info[0:2]``."

#: ../../library/ast.rst:1552
msgid ""
"If source contains a null character ('\\0'), :exc:`ValueError` is raised."
msgstr ""
"Якщо джерело містить нульовий символ ('\\0'), виникає :exc:`ValueError`."

#: ../../library/ast.rst:1555
msgid ""
"Note that successfully parsing source code into an AST object doesn't "
"guarantee that the source code provided is valid Python code that can be "
"executed as the compilation step can raise further :exc:`SyntaxError` "
"exceptions. For instance, the source ``return 42`` generates a valid AST "
"node for a return statement, but it cannot be compiled alone (it needs to be "
"inside a function node)."
msgstr ""
"Зауважте, що успішний розбір вихідного коду в об’єкт AST не гарантує, що "
"наданий вихідний код є дійсним кодом Python, який можна виконати, оскільки "
"етап компіляції може викликати подальші винятки :exc:`SyntaxError`. "
"Наприклад, вихідний ``return 42`` генерує дійсний вузол AST для оператора "
"return, але його не можна скомпілювати окремо (він має бути всередині "
"функціонального вузла)."

#: ../../library/ast.rst:1562
msgid ""
"In particular, :func:`ast.parse` won't do any scoping checks, which the "
"compilation step does."
msgstr ""
"Зокрема, :func:`ast.parse` не виконуватиме жодних перевірок обсягу, що "
"робить крок компіляції."

#: ../../library/ast.rst:1566
msgid ""
"It is possible to crash the Python interpreter with a sufficiently large/"
"complex string due to stack depth limitations in Python's AST compiler."
msgstr ""
"Можливий збій інтерпретатора Python із досить великим/складним рядком через "
"обмеження глибини стеку в компіляторі AST Python."

#: ../../library/ast.rst:1570
msgid "Added ``type_comments``, ``mode='func_type'`` and ``feature_version``."
msgstr "Додано ``type_comments``, ``mode='func_type'`` і ``feature_version``."

#: ../../library/ast.rst:1576
msgid ""
"Unparse an :class:`ast.AST` object and generate a string with code that "
"would produce an equivalent :class:`ast.AST` object if parsed back with :"
"func:`ast.parse`."
msgstr ""
"Розберіть об’єкт :class:`ast.AST` і згенеруйте рядок із кодом, який створить "
"еквівалентний об’єкт :class:`ast.AST`, якщо його проаналізувати назад за "
"допомогою :func:`ast.parse`."

#: ../../library/ast.rst:1581
msgid ""
"The produced code string will not necessarily be equal to the original code "
"that generated the :class:`ast.AST` object (without any compiler "
"optimizations, such as constant tuples/frozensets)."
msgstr ""
"Створений рядок коду не обов’язково дорівнюватиме вихідному коду, який "
"згенерував об’єкт :class:`ast.AST` (без будь-яких оптимізацій компілятора, "
"таких як константні кортежі/заморожені набори)."

#: ../../library/ast.rst:1586
msgid ""
"Trying to unparse a highly complex expression would result with :exc:"
"`RecursionError`."
msgstr ""
"Спроба розібрати дуже складний вираз призведе до :exc:`RecursionError`."

#: ../../library/ast.rst:1594
msgid ""
"Evaluate an expression node or a string containing only a Python literal or "
"container display.  The string or node provided may only consist of the "
"following Python literal structures: strings, bytes, numbers, tuples, lists, "
"dicts, sets, booleans, and ``None``."
msgstr ""

#: ../../library/ast.rst:1599
msgid ""
"This can be used for evaluating strings containing Python values without the "
"need to parse the values oneself.  It is not capable of evaluating "
"arbitrarily complex expressions, for example involving operators or indexing."
msgstr ""

#: ../../library/ast.rst:1604
msgid ""
"This function had been documented as \"safe\" in the past without defining "
"what that meant. That was misleading. This is specifically designed not to "
"execute Python code, unlike the more general :func:`eval`. There is no "
"namespace, no name lookups, or ability to call out. But it is not free from "
"attack: A relatively small input can lead to memory exhaustion or to C stack "
"exhaustion, crashing the process. There is also the possibility for "
"excessive CPU consumption denial of service on some inputs. Calling it on "
"untrusted data is thus not recommended."
msgstr ""

#: ../../library/ast.rst:1614
msgid ""
"It is possible to crash the Python interpreter due to stack depth "
"limitations in Python's AST compiler."
msgstr ""

#: ../../library/ast.rst:1617
msgid "Now allows bytes and set literals."
msgstr "Тепер дозволяє байти та встановлені літерали."

#: ../../library/ast.rst:1620
msgid "Now supports creating empty sets with ``'set()'``."
msgstr ""
"Тепер підтримується створення порожніх наборів за допомогою ``'set()'``."

#: ../../library/ast.rst:1626
msgid ""
"Return the docstring of the given *node* (which must be a :class:"
"`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef`, or :class:"
"`Module` node), or ``None`` if it has no docstring. If *clean* is true, "
"clean up the docstring's indentation with :func:`inspect.cleandoc`."
msgstr ""
"Повертає рядок документації даного *вузла* (який має бути :class:"
"`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef` або :class:"
"`Module` вузол), або ``None``, якщо він не має рядка документації. Якщо "
"*clean* має значення true, очистіть відступ у рядку документа за допомогою :"
"func:`inspect.cleandoc`."

#: ../../library/ast.rst:1632
msgid ":class:`AsyncFunctionDef` is now supported."
msgstr ":class:`AsyncFunctionDef` тепер підтримується."

#: ../../library/ast.rst:1638
msgid ""
"Get source code segment of the *source* that generated *node*. If some "
"location information (:attr:`lineno`, :attr:`end_lineno`, :attr:"
"`col_offset`, or :attr:`end_col_offset`) is missing, return ``None``."
msgstr ""
"Отримати сегмент вихідного коду *джерела*, який створив *вузол*. Якщо якась "
"інформація про місцезнаходження (:attr:`lineno`, :attr:`end_lineno`, :attr:"
"`col_offset` або :attr:`end_col_offset`) відсутня, поверніть ``None``."

#: ../../library/ast.rst:1642
msgid ""
"If *padded* is ``True``, the first line of a multi-line statement will be "
"padded with spaces to match its original position."
msgstr ""
"Якщо *paded* має значення ``True``, перший рядок багаторядкового оператора "
"буде доповнено пробілами відповідно до його вихідної позиції."

#: ../../library/ast.rst:1650
msgid ""
"When you compile a node tree with :func:`compile`, the compiler expects :"
"attr:`lineno` and :attr:`col_offset` attributes for every node that supports "
"them.  This is rather tedious to fill in for generated nodes, so this helper "
"adds these attributes recursively where not already set, by setting them to "
"the values of the parent node.  It works recursively starting at *node*."
msgstr ""
"Коли ви компілюєте дерево вузлів за допомогою :func:`compile`, компілятор "
"очікує атрибутів :attr:`lineno` і :attr:`col_offset` для кожного вузла, який "
"їх підтримує. Це досить нудно заповнювати для згенерованих вузлів, тому цей "
"помічник рекурсивно додає ці атрибути там, де ще не встановлено, "
"встановлюючи для них значення батьківського вузла. Він працює рекурсивно, "
"починаючи з *node*."

#: ../../library/ast.rst:1659
msgid ""
"Increment the line number and end line number of each node in the tree "
"starting at *node* by *n*. This is useful to \"move code\" to a different "
"location in a file."
msgstr ""
"Збільште номер рядка та номер кінцевого рядка кожного вузла в дереві, "
"починаючи з *вузла*, на *n*. Це корисно для \"переміщення коду\" в інше "
"місце у файлі."

#: ../../library/ast.rst:1666
msgid ""
"Copy source location (:attr:`lineno`, :attr:`col_offset`, :attr:"
"`end_lineno`, and :attr:`end_col_offset`) from *old_node* to *new_node* if "
"possible, and return *new_node*."
msgstr ""
"Скопіюйте вихідне розташування (:attr:`lineno`, :attr:`col_offset`, :attr:"
"`end_lineno` та :attr:`end_col_offset`) із *old_node* у *new_node*, якщо "
"можливо, і поверніть *new_node*."

#: ../../library/ast.rst:1673
msgid ""
"Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields`` "
"that is present on *node*."
msgstr ""
"Отримайте кортеж ``(fieldname, value)`` для кожного поля ``node._fields``, "
"який присутній на *node*."

#: ../../library/ast.rst:1679
msgid ""
"Yield all direct child nodes of *node*, that is, all fields that are nodes "
"and all items of fields that are lists of nodes."
msgstr ""
"Видає всі прямі дочірні вузли *node*, тобто всі поля, які є вузлами, і всі "
"елементи полів, які є списками вузлів."

#: ../../library/ast.rst:1685
msgid ""
"Recursively yield all descendant nodes in the tree starting at *node* "
"(including *node* itself), in no specified order.  This is useful if you "
"only want to modify nodes in place and don't care about the context."
msgstr ""
"Рекурсивно створювати всі вузли-нащадки в дереві, починаючи з *node* "
"(включаючи сам *node*), у невизначеному порядку. Це корисно, якщо ви хочете "
"лише змінити вузли на місці й не дбаєте про контекст."

#: ../../library/ast.rst:1692
msgid ""
"A node visitor base class that walks the abstract syntax tree and calls a "
"visitor function for every node found.  This function may return a value "
"which is forwarded by the :meth:`visit` method."
msgstr ""
"Базовий клас відвідувача вузла, який проходить абстрактне синтаксичне дерево "
"та викликає функцію відвідувача для кожного знайденого вузла. Ця функція "
"може повертати значення, яке пересилається методом :meth:`visit`."

#: ../../library/ast.rst:1696
msgid ""
"This class is meant to be subclassed, with the subclass adding visitor "
"methods."
msgstr ""
"Цей клас призначений для створення підкласу, який додає методи відвідувачів."

#: ../../library/ast.rst:1701
msgid ""
"Visit a node.  The default implementation calls the method called :samp:"
"`self.visit_{classname}` where *classname* is the name of the node class, "
"or :meth:`generic_visit` if that method doesn't exist."
msgstr ""
"Відвідайте вузол. Стандартна реалізація викликає метод під назвою :samp:"
"`self.visit_{classname}`, де *classname* є назвою класу вузла, або :meth:"
"`generic_visit`, якщо цей метод не існує."

#: ../../library/ast.rst:1707
msgid "This visitor calls :meth:`visit` on all children of the node."
msgstr "Цей відвідувач викликає :meth:`visit` для всіх дітей вузла."

#: ../../library/ast.rst:1709
msgid ""
"Note that child nodes of nodes that have a custom visitor method won't be "
"visited unless the visitor calls :meth:`generic_visit` or visits them itself."
msgstr ""
"Зауважте, що дочірні вузли вузлів, які мають спеціальний метод відвідувача, "
"не будуть відвідані, якщо відвідувач не викличе :meth:`generic_visit` або "
"відвідає їх сам."

#: ../../library/ast.rst:1713
msgid ""
"Don't use the :class:`NodeVisitor` if you want to apply changes to nodes "
"during traversal.  For this a special visitor exists (:class:"
"`NodeTransformer`) that allows modifications."
msgstr ""
"Не використовуйте :class:`NodeVisitor`, якщо ви хочете застосувати зміни до "
"вузлів під час обходу. Для цього існує спеціальний відвідувач (:class:"
"`NodeTransformer`), який дозволяє вносити зміни."

#: ../../library/ast.rst:1719
msgid ""
"Methods :meth:`visit_Num`, :meth:`visit_Str`, :meth:`visit_Bytes`, :meth:"
"`visit_NameConstant` and :meth:`visit_Ellipsis` are deprecated now and will "
"not be called in future Python versions.  Add the :meth:`visit_Constant` "
"method to handle all constant nodes."
msgstr ""
"Методи :meth:`visit_Num`, :meth:`visit_Str`, :meth:`visit_Bytes`, :meth:"
"`visit_NameConstant` і :meth:`visit_Ellipsis` зараз застаріли та не будуть "
"викликатися в майбутніх версіях Python. Додайте метод :meth:`visit_Constant` "
"для обробки всіх постійних вузлів."

#: ../../library/ast.rst:1727
msgid ""
"A :class:`NodeVisitor` subclass that walks the abstract syntax tree and "
"allows modification of nodes."
msgstr ""
"Підклас :class:`NodeVisitor`, який проходить абстрактне синтаксичне дерево "
"та дозволяє модифікувати вузли."

#: ../../library/ast.rst:1730
msgid ""
"The :class:`NodeTransformer` will walk the AST and use the return value of "
"the visitor methods to replace or remove the old node.  If the return value "
"of the visitor method is ``None``, the node will be removed from its "
"location, otherwise it is replaced with the return value.  The return value "
"may be the original node in which case no replacement takes place."
msgstr ""
":class:`NodeTransformer` пройде AST і використає значення, що повертається "
"методами відвідувача, щоб замінити або видалити старий вузол. Якщо "
"значенням, що повертається методом відвідувача, є ``None``, вузол буде "
"видалено зі свого розташування, інакше він замінюється значенням, що "
"повертається. Поверненим значенням може бути вихідний вузол, і в цьому "
"випадку заміна не відбувається."

#: ../../library/ast.rst:1736
msgid ""
"Here is an example transformer that rewrites all occurrences of name lookups "
"(``foo``) to ``data['foo']``::"
msgstr ""
"Ось приклад трансформатора, який переписує всі випадки пошуку імен (``foo``) "
"на ``data['foo']``::"

#: ../../library/ast.rst:1748
msgid ""
"Keep in mind that if the node you're operating on has child nodes you must "
"either transform the child nodes yourself or call the :meth:`generic_visit` "
"method for the node first."
msgstr ""
"Майте на увазі, що якщо вузол, на якому ви працюєте, має дочірні вузли, ви "
"повинні або трансформувати дочірні вузли самостійно, або спочатку викликати "
"метод :meth:`generic_visit` для вузла."

#: ../../library/ast.rst:1752
msgid ""
"For nodes that were part of a collection of statements (that applies to all "
"statement nodes), the visitor may also return a list of nodes rather than "
"just a single node."
msgstr ""
"Для вузлів, які були частиною набору операторів (що стосується всіх вузлів "
"операторів), відвідувач також може повернути список вузлів, а не лише один "
"вузол."

#: ../../library/ast.rst:1756
msgid ""
"If :class:`NodeTransformer` introduces new nodes (that weren't part of "
"original tree) without giving them location information (such as :attr:"
"`lineno`), :func:`fix_missing_locations` should be called with the new sub-"
"tree to recalculate the location information::"
msgstr ""
"Якщо :class:`NodeTransformer` вводить нові вузли (які не були частиною "
"оригінального дерева) без надання інформації про їх розташування "
"(наприклад, :attr:`lineno`), :func:`fix_missing_locations` має бути "
"викликано з новим під- дерево для перерахунку інформації про "
"місцезнаходження::"

#: ../../library/ast.rst:1764
msgid "Usually you use the transformer like this::"
msgstr "Зазвичай ви використовуєте трансформатор таким чином:"

#: ../../library/ast.rst:1771
msgid ""
"Return a formatted dump of the tree in *node*.  This is mainly useful for "
"debugging purposes.  If *annotate_fields* is true (by default), the returned "
"string will show the names and the values for fields. If *annotate_fields* "
"is false, the result string will be more compact by omitting unambiguous "
"field names.  Attributes such as line numbers and column offsets are not "
"dumped by default.  If this is wanted, *include_attributes* can be set to "
"true."
msgstr ""
"Повернути відформатований дамп дерева у *node*. Це в основному корисно для "
"цілей налагодження. Якщо *annotate_fields* має значення true (за "
"замовчуванням), у поверненому рядку відображатимуться імена та значення для "
"полів. Якщо *annotate_fields* має значення false, рядок результату буде "
"більш компактним за рахунок пропуску однозначних імен полів. Такі атрибути, "
"як номери рядків і зміщення стовпців, не скидаються за замовчуванням. Якщо "
"це потрібно, *include_attributes* можна встановити на true."

#: ../../library/ast.rst:1779
msgid ""
"If *indent* is a non-negative integer or string, then the tree will be "
"pretty-printed with that indent level.  An indent level of 0, negative, or "
"``\"\"`` will only insert newlines.  ``None`` (the default) selects the "
"single line representation. Using a positive integer indent indents that "
"many spaces per level.  If *indent* is a string (such as ``\"\\t\"``), that "
"string is used to indent each level."
msgstr ""
"Якщо *indent* є невід’ємним цілим числом або рядком, то дерево буде "
"надруковано з таким рівнем відступу. Рівень відступу 0, негативний або "
"``\"\"`` вставлятиме лише нові рядки. ``None`` (за замовчуванням) вибирає "
"однорядкове представлення. Використання додатного цілого відступу робить "
"стільки відступів на рівень. Якщо *indent* є рядком (наприклад, "
"``\"\\t\"``), цей рядок використовується для відступу кожного рівня."

#: ../../library/ast.rst:1786
msgid "Added the *indent* option."
msgstr "Додано параметр *відступ*."

#: ../../library/ast.rst:1793
msgid "Compiler Flags"
msgstr "Прапори компілятора"

#: ../../library/ast.rst:1795
msgid ""
"The following flags may be passed to :func:`compile` in order to change "
"effects on the compilation of a program:"
msgstr ""
"Наступні прапорці можуть бути передані :func:`compile`, щоб змінити вплив на "
"компіляцію програми:"

#: ../../library/ast.rst:1800
msgid ""
"Enables support for top-level ``await``, ``async for``, ``async with`` and "
"async comprehensions."
msgstr ""
"Вмикає підтримку ``await`` верхнього рівня, ``async for``, ``async with`` та "
"асинхронне розуміння."

#: ../../library/ast.rst:1807
msgid ""
"Generates and returns an abstract syntax tree instead of returning a "
"compiled code object."
msgstr ""
"Створює та повертає абстрактне синтаксичне дерево замість повернення "
"скомпільованого об’єкта коду."

#: ../../library/ast.rst:1812
msgid ""
"Enables support for :pep:`484` and :pep:`526` style type comments (``# type: "
"<type>``, ``# type: ignore <stuff>``)."
msgstr ""
"Вмикає підтримку коментарів типу :pep:`484` і :pep:`526` (``# type: "
"<type>``, ``# type: ignore <stuff>``)."

#: ../../library/ast.rst:1821
msgid "Command-Line Usage"
msgstr "Використання командного рядка"

#: ../../library/ast.rst:1825
msgid ""
"The :mod:`ast` module can be executed as a script from the command line. It "
"is as simple as:"
msgstr ""
"Модуль :mod:`ast` можна запустити як скрипт із командного рядка. Це так "
"просто:"

#: ../../library/ast.rst:1832
msgid "The following options are accepted:"
msgstr "Приймаються такі варіанти:"

#: ../../library/ast.rst:1838
msgid "Show the help message and exit."
msgstr "Показати довідкове повідомлення та вийти."

#: ../../library/ast.rst:1843
msgid ""
"Specify what kind of code must be compiled, like the *mode* argument in :"
"func:`parse`."
msgstr ""
"Укажіть тип коду, який потрібно скомпілювати, наприклад аргумент *mode* у :"
"func:`parse`."

#: ../../library/ast.rst:1848
msgid "Don't parse type comments."
msgstr "Не аналізуйте коментарі типу."

#: ../../library/ast.rst:1852
msgid "Include attributes such as line numbers and column offsets."
msgstr "Додайте такі атрибути, як номери рядків і зміщення стовпців."

#: ../../library/ast.rst:1857
msgid "Indentation of nodes in AST (number of spaces)."
msgstr "Відступ вузлів в AST (кількість пробілів)."

#: ../../library/ast.rst:1859
msgid ""
"If :file:`infile` is specified its contents are parsed to AST and dumped to "
"stdout.  Otherwise, the content is read from stdin."
msgstr ""
"Якщо вказано :file:`infile`, його вміст аналізується в AST і скидається в "
"stdout. В іншому випадку вміст читається зі стандартного вводу."

#: ../../library/ast.rst:1865
msgid ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, an external "
"documentation resource, has good details on working with Python ASTs."
msgstr ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, зовнішній "
"ресурс документації, містить хороші відомості про роботу з Python AST."

#: ../../library/ast.rst:1868
msgid ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ "
"annotates Python ASTs with the positions of tokens and text in the source "
"code that generated them. This is helpful for tools that make source code "
"transformations."
msgstr ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_ "
"анотує AST Python за допомогою позицій токенів і тексту у вихідному коді, "
"який їх створив. Це корисно для інструментів, які здійснюють перетворення "
"вихідного коду."

#: ../../library/ast.rst:1873
msgid ""
"`leoAst.py <http://leoeditor.com/appendices.html#leoast-py>`_ unifies the "
"token-based and parse-tree-based views of python programs by inserting two-"
"way links between tokens and ast nodes."
msgstr ""
"`leoAst.py <http://leoeditor.com/appendices.html#leoast-py>`_ об’єднує "
"представлення програм на Python на основі токенів і дерева розбору, "
"вставляючи двосторонні посилання між токенами та вузлами ast."

#: ../../library/ast.rst:1877
msgid ""
"`LibCST <https://libcst.readthedocs.io/>`_ parses code as a Concrete Syntax "
"Tree that looks like an ast tree and keeps all formatting details. It's "
"useful for building automated refactoring (codemod) applications and linters."
msgstr ""
"`LibCST <https://libcst.readthedocs.io/>`_ аналізує код як конкретне "
"синтаксичне дерево, яке виглядає як дерево ast і зберігає всі деталі "
"форматування. Це корисно для створення додатків і лінтерів для "
"автоматизованого рефакторинга (codemod)."

#: ../../library/ast.rst:1882
msgid ""
"`Parso <https://parso.readthedocs.io>`_ is a Python parser that supports "
"error recovery and round-trip parsing for different Python versions (in "
"multiple Python versions). Parso is also able to list multiple syntax errors "
"in your python file."
msgstr ""
"`Parso <https://parso.readthedocs.io>`_ — це аналізатор Python, який "
"підтримує відновлення помилок і двосторонній аналіз для різних версій Python "
"(у кількох версіях Python). Parso також може перелічувати численні "
"синтаксичні помилки у вашому файлі python."
