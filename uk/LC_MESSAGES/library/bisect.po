# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-21 22:20+0000\n"
"PO-Revision-Date: 2023-05-24 02:13+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../library/bisect.rst:2
msgid ":mod:`bisect` --- Array bisection algorithm"
msgstr ":mod:`bisect` --- Алгоритм поділу масиву навпіл"

#: ../../library/bisect.rst:10
msgid "**Source code:** :source:`Lib/bisect.py`"
msgstr "**Вихідний код:** :source:`Lib/bisect.py`"

#: ../../library/bisect.rst:14
msgid ""
"This module provides support for maintaining a list in sorted order without "
"having to sort the list after each insertion.  For long lists of items with "
"expensive comparison operations, this can be an improvement over the more "
"common approach.  The module is called :mod:`bisect` because it uses a basic "
"bisection algorithm to do its work.  The source code may be most useful as a "
"working example of the algorithm (the boundary conditions are already "
"right!)."
msgstr ""
"Цей модуль забезпечує підтримку підтримки списку в порядку сортування без "
"необхідності сортувати список після кожного вставлення. Для довгих списків "
"елементів із дорогими операціями порівняння це може бути покращенням "
"порівняно з більш поширеним підходом. Модуль називається :mod:`bisect`, "
"оскільки для виконання своєї роботи він використовує базовий алгоритм поділу "
"навпіл. Вихідний код може бути найбільш корисним як робочий приклад "
"алгоритму (граничні умови вже правильні!)."

#: ../../library/bisect.rst:23
msgid "The following functions are provided:"
msgstr "Передбачені такі функції:"

#: ../../library/bisect.rst:28
msgid ""
"Locate the insertion point for *x* in *a* to maintain sorted order. The "
"parameters *lo* and *hi* may be used to specify a subset of the list which "
"should be considered; by default the entire list is used.  If *x* is already "
"present in *a*, the insertion point will be before (to the left of) any "
"existing entries.  The return value is suitable for use as the first "
"parameter to ``list.insert()`` assuming that *a* is already sorted."
msgstr ""
"Знайдіть точку вставки для *x* у *a*, щоб зберегти відсортований порядок. "
"Параметри *lo* і *hi* можуть використовуватися для визначення підмножини "
"списку, яку слід враховувати; за замовчуванням використовується весь список. "
"Якщо *x* уже присутній у *a*, точка вставки буде перед будь-якими існуючими "
"записами (зліва від них). Повернене значення придатне для використання як "
"перший параметр для ``list.insert()`` за умови, що *a* вже відсортовано."

#: ../../library/bisect.rst:35
msgid ""
"The returned insertion point *i* partitions the array *a* into two halves so "
"that ``all(val < x for val in a[lo : i])`` for the left side and ``all(val "
">= x for val in a[i : hi])`` for the right side."
msgstr ""
"Повернена точка вставки *i* ділить масив *a* на дві половини так, що "
"``all(val < x for val in a[lo : i])`` for the left side and ``all(val > = x "
"for val in a[i : hi])`` для правої сторони."

#: ../../library/bisect.rst:39 ../../library/bisect.rst:60
msgid ""
"*key* specifies a :term:`key function` of one argument that is used to "
"extract a comparison key from each element in the array.  To support "
"searching complex records, the key function is not applied to the *x* value."
msgstr ""
"*key* визначає :term:`key function` одного аргументу, який використовується "
"для отримання ключа порівняння з кожного елемента в масиві. Для підтримки "
"пошуку складних записів функція ключа не застосовується до значення *x*."

#: ../../library/bisect.rst:43 ../../library/bisect.rst:64
msgid ""
"If *key* is ``None``, the elements are compared directly with no intervening "
"function call."
msgstr ""
"Якщо *key* має значення ``None``, елементи порівнюються безпосередньо без "
"виклику функції."

#: ../../library/bisect.rst:46 ../../library/bisect.rst:67
#: ../../library/bisect.rst:85 ../../library/bisect.rst:105
msgid "Added the *key* parameter."
msgstr "Додано параметр *key*."

#: ../../library/bisect.rst:53
msgid ""
"Similar to :py:func:`~bisect.bisect_left`, but returns an insertion point "
"which comes after (to the right of) any existing entries of *x* in *a*."
msgstr ""
"Аналогічно до  :py:func:`~bisect.bisect_left`, але повертає точку вставки, "
"що іде після (праворуч від) усіх наявних входжень *x* у *a*."

#: ../../library/bisect.rst:56
msgid ""
"The returned insertion point *i* partitions the array *a* into two halves so "
"that ``all(val <= x for val in a[lo : i])`` for the left side and ``all(val "
"> x for val in a[i : hi])`` for the right side."
msgstr ""
"Повернена точка вставки *i* ділить масив *a* на дві половини так, що "
"``all(val <= x for val in a[lo : i])`` for the left side and ``all(val > x "
"for val in a[i : hi])`` для правої сторони."

#: ../../library/bisect.rst:73
msgid "Insert *x* in *a* in sorted order."
msgstr "Вставте *x* у *a* в порядку сортування."

#: ../../library/bisect.rst:75
msgid ""
"This function first runs :py:func:`~bisect.bisect_left` to locate an "
"insertion point. Next, it runs the :meth:`!insert` method on *a* to insert "
"*x* at the appropriate position to maintain sort order."
msgstr ""
"Ця функція спершу виконує :py:func:`~bisect.bisect_left`, щоб знайти точку "
"вставлення. Тоді вона виконує метод :meth:`!insert` для *a*, щоб вставити "
"*x* у відповідну позицію для підтримання порядку сортування."

#: ../../library/bisect.rst:79 ../../library/bisect.rst:99
msgid ""
"To support inserting records in a table, the *key* function (if any) is "
"applied to *x* for the search step but not for the insertion step."
msgstr ""
"Щоб підтримувати вставлення записів у таблицю, функція *key* (якщо є) "
"застосовується до *x* для кроку пошуку, але не для кроку вставки."

#: ../../library/bisect.rst:82 ../../library/bisect.rst:102
msgid ""
"Keep in mind that the *O*\\ (log *n*) search is dominated by the slow *O*\\ "
"(*n*) insertion step."
msgstr ""
"Зверніть увагу, що пошук за *O*\\ (log *n*) є швидким порівняно з кроком "
"вставлення за *O*\\ (*n*)."

#: ../../library/bisect.rst:92
msgid ""
"Similar to :py:func:`~bisect.insort_left`, but inserting *x* in *a* after "
"any existing entries of *x*."
msgstr ""
"Аналогічно до :py:func:`~bisect.insort_left`, але вставляє *x* у *a* після "
"усіх наявних входжень *x*."

#: ../../library/bisect.rst:95
msgid ""
"This function first runs :py:func:`~bisect.bisect_right` to locate an "
"insertion point. Next, it runs the :meth:`!insert` method on *a* to insert "
"*x* at the appropriate position to maintain sort order."
msgstr ""
"Ця функція спершу виконує :py:func:`~bisect.bisect_right`, щоб знайти точку "
"вставлення. Тоді вона виконує метод :meth:`!insert` для *a*, щоб вставити "
"*x* у відповідну позицію для підтримання порядку сортування."

#: ../../library/bisect.rst:110
msgid "Performance Notes"
msgstr "Примітки щодо продуктивності"

#: ../../library/bisect.rst:112
msgid ""
"When writing time sensitive code using *bisect()* and *insort()*, keep these "
"thoughts in mind:"
msgstr ""
"Під час написання чутливого до часу коду за допомогою *bisect()* і "
"*insort()* пам’ятайте про такі думки:"

#: ../../library/bisect.rst:115
msgid ""
"Bisection is effective for searching ranges of values. For locating specific "
"values, dictionaries are more performant."
msgstr ""
"Ділення навпіл ефективне для пошуку діапазонів значень. Для пошуку "
"конкретних значень словники більш ефективні."

#: ../../library/bisect.rst:118
msgid ""
"The *insort()* functions are *O*\\ (*n*) because the logarithmic search step "
"is dominated by the linear time insertion step."
msgstr ""
"Функції *insort()* мають складність *O*\\ (*n*), бо логарифмічний час кроку "
"пошуку нівелюється лінійним часом кроку вставлення."

#: ../../library/bisect.rst:121
msgid ""
"The search functions are stateless and discard key function results after "
"they are used.  Consequently, if the search functions are used in a loop, "
"the key function may be called again and again on the same array elements. "
"If the key function isn't fast, consider wrapping it with :py:func:"
"`functools.cache` to avoid duplicate computations.  Alternatively, consider "
"searching an array of precomputed keys to locate the insertion point (as "
"shown in the examples section below)."
msgstr ""
"Функції пошуку не мають стану і видаляють результати, повернуті ключовою "
"функцією, після використання. Як наслідок, якщо функції пошуку "
"використовуються в циклі, ключова функція може бути застосована кілька разів "
"до одних і тих самих елементів масиву. Якщо ключова функція недостатньо "
"швидка, розгляньте можливість обгортання її у :py:func:`functools.cache` для "
"уникання повторних обчислень. Як альтернативу, розгляньте пошук у масиві "
"заздалегідь обчислених ключів для пошуку точки вставлення (як показано у "
"секції прикладів нижче)."

#: ../../library/bisect.rst:131
msgid ""
"`Sorted Collections <https://grantjenks.com/docs/sortedcollections/>`_ is a "
"high performance module that uses *bisect* to managed sorted collections of "
"data."
msgstr ""
"`Sorted Collections <https://grantjenks.com/docs/sortedcollections/>`_ - це "
"високопродуктивний модуль, який використовує *bisect* для керування "
"відсортованими колекціями даних."

#: ../../library/bisect.rst:135
msgid ""
"The `SortedCollection recipe <https://code.activestate.com/recipes/577197-"
"sortedcollection/>`_ uses bisect to build a full-featured collection class "
"with straight-forward search methods and support for a key-function.  The "
"keys are precomputed to save unnecessary calls to the key function during "
"searches."
msgstr ""
"`Рецепт SortedCollection <https://code.activestate.com/recipes/577197-"
"sortedcollection/>`_ використовує bisect для створення повнофункціонального "
"класу колекції з прямими методами пошуку та підтримкою функції ключа. Ключі "
"попередньо обчислені, щоб уникнути непотрібних викликів функції клавіш під "
"час пошуку."

#: ../../library/bisect.rst:143
msgid "Searching Sorted Lists"
msgstr "Пошук у відсортованих списках"

#: ../../library/bisect.rst:145
msgid ""
"The above `bisect functions`_ are useful for finding insertion points but "
"can be tricky or awkward to use for common searching tasks. The following "
"five functions show how to transform them into the standard lookups for "
"sorted lists::"
msgstr ""
"Наведені вище `функції bisect`_ корисні для пошуку точок вставки, але можуть "
"бути складними або незручними для використання у звичайних завданнях пошуку. "
"Наступні п'ять функцій показують, як перетворити їх на стандартний пошук у "
"відсортованих списках::"

#: ../../library/bisect.rst:187
msgid "Examples"
msgstr "Приклади"

#: ../../library/bisect.rst:191
msgid ""
"The :py:func:`~bisect.bisect` function can be useful for numeric table "
"lookups. This example uses :py:func:`~bisect.bisect` to look up a letter "
"grade for an exam score (say) based on a set of ordered numeric breakpoints: "
"90 and up is an 'A', 80 to 89 is a 'B', and so on::"
msgstr ""
"Функція :py:func:`~bisect.bisect` може бути корисною для пошуку у числових "
"таблицях. У цьому прикладі використовується :py:func:`~bisect.bisect` для "
"пошуку літерної оцінки за іспит (скажімо) на основі набору впорядкованих "
"числових точок розбиття: 90 і вище - це \"A\", від 80 до 89 - \"B\", і так "
"далі:"

#: ../../library/bisect.rst:203
msgid ""
"The :py:func:`~bisect.bisect` and :py:func:`~bisect.insort` functions also "
"work with lists of tuples.  The *key* argument can serve to extract the "
"field used for ordering records in a table::"
msgstr ""
"Фунеції :py:func:`~bisect.bisect` та :py:func:`~bisect.insort`  також "
"працюють зі списками кортежів.  За допомогою аргумента *key* можна виділити "
"поле, яке використовується для впорядкування записів у таблиці::"

#: ../../library/bisect.rst:237
msgid ""
"If the key function is expensive, it is possible to avoid repeated function "
"calls by searching a list of precomputed keys to find the index of a record::"
msgstr ""
"Якщо функція ключа є дорогою, можна уникнути повторних викликів функції "
"шляхом пошуку списку попередньо обчислених ключів, щоб знайти індекс запису::"
