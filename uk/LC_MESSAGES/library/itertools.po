# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-28 16:12+0000\n"
"PO-Revision-Date: 2022-11-05 17:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../library/itertools.rst:2
msgid ":mod:`itertools` --- Functions creating iterators for efficient looping"
msgstr ""
":mod:`itertools` --- Функції, що створюють ітератори для ефективного циклу"

#: ../../library/itertools.rst:16
msgid ""
"This module implements a number of :term:`iterator` building blocks inspired "
"by constructs from APL, Haskell, and SML.  Each has been recast in a form "
"suitable for Python."
msgstr ""
"Цей модуль реалізує кілька будівельних блоків :term:`iterator`, натхненних "
"конструкціями з APL, Haskell і SML. Кожен був перероблений у формі, "
"придатній для Python."

#: ../../library/itertools.rst:20
msgid ""
"The module standardizes a core set of fast, memory efficient tools that are "
"useful by themselves or in combination.  Together, they form an \"iterator "
"algebra\" making it possible to construct specialized tools succinctly and "
"efficiently in pure Python."
msgstr ""
"Модуль стандартизує основний набір швидких, ефективних інструментів пам’яті, "
"які корисні окремо або в комбінації. Разом вони утворюють \"алгебру "
"ітераторів\", що дає змогу створювати спеціалізовані інструменти лаконічно "
"та ефективно на чистому Python."

#: ../../library/itertools.rst:25
msgid ""
"For instance, SML provides a tabulation tool: ``tabulate(f)`` which produces "
"a sequence ``f(0), f(1), ...``.  The same effect can be achieved in Python "
"by combining :func:`map` and :func:`count` to form ``map(f, count())``."
msgstr ""
"Наприклад, SML надає інструмент табуляції: ``tabulate(f)``, який створює "
"послідовність ``f(0), f(1), ...``. Такого ж ефекту можна досягти в Python, "
"об’єднавши :func:`map` і :func:`count` для формування ``map(f, count())``."

#: ../../library/itertools.rst:29
msgid ""
"These tools and their built-in counterparts also work well with the high-"
"speed functions in the :mod:`operator` module.  For example, the "
"multiplication operator can be mapped across two vectors to form an "
"efficient dot-product: ``sum(map(operator.mul, vector1, vector2))``."
msgstr ""
"Ці інструменти та їхні вбудовані аналоги також добре працюють із "
"високошвидкісними функціями в модулі :mod:`operator`. Наприклад, оператор "
"множення можна відобразити на два вектори для формування ефективного "
"скалярного добутку: ``sum(map(operator.mul, vector1, vector2))``."

#: ../../library/itertools.rst:35
msgid "**Infinite iterators:**"
msgstr "**Нескінченні ітератори:**"

#: ../../library/itertools.rst:38 ../../library/itertools.rst:48
#: ../../library/itertools.rst:68
msgid "Iterator"
msgstr "Ітератор"

#: ../../library/itertools.rst:38 ../../library/itertools.rst:48
#: ../../library/itertools.rst:68
msgid "Arguments"
msgstr "Аргументи"

#: ../../library/itertools.rst:38 ../../library/itertools.rst:48
#: ../../library/itertools.rst:68 ../../library/itertools.rst:77
msgid "Results"
msgstr "Результати"

#: ../../library/itertools.rst:38 ../../library/itertools.rst:48
msgid "Example"
msgstr "приклад"

#: ../../library/itertools.rst:40
msgid ":func:`count`"
msgstr ":func:`count`"

#: ../../library/itertools.rst:40
msgid "start, [step]"
msgstr "початок, [крок]"

#: ../../library/itertools.rst:40
msgid "start, start+step, start+2*step, ..."
msgstr "початок, початок+крок, початок+2*крок, ..."

#: ../../library/itertools.rst:40
msgid "``count(10) --> 10 11 12 13 14 ...``"
msgstr "``count(10) --> 10 11 12 13 14 ...``"

#: ../../library/itertools.rst:41
msgid ":func:`cycle`"
msgstr ":func:`cycle`"

#: ../../library/itertools.rst:41
msgid "p"
msgstr "p"

#: ../../library/itertools.rst:41
msgid "p0, p1, ... plast, p0, p1, ..."
msgstr "p0, p1, ... plast, p0, p1, ..."

#: ../../library/itertools.rst:41
msgid "``cycle('ABCD') --> A B C D A B C D ...``"
msgstr "``цикл('ABCD') --> A B C D A B C D ...``"

#: ../../library/itertools.rst:42
msgid ":func:`repeat`"
msgstr ":func:`repeat`"

#: ../../library/itertools.rst:42
msgid "elem [,n]"
msgstr "елемент [,n]"

#: ../../library/itertools.rst:42
msgid "elem, elem, elem, ... endlessly or up to n times"
msgstr "елем, елем, елем, ... нескінченно або до n разів"

#: ../../library/itertools.rst:42
msgid "``repeat(10, 3) --> 10 10 10``"
msgstr "``повторити(10, 3) --> 10 10 10``"

#: ../../library/itertools.rst:45
msgid "**Iterators terminating on the shortest input sequence:**"
msgstr "**Ітератори, що завершуються на найкоротшій вхідній послідовності:**"

#: ../../library/itertools.rst:50
msgid ":func:`accumulate`"
msgstr ":func:`accumulate`"

#: ../../library/itertools.rst:50
msgid "p [,func]"
msgstr "p [,func]"

#: ../../library/itertools.rst:50
msgid "p0, p0+p1, p0+p1+p2, ..."
msgstr "p0, p0+p1, p0+p1+p2, ..."

#: ../../library/itertools.rst:50
msgid "``accumulate([1,2,3,4,5]) --> 1 3 6 10 15``"
msgstr "``накопичувати([1,2,3,4,5]) --> 1 3 6 10 15``"

#: ../../library/itertools.rst:51
msgid ":func:`chain`"
msgstr ":func:`chain`"

#: ../../library/itertools.rst:51 ../../library/itertools.rst:62
msgid "p, q, ..."
msgstr "p, q, ..."

#: ../../library/itertools.rst:51 ../../library/itertools.rst:52
msgid "p0, p1, ... plast, q0, q1, ..."
msgstr "p0, p1, ... plast, q0, q1, ..."

#: ../../library/itertools.rst:51
msgid "``chain('ABC', 'DEF') --> A B C D E F``"
msgstr "``ланцюг('ABC', 'DEF') --> A B C D E F``"

#: ../../library/itertools.rst:52
msgid ":func:`chain.from_iterable`"
msgstr ":func:`chain.from_iterable`"

#: ../../library/itertools.rst:52 ../../library/itertools.rst:58
msgid "iterable"
msgstr "ітерований"

#: ../../library/itertools.rst:52
msgid "``chain.from_iterable(['ABC', 'DEF']) --> A B C D E F``"
msgstr "``chain.from_iterable(['ABC', 'DEF']) --> A B C D E F``"

#: ../../library/itertools.rst:53
msgid ":func:`compress`"
msgstr ":func:`compress`"

#: ../../library/itertools.rst:53
msgid "data, selectors"
msgstr "дані, селектори"

#: ../../library/itertools.rst:53
msgid "(d[0] if s[0]), (d[1] if s[1]), ..."
msgstr "(d[0], якщо s[0]), (d[1], якщо s[1]), ..."

#: ../../library/itertools.rst:53
msgid "``compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F``"
msgstr "``стиснути('ABCDEF', [1,0,1,0,1,1]) --> A C E F``"

#: ../../library/itertools.rst:54
msgid ":func:`dropwhile`"
msgstr ":func:`dropwhile`"

#: ../../library/itertools.rst:54 ../../library/itertools.rst:55
#: ../../library/itertools.rst:60
msgid "pred, seq"
msgstr "перед, посл"

#: ../../library/itertools.rst:54
msgid "seq[n], seq[n+1], starting when pred fails"
msgstr "seq[n], seq[n+1], починаючи з невдачі pred"

#: ../../library/itertools.rst:54
msgid "``dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1``"
msgstr "``dropwhile(лямбда x: x <5, [1,4,6,4,1]) --> 6 4 1``"

#: ../../library/itertools.rst:55
msgid ":func:`filterfalse`"
msgstr ":func:`filterfalse`"

#: ../../library/itertools.rst:55
msgid "elements of seq where pred(elem) is false"
msgstr "елементи seq, де pred(elem) false"

#: ../../library/itertools.rst:55
msgid "``filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8``"
msgstr "``filterfalse(лямбда x: x%2, діапазон(10)) --> 0 2 4 6 8``"

#: ../../library/itertools.rst:56
msgid ":func:`groupby`"
msgstr ":func:`groupby`"

#: ../../library/itertools.rst:56
msgid "iterable[, key]"
msgstr "ітерований [, ключ]"

#: ../../library/itertools.rst:56
msgid "sub-iterators grouped by value of key(v)"
msgstr "субітератори, згруповані за значенням ключа (v)"

#: ../../library/itertools.rst:57
msgid ":func:`islice`"
msgstr ":func:`islice`"

#: ../../library/itertools.rst:57
msgid "seq, [start,] stop [, step]"
msgstr "seq, [початок,] зупинка [, крок]"

#: ../../library/itertools.rst:57
msgid "elements from seq[start:stop:step]"
msgstr "елементи з seq[start:stop:step]"

#: ../../library/itertools.rst:57
msgid "``islice('ABCDEFG', 2, None) --> C D E F G``"
msgstr "``islice('ABCDEFG', 2, None) --> C D E F G``"

#: ../../library/itertools.rst:58
msgid ":func:`pairwise`"
msgstr ":func:`pairwise`"

#: ../../library/itertools.rst:58
msgid "(p[0], p[1]), (p[1], p[2])"
msgstr "(p[0], p[1]), (p[1], p[2])"

#: ../../library/itertools.rst:58
msgid "``pairwise('ABCDEFG') --> AB BC CD DE EF FG``"
msgstr "``попарно('ABCDEFG') --> AB BC CD DE EF FG``"

#: ../../library/itertools.rst:59
msgid ":func:`starmap`"
msgstr ":func:`starmap`"

#: ../../library/itertools.rst:59
msgid "func, seq"
msgstr "функція, посл"

#: ../../library/itertools.rst:59
msgid "func(\\*seq[0]), func(\\*seq[1]), ..."
msgstr "func(\\*seq[0]), func(\\*seq[1]), ..."

#: ../../library/itertools.rst:59
msgid "``starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000``"
msgstr "``зоряна карта(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000``"

#: ../../library/itertools.rst:60
msgid ":func:`takewhile`"
msgstr ":func:`takewhile`"

#: ../../library/itertools.rst:60
msgid "seq[0], seq[1], until pred fails"
msgstr "seq[0], seq[1], поки pred не вийде"

#: ../../library/itertools.rst:60
msgid "``takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4``"
msgstr "``takewhile(лямбда x: x <5, [1,4,6,4,1]) --> 1 4``"

#: ../../library/itertools.rst:61
msgid ":func:`tee`"
msgstr ":func:`tee`"

#: ../../library/itertools.rst:61
msgid "it, n"
msgstr "воно, п"

#: ../../library/itertools.rst:61
msgid "it1, it2, ... itn  splits one iterator into n"
msgstr "it1, it2, ... itn розділяє один ітератор на n"

#: ../../library/itertools.rst:62
msgid ":func:`zip_longest`"
msgstr ":func:`zip_longest`"

#: ../../library/itertools.rst:62
msgid "(p[0], q[0]), (p[1], q[1]), ..."
msgstr "(p[0], q[0]), (p[1], q[1]), ..."

#: ../../library/itertools.rst:62
msgid "``zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-``"
msgstr "``zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-``"

#: ../../library/itertools.rst:65
msgid "**Combinatoric iterators:**"
msgstr "**Комбінаторні ітератори:**"

#: ../../library/itertools.rst:70
msgid ":func:`product`"
msgstr ":func:`product`"

#: ../../library/itertools.rst:70
msgid "p, q, ... [repeat=1]"
msgstr "p, q, ... [repeat=1]"

#: ../../library/itertools.rst:70
msgid "cartesian product, equivalent to a nested for-loop"
msgstr "декартовий добуток, еквівалентний вкладеному циклу for"

#: ../../library/itertools.rst:71
msgid ":func:`permutations`"
msgstr ":func:`permutations`"

#: ../../library/itertools.rst:71
msgid "p[, r]"
msgstr "p[, r]"

#: ../../library/itertools.rst:71
msgid "r-length tuples, all possible orderings, no repeated elements"
msgstr ""
"кортежі довжини r, усі можливі впорядкування, відсутність повторюваних "
"елементів"

#: ../../library/itertools.rst:72
msgid ":func:`combinations`"
msgstr ":func:`combinations`"

#: ../../library/itertools.rst:72 ../../library/itertools.rst:73
msgid "p, r"
msgstr "p, r"

#: ../../library/itertools.rst:72
msgid "r-length tuples, in sorted order, no repeated elements"
msgstr ""
"кортежі довжини r, у відсортованому порядку, без повторюваних елементів"

#: ../../library/itertools.rst:73
msgid ":func:`combinations_with_replacement`"
msgstr ":func:`combinations_with_replacement`"

#: ../../library/itertools.rst:73
msgid "r-length tuples, in sorted order, with repeated elements"
msgstr ""
"кортежі довжини r, у відсортованому порядку, з повторюваними елементами"

#: ../../library/itertools.rst:77
msgid "Examples"
msgstr "Приклади"

#: ../../library/itertools.rst:79
msgid "``product('ABCD', repeat=2)``"
msgstr "``product('ABCD', repeat=2)``"

#: ../../library/itertools.rst:79
msgid "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"
msgstr "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"

#: ../../library/itertools.rst:80
msgid "``permutations('ABCD', 2)``"
msgstr "``permutations('ABCD', 2)``"

#: ../../library/itertools.rst:80
msgid "``AB AC AD BA BC BD CA CB CD DA DB DC``"
msgstr "``AB AC AD BA BC BD CA CB CD DA DB DC``"

#: ../../library/itertools.rst:81
msgid "``combinations('ABCD', 2)``"
msgstr "``combinations('ABCD', 2)``"

#: ../../library/itertools.rst:81
msgid "``AB AC AD BC BD CD``"
msgstr "``AB AC AD BC BD CD``"

#: ../../library/itertools.rst:82
msgid "``combinations_with_replacement('ABCD', 2)``"
msgstr "``combinations_with_replacement('ABCD', 2)``"

#: ../../library/itertools.rst:82
msgid "``AA AB AC AD BB BC BD CC CD DD``"
msgstr "``AA AB AC AD BB BC BD CC CD DD``"

#: ../../library/itertools.rst:89
msgid "Itertool functions"
msgstr "Функції Itertool"

#: ../../library/itertools.rst:91
msgid ""
"The following module functions all construct and return iterators. Some "
"provide streams of infinite length, so they should only be accessed by "
"functions or loops that truncate the stream."
msgstr ""
"У наступному модулі функціонують усі ітератори конструкцій і повернення. "
"Деякі надають потоки нескінченної довжини, тому до них мають звертатися лише "
"функції або цикли, які скорочують потік."

#: ../../library/itertools.rst:97
msgid ""
"Make an iterator that returns accumulated sums, or accumulated results of "
"other binary functions (specified via the optional *func* argument)."
msgstr ""
"Створіть ітератор, який повертає накопичені суми або накопичені результати "
"інших бінарних функцій (зазначених за допомогою необов’язкового аргументу "
"*func*)."

#: ../../library/itertools.rst:101
msgid ""
"If *func* is supplied, it should be a function of two arguments. Elements of "
"the input *iterable* may be any type that can be accepted as arguments to "
"*func*. (For example, with the default operation of addition, elements may "
"be any addable type including :class:`~decimal.Decimal` or :class:"
"`~fractions.Fraction`.)"
msgstr ""
"Якщо вказано *func*, це має бути функція двох аргументів. Елементи вхідних "
"даних *iterable* можуть мати будь-який тип, який можна прийняти як аргументи "
"*func*. (Наприклад, із операцією додавання за замовчуванням елементи можуть "
"мати будь-який доданий тип, включаючи :class:`~decimal.Decimal` або :class:"
"`~fractions.Fraction`.)"

#: ../../library/itertools.rst:108
msgid ""
"Usually, the number of elements output matches the input iterable. However, "
"if the keyword argument *initial* is provided, the accumulation leads off "
"with the *initial* value so that the output has one more element than the "
"input iterable."
msgstr ""
"Зазвичай кількість виведених елементів збігається з вхідним ітерованим. "
"Однак, якщо надано ключовий аргумент *initial*, накопичення розпочинається з "
"*початковим* значенням, так що вихід має на один елемент більше, ніж "
"ітерований вхід."

#: ../../library/itertools.rst:113 ../../library/itertools.rst:211
#: ../../library/itertools.rst:260 ../../library/itertools.rst:487
#: ../../library/itertools.rst:514 ../../library/itertools.rst:596
#: ../../library/itertools.rst:649
msgid "Roughly equivalent to::"
msgstr "Приблизно еквівалентно::"

#: ../../library/itertools.rst:132
msgid ""
"There are a number of uses for the *func* argument.  It can be set to :func:"
"`min` for a running minimum, :func:`max` for a running maximum, or :func:"
"`operator.mul` for a running product.  Amortization tables can be built by "
"accumulating interest and applying payments.  First-order `recurrence "
"relations <https://en.wikipedia.org/wiki/Recurrence_relation>`_ can be "
"modeled by supplying the initial value in the iterable and using only the "
"accumulated total in *func* argument::"
msgstr ""
"Існує кілька способів використання аргументу *func*. Його можна встановити "
"на :func:`min` для поточного мінімуму, :func:`max` для поточного максимуму "
"або :func:`operator.mul` для поточного продукту. Таблиці амортизації можна "
"побудувати шляхом накопичення відсотків і застосування платежів. `Рекурентні "
"відносини першого порядку <https://en.wikipedia.org/wiki/"
"Recurrence_relation>`_ можна моделювати шляхом надання початкового значення "
"в ітеруючому елементі та використання лише накопиченої суми в аргументі "
"*func*::"

#: ../../library/itertools.rst:162
msgid ""
"See :func:`functools.reduce` for a similar function that returns only the "
"final accumulated value."
msgstr ""
"Перегляньте :func:`functools.reduce` подібну функцію, яка повертає лише "
"остаточне накопичене значення."

#: ../../library/itertools.rst:167
msgid "Added the optional *func* parameter."
msgstr "Додано необов’язковий параметр *func*."

#: ../../library/itertools.rst:170
msgid "Added the optional *initial* parameter."
msgstr "Додано необов'язковий *початковий* параметр."

#: ../../library/itertools.rst:175
msgid ""
"Make an iterator that returns elements from the first iterable until it is "
"exhausted, then proceeds to the next iterable, until all of the iterables "
"are exhausted.  Used for treating consecutive sequences as a single "
"sequence. Roughly equivalent to::"
msgstr ""
"Створіть ітератор, який повертає елементи з першого ітератора, поки він не "
"буде вичерпаний, а потім переходить до наступного ітератора, доки всі "
"ітератори не будуть вичерпані. Використовується для обробки послідовних "
"послідовностей як однієї послідовності. Приблизно еквівалентно::"

#: ../../library/itertools.rst:189
msgid ""
"Alternate constructor for :func:`chain`.  Gets chained inputs from a single "
"iterable argument that is evaluated lazily.  Roughly equivalent to::"
msgstr ""
"Альтернативний конструктор для :func:`chain`. Отримує ланцюгові вхідні дані "
"з одного ітерованого аргументу, який обчислюється ліниво. Приблизно "
"еквівалентно::"

#: ../../library/itertools.rst:201
msgid "Return *r* length subsequences of elements from the input *iterable*."
msgstr ""
"Повертає *r* довжину підпослідовностей елементів із вхідного *iterable*."

#: ../../library/itertools.rst:203 ../../library/itertools.rst:252
msgid ""
"The combination tuples are emitted in lexicographic ordering according to "
"the order of the input *iterable*. So, if the input *iterable* is sorted, "
"the combination tuples will be produced in sorted order."
msgstr ""
"Комбінаційні кортежі видаються в лексикографічному порядку відповідно до "
"порядку введення *iterable*. Отже, якщо вхідні дані *iterable* відсортовано, "
"комбінаційні кортежі створюватимуться у відсортованому порядку."

#: ../../library/itertools.rst:207
msgid ""
"Elements are treated as unique based on their position, not on their value.  "
"So if the input elements are unique, there will be no repeat values in each "
"combination."
msgstr ""
"Елементи розглядаються як унікальні на основі їх позиції, а не їх значення. "
"Отже, якщо вхідні елементи унікальні, у кожній комбінації не буде "
"повторюваних значень."

#: ../../library/itertools.rst:233
msgid ""
"The code for :func:`combinations` can be also expressed as a subsequence of :"
"func:`permutations` after filtering entries where the elements are not in "
"sorted order (according to their position in the input pool)::"
msgstr ""
"Код для :func:`combinations` також може бути виражений як підпослідовність :"
"func:`permutations` після фільтрації записів, де елементи не відсортовані "
"(відповідно до їхньої позиції у вхідному пулі)::"

#: ../../library/itertools.rst:244
msgid ""
"The number of items returned is ``n! / r! / (n-r)!`` when ``0 <= r <= n`` or "
"zero when ``r > n``."
msgstr ""
"Кількість повернених елементів – ``n! / р! / (n-r)!`` коли ``0 <= r <= n`` "
"or zero when ``r > n``."

#: ../../library/itertools.rst:249
msgid ""
"Return *r* length subsequences of elements from the input *iterable* "
"allowing individual elements to be repeated more than once."
msgstr ""
"Повертає *r* довжину підпослідовностей елементів із вхідного *iterable*, що "
"дозволяє повторювати окремі елементи більше одного разу."

#: ../../library/itertools.rst:256
msgid ""
"Elements are treated as unique based on their position, not on their value.  "
"So if the input elements are unique, the generated combinations will also be "
"unique."
msgstr ""
"Елементи розглядаються як унікальні на основі їх позиції, а не їх значення. "
"Отже, якщо вхідні елементи унікальні, згенеровані комбінації також будуть "
"унікальними."

#: ../../library/itertools.rst:279
msgid ""
"The code for :func:`combinations_with_replacement` can be also expressed as "
"a subsequence of :func:`product` after filtering entries where the elements "
"are not in sorted order (according to their position in the input pool)::"
msgstr ""
"Код для :func:`combinations_with_replacement` також можна виразити як "
"підпослідовність :func:`product` після фільтрації записів, де елементи не "
"відсортовані (відповідно до їхньої позиції у вхідному пулі):"

#: ../../library/itertools.rst:290
msgid ""
"The number of items returned is ``(n+r-1)! / r! / (n-1)!`` when ``n > 0``."
msgstr ""
"Кількість повернених елементів – ``(n+r-1)! / р! / (n-1)!`` коли ``n > 0``."

#: ../../library/itertools.rst:297
msgid ""
"Make an iterator that filters elements from *data* returning only those that "
"have a corresponding element in *selectors* that evaluates to ``True``. "
"Stops when either the *data* or *selectors* iterables has been exhausted. "
"Roughly equivalent to::"
msgstr ""
"Створіть ітератор, який фільтрує елементи з *даних*, повертаючи лише ті, які "
"мають відповідний елемент у *селекторах*, який оцінюється як ``True``. "
"Зупиняється, коли ітерації *data* або *selectors* вичерпано. Приблизно "
"еквівалентно::"

#: ../../library/itertools.rst:311
msgid ""
"Make an iterator that returns evenly spaced values starting with number "
"*start*. Often used as an argument to :func:`map` to generate consecutive "
"data points. Also, used with :func:`zip` to add sequence numbers.  Roughly "
"equivalent to::"
msgstr ""
"Створіть ітератор, який повертає значення з рівним інтервалом, починаючи з "
"числа *start*. Часто використовується як аргумент :func:`map` для створення "
"послідовних точок даних. Також використовується з :func:`zip` для додавання "
"порядкових номерів. Приблизно еквівалентно::"

#: ../../library/itertools.rst:323
msgid ""
"When counting with floating point numbers, better accuracy can sometimes be "
"achieved by substituting multiplicative code such as: ``(start + step * i "
"for i in count())``."
msgstr ""
"Під час підрахунку з числами з плаваючою комою кращої точності інколи можна "
"досягти шляхом заміни мультиплікативного коду, наприклад: ``(початок + крок "
"* i для i в count())``."

#: ../../library/itertools.rst:327
msgid "Added *step* argument and allowed non-integer arguments."
msgstr "Додано аргумент *step* і дозволено нецілі аргументи."

#: ../../library/itertools.rst:332
msgid ""
"Make an iterator returning elements from the iterable and saving a copy of "
"each. When the iterable is exhausted, return elements from the saved copy.  "
"Repeats indefinitely.  Roughly equivalent to::"
msgstr ""
"Зробіть ітератор, який повертає елементи з iterable і зберігає копію "
"кожного. Коли iterable вичерпано, поверніть елементи зі збереженої копії. "
"Повторюється безкінечно. Приблизно еквівалентно::"

#: ../../library/itertools.rst:346
msgid ""
"Note, this member of the toolkit may require significant auxiliary storage "
"(depending on the length of the iterable)."
msgstr ""
"Зверніть увагу, що цей член набору інструментів може потребувати значного "
"допоміжного сховища (залежно від довжини ітерованого)."

#: ../../library/itertools.rst:352
msgid ""
"Make an iterator that drops elements from the iterable as long as the "
"predicate is true; afterwards, returns every element.  Note, the iterator "
"does not produce *any* output until the predicate first becomes false, so it "
"may have a lengthy start-up time.  Roughly equivalent to::"
msgstr ""
"Створіть ітератор, який видаляє елементи з ітерованого, якщо предикат "
"істинний; згодом повертає кожен елемент. Зауважте, що ітератор не створює "
"*жодних* виходів, доки предикат не стане хибним, тому він може мати тривалий "
"час запуску. Приблизно еквівалентно::"

#: ../../library/itertools.rst:369
msgid ""
"Make an iterator that filters elements from iterable returning only those "
"for which the predicate is ``False``. If *predicate* is ``None``, return the "
"items that are false. Roughly equivalent to::"
msgstr ""
"Створіть ітератор, який фільтрує елементи з ітерованих, повертаючи лише ті, "
"для яких предикат має значення ``False``. Якщо *predicate* має значення "
"``None``, повернути елементи, які є false. Приблизно еквівалентно::"

#: ../../library/itertools.rst:384
msgid ""
"Make an iterator that returns consecutive keys and groups from the "
"*iterable*. The *key* is a function computing a key value for each element.  "
"If not specified or is ``None``, *key* defaults to an identity function and "
"returns the element unchanged.  Generally, the iterable needs to already be "
"sorted on the same key function."
msgstr ""
"Створіть ітератор, який повертає послідовні ключі та групи з *iterable*. "
"*Ключ* — це функція, яка обчислює значення ключа для кожного елемента. Якщо "
"не вказано або має значення ``None``, *key* за замовчуванням "
"використовується як функція ідентифікації та повертає елемент без змін. Як "
"правило, iterable вже має бути відсортований за тією самою ключовою функцією."

#: ../../library/itertools.rst:390
msgid ""
"The operation of :func:`groupby` is similar to the ``uniq`` filter in Unix.  "
"It generates a break or new group every time the value of the key function "
"changes (which is why it is usually necessary to have sorted the data using "
"the same key function).  That behavior differs from SQL's GROUP BY which "
"aggregates common elements regardless of their input order."
msgstr ""
"Робота :func:`groupby` подібна до фільтра ``uniq`` в Unix. Він генерує "
"розрив або нову групу щоразу, коли змінюється значення ключової функції "
"(саме тому зазвичай необхідно відсортувати дані за допомогою тієї самої "
"ключової функції). Така поведінка відрізняється від GROUP BY SQL, яка "
"агрегує загальні елементи незалежно від порядку введення."

#: ../../library/itertools.rst:396
msgid ""
"The returned group is itself an iterator that shares the underlying iterable "
"with :func:`groupby`.  Because the source is shared, when the :func:"
"`groupby` object is advanced, the previous group is no longer visible.  So, "
"if that data is needed later, it should be stored as a list::"
msgstr ""
"Повернена група сама є ітератором, який ділиться основним ітератором із :"
"func:`groupby`. Оскільки джерело є спільним, коли об’єкт :func:`groupby` "
"розширено, попередня група більше не відображається. Отже, якщо ці дані "
"знадобляться пізніше, їх слід зберегти як список::"

#: ../../library/itertools.rst:408
msgid ":func:`groupby` is roughly equivalent to::"
msgstr ":func:`groupby` приблизно еквівалентно::"

#: ../../library/itertools.rst:441
msgid ""
"Make an iterator that returns selected elements from the iterable. If "
"*start* is non-zero, then elements from the iterable are skipped until start "
"is reached. Afterward, elements are returned consecutively unless *step* is "
"set higher than one which results in items being skipped.  If *stop* is "
"``None``, then iteration continues until the iterator is exhausted, if at "
"all; otherwise, it stops at the specified position.  Unlike regular "
"slicing, :func:`islice` does not support negative values for *start*, "
"*stop*, or *step*.  Can be used to extract related fields from data where "
"the internal structure has been flattened (for example, a multi-line report "
"may list a name field on every third line).  Roughly equivalent to::"
msgstr ""
"Створіть ітератор, який повертає вибрані елементи з ітерованого. Якщо "
"*start* відмінний від нуля, то елементи з iterable пропускаються, доки не "
"буде досягнуто початок. Після цього елементи повертаються послідовно, якщо "
"*крок* не встановлено вище, ніж один, що призводить до пропуску елементів. "
"Якщо *stop* має значення ``None``, тоді ітерація продовжується, доки "
"ітератор не буде вичерпано, якщо взагалі; інакше він зупиняється у вказаній "
"позиції. На відміну від звичайного нарізування, :func:`islice` не підтримує "
"від’ємні значення для *start*, *stop* або *step*. Може використовуватися для "
"вилучення пов’язаних полів із даних, внутрішня структура яких була зведена "
"(наприклад, багаторядковий звіт може вказувати поле імені в кожному третьому "
"рядку). Приблизно еквівалентно::"

#: ../../library/itertools.rst:476
msgid ""
"If *start* is ``None``, then iteration starts at zero. If *step* is "
"``None``, then the step defaults to one."
msgstr ""
"Якщо *start* має значення ``None``, то ітерація починається з нуля. Якщо "
"*крок* має значення ``None``, тоді крок за умовчанням дорівнює одиниці."

#: ../../library/itertools.rst:481
msgid "Return successive overlapping pairs taken from the input *iterable*."
msgstr ""
"Повертає послідовні пари, що перекриваються, взяті з вхідних даних "
"*iterable*."

#: ../../library/itertools.rst:483
msgid ""
"The number of 2-tuples in the output iterator will be one fewer than the "
"number of inputs.  It will be empty if the input iterable has fewer than two "
"values."
msgstr ""
"Кількість 2-кортежів у вихідному ітераторі буде на один менше, ніж кількість "
"входів. Він буде порожнім, якщо вхідний ітератор має менше двох значень."

#: ../../library/itertools.rst:500
msgid ""
"Return successive *r* length permutations of elements in the *iterable*."
msgstr "Повертає послідовні зміни довжини *r* елементів у *iterable*."

#: ../../library/itertools.rst:502
msgid ""
"If *r* is not specified or is ``None``, then *r* defaults to the length of "
"the *iterable* and all possible full-length permutations are generated."
msgstr ""
"Якщо *r* не вказано або має значення ``None``, тоді *r* за замовчуванням "
"відповідає довжині *iterable* і генеруються всі можливі перестановки повної "
"довжини."

#: ../../library/itertools.rst:506
msgid ""
"The permutation tuples are emitted in lexicographic ordering according to "
"the order of the input *iterable*. So, if the input *iterable* is sorted, "
"the combination tuples will be produced in sorted order."
msgstr ""
"Кортежі перестановок випускаються в лексикографічному порядку відповідно до "
"порядку введення *iterable*. Отже, якщо вхідні дані *iterable* відсортовано, "
"комбінаційні кортежі створюватимуться у відсортованому порядку."

#: ../../library/itertools.rst:510
msgid ""
"Elements are treated as unique based on their position, not on their value.  "
"So if the input elements are unique, there will be no repeat values in each "
"permutation."
msgstr ""
"Елементи розглядаються як унікальні на основі їх позиції, а не їх значення. "
"Отже, якщо вхідні елементи унікальні, у кожній перестановці не буде "
"повторюваних значень."

#: ../../library/itertools.rst:541
msgid ""
"The code for :func:`permutations` can be also expressed as a subsequence of :"
"func:`product`, filtered to exclude entries with repeated elements (those "
"from the same position in the input pool)::"
msgstr ""
"Код для :func:`permutations` також може бути виражений як підпослідовність :"
"func:`product`, відфільтрована, щоб виключити записи з повторюваними "
"елементами (ті, що знаходяться в одній позиції у вхідному пулі):"

#: ../../library/itertools.rst:553
msgid ""
"The number of items returned is ``n! / (n-r)!`` when ``0 <= r <= n`` or zero "
"when ``r > n``."
msgstr ""
"Кількість повернених елементів – ``n! / (n-r)!`` коли ``0 <= r <= n`` or "
"zero when ``r > n``."

#: ../../library/itertools.rst:558
msgid "Cartesian product of input iterables."
msgstr "Декартовий добуток вхідних ітерацій."

#: ../../library/itertools.rst:560
msgid ""
"Roughly equivalent to nested for-loops in a generator expression. For "
"example, ``product(A, B)`` returns the same as ``((x,y) for x in A for y in "
"B)``."
msgstr ""
"Приблизно еквівалентно вкладеним циклам for у виразі генератора. Наприклад, "
"``product(A, B)`` повертає те саме, що ``((x,y) для x в A для y у B)``."

#: ../../library/itertools.rst:563
msgid ""
"The nested loops cycle like an odometer with the rightmost element advancing "
"on every iteration.  This pattern creates a lexicographic ordering so that "
"if the input's iterables are sorted, the product tuples are emitted in "
"sorted order."
msgstr ""
"Вкладені цикли обертаються як одометр із крайнім правим елементом, що "
"просувається на кожній ітерації. Цей шаблон створює лексикографічне "
"впорядкування, так що якщо ітеровані вхідні елементи відсортовані, кортежі "
"продукту видаються в відсортованому порядку."

#: ../../library/itertools.rst:568
msgid ""
"To compute the product of an iterable with itself, specify the number of "
"repetitions with the optional *repeat* keyword argument.  For example, "
"``product(A, repeat=4)`` means the same as ``product(A, A, A, A)``."
msgstr ""
"Щоб обчислити добуток iterable із самим собою, вкажіть кількість повторень "
"за допомогою необов’язкового аргументу *repeat*. Наприклад, ``product(A, "
"repeat=4)`` означає те саме, що ``product(A, A, A, A)``."

#: ../../library/itertools.rst:572
msgid ""
"This function is roughly equivalent to the following code, except that the "
"actual implementation does not build up intermediate results in memory::"
msgstr ""
"Ця функція приблизно еквівалентна наступному коду, за винятком того, що "
"фактична реалізація не накопичує проміжні результати в пам’яті:"

#: ../../library/itertools.rst:585
msgid ""
"Before :func:`product` runs, it completely consumes the input iterables, "
"keeping pools of values in memory to generate the products.  Accordingly, it "
"is only useful with finite inputs."
msgstr ""
"Перед запуском :func:`product` він повністю споживає вхідні ітерації, "
"зберігаючи пули значень у пам’яті для генерації продуктів. Відповідно, це "
"корисно лише з обмеженими вхідними даними."

#: ../../library/itertools.rst:591
msgid ""
"Make an iterator that returns *object* over and over again. Runs "
"indefinitely unless the *times* argument is specified. Used as argument to :"
"func:`map` for invariant parameters to the called function.  Also used with :"
"func:`zip` to create an invariant part of a tuple record."
msgstr ""
"Створіть ітератор, який повертає *об’єкт* знову і знову. Працює безстроково, "
"якщо не вказано аргумент *times*. Використовується як аргумент :func:`map` "
"для інваріантних параметрів викликаної функції. Також використовується з :"
"func:`zip` для створення інваріантної частини запису кортежу."

#: ../../library/itertools.rst:607
msgid ""
"A common use for *repeat* is to supply a stream of constant values to *map* "
"or *zip*::"
msgstr ""
"Зазвичай *repeat* використовується для надання потоку постійних значень до "
"*map* або *zip*::"

#: ../../library/itertools.rst:615
msgid ""
"Make an iterator that computes the function using arguments obtained from "
"the iterable.  Used instead of :func:`map` when argument parameters are "
"already grouped in tuples from a single iterable (the data has been \"pre-"
"zipped\").  The difference between :func:`map` and :func:`starmap` parallels "
"the distinction between ``function(a,b)`` and ``function(*c)``. Roughly "
"equivalent to::"
msgstr ""
"Створіть ітератор, який обчислює функцію, використовуючи аргументи, отримані "
"від ітератора. Використовується замість :func:`map`, коли параметри "
"аргументу вже згруповані в кортежі з одного ітерованого елемента (дані були "
"попередньо заархівовані). Різниця між :func:`map` і :func:`starmap` є "
"паралельною до різниці між ``function(a,b)`` і ``function(*c)``. Приблизно "
"еквівалентно::"

#: ../../library/itertools.rst:629
msgid ""
"Make an iterator that returns elements from the iterable as long as the "
"predicate is true.  Roughly equivalent to::"
msgstr ""
"Створіть ітератор, який повертає елементи з ітерованого, якщо предикат "
"істинний. Приблизно еквівалентно::"

#: ../../library/itertools.rst:643
msgid "Return *n* independent iterators from a single iterable."
msgstr "Повертає *n* незалежних ітераторів з одного ітератора."

#: ../../library/itertools.rst:645
msgid ""
"The following Python code helps explain what *tee* does (although the actual "
"implementation is more complex and uses only a single underlying :abbr:`FIFO "
"(first-in, first-out)` queue)."
msgstr ""
"Наступний код Python допомагає пояснити, що робить *tee* (хоча фактична "
"реалізація є складнішою та використовує лише одну базову чергу :abbr:`FIFO "
"(першим увійшов, першим вийшов)`)."

#: ../../library/itertools.rst:666
msgid ""
"Once :func:`tee` has made a split, the original *iterable* should not be "
"used anywhere else; otherwise, the *iterable* could get advanced without the "
"tee objects being informed."
msgstr ""
"Після того, як :func:`tee` здійснив розбиття, оригінальний *iterable* більше "
"ніде не слід використовувати; в іншому випадку *iterable* може бути "
"просунуто без інформування об’єктів tee."

#: ../../library/itertools.rst:670
msgid ""
"``tee`` iterators are not threadsafe. A :exc:`RuntimeError` may be raised "
"when using simultaneously iterators returned by the same :func:`tee` call, "
"even if the original *iterable* is threadsafe."
msgstr ""
"Ітератори ``tee`` не є потокобезпечними. Помилка :exc:`RuntimeError` може "
"виникнути під час одночасного використання ітераторів, що повертаються тим "
"самим викликом :func:`tee`, навіть якщо оригінальний *iterable* є "
"потокобезпечним."

#: ../../library/itertools.rst:674
msgid ""
"This itertool may require significant auxiliary storage (depending on how "
"much temporary data needs to be stored). In general, if one iterator uses "
"most or all of the data before another iterator starts, it is faster to use :"
"func:`list` instead of :func:`tee`."
msgstr ""
"Цей інструмент itertool може потребувати значного допоміжного сховища "
"(залежно від того, скільки тимчасових даних потрібно зберегти). Загалом, "
"якщо один ітератор використовує більшість або всі дані перед запуском іншого "
"ітератора, швидше використовувати :func:`list` замість :func:`tee`."

#: ../../library/itertools.rst:682
msgid ""
"Make an iterator that aggregates elements from each of the iterables. If the "
"iterables are of uneven length, missing values are filled-in with "
"*fillvalue*. Iteration continues until the longest iterable is exhausted.  "
"Roughly equivalent to::"
msgstr ""
"Створіть ітератор, який агрегує елементи з кожного ітератора. Якщо ітерації "
"мають нерівномірну довжину, відсутні значення заповнюються за допомогою "
"*fillvalue*. Ітерація триває до тих пір, поки не буде вичерпано найдовшу "
"ітерацію. Приблизно еквівалентно::"

#: ../../library/itertools.rst:706
msgid ""
"If one of the iterables is potentially infinite, then the :func:"
"`zip_longest` function should be wrapped with something that limits the "
"number of calls (for example :func:`islice` or :func:`takewhile`).  If not "
"specified, *fillvalue* defaults to ``None``."
msgstr ""
"Якщо один із ітераторів потенційно нескінченний, то функцію :func:"
"`zip_longest` слід обернути чимось, що обмежує кількість викликів "
"(наприклад, :func:`islice` або :func:`takewhile`). Якщо не вказано, "
"*fillvalue* за замовчуванням має значення ``None``."

#: ../../library/itertools.rst:715
msgid "Itertools Recipes"
msgstr "Рецепти Itertools"

#: ../../library/itertools.rst:717
msgid ""
"This section shows recipes for creating an extended toolset using the "
"existing itertools as building blocks."
msgstr ""
"У цьому розділі наведено рецепти для створення розширеного набору "
"інструментів з використанням існуючих itertools як будівельних блоків."

#: ../../library/itertools.rst:720
msgid ""
"Substantially all of these recipes and many, many others can be installed "
"from the `more-itertools project <https://pypi.org/project/more-itertools/"
">`_ found on the Python Package Index::"
msgstr ""
"Практично всі ці рецепти та багато, багато інших можна встановити з `more-"
"itertools project <https://pypi.org/project/more-itertools/>`_, знайденого в "
"індексі пакетів Python::"

#: ../../library/itertools.rst:726
msgid ""
"The extended tools offer the same high performance as the underlying "
"toolset. The superior memory performance is kept by processing elements one "
"at a time rather than bringing the whole iterable into memory all at once. "
"Code volume is kept small by linking the tools together in a functional "
"style which helps eliminate temporary variables.  High speed is retained by "
"preferring \"vectorized\" building blocks over the use of for-loops and :"
"term:`generator`\\s which incur interpreter overhead."
msgstr ""
"Розширені інструменти пропонують таку ж високу продуктивність, як і базовий "
"набір інструментів. Чудова продуктивність пам’яті зберігається завдяки "
"обробці елементів по одному, а не перенесенню всього ітерованого в пам’ять "
"відразу. Обсяг коду зберігається невеликим завдяки пов’язуванню інструментів "
"разом у функціональному стилі, що допомагає усунути тимчасові змінні. Висока "
"швидкість зберігається завдяки відданню переваги \"векторизованим\" "
"будівельним блокам перед використанням циклів for і :term:`generator`\\s, "
"які спричиняють накладні витрати інтерпретатора."
