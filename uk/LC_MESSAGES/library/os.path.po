# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-06 17:28+0000\n"
"PO-Revision-Date: 2017-02-16 23:20+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2025\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../library/os.path.rst:2
msgid ":mod:`os.path` --- Common pathname manipulations"
msgstr ":mod:`os.path` --- Типові маніпуляції з іменами шляху"

#: ../../library/os.path.rst:7
msgid ""
"**Source code:** :source:`Lib/posixpath.py` (for POSIX) and :source:`Lib/"
"ntpath.py` (for Windows)."
msgstr ""
"**Вихідний код:** :source:`Lib/posixpath.py` (для POSIX) і :source:`Lib/"
"ntpath.py` (для Windows)."

#: ../../library/os.path.rst:14
msgid ""
"This module implements some useful functions on pathnames. To read or write "
"files see :func:`open`, and for accessing the filesystem see the :mod:`os` "
"module. The path parameters can be passed as strings, or bytes, or any "
"object implementing the :class:`os.PathLike` protocol."
msgstr ""
"Цей модуль реалізує деякі корисні функції для шляхів. Щоб прочитати або "
"записати файли, перегляньте :func:`open`, а для доступу до файлової системи "
"перегляньте модуль :mod:`os`. Параметри шляху можна передати як рядки, або "
"байти, або будь-який об’єкт, що реалізує протокол :class:`os.PathLike`."

#: ../../library/os.path.rst:19
msgid ""
"Unlike a unix shell, Python does not do any *automatic* path expansions. "
"Functions such as :func:`expanduser` and :func:`expandvars` can be invoked "
"explicitly when an application desires shell-like path expansion.  (See also "
"the :mod:`glob` module.)"
msgstr ""
"На відміну від оболонки Unix, Python не виконує *автоматичних* розширень "
"шляху. Такі функції, як :func:`expanduser` і :func:`expandvars`, можна "
"викликати явно, коли програма бажає розширення шляху, подібного до оболонки. "
"(Див. також модуль :mod:`glob`.)"

#: ../../library/os.path.rst:26
msgid "The :mod:`pathlib` module offers high-level path objects."
msgstr "Модуль :mod:`pathlib` пропонує об’єкти шляху високого рівня."

#: ../../library/os.path.rst:31
msgid ""
"All of these functions accept either only bytes or only string objects as "
"their parameters.  The result is an object of the same type, if a path or "
"file name is returned."
msgstr ""
"Усі ці функції приймають як параметри лише байти або лише рядкові об’єкти. "
"Результатом є об’єкт того самого типу, якщо повертається шлях або ім’я файлу."

#: ../../library/os.path.rst:37
msgid ""
"Since different operating systems have different path name conventions, "
"there are several versions of this module in the standard library.  The :mod:"
"`os.path` module is always the path module suitable for the operating system "
"Python is running on, and therefore usable for local paths.  However, you "
"can also import and use the individual modules if you want to manipulate a "
"path that is *always* in one of the different formats.  They all have the "
"same interface:"
msgstr ""
"Оскільки різні операційні системи мають різні імена шляхів, у стандартній "
"бібліотеці є кілька версій цього модуля. Модуль :mod:`os.path` завжди є "
"модулем шляху, який підходить для операційної системи, у якій працює Python, "
"і тому його можна використовувати для локальних шляхів. Однак ви також "
"можете імпортувати та використовувати окремі модулі, якщо хочете "
"маніпулювати шляхом, який *завжди* має один із різних форматів. Усі вони "
"мають однаковий інтерфейс:"

#: ../../library/os.path.rst:45
msgid ":mod:`posixpath` for UNIX-style paths"
msgstr ":mod:`posixpath` для шляхів у стилі UNIX"

#: ../../library/os.path.rst:46
msgid ":mod:`ntpath` for Windows paths"
msgstr ":mod:`ntpath` для шляхів Windows"

#: ../../library/os.path.rst:51
msgid ""
":func:`exists`, :func:`lexists`, :func:`isdir`, :func:`isfile`, :func:"
"`islink`, and :func:`ismount` now return ``False`` instead of raising an "
"exception for paths that contain characters or bytes unrepresentable at the "
"OS level."
msgstr ""
":func:`exists`, :func:`lexists`, :func:`isdir`, :func:`isfile`, :func:"
"`islink` і :func:`ismount` тепер замість цього повертають ``False`` "
"створення винятку для шляхів, які містять символи або байти, які неможливо "
"відобразити на рівні ОС."

#: ../../library/os.path.rst:59
msgid ""
"Return a normalized absolutized version of the pathname *path*. On most "
"platforms, this is equivalent to calling the function :func:`normpath` as "
"follows: ``normpath(join(os.getcwd(), path))``."
msgstr ""
"Повертає нормалізовану абсолютизовану версію імені шляху *path*. На "
"більшості платформ це еквівалентно виклику функції :func:`normpath` таким "
"чином: ``normpath(join(os.getcwd(), path))``."

#: ../../library/os.path.rst:63 ../../library/os.path.rst:76
#: ../../library/os.path.rst:116 ../../library/os.path.rst:125
#: ../../library/os.path.rst:141 ../../library/os.path.rst:151
#: ../../library/os.path.rst:177 ../../library/os.path.rst:197
#: ../../library/os.path.rst:214 ../../library/os.path.rst:226
#: ../../library/os.path.rst:235 ../../library/os.path.rst:245
#: ../../library/os.path.rst:255 ../../library/os.path.rst:265
#: ../../library/os.path.rst:275 ../../library/os.path.rst:294
#: ../../library/os.path.rst:324 ../../library/os.path.rst:344
#: ../../library/os.path.rst:383 ../../library/os.path.rst:414
#: ../../library/os.path.rst:432 ../../library/os.path.rst:445
#: ../../library/os.path.rst:461 ../../library/os.path.rst:477
#: ../../library/os.path.rst:502 ../../library/os.path.rst:533
msgid "Accepts a :term:`path-like object`."
msgstr "Приймає :term:`path-like object`."

#: ../../library/os.path.rst:69
msgid ""
"Return the base name of pathname *path*.  This is the second element of the "
"pair returned by passing *path* to the function :func:`split`.  Note that "
"the result of this function is different from the Unix :program:`basename` "
"program; where :program:`basename` for ``'/foo/bar/'`` returns ``'bar'``, "
"the :func:`basename` function returns an empty string (``''``)."
msgstr ""
"Повертає базову назву шляху *path*. Це другий елемент пари, що повертається "
"шляхом передачі *path* до функції :func:`split`. Зверніть увагу, що "
"результат цієї функції відрізняється від програми Unix :program:`basename`; "
"де :program:`basename` для ``'/foo/bar/'`` повертає ``'bar'``, функція :func:"
"`basename` повертає порожній рядок (``''``)."

#: ../../library/os.path.rst:82
msgid ""
"Return the longest common sub-path of each pathname in the sequence "
"*paths*.  Raise :exc:`ValueError` if *paths* contain both absolute and "
"relative pathnames, the *paths* are on the different drives or if *paths* is "
"empty.  Unlike :func:`commonprefix`, this returns a valid path."
msgstr ""
"Повертає найдовший спільний підшлях кожного шляху в послідовності *шляхи*. "
"Викликайте :exc:`ValueError`, якщо *шляхи* містять як абсолютні, так і "
"відносні шляхи, *шляхи* знаходяться на різних дисках або якщо *шляхи* "
"порожні. На відміну від :func:`commonprefix`, це повертає дійсний шлях."

#: ../../library/os.path.rst:89 ../../library/os.path.rst:413
#: ../../library/os.path.rst:425 ../../library/os.path.rst:441
#: ../../library/os.path.rst:457
msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ":ref:`Наявність <availability>`: Unix, Windows."

#: ../../library/os.path.rst:92
msgid "Accepts a sequence of :term:`path-like objects <path-like object>`."
msgstr "Приймає послідовність :term:`шляхових об’єктів <path-like object>`."

#: ../../library/os.path.rst:98
msgid ""
"Return the longest path prefix (taken character-by-character) that is a "
"prefix of all paths in  *list*.  If *list* is empty, return the empty string "
"(``''``)."
msgstr ""
"Повертає найдовший префікс шляху (взятий посимвольно), який є префіксом усіх "
"шляхів у *списку*. Якщо *список* порожній, поверніть порожній рядок (``''``)."

#: ../../library/os.path.rst:104
msgid ""
"This function may return invalid paths because it works a character at a "
"time.  To obtain a valid path, see :func:`commonpath`."
msgstr ""
"Ця функція може повертати недійсні шляхи, оскільки вона працює по символам "
"за раз. Щоб отримати правильний шлях, перегляньте :func:`commonpath`."

#: ../../library/os.path.rst:122
msgid ""
"Return the directory name of pathname *path*.  This is the first element of "
"the pair returned by passing *path* to the function :func:`split`."
msgstr ""
"Повертає назву каталогу *path*. Це перший елемент пари, який повертається "
"шляхом передачі *шляху* до функції :func:`split`."

#: ../../library/os.path.rst:131
msgid ""
"Return ``True`` if *path* refers to an existing path or an open file "
"descriptor.  Returns ``False`` for broken symbolic links.  On some "
"platforms, this function may return ``False`` if permission is not granted "
"to execute :func:`os.stat` on the requested file, even if the *path* "
"physically exists."
msgstr ""
"Повертає ``True``, якщо *path* посилається на існуючий шлях або дескриптор "
"відкритого файлу. Повертає ``False`` для пошкоджених символічних посилань. "
"На деяких платформах ця функція може повертати ``False``, якщо не надано "
"дозвіл на виконання :func:`os.stat` над запитуваним файлом, навіть якщо "
"*шлях* фізично існує."

#: ../../library/os.path.rst:137
msgid ""
"*path* can now be an integer: ``True`` is returned if it is an  open file "
"descriptor, ``False`` otherwise."
msgstr ""
"*шлях* тепер може бути цілим числом: ``True`` повертається, якщо це "
"дескриптор відкритого файлу, ``False`` інакше."

#: ../../library/os.path.rst:147
msgid ""
"Return ``True`` if *path* refers to an existing path. Returns ``True`` for "
"broken symbolic links.   Equivalent to :func:`exists` on platforms lacking :"
"func:`os.lstat`."
msgstr ""
"Повертає ``True``, якщо *path* посилається на існуючий шлях. Повертає "
"``True`` для пошкоджених символічних посилань. Еквівалент :func:`exists` на "
"платформах, на яких відсутній :func:`os.lstat`."

#: ../../library/os.path.rst:159
msgid ""
"On Unix and Windows, return the argument with an initial component of ``~`` "
"or ``~user`` replaced by that *user*'s home directory."
msgstr ""
"В Unix і Windows поверніть аргумент із початковим компонентом ``~`` або "
"``~user``, заміненим домашнім каталогом *користувача*."

#: ../../library/os.path.rst:164
msgid ""
"On Unix, an initial ``~`` is replaced by the environment variable :envvar:"
"`HOME` if it is set; otherwise the current user's home directory is looked "
"up in the password directory through the built-in module :mod:`pwd`. An "
"initial ``~user`` is looked up directly in the password directory."
msgstr ""
"В Unix початковий ``~`` замінюється змінною середовища :envvar:`HOME`, якщо "
"вона встановлена; інакше домашній каталог поточного користувача шукається в "
"каталозі паролів за допомогою вбудованого модуля :mod:`pwd`. Початковий "
"``~користувач`` шукається безпосередньо в каталозі паролів."

#: ../../library/os.path.rst:169
msgid ""
"On Windows, :envvar:`USERPROFILE` will be used if set, otherwise a "
"combination of :envvar:`HOMEPATH` and :envvar:`HOMEDRIVE` will be used.  An "
"initial ``~user`` is handled by stripping the last directory component from "
"the created user path derived above."
msgstr ""

#: ../../library/os.path.rst:174
msgid ""
"If the expansion fails or if the path does not begin with a tilde, the path "
"is returned unchanged."
msgstr ""
"Якщо розширення не вдається або якщо шлях не починається з тильди, шлях "
"повертається без змін."

#: ../../library/os.path.rst:180
msgid "No longer uses :envvar:`HOME` on Windows."
msgstr "Більше не використовує :envvar:`HOME` у Windows."

#: ../../library/os.path.rst:189
msgid ""
"Return the argument with environment variables expanded.  Substrings of the "
"form ``$name`` or ``${name}`` are replaced by the value of environment "
"variable *name*.  Malformed variable names and references to non-existing "
"variables are left unchanged."
msgstr ""
"Повертає аргумент із розгорнутими змінними середовища. Підрядки у формі "
"``$name`` або ``${name}`` замінюються значенням змінної середовища *name*. "
"Неправильні назви змінних і посилання на неіснуючі змінні залишаються без "
"змін."

#: ../../library/os.path.rst:194
msgid ""
"On Windows, ``%name%`` expansions are supported in addition to ``$name`` and "
"``${name}``."
msgstr ""
"У Windows підтримуються розширення ``%name%`` на додаток до ``$name`` і "
"``${name}``."

#: ../../library/os.path.rst:203
msgid ""
"Return the time of last access of *path*.  The return value is a floating "
"point number giving the number of seconds since the epoch (see the  :mod:"
"`time` module).  Raise :exc:`OSError` if the file does not exist or is "
"inaccessible."
msgstr ""
"Повертає час останнього доступу до *path*. Поверненим значенням є число з "
"плаваючою комою, що вказує кількість секунд після епохи (див. модуль :mod:"
"`time`). Викликати :exc:`OSError`, якщо файл не існує або недоступний."

#: ../../library/os.path.rst:210
msgid ""
"Return the time of last modification of *path*.  The return value is a "
"floating point number giving the number of seconds since the epoch (see "
"the  :mod:`time` module). Raise :exc:`OSError` if the file does not exist or "
"is inaccessible."
msgstr ""
"Повертає час останньої зміни *шляху*. Поверненим значенням є число з "
"плаваючою комою, що вказує кількість секунд після епохи (див. модуль :mod:"
"`time`). Викликати :exc:`OSError`, якщо файл не існує або недоступний."

#: ../../library/os.path.rst:220
msgid ""
"Return the system's ctime which, on some systems (like Unix) is the time of "
"the last metadata change, and, on others (like Windows), is the creation "
"time for *path*. The return value is a number giving the number of seconds "
"since the epoch (see the  :mod:`time` module).  Raise :exc:`OSError` if the "
"file does not exist or is inaccessible."
msgstr ""
"Повертає системний час ctime, який у деяких системах (наприклад, Unix) є "
"часом останньої зміни метаданих, а в інших (наприклад, Windows) є часом "
"створення *шляху*. Поверненим значенням є число, що вказує кількість секунд "
"з моменту епохи (див. модуль :mod:`time`). Викликати :exc:`OSError`, якщо "
"файл не існує або недоступний."

#: ../../library/os.path.rst:232
msgid ""
"Return the size, in bytes, of *path*.  Raise :exc:`OSError` if the file does "
"not exist or is inaccessible."
msgstr ""
"Повертає розмір у байтах *шляху*. Викликати :exc:`OSError`, якщо файл не "
"існує або недоступний."

#: ../../library/os.path.rst:241
msgid ""
"Return ``True`` if *path* is an absolute pathname.  On Unix, that means it "
"begins with a slash, on Windows that it begins with a (back)slash after "
"chopping off a potential drive letter."
msgstr ""
"Повертає ``True``, якщо *path* є абсолютним шляхом. В Unix це означає, що "
"він починається з похилої риски, а в Windows – із (зворотної) похилої риски "
"після відрізання потенційної літери диска."

#: ../../library/os.path.rst:251
msgid ""
"Return ``True`` if *path* is an :func:`existing <exists>` regular file. This "
"follows symbolic links, so both :func:`islink` and :func:`isfile` can be "
"true for the same path."
msgstr ""
"Повертає ``True``, якщо *path* є :func:`існуючим <exists>` звичайним файлом. "
"Це йде за символічними посиланнями, тому і :func:`islink`, і :func:`isfile` "
"можуть бути істинними для одного шляху."

#: ../../library/os.path.rst:261
msgid ""
"Return ``True`` if *path* is an :func:`existing <exists>` directory.  This "
"follows symbolic links, so both :func:`islink` and :func:`isdir` can be true "
"for the same path."
msgstr ""
"Повертає ``True``, якщо *path* є :func:`існуючим каталогом <exists>`. Це "
"слідує за символічними посиланнями, тому і :func:`islink`, і :func:`isdir` "
"можуть бути вірними для одного шляху."

#: ../../library/os.path.rst:271
msgid ""
"Return ``True`` if *path* refers to an :func:`existing <exists>` directory "
"entry that is a symbolic link.  Always ``False`` if symbolic links are not "
"supported by the Python runtime."
msgstr ""
"Повертає ``True``, якщо *path* посилається на :func:`існуючий запис каталогу "
"<exists>`, який є символічним посиланням. Завжди ``False``, якщо символічні "
"посилання не підтримуються середовищем виконання Python."

#: ../../library/os.path.rst:281
msgid ""
"Return ``True`` if pathname *path* is a :dfn:`mount point`: a point in a "
"file system where a different file system has been mounted.  On POSIX, the "
"function checks whether *path*'s parent, :file:`{path}/..`, is on a "
"different device than *path*, or whether :file:`{path}/..` and *path* point "
"to the same i-node on the same device --- this should detect mount points "
"for all Unix and POSIX variants.  It is not able to reliably detect bind "
"mounts on the same filesystem.  On Windows, a drive letter root and a share "
"UNC are always mount points, and for any other path ``GetVolumePathName`` is "
"called to see if it is different from the input path."
msgstr ""
"Повертає ``True``, якщо шлях *path* є :dfn:`mount point`: точкою у файловій "
"системі, де була змонтована інша файлова система. У POSIX функція перевіряє, "
"чи батьківський елемент *path*, :file:`{path}/..`, знаходиться на іншому "
"пристрої, ніж *path*, або :file:`{path}/..` і *шлях* вказує на той самий i-"
"node на тому самому пристрої --- це має виявити точки монтування для всіх "
"варіантів Unix і POSIX. Він не в змозі надійно виявити монтування прив’язки "
"на тій же файловій системі. У Windows коренева буква диска та спільний UNC "
"завжди є точками монтування, а для будь-якого іншого шляху викликається "
"GetVolumePathName, щоб перевірити, чи відрізняється він від шляху введення."

#: ../../library/os.path.rst:291
msgid "Support for detecting non-root mount points on Windows."
msgstr "Підтримка виявлення некореневих точок монтування в Windows."

#: ../../library/os.path.rst:300
msgid ""
"Join one or more path components intelligently.  The return value is the "
"concatenation of *path* and any members of *\\*paths* with exactly one "
"directory separator following each non-empty part except the last, meaning "
"that the result will only end in a separator if the last part is empty.  If "
"a component is an absolute path, all previous components are thrown away and "
"joining continues from the absolute path component."
msgstr ""
"Розумно об’єднайте один або кілька компонентів шляху. Повернене значення є "
"конкатенацією *path* і будь-яких членів *\\*paths* із рівно одним "
"роздільником каталогу після кожної непорожньої частини, крім останньої, "
"тобто результат завершуватиметься роздільником, лише якщо остання частина "
"порожня . Якщо компонент є абсолютним шляхом, усі попередні компоненти "
"відкидаються, а приєднання продовжується з компонента абсолютного шляху."

#: ../../library/os.path.rst:307
msgid ""
"On Windows, the drive letter is not reset when an absolute path component (e."
"g., ``r'\\foo'``) is encountered.  If a component contains a drive letter, "
"all previous components are thrown away and the drive letter is reset.  Note "
"that since there is a current directory for each drive, ``os.path.join(\"c:"
"\", \"foo\")`` represents a path relative to the current directory on drive :"
"file:`C:` (:file:`c:foo`), not :file:`c:\\\\foo`."
msgstr ""
"У Windows літера диска не скидається, коли зустрічається компонент "
"абсолютного шляху (наприклад, ``r'\\foo'``). Якщо компонент містить букву "
"диска, усі попередні компоненти викидаються, а літеру диска скидається. "
"Зауважте, що оскільки для кожного диска існує поточний каталог, os.path."
"join(\"c:\", \"foo\")`` представляє шлях відносно поточного каталогу на "
"диску :file:`C:` (: file:`c:foo`), а не :file:`c:\\\\foo`."

#: ../../library/os.path.rst:314
msgid "Accepts a :term:`path-like object` for *path* and *paths*."
msgstr "Приймає :term:`path-like object` для *path* і *paths*."

#: ../../library/os.path.rst:320
msgid ""
"Normalize the case of a pathname.  On Windows, convert all characters in the "
"pathname to lowercase, and also convert forward slashes to backward slashes. "
"On other operating systems, return the path unchanged."
msgstr ""
"Нормалізуйте регістр імені шляху. У Windows перетворіть усі символи в імені "
"шляху на малі літери, а також перетворіть косі риски на зворотні. В інших "
"операційних системах повертайте шлях без змін."

#: ../../library/os.path.rst:330
msgid ""
"Normalize a pathname by collapsing redundant separators and up-level "
"references so that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all "
"become ``A/B``.  This string manipulation may change the meaning of a path "
"that contains symbolic links.  On Windows, it converts forward slashes to "
"backward slashes. To normalize case, use :func:`normcase`."
msgstr ""
"Нормалізуйте шлях шляхом згортання надлишкових роздільників і посилань "
"верхнього рівня, щоб ``A//B``, ``A/B/``, ``A/./B`` і ``A/foo/.. /B`` всі "
"стають ``A/B``. Ця маніпуляція рядком може змінити значення шляху, який "
"містить символічні посилання. У Windows він перетворює косі риски на "
"зворотні. Щоб нормалізувати регістр, використовуйте :func:`normcase`."

#: ../../library/os.path.rst:337
msgid ""
"On POSIX systems, in accordance with `IEEE Std 1003.1 2013 Edition; 4.13 "
"Pathname Resolution <http://pubs.opengroup.org/onlinepubs/9699919799/"
"basedefs/V1_chap04.html#tag_04_13>`_, if a pathname begins with exactly two "
"slashes, the first component following the leading characters may be "
"interpreted in an implementation-defined manner, although more than two "
"leading characters shall be treated as a single character."
msgstr ""
"У системах POSIX, відповідно до `IEEE Std 1003.1 2013 Edition; 4.13 "
"Розділення імені шляху <http://pubs.opengroup.org/onlinepubs/9699919799/"
"basedefs/V1_chap04.html#tag_04_13>`_, якщо ім’я шляху починається рівно з "
"двох похилих рисок, перший компонент після початкових символів може бути "
"інтерпретований у спосіб, визначений реалізацією, хоча більше ніж два "
"початкові символи повинні розглядатися як один символ."

#: ../../library/os.path.rst:350
msgid ""
"Return the canonical path of the specified filename, eliminating any "
"symbolic links encountered in the path (if they are supported by the "
"operating system)."
msgstr ""
"Повертає канонічний шлях до вказаного імені файлу, усуваючи будь-які "
"символічні посилання, які зустрічаються в шляху (якщо вони підтримуються "
"операційною системою)."

#: ../../library/os.path.rst:354
msgid ""
"By default, the path is evaluated up to the first component that does not "
"exist, is a symlink loop, or whose evaluation raises :exc:`OSError`. All "
"such components are appended unchanged to the existing part of the path."
msgstr ""

#: ../../library/os.path.rst:358
msgid ""
"Some errors that are handled this way include \"access denied\", \"not a "
"directory\", or \"bad argument to internal function\". Thus, the resulting "
"path may be missing or inaccessible, may still contain links or loops, and "
"may traverse non-directories."
msgstr ""

#: ../../library/os.path.rst:363
msgid "This behavior can be modified by keyword arguments:"
msgstr ""

#: ../../library/os.path.rst:365
msgid ""
"If *strict* is ``True``, the first error encountered when evaluating the "
"path is re-raised. In particular, :exc:`FileNotFoundError` is raised if "
"*path* does not exist, or another :exc:`OSError` if it is otherwise "
"inaccessible."
msgstr ""

#: ../../library/os.path.rst:370
msgid ""
"If *strict* is :py:data:`os.path.ALLOW_MISSING`, errors other than :exc:"
"`FileNotFoundError` are re-raised (as with ``strict=True``). Thus, the "
"returned path will not contain any symbolic links, but the named file and "
"some of its parent directories may be missing."
msgstr ""

#: ../../library/os.path.rst:376
msgid ""
"This function emulates the operating system's procedure for making a path "
"canonical, which differs slightly between Windows and UNIX with respect to "
"how links and subsequent path components interact."
msgstr ""
"Ця функція емулює процедуру операційної системи, щоб зробити шлях "
"канонічним, який дещо відрізняється між Windows і UNIX стосовно того, як "
"взаємодіють посилання та наступні компоненти шляху."

#: ../../library/os.path.rst:380
msgid ""
"Operating system APIs make paths canonical as needed, so it's not normally "
"necessary to call this function."
msgstr ""
"API операційної системи роблять шляхи канонічними за потреби, тому зазвичай "
"не потрібно викликати цю функцію."

#: ../../library/os.path.rst:386
msgid "Symbolic links and junctions are now resolved on Windows."
msgstr "Символічні зв’язки та з’єднання тепер розпізнаються у Windows."

#: ../../library/os.path.rst:389
msgid "The *strict* parameter was added."
msgstr "Додано параметр *strict*."

#: ../../library/os.path.rst:392
msgid ""
"The :py:data:`~os.path.ALLOW_MISSING` value for the *strict* parameter was "
"added."
msgstr ""

#: ../../library/os.path.rst:398
msgid "Special value used for the *strict* argument in :func:`realpath`."
msgstr ""

#: ../../library/os.path.rst:404
msgid ""
"Return a relative filepath to *path* either from the current directory or "
"from an optional *start* directory.  This is a path computation:  the "
"filesystem is not accessed to confirm the existence or nature of *path* or "
"*start*.  On Windows, :exc:`ValueError` is raised when *path* and *start* "
"are on different drives."
msgstr ""
"Повертає відносний шлях до файлу до *path* або з поточного каталогу, або з "
"додаткового каталогу *start*. Це обчислення шляху: доступ до файлової "
"системи не здійснюється для підтвердження існування або природи *шляху* або "
"*початку*. У Windows :exc:`ValueError` виникає, коли *шлях* і *початок* "
"знаходяться на різних дисках."

#: ../../library/os.path.rst:410
msgid "*start* defaults to :attr:`os.curdir`."
msgstr "*start* за замовчуванням :attr:`os.curdir`."

#: ../../library/os.path.rst:420
msgid ""
"Return ``True`` if both pathname arguments refer to the same file or "
"directory. This is determined by the device number and i-node number and "
"raises an exception if an :func:`os.stat` call on either pathname fails."
msgstr ""
"Повертає ``True``, якщо обидва аргументи шляху посилаються на той самий файл "
"або каталог. Це визначається номером пристрою та номером i-вузла та викликає "
"виняток, якщо виклик :func:`os.stat` будь-якого шляху не вдається."

#: ../../library/os.path.rst:426 ../../library/os.path.rst:442
#: ../../library/os.path.rst:458
msgid "Added Windows support."
msgstr "Додана підтримка Windows."

#: ../../library/os.path.rst:429
msgid "Windows now uses the same implementation as all other platforms."
msgstr ""
"Windows тепер використовує ту саму реалізацію, що й усі інші платформи."

#: ../../library/os.path.rst:438
msgid ""
"Return ``True`` if the file descriptors *fp1* and *fp2* refer to the same "
"file."
msgstr ""
"Повертає ``True``, якщо файлові дескриптори *fp1* і *fp2* стосуються одного "
"файлу."

#: ../../library/os.path.rst:451
msgid ""
"Return ``True`` if the stat tuples *stat1* and *stat2* refer to the same "
"file. These structures may have been returned by :func:`os.fstat`, :func:`os."
"lstat`, or :func:`os.stat`.  This function implements the underlying "
"comparison used by :func:`samefile` and :func:`sameopenfile`."
msgstr ""
"Повертає ``True``, якщо кортежі статистики *stat1* і *stat2* посилаються на "
"той самий файл. Ці структури могли бути повернуті :func:`os.fstat`, :func:"
"`os.lstat` або :func:`os.stat`. Ця функція реалізує основне порівняння, яке "
"використовується :func:`samefile` і :func:`sameopenfile`."

#: ../../library/os.path.rst:467
msgid ""
"Split the pathname *path* into a pair, ``(head, tail)`` where *tail* is the "
"last pathname component and *head* is everything leading up to that.  The "
"*tail* part will never contain a slash; if *path* ends in a slash, *tail* "
"will be empty.  If there is no slash in *path*, *head* will be empty.  If "
"*path* is empty, both *head* and *tail* are empty.  Trailing slashes are "
"stripped from *head* unless it is the root (one or more slashes only).  In "
"all cases, ``join(head, tail)`` returns a path to the same location as "
"*path* (but the strings may differ).  Also see the functions :func:`dirname` "
"and :func:`basename`."
msgstr ""
"Розділіть шлях *path* на пару, ``(head, tail)``, де *tail* — це останній "
"компонент шляху, а *head* — усе, що веде до нього. Частина *хвоста* ніколи "
"не міститиме косу риску; якщо *шлях* закінчується скісною рискою, *хвіст* "
"буде порожнім. Якщо в *path* немає скісної риски, *head* буде порожнім. Якщо "
"*шлях* порожній, і *голова*, і *хвіст* порожні. Кінцеві похилі риски "
"видаляються з *голови*, якщо це не корінь (лише одна або кілька похилих). У "
"всіх випадках ``join(head, tail)`` повертає шлях до того самого місця, що й "
"*path* (але рядки можуть відрізнятися). Також перегляньте функції :func:"
"`dirname` і :func:`basename`."

#: ../../library/os.path.rst:483
msgid ""
"Split the pathname *path* into a pair ``(drive, tail)`` where *drive* is "
"either a mount point or the empty string.  On systems which do not use drive "
"specifications, *drive* will always be the empty string.  In all cases, "
"``drive + tail`` will be the same as *path*."
msgstr ""
"Розділіть назву шляху *path* на пару ``(диск, хвіст)``, де *диск* є або "
"точкою монтування, або порожнім рядком. У системах, які не використовують "
"специфікації дисків, *drive* завжди буде порожнім рядком. У всіх випадках "
"``drive + tail`` буде таким самим, як *path*."

#: ../../library/os.path.rst:488
msgid ""
"On Windows, splits a pathname into drive/UNC sharepoint and relative path."
msgstr "У Windows розділяє шлях на диск/загальну точку UNC і відносний шлях."

#: ../../library/os.path.rst:490
msgid ""
"If the path contains a drive letter, drive will contain everything up to and "
"including the colon::"
msgstr ""
"Якщо шлях містить букву диска, диск міститиме все, аж до двокрапки включно::"

#: ../../library/os.path.rst:496
msgid ""
"If the path contains a UNC path, drive will contain the host name and share, "
"up to but not including the fourth separator::"
msgstr ""
"Якщо шлях містить UNC-шлях, диск міститиме ім’я хоста та спільний ресурс, до "
"четвертого роздільника, але не включаючи::"

#: ../../library/os.path.rst:508
msgid ""
"Split the pathname *path* into a pair ``(root, ext)``  such that ``root + "
"ext == path``, and the extension, *ext*, is empty or begins with a period "
"and contains at most one period."
msgstr ""
"Розділіть назву шляху *path* на пару ``(root, ext)`` таким чином, ``root + "
"ext == path``, а розширення *ext* буде порожнім або починається з крапки та "
"містить щонайбільше один період."

#: ../../library/os.path.rst:512
msgid "If the path contains no extension, *ext* will be ``''``::"
msgstr "Якщо шлях не містить розширення, *ext* буде ``''``::"

#: ../../library/os.path.rst:517
msgid ""
"If the path contains an extension, then *ext* will be set to this extension, "
"including the leading period. Note that previous periods will be ignored::"
msgstr ""
"Якщо шлях містить розширення, то *ext* буде встановлено для цього "
"розширення, включаючи початкову точку. Зауважте, що попередні періоди "
"ігноруватимуться:"

#: ../../library/os.path.rst:525
msgid ""
"Leading periods of the last component of the path are considered to be part "
"of the root::"
msgstr ""
"Початкові періоди останнього компонента шляху вважаються частиною кореня::"

#: ../../library/os.path.rst:539
msgid ""
"``True`` if arbitrary Unicode strings can be used as file names (within "
"limitations imposed by the file system)."
msgstr ""
"``True``, якщо довільні рядки Unicode можуть використовуватися як імена "
"файлів (в межах обмежень, накладених файловою системою)."
