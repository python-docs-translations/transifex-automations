# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-21 22:53+0000\n"
"PO-Revision-Date: 2022-11-05 17:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2024\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../library/asynchat.rst:2
msgid ":mod:`asynchat` --- Asynchronous socket command/response handler"
msgstr ":mod:`asynchat` --- обробник команд/відповідей асинхронного сокета"

#: ../../library/asynchat.rst:11
msgid "**Source code:** :source:`Lib/asynchat.py`"
msgstr "**Вихідний код:** :source:`Lib/asynchat.py`"

#: ../../library/asynchat.rst:13
msgid ""
":mod:`asynchat` will be removed in Python 3.12 (see :pep:`PEP 594 "
"<594#asynchat>` for details). Please use :mod:`asyncio` instead."
msgstr ""

#: ../../library/asynchat.rst:22
msgid ""
"This module exists for backwards compatibility only.  For new code we "
"recommend using :mod:`asyncio`."
msgstr ""
"Цей модуль існує лише для зворотної сумісності. Для нового коду ми "
"рекомендуємо використовувати :mod:`asyncio`."

#: ../../library/asynchat.rst:25
msgid ""
"This module builds on the :mod:`asyncore` infrastructure, simplifying "
"asynchronous clients and servers and making it easier to handle protocols "
"whose elements are terminated by arbitrary strings, or are of variable "
"length. :mod:`asynchat` defines the abstract class :class:`async_chat` that "
"you subclass, providing implementations of the :meth:`collect_incoming_data` "
"and :meth:`found_terminator` methods. It uses the same asynchronous loop as :"
"mod:`asyncore`, and the two types of channel, :class:`asyncore.dispatcher` "
"and :class:`asynchat.async_chat`, can freely be mixed in the channel map. "
"Typically an :class:`asyncore.dispatcher` server channel generates new :"
"class:`asynchat.async_chat` channel objects as it receives incoming "
"connection requests."
msgstr ""
"Цей модуль базується на інфраструктурі :mod:`asyncore`, спрощуючи роботу "
"асинхронних клієнтів і серверів і полегшуючи роботу з протоколами, елементи "
"яких завершуються довільними рядками або мають змінну довжину. :mod:"
"`asynchat` визначає абстрактний клас :class:`async_chat`, підклас якого ви "
"створюєте, надаючи реалізацію методів :meth:`collect_incoming_data` і :meth:"
"`found_terminator`. Він використовує той самий асинхронний цикл, що й :mod:"
"`asyncore`, і два типи каналів, :class:`asyncore.dispatcher` і :class:"
"`asynchat.async_chat`, можна вільно змішувати в карті каналів. Зазвичай "
"канал сервера :class:`asyncore.dispatcher` створює нові об’єкти каналу :"
"class:`asynchat.async_chat`, коли отримує вхідні запити на з’єднання."

#: ../../library/asynchat.rst:40
msgid ""
"This class is an abstract subclass of :class:`asyncore.dispatcher`. To make "
"practical use of the code you must subclass :class:`async_chat`, providing "
"meaningful :meth:`collect_incoming_data` and :meth:`found_terminator` "
"methods. The :class:`asyncore.dispatcher` methods can be used, although not "
"all make sense in a message/response context."
msgstr ""
"Цей клас є абстрактним підкласом :class:`asyncore.dispatcher`. Щоб практично "
"використовувати код, ви повинні створити підклас :class:`async_chat`, "
"надаючи значущі методи :meth:`collect_incoming_data` і :meth:"
"`found_terminator`. Методи :class:`asyncore.dispatcher` можна "
"використовувати, хоча не всі мають сенс у контексті повідомлення/відповіді."

#: ../../library/asynchat.rst:47
msgid ""
"Like :class:`asyncore.dispatcher`, :class:`async_chat` defines a set of "
"events that are generated by an analysis of socket conditions after a :c:"
"func:`select` call. Once the polling loop has been started the :class:"
"`async_chat` object's methods are called by the event-processing framework "
"with no action on the part of the programmer."
msgstr ""
"Як і :class:`asyncore.dispatcher`, :class:`async_chat` визначає набір подій, "
"які генеруються аналізом умов сокета після виклику :c:func:`select`. Після "
"запуску циклу опитування методи об’єкта :class:`async_chat` викликаються "
"структурою обробки подій без жодних дій з боку програміста."

#: ../../library/asynchat.rst:53
msgid ""
"Two class attributes can be modified, to improve performance, or possibly "
"even to conserve memory."
msgstr ""
"Два атрибути класу можна змінити, щоб покращити продуктивність або, можливо, "
"навіть зберегти пам'ять."

#: ../../library/asynchat.rst:59
msgid "The asynchronous input buffer size (default ``4096``)."
msgstr "Розмір буфера асинхронного введення (за замовчуванням ``4096``)."

#: ../../library/asynchat.rst:64
msgid "The asynchronous output buffer size (default ``4096``)."
msgstr "Розмір буфера асинхронного виводу (за замовчуванням ``4096``)."

#: ../../library/asynchat.rst:66
msgid ""
"Unlike :class:`asyncore.dispatcher`, :class:`async_chat` allows you to "
"define a :abbr:`FIFO (first-in, first-out)` queue of *producers*. A producer "
"need have only one method, :meth:`more`, which should return data to be "
"transmitted on the channel. The producer indicates exhaustion (*i.e.* that "
"it contains no more data) by having its :meth:`more` method return the empty "
"bytes object. At this point the :class:`async_chat` object removes the "
"producer from the queue and starts using the next producer, if any. When the "
"producer queue is empty the :meth:`handle_write` method does nothing. You "
"use the channel object's :meth:`set_terminator` method to describe how to "
"recognize the end of, or an important breakpoint in, an incoming "
"transmission from the remote endpoint."
msgstr ""
"На відміну від :class:`asyncore.dispatcher`, :class:`async_chat` дозволяє "
"вам визначити чергу :abbr:`FIFO (першим увійшов, першим вийшов)` "
"*виробників*. Продюсеру потрібен лише один метод, :meth:`more`, який має "
"повертати дані для передачі по каналу. Виробник вказує на вичерпання "
"(*тобто*, що він більше не містить даних), за допомогою методу :meth:`more`, "
"який повертає порожній об’єкт bytes. У цей момент об’єкт :class:`async_chat` "
"видаляє виробника з черги та починає використовувати наступного виробника, "
"якщо такий є. Коли черга виробника порожня, метод :meth:`handle_write` "
"нічого не робить. Ви використовуєте метод :meth:`set_terminator` об’єкта "
"каналу, щоб описати, як розпізнати кінець або важливу точку зупину вхідної "
"передачі від віддаленої кінцевої точки."

#: ../../library/asynchat.rst:79
msgid ""
"To build a functioning :class:`async_chat` subclass your  input methods :"
"meth:`collect_incoming_data` and :meth:`found_terminator` must handle the "
"data that the channel receives asynchronously. The methods are described "
"below."
msgstr ""
"Щоб побудувати функціонуючий підклас :class:`async_chat`, ваші методи "
"введення :meth:`collect_incoming_data` і :meth:`found_terminator` повинні "
"обробляти дані, які отримує канал асинхронно. Методи описані нижче."

#: ../../library/asynchat.rst:87
msgid ""
"Pushes a ``None`` on to the producer queue. When this producer is popped off "
"the queue it causes the channel to be closed."
msgstr ""
"Вставляє ``None`` до черги виробника. Коли цього виробника видаляють із "
"черги, канал закривається."

#: ../../library/asynchat.rst:93
msgid ""
"Called with *data* holding an arbitrary amount of received data.  The "
"default method, which must be overridden, raises a :exc:"
"`NotImplementedError` exception."
msgstr ""
"Викликається з *data*, що містить довільну кількість отриманих даних. Метод "
"за замовчуванням, який потрібно перевизначати, викликає виняток :exc:"
"`NotImplementedError`."

#: ../../library/asynchat.rst:100
msgid ""
"In emergencies this method will discard any data held in the input and/or "
"output buffers and the producer queue."
msgstr ""
"У надзвичайних ситуаціях цей метод скидає будь-які дані, що зберігаються у "
"вхідних та/або вихідних буферах і черзі виробника."

#: ../../library/asynchat.rst:106
msgid ""
"Called when the incoming data stream  matches the termination condition set "
"by :meth:`set_terminator`. The default method, which must be overridden, "
"raises a :exc:`NotImplementedError` exception. The buffered input data "
"should be available via an instance attribute."
msgstr ""
"Викликається, коли вхідний потік даних відповідає умові завершення, "
"встановленій :meth:`set_terminator`. Метод за замовчуванням, який потрібно "
"перевизначати, викликає виняток :exc:`NotImplementedError`. Буферизовані "
"вхідні дані мають бути доступні через атрибут екземпляра."

#: ../../library/asynchat.rst:114
msgid "Returns the current terminator for the channel."
msgstr "Повертає поточний термінатор для каналу."

#: ../../library/asynchat.rst:119
msgid ""
"Pushes data on to the channel's queue to ensure its transmission. This is "
"all you need to do to have the channel write the data out to the network, "
"although it is possible to use your own producers in more complex schemes to "
"implement encryption and chunking, for example."
msgstr ""
"Надсилає дані до черги каналу, щоб забезпечити їх передачу. Це все, що вам "
"потрібно зробити, щоб канал записував дані в мережу, хоча можна "
"використовувати власні виробники в складніших схемах, наприклад, для "
"реалізації шифрування та фрагментації."

#: ../../library/asynchat.rst:127
msgid ""
"Takes a producer object and adds it to the producer queue associated with "
"the channel.  When all currently pushed producers have been exhausted the "
"channel will consume this producer's data by calling its :meth:`more` method "
"and send the data to the remote endpoint."
msgstr ""

#: ../../library/asynchat.rst:135
msgid ""
"Sets the terminating condition to be recognized on the channel.  ``term`` "
"may be any of three types of value, corresponding to three different ways to "
"handle incoming protocol data."
msgstr ""
"Встановлює умову завершення, яку буде розпізнано на каналі. ``term`` може "
"бути будь-яким із трьох типів значення, що відповідає трьом різним способам "
"обробки вхідних даних протоколу."

#: ../../library/asynchat.rst:140
msgid "term"
msgstr "термін"

#: ../../library/asynchat.rst:140
msgid "Description"
msgstr "опис"

#: ../../library/asynchat.rst:142
msgid "*string*"
msgstr "*рядок*"

#: ../../library/asynchat.rst:142
msgid ""
"Will call :meth:`found_terminator` when the string is found in the input "
"stream"
msgstr ""
"Викличе :meth:`found_terminator`, коли рядок знайдено у вхідному потоці"

#: ../../library/asynchat.rst:145
msgid "*integer*"
msgstr "*ціле*"

#: ../../library/asynchat.rst:145
msgid ""
"Will call :meth:`found_terminator` when the indicated number of characters "
"have been received"
msgstr ""
"Викличе :meth:`found_terminator`, коли буде отримано вказану кількість "
"символів"

#: ../../library/asynchat.rst:149
msgid "``None``"
msgstr "``Жодного``"

#: ../../library/asynchat.rst:149
msgid "The channel continues to collect data forever"
msgstr "Канал продовжує збирати дані вічно"

#: ../../library/asynchat.rst:153
msgid ""
"Note that any data following the terminator will be available for reading by "
"the channel after :meth:`found_terminator` is called."
msgstr ""
"Зауважте, що будь-які дані після термінатора будуть доступні для читання "
"каналом після виклику :meth:`found_terminator`."

#: ../../library/asynchat.rst:160
msgid "asynchat Example"
msgstr "Приклад асинчат"

#: ../../library/asynchat.rst:162
msgid ""
"The following partial example shows how HTTP requests can be read with :"
"class:`async_chat`.  A web server might create an :class:"
"`http_request_handler` object for each incoming client connection. Notice "
"that initially the channel terminator is set to match the blank line at the "
"end of the HTTP headers, and a flag indicates that the headers are being "
"read."
msgstr ""
"Наступний частковий приклад показує, як HTTP-запити можна читати за "
"допомогою :class:`async_chat`. Веб-сервер може створити об’єкт :class:"
"`http_request_handler` для кожного вхідного підключення клієнта. Зауважте, "
"що початково термінатор каналу встановлено на відповідність порожньому рядку "
"в кінці заголовків HTTP, а прапорець вказує, що заголовки зчитуються."

#: ../../library/asynchat.rst:169
msgid ""
"Once the headers have been read, if the request is of type POST (indicating "
"that further data are present in the input stream) then the ``Content-Length:"
"`` header is used to set a numeric terminator to read the right amount of "
"data from the channel."
msgstr ""
"Після прочитання заголовків, якщо запит має тип POST (що вказує на наявність "
"додаткових даних у вхідному потоці), тоді заголовок ``Content-Length:`` "
"використовується для встановлення числового термінатора для читання "
"потрібної кількості дані з каналу."

#: ../../library/asynchat.rst:174
msgid ""
"The :meth:`handle_request` method is called once all relevant input has been "
"marshalled, after setting the channel terminator to ``None`` to ensure that "
"any extraneous data sent by the web client are ignored. ::"
msgstr ""
"Метод :meth:`handle_request` викликається після сортування всіх відповідних "
"вхідних даних після встановлення термінатора каналу на ``None``, щоб "
"гарантувати, що будь-які сторонні дані, надіслані веб-клієнтом, "
"ігноруються. ::"
