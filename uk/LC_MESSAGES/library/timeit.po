# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 16:06+0000\n"
"PO-Revision-Date: 2022-11-05 17:22+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2022\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../library/timeit.rst:2
msgid ":mod:`timeit` --- Measure execution time of small code snippets"
msgstr ":mod:`timeit` --- Вимірювання часу виконання невеликих фрагментів коду"

#: ../../library/timeit.rst:7
msgid "**Source code:** :source:`Lib/timeit.py`"
msgstr "**Вихідний код:** :source:`Lib/timeit.py`"

#: ../../library/timeit.rst:15
msgid ""
"This module provides a simple way to time small bits of Python code. It has "
"both a :ref:`timeit-command-line-interface` as well as a :ref:`callable "
"<python-interface>` one.  It avoids a number of common traps for measuring "
"execution times. See also Tim Peters' introduction to the \"Algorithms\" "
"chapter in the second edition of *Python Cookbook*, published by O'Reilly."
msgstr ""
"Цей модуль забезпечує простий спосіб вимірювання часу невеликих фрагментів "
"коду Python. Він має як :ref:`timeit-command-line-interface`, так і :ref:"
"`callable <python-interface>`. Це дозволяє уникнути ряду типових пасток для "
"вимірювання часу виконання. Дивіться також вступ Тіма Пітерса до розділу "
"\"Алгоритми\" у другому виданні *Python Cookbook*, опублікованому O'Reilly."

#: ../../library/timeit.rst:23
msgid "Basic Examples"
msgstr "Основні приклади"

#: ../../library/timeit.rst:25
msgid ""
"The following example shows how the :ref:`timeit-command-line-interface` can "
"be used to compare three different expressions:"
msgstr ""
"У наступному прикладі показано, як :ref:`timeit-command-line-interface` "
"можна використовувати для порівняння трьох різних виразів:"

#: ../../library/timeit.rst:37
msgid "This can be achieved from the :ref:`python-interface` with::"
msgstr ""
"Цього можна досягти за допомогою :ref:`python-interface` за допомогою::"

#: ../../library/timeit.rst:47
msgid "A callable can also be passed from the :ref:`python-interface`::"
msgstr "Викликається також можна передати з :ref:`python-interface`::"

#: ../../library/timeit.rst:52
msgid ""
"Note however that :func:`.timeit` will automatically determine the number of "
"repetitions only when the command-line interface is used.  In the :ref:"
"`timeit-examples` section you can find more advanced examples."
msgstr ""
"Зауважте, однак, що :func:`.timeit` автоматично визначатиме кількість "
"повторень, лише якщо використовується інтерфейс командного рядка. У розділі :"
"ref:`timeit-examples` ви можете знайти більш складні приклади."

#: ../../library/timeit.rst:60
msgid "Python Interface"
msgstr "Інтерфейс Python"

#: ../../library/timeit.rst:62
msgid "The module defines three convenience functions and a public class:"
msgstr "Модуль визначає три зручні функції та публічний клас:"

#: ../../library/timeit.rst:67
msgid ""
"Create a :class:`Timer` instance with the given statement, *setup* code and "
"*timer* function and run its :meth:`.timeit` method with *number* "
"executions. The optional *globals* argument specifies a namespace in which "
"to execute the code."
msgstr ""
"Створіть екземпляр :class:`Timer` із заданим оператором, кодом *setup* і "
"функцією *timer* і запустіть його метод :meth:`.timeit` з *кількістю* "
"виконань. Необов’язковий аргумент *globals* визначає простір імен, у якому "
"виконуватиметься код."

#: ../../library/timeit.rst:72 ../../library/timeit.rst:83
#: ../../library/timeit.rst:120
msgid "The optional *globals* parameter was added."
msgstr "Додано необов’язковий параметр *globals*."

#: ../../library/timeit.rst:78
msgid ""
"Create a :class:`Timer` instance with the given statement, *setup* code and "
"*timer* function and run its :meth:`.repeat` method with the given *repeat* "
"count and *number* executions.  The optional *globals* argument specifies a "
"namespace in which to execute the code."
msgstr ""
"Створіть екземпляр :class:`Timer` із заданим оператором, кодом *setup* і "
"функцією *timer* і запустіть його метод :meth:`.repeat` із заданою кількістю "
"*repeat* і *кількістю* виконань. Необов’язковий аргумент *globals* визначає "
"простір імен, у якому виконуватиметься код."

#: ../../library/timeit.rst:86 ../../library/timeit.rst:181
msgid "Default value of *repeat* changed from 3 to 5."
msgstr "Значення *repeat* за замовчуванням змінено з 3 на 5."

#: ../../library/timeit.rst:91
msgid "The default timer, which is always :func:`time.perf_counter`."
msgstr "Таймер за умовчанням, яким завжди є :func:`time.perf_counter`."

#: ../../library/timeit.rst:93
msgid ":func:`time.perf_counter` is now the default timer."
msgstr ":func:`time.perf_counter` тепер є таймером за умовчанням."

#: ../../library/timeit.rst:99
msgid "Class for timing execution speed of small code snippets."
msgstr "Клас швидкості виконання невеликих фрагментів коду."

#: ../../library/timeit.rst:101
msgid ""
"The constructor takes a statement to be timed, an additional statement used "
"for setup, and a timer function.  Both statements default to ``'pass'``; the "
"timer function is platform-dependent (see the module doc string). *stmt* and "
"*setup* may also contain multiple statements separated by ``;`` or newlines, "
"as long as they don't contain multi-line string literals.  The statement "
"will by default be executed within timeit's namespace; this behavior can be "
"controlled by passing a namespace to *globals*."
msgstr ""
"Конструктор приймає інструкцію для визначення часу, додаткову інструкцію, "
"яка використовується для налаштування, і функцію таймера. Обидва оператори "
"за замовчуванням ``'pass'``; функція таймера залежить від платформи "
"(дивіться рядок документа модуля). *stmt* і *setup* також можуть містити "
"кілька операторів, розділених символами ``;`` або символами нового рядка, за "
"умови, що вони не містять багаторядкових рядкових літералів. Оператор за "
"замовчуванням виконуватиметься в межах простору імен timeit; цією поведінкою "
"можна керувати, передавши простір імен у *globals*."

#: ../../library/timeit.rst:109
msgid ""
"To measure the execution time of the first statement, use the :meth:`."
"timeit` method.  The :meth:`.repeat` and :meth:`.autorange` methods are "
"convenience methods to call :meth:`.timeit` multiple times."
msgstr ""
"Щоб виміряти час виконання першого оператора, використовуйте метод :meth:`."
"timeit`. Методи :meth:`.repeat` і :meth:`.autorange` є зручними для виклику :"
"meth:`.timeit` кілька разів."

#: ../../library/timeit.rst:113
msgid ""
"The execution time of *setup* is excluded from the overall timed execution "
"run."
msgstr "Час виконання *setup* виключається із загального часу виконання."

#: ../../library/timeit.rst:115
msgid ""
"The *stmt* and *setup* parameters can also take objects that are callable "
"without arguments.  This will embed calls to them in a timer function that "
"will then be executed by :meth:`.timeit`.  Note that the timing overhead is "
"a little larger in this case because of the extra function calls."
msgstr ""
"Параметри *stmt* і *setup* також можуть приймати об’єкти, які можна "
"викликати без аргументів. Це вбудує виклики до них у функцію таймера, яка "
"потім буде виконана :meth:`.timeit`. Зверніть увагу, що накладні витрати "
"часу трохи більші в цьому випадку через додаткові виклики функцій."

#: ../../library/timeit.rst:125
msgid ""
"Time *number* executions of the main statement.  This executes the setup "
"statement once, and then returns the time it takes to execute the main "
"statement a number of times, measured in seconds as a float. The argument is "
"the number of times through the loop, defaulting to one million.  The main "
"statement, the setup statement and the timer function to be used are passed "
"to the constructor."
msgstr ""
"Час *кількість* виконання основного оператора. Це виконує оператор "
"налаштування один раз, а потім повертає час, необхідний для виконання "
"основного оператора кілька разів, виміряний у секундах як число з плаваючою "
"точкою. Аргументом є кількість проходжень циклу, за замовчуванням один "
"мільйон. Основний оператор, оператор налаштування та функція таймера, які "
"будуть використані, передаються конструктору."

#: ../../library/timeit.rst:134
msgid ""
"By default, :meth:`.timeit` temporarily turns off :term:`garbage collection` "
"during the timing.  The advantage of this approach is that it makes "
"independent timings more comparable.  The disadvantage is that GC may be an "
"important component of the performance of the function being measured.  If "
"so, GC can be re-enabled as the first statement in the *setup* string.  For "
"example::"
msgstr ""
"За замовчуванням :meth:`.timeit` тимчасово вимикає :term:`garbage "
"collection` протягом часу. Перевага цього підходу полягає в тому, що він "
"робить незалежні таймінги більш порівнянними. Недоліком є те, що GC може "
"бути важливим компонентом продуктивності вимірюваної функції. Якщо так, GC "
"можна повторно ввімкнути як перший оператор у рядку *setup*. Наприклад::"

#: ../../library/timeit.rst:146
msgid "Automatically determine how many times to call :meth:`.timeit`."
msgstr "Автоматично визначати, скільки разів викликати :meth:`.timeit`."

#: ../../library/timeit.rst:148
msgid ""
"This is a convenience function that calls :meth:`.timeit` repeatedly so that "
"the total time >= 0.2 second, returning the eventual (number of loops, time "
"taken for that number of loops). It calls :meth:`.timeit` with increasing "
"numbers from the sequence 1, 2, 5, 10, 20, 50, ... until the time taken is "
"at least 0.2 second."
msgstr ""
"Це зручна функція, яка викликає :meth:`.timeit` неодноразово, щоб загальний "
"час становив >= 0,2 секунди, повертаючи остаточне значення (кількість "
"циклів, час, витрачений на цю кількість циклів). Він викликає :meth:`."
"timeit` із зростаючими числами з послідовності 1, 2, 5, 10, 20, 50, ... до "
"тих пір, поки витрачений час не становитиме принаймні 0,2 секунди."

#: ../../library/timeit.rst:154
msgid ""
"If *callback* is given and is not ``None``, it will be called after each "
"trial with two arguments: ``callback(number, time_taken)``."
msgstr ""
"Якщо надано *callback*, а не ``None``, його буде викликано після кожного "
"випробування з двома аргументами: ``callback(number, time_taken)``."

#: ../../library/timeit.rst:162
msgid "Call :meth:`.timeit` a few times."
msgstr "Викличте :meth:`.timeit` кілька разів."

#: ../../library/timeit.rst:164
msgid ""
"This is a convenience function that calls the :meth:`.timeit` repeatedly, "
"returning a list of results.  The first argument specifies how many times to "
"call :meth:`.timeit`.  The second argument specifies the *number* argument "
"for :meth:`.timeit`."
msgstr ""
"Це зручна функція, яка багаторазово викликає :meth:`.timeit`, повертаючи "
"список результатів. Перший аргумент визначає, скільки разів викликати :meth:"
"`.timeit`. Другий аргумент визначає аргумент *число* для :meth:`.timeit`."

#: ../../library/timeit.rst:171
msgid ""
"It's tempting to calculate mean and standard deviation from the result "
"vector and report these.  However, this is not very useful. In a typical "
"case, the lowest value gives a lower bound for how fast your machine can run "
"the given code snippet; higher values in the result vector are typically not "
"caused by variability in Python's speed, but by other processes interfering "
"with your timing accuracy. So the :func:`min` of the result is probably the "
"only number you should be interested in.  After that, you should look at the "
"entire vector and apply common sense rather than statistics."
msgstr ""
"Спокусливо обчислити середнє та стандартне відхилення від вектора результату "
"та повідомити про це. Однак це не дуже корисно. У типовому випадку найнижче "
"значення дає нижню межу того, наскільки швидко ваша машина може запускати "
"заданий фрагмент коду; більш високі значення у векторі результату зазвичай "
"спричинені не мінливістю швидкості Python, а іншими процесами, які заважають "
"вашій точності синхронізації. Тож :func:`min` результату, ймовірно, єдине "
"число, яке вас має цікавити. Після цього вам слід переглянути весь вектор і "
"застосувати здоровий глузд, а не статистику."

#: ../../library/timeit.rst:187
msgid "Helper to print a traceback from the timed code."
msgstr "Помічник для друку зворотного відстеження з часового коду."

#: ../../library/timeit.rst:189
msgid "Typical use::"
msgstr "Типове використання::"

#: ../../library/timeit.rst:197
msgid ""
"The advantage over the standard traceback is that source lines in the "
"compiled template will be displayed.  The optional *file* argument directs "
"where the traceback is sent; it defaults to :data:`sys.stderr`."
msgstr ""
"Перевага перед стандартним трасуванням полягає в тому, що вихідні рядки у "
"скомпільованому шаблоні відображатимуться. Необов'язковий аргумент *file* "
"вказує, куди надсилається відстеження; за замовчуванням :data:`sys.stderr`."

#: ../../library/timeit.rst:205
msgid "Command-Line Interface"
msgstr "Інтерфейс командного рядка"

#: ../../library/timeit.rst:207
msgid ""
"When called as a program from the command line, the following form is used::"
msgstr "При виклику програми з командного рядка використовується така форма:"

#: ../../library/timeit.rst:211
msgid "Where the following options are understood:"
msgstr "Де розуміються такі варіанти:"

#: ../../library/timeit.rst:217
msgid "how many times to execute 'statement'"
msgstr "скільки разів виконати 'оператор'"

#: ../../library/timeit.rst:221
msgid "how many times to repeat the timer (default 5)"
msgstr "скільки разів повторити таймер (за замовчуванням 5)"

#: ../../library/timeit.rst:225
msgid "statement to be executed once initially (default ``pass``)"
msgstr "оператор, який буде виконано один раз (за замовчуванням ``pass``)"

#: ../../library/timeit.rst:229
msgid ""
"measure process time, not wallclock time, using :func:`time.process_time` "
"instead of :func:`time.perf_counter`, which is the default"
msgstr ""
"вимірювати час процесу, а не час настінного годинника, використовуючи :func:"
"`time.process_time` замість :func:`time.perf_counter`, який є типовим"

#: ../../library/timeit.rst:236
msgid ""
"specify a time unit for timer output; can select nsec, usec, msec, or sec"
msgstr ""

#: ../../library/timeit.rst:242
msgid "print raw timing results; repeat for more digits precision"
msgstr ""
"друк необроблених результатів синхронізації; повторіть для більшої точності "
"цифр"

#: ../../library/timeit.rst:246
msgid "print a short usage message and exit"
msgstr "надрукувати коротке повідомлення про використання та вийти"

#: ../../library/timeit.rst:248
msgid ""
"A multi-line statement may be given by specifying each line as a separate "
"statement argument; indented lines are possible by enclosing an argument in "
"quotes and using leading spaces.  Multiple :option:`-s` options are treated "
"similarly."
msgstr ""
"Багаторядковий оператор може бути заданий шляхом визначення кожного рядка як "
"окремого аргументу оператора; рядки з відступом можливі, якщо взяти аргумент "
"у лапки та використовувати пробіли на початку. Кілька параметрів :option:`-"
"s` обробляються аналогічно."

#: ../../library/timeit.rst:253
msgid ""
"If :option:`-n` is not given, a suitable number of loops is calculated by "
"trying increasing numbers from the sequence 1, 2, 5, 10, 20, 50, ... until "
"the total time is at least 0.2 seconds."
msgstr ""
"Якщо :option:`-n` не вказано, відповідна кількість циклів обчислюється "
"шляхом спроб збільшення чисел із послідовності 1, 2, 5, 10, 20, 50, ... доки "
"загальний час не становитиме принаймні 0,2 секунди ."

#: ../../library/timeit.rst:257
msgid ""
":func:`default_timer` measurements can be affected by other programs running "
"on the same machine, so the best thing to do when accurate timing is "
"necessary is to repeat the timing a few times and use the best time.  The :"
"option:`-r` option is good for this; the default of 5 repetitions is "
"probably enough in most cases.  You can use :func:`time.process_time` to "
"measure CPU time."
msgstr ""
" На вимірювання  :func:`default_timer` можуть впливати інші програми, "
"запущені на тій же машині, тому найкраще, що можна зробити, коли потрібен "
"точний час, це повторити відлік часу кілька разів і використовувати "
"найкращий час. Опція :option:`-r` підходить для цього; 5 повторень за "
"замовчуванням, ймовірно, достатньо в більшості випадків. Ви можете "
"використовувати :func:`time.process_time` для вимірювання часу ЦП."

#: ../../library/timeit.rst:265
msgid ""
"There is a certain baseline overhead associated with executing a pass "
"statement. The code here doesn't try to hide it, but you should be aware of "
"it.  The baseline overhead can be measured by invoking the program without "
"arguments, and it might differ between Python versions."
msgstr ""
"Існує певна базова накладна вартість, пов’язана з виконанням оператора "
"проходу. Код тут не намагається це приховати, але ви повинні про це знати. "
"Базові накладні витрати можна виміряти, викликавши програму без аргументів, "
"і вони можуть відрізнятися в різних версіях Python."

#: ../../library/timeit.rst:274
msgid "Examples"
msgstr "Приклади"

#: ../../library/timeit.rst:276
msgid ""
"It is possible to provide a setup statement that is executed only once at "
"the beginning:"
msgstr ""
"Можна надати оператор налаштування, який виконується лише один раз на "
"початку:"

#: ../../library/timeit.rst:285
msgid ""
"In the output, there are three fields. The loop count, which tells you how "
"many times the statement body was run per timing loop repetition. The "
"repetition count ('best of 5') which tells you how many times the timing "
"loop was repeated, and finally the time the statement body took on average "
"within the best repetition of the timing loop. That is, the time the fastest "
"repetition took divided by the loop count."
msgstr ""
"У вихідних даних є три поля. Кількість циклів, яка повідомляє вам, скільки "
"разів було виконано тіло оператора за повторення циклу синхронізації. "
"Кількість повторів (\"найкраще з 5\"), яка повідомляє вам, скільки разів "
"цикл синхронізації повторювався, і, нарешті, час, який у середньому "
"витрачено на тіло оператора протягом найкращого повторення циклу "
"синхронізації. Тобто час найшвидшого повторення, поділений на кількість "
"циклів."

#: ../../library/timeit.rst:300
msgid "The same can be done using the :class:`Timer` class and its methods::"
msgstr ""
"Те саме можна зробити за допомогою класу :class:`Timer` та його методів:"

#: ../../library/timeit.rst:310
msgid ""
"The following examples show how to time expressions that contain multiple "
"lines. Here we compare the cost of using :func:`hasattr` vs. :keyword:`try`/:"
"keyword:`except` to test for missing and present object attributes:"
msgstr ""
"У наведених нижче прикладах показано, як визначити час для виразів, які "
"містять кілька рядків. Тут ми порівнюємо вартість використання :func:"
"`hasattr` і :keyword:`try`/:keyword:`except` для перевірки відсутніх і "
"присутніх атрибутів об’єкта:"

#: ../../library/timeit.rst:356
msgid ""
"To give the :mod:`timeit` module access to functions you define, you can "
"pass a *setup* parameter which contains an import statement::"
msgstr ""
"Щоб надати модулю :mod:`timeit` доступ до визначених вами функцій, ви можете "
"передати параметр *setup*, який містить оператор імпорту::"

#: ../../library/timeit.rst:367
msgid ""
"Another option is to pass :func:`globals` to the  *globals* parameter, which "
"will cause the code to be executed within your current global namespace.  "
"This can be more convenient than individually specifying imports::"
msgstr ""
"Іншим варіантом є передача :func:`globals` у параметр *globals*, що "
"спричинить виконання коду у вашому поточному глобальному просторі імен. Це "
"може бути зручніше, ніж індивідуальне визначення імпорту:"
