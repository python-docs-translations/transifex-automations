# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-07-25 19:10+0000\n"
"PO-Revision-Date: 2025-07-18 19:17+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../c-api/structures.rst:6
msgid "Common Object Structures"
msgstr "Загальні структури об'єктів"

#: ../../c-api/structures.rst:8
msgid ""
"There are a large number of structures which are used in the definition of "
"object types for Python.  This section describes these structures and how "
"they are used."
msgstr ""
"Існує велика кількість структур, які використовуються для визначення типів "
"об’єктів для Python. У цьому розділі описано ці структури та як вони "
"використовуються."

#: ../../c-api/structures.rst:14
msgid "Base object types and macros"
msgstr "Базові типи об'єктів і макроси"

#: ../../c-api/structures.rst:16
msgid ""
"All Python objects ultimately share a small number of fields at the "
"beginning of the object's representation in memory.  These are represented "
"by the :c:type:`PyObject` and :c:type:`PyVarObject` types, which are "
"defined, in turn, by the expansions of some macros also used, whether "
"directly or indirectly, in the definition of all other Python objects."
msgstr ""
"Зрештою, усі об’єкти Python мають спільну невелику кількість полів на "
"початку представлення об’єкта в пам’яті. Вони представлені типами :c:type:"
"`PyObject` і :c:type:`PyVarObject`, які, у свою чергу, визначаються "
"розширеннями деяких макросів, які також використовуються, прямо чи "
"опосередковано, у визначенні всіх інші об’єкти Python."

#: ../../c-api/structures.rst:25
msgid ""
"All object types are extensions of this type.  This is a type which contains "
"the information Python needs to treat a pointer to an object as an object.  "
"In a normal \"release\" build, it contains only the object's reference count "
"and a pointer to the corresponding type object. Nothing is actually declared "
"to be a :c:type:`PyObject`, but every pointer to a Python object can be cast "
"to a :c:type:`PyObject*`.  Access to the members must be done by using the "
"macros :c:macro:`Py_REFCNT` and :c:macro:`Py_TYPE`."
msgstr ""
"Усі типи об’єктів є розширеннями цього типу. Це тип, який містить "
"інформацію, необхідну Python, щоб розглядати покажчик на об’єкт як об’єкт. У "
"звичайній \"релізній\" збірці він містить лише кількість посилань на об’єкт "
"і вказівник на об’єкт відповідного типу. Насправді нічого не оголошено як :c:"
"type:`PyObject`, але кожен вказівник на об’єкт Python може бути приведений "
"до :c:type:`PyObject*`. Доступ до учасників має здійснюватися за допомогою "
"макросів :c:macro:`Py_REFCNT` і :c:macro:`Py_TYPE`."

#: ../../c-api/structures.rst:37
msgid ""
"This is an extension of :c:type:`PyObject` that adds the :attr:`ob_size` "
"field.  This is only used for objects that have some notion of *length*. "
"This type does not often appear in the Python/C API. Access to the members "
"must be done by using the macros :c:macro:`Py_REFCNT`, :c:macro:`Py_TYPE`, "
"and :c:macro:`Py_SIZE`."
msgstr ""
"Це розширення :c:type:`PyObject`, яке додає поле :attr:`ob_size`. Це "
"використовується лише для об’єктів, які мають деяке поняття *довжини*. Цей "
"тип не часто зустрічається в Python/C API. Доступ до учасників має "
"здійснюватися за допомогою макросів :c:macro:`Py_REFCNT`, :c:macro:`Py_TYPE` "
"і :c:macro:`Py_SIZE`."

#: ../../c-api/structures.rst:46
msgid ""
"This is a macro used when declaring new types which represent objects "
"without a varying length.  The PyObject_HEAD macro expands to::"
msgstr ""
"Це макрос, який використовується під час оголошення нових типів, які "
"представляють об’єкти без змінної довжини. Макрос PyObject_HEAD розширюється "
"до:"

#: ../../c-api/structures.rst:51
msgid "See documentation of :c:type:`PyObject` above."
msgstr "Перегляньте документацію :c:type:`PyObject` вище."

#: ../../c-api/structures.rst:56
msgid ""
"This is a macro used when declaring new types which represent objects with a "
"length that varies from instance to instance. The PyObject_VAR_HEAD macro "
"expands to::"
msgstr ""
"Це макрос, який використовується під час оголошення нових типів, які "
"представляють об’єкти з довжиною, що змінюється від екземпляра до "
"екземпляра. Макрос PyObject_VAR_HEAD розширюється до:"

#: ../../c-api/structures.rst:62
msgid "See documentation of :c:type:`PyVarObject` above."
msgstr "Перегляньте документацію :c:type:`PyVarObject` вище."

#: ../../c-api/structures.rst:67
msgid ""
"This macro is used to access the :attr:`ob_type` member of a Python object. "
"It expands to::"
msgstr ""

#: ../../c-api/structures.rst:75
msgid ""
"Return non-zero if the object *o* type is *type*. Return zero otherwise. "
"Equivalent to: ``Py_TYPE(o) == type``."
msgstr ""
"Повертає ненульове значення, якщо тип об’єкта *o* є *type*. Інакше поверніть "
"нуль. Еквівалент: ``Py_TYPE(o) == type``."

#: ../../c-api/structures.rst:83
msgid "Set the object *o* type to *type*."
msgstr "Встановіть тип об’єкта *o* на *type*."

#: ../../c-api/structures.rst:90
msgid ""
"This macro is used to access the :attr:`ob_refcnt` member of a Python "
"object. It expands to::"
msgstr ""

#: ../../c-api/structures.rst:99
msgid "Set the object *o* reference counter to *refcnt*."
msgstr "Встановіть лічильник посилань *o* на *refcnt*."

#: ../../c-api/structures.rst:106
msgid ""
"This macro is used to access the :attr:`ob_size` member of a Python object. "
"It expands to::"
msgstr ""

#: ../../c-api/structures.rst:114
msgid "Set the object *o* size to *size*."
msgstr "Встановіть розмір об’єкта *o* на *size*."

#: ../../c-api/structures.rst:121
msgid ""
"This is a macro which expands to initialization values for a new :c:type:"
"`PyObject` type.  This macro expands to::"
msgstr ""
"Це макрос, який розширюється до значень ініціалізації для нового типу :c:"
"type:`PyObject`. Цей макрос розширюється до:"

#: ../../c-api/structures.rst:130
msgid ""
"This is a macro which expands to initialization values for a new :c:type:"
"`PyVarObject` type, including the :attr:`ob_size` field. This macro expands "
"to::"
msgstr ""
"Це макрос, який розширюється до значень ініціалізації для нового типу :c:"
"type:`PyVarObject`, включаючи поле :attr:`ob_size`. Цей макрос розширюється "
"до:"

#: ../../c-api/structures.rst:139
msgid "Implementing functions and methods"
msgstr "Реалізація функцій і методів"

#: ../../c-api/structures.rst:143
msgid ""
"Type of the functions used to implement most Python callables in C. "
"Functions of this type take two :c:type:`PyObject*` parameters and return "
"one such value.  If the return value is ``NULL``, an exception shall have "
"been set.  If not ``NULL``, the return value is interpreted as the return "
"value of the function as exposed in Python.  The function must return a new "
"reference."
msgstr ""
"Тип функцій, які використовуються для реалізації більшості викликів Python у "
"C. Функції цього типу приймають два параметри :c:type:`PyObject*` і "
"повертають одне таке значення. Якщо повертається значення ``NULL``, має бути "
"встановлено виняток. Якщо не ``NULL``, повернене значення інтерпретується як "
"повернене значення функції, представлене в Python. Функція має повертати "
"нове посилання."

#: ../../c-api/structures.rst:150
msgid "The function signature is::"
msgstr "Сигнатура функції:"

#: ../../c-api/structures.rst:157
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :const:`METH_VARARGS | METH_KEYWORDS`. The function signature is::"
msgstr ""
"Тип функцій, які використовуються для реалізації викликів Python у C із "
"підписом :const:`METH_VARARGS | METH_KEYWORDS`. Сигнатура функції:"

#: ../../c-api/structures.rst:168
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :const:`METH_FASTCALL`. The function signature is::"
msgstr ""
"Тип функцій, які використовуються для реалізації викликів Python у C із "
"підписом :const:`METH_FASTCALL`. Сигнатура функції:"

#: ../../c-api/structures.rst:178
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :const:`METH_FASTCALL | METH_KEYWORDS`. The function signature is::"
msgstr ""
"Тип функцій, які використовуються для реалізації викликів Python у C із "
"підписом :const:`METH_FASTCALL | METH_KEYWORDS`. Сигнатура функції:"

#: ../../c-api/structures.rst:189
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :const:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`. The function "
"signature is::"
msgstr ""
"Тип функцій, які використовуються для реалізації викликів Python у C із "
"підписом :const:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`. Сигнатура "
"функції:"

#: ../../c-api/structures.rst:204
msgid ""
"Structure used to describe a method of an extension type.  This structure "
"has four fields:"
msgstr ""
"Структура, що використовується для опису методу типу розширення. Ця "
"структура має чотири поля:"

#: ../../c-api/structures.rst:208 ../../c-api/structures.rst:364
#: ../../c-api/structures.rst:460
msgid "Field"
msgstr "Поле"

#: ../../c-api/structures.rst:208 ../../c-api/structures.rst:364
#: ../../c-api/structures.rst:460
msgid "C Type"
msgstr "C Тип"

#: ../../c-api/structures.rst:208 ../../c-api/structures.rst:364
#: ../../c-api/structures.rst:460
msgid "Meaning"
msgstr "Значення"

#: ../../c-api/structures.rst:210
msgid ":attr:`ml_name`"
msgstr ":attr:`ml_name`"

#: ../../c-api/structures.rst:210 ../../c-api/structures.rst:218
#: ../../c-api/structures.rst:366 ../../c-api/structures.rst:379
#: ../../c-api/structures.rst:395 ../../c-api/structures.rst:462
#: ../../c-api/structures.rst:470
msgid "const char \\*"
msgstr "const char \\*"

#: ../../c-api/structures.rst:210
msgid "name of the method"
msgstr "назва методу"

#: ../../c-api/structures.rst:212
msgid ":attr:`ml_meth`"
msgstr ":attr:`ml_meth`"

#: ../../c-api/structures.rst:212
msgid "PyCFunction"
msgstr "PyCFunction"

#: ../../c-api/structures.rst:212
msgid "pointer to the C implementation"
msgstr "покажчик на реалізацію C"

#: ../../c-api/structures.rst:215
msgid ":attr:`ml_flags`"
msgstr ":attr:`ml_flags`"

#: ../../c-api/structures.rst:215 ../../c-api/structures.rst:368
#: ../../c-api/structures.rst:375 ../../c-api/structures.rst:391
msgid "int"
msgstr "int"

#: ../../c-api/structures.rst:215
msgid "flag bits indicating how the call should be constructed"
msgstr "біти прапорців, що вказують, як має бути побудований виклик"

#: ../../c-api/structures.rst:218
msgid ":attr:`ml_doc`"
msgstr ":attr:`ml_doc`"

#: ../../c-api/structures.rst:218 ../../c-api/structures.rst:379
msgid "points to the contents of the docstring"
msgstr "вказує на вміст рядка документації"

#: ../../c-api/structures.rst:222
msgid ""
"The :attr:`ml_meth` is a C function pointer.  The functions may be of "
"different types, but they always return :c:type:`PyObject*`.  If the "
"function is not of the :c:type:`PyCFunction`, the compiler will require a "
"cast in the method table. Even though :c:type:`PyCFunction` defines the "
"first parameter as :c:type:`PyObject*`, it is common that the method "
"implementation uses the specific C type of the *self* object."
msgstr ""
":attr:`ml_meth` — це покажчик на функцію C. Функції можуть бути різних "
"типів, але вони завжди повертають :c:type:`PyObject*`. Якщо функція не є :c:"
"type:`PyCFunction`, компілятор вимагатиме приведення в таблиці методів. "
"Незважаючи на те, що :c:type:`PyCFunction` визначає перший параметр як :c:"
"type:`PyObject*`, зазвичай у реалізації методу використовується конкретний "
"тип C об’єкта *self*."

#: ../../c-api/structures.rst:229
msgid ""
"The :attr:`ml_flags` field is a bitfield which can include the following "
"flags. The individual flags indicate either a calling convention or a "
"binding convention."
msgstr ""
"Поле :attr:`ml_flags` — це бітове поле, яке може містити наступні прапорці. "
"Окремі прапорці вказують або на угоду про виклик, або на прив’язувальну "
"угоду."

#: ../../c-api/structures.rst:233
msgid "There are these calling conventions:"
msgstr "Існують такі умови виклику:"

#: ../../c-api/structures.rst:237
msgid ""
"This is the typical calling convention, where the methods have the type :c:"
"type:`PyCFunction`. The function expects two :c:type:`PyObject*` values. The "
"first one is the *self* object for methods; for module functions, it is the "
"module object.  The second parameter (often called *args*) is a tuple object "
"representing all arguments. This parameter is typically processed using :c:"
"func:`PyArg_ParseTuple` or :c:func:`PyArg_UnpackTuple`."
msgstr ""
"Це типова угода про виклики, де методи мають тип :c:type:`PyCFunction`. "
"Функція очікує два значення :c:type:`PyObject*`. Перший — об’єкт *self* для "
"методів; для функцій модуля це об’єкт модуля. Другий параметр (часто званий "
"*args*) — це об’єкт кортежу, що представляє всі аргументи. Цей параметр "
"зазвичай обробляється за допомогою :c:func:`PyArg_ParseTuple` або :c:func:"
"`PyArg_UnpackTuple`."

#: ../../c-api/structures.rst:247
msgid ""
"Methods with these flags must be of type :c:type:`PyCFunctionWithKeywords`. "
"The function expects three parameters: *self*, *args*, *kwargs* where "
"*kwargs* is a dictionary of all the keyword arguments or possibly ``NULL`` "
"if there are no keyword arguments.  The parameters are typically processed "
"using :c:func:`PyArg_ParseTupleAndKeywords`."
msgstr ""
"Методи з цими прапорцями мають бути типу :c:type:`PyCFunctionWithKeywords`. "
"Функція очікує три параметри: *self*, *args*, *kwargs*, де *kwargs* є "
"словником усіх аргументів ключового слова або, можливо, ``NULL``, якщо "
"аргументів ключового слова немає. Параметри зазвичай обробляються за "
"допомогою :c:func:`PyArg_ParseTupleAndKeywords`."

#: ../../c-api/structures.rst:256
msgid ""
"Fast calling convention supporting only positional arguments. The methods "
"have the type :c:type:`_PyCFunctionFast`. The first parameter is *self*, the "
"second parameter is a C array of :c:type:`PyObject*` values indicating the "
"arguments and the third parameter is the number of arguments (the length of "
"the array)."
msgstr ""
"Правила швидкого виклику, які підтримують лише позиційні аргументи. Методи "
"мають тип :c:type:`_PyCFunctionFast`. Перший параметр — *self*, другий "
"параметр — це масив C значень :c:type:`PyObject*`, що вказує на аргументи, а "
"третій параметр — це кількість аргументів (довжина масиву)."

#: ../../c-api/structures.rst:262 ../../c-api/structures.rst:279
msgid "This is not part of the :ref:`limited API <stable>`."
msgstr ""

#: ../../c-api/structures.rst:269
msgid ""
"Extension of :const:`METH_FASTCALL` supporting also keyword arguments, with "
"methods of type :c:type:`_PyCFunctionFastWithKeywords`. Keyword arguments "
"are passed the same way as in the :ref:`vectorcall protocol <vectorcall>`: "
"there is an additional fourth :c:type:`PyObject*` parameter which is a tuple "
"representing the names of the keyword arguments (which are guaranteed to be "
"strings) or possibly ``NULL`` if there are no keywords.  The values of the "
"keyword arguments are stored in the *args* array, after the positional "
"arguments."
msgstr ""
"Розширення :const:`METH_FASTCALL`, що також підтримує ключові аргументи з "
"методами типу :c:type:`_PyCFunctionFastWithKeywords`. Аргументи ключових "
"слів передаються так само, як у протоколі :ref:`vectorcall <vectorcall>`: є "
"додатковий четвертий параметр :c:type:`PyObject*`, який є кортежем, що "
"представляє імена аргументів ключових слів (які гарантовано бути рядками) "
"або, можливо, ``NULL``, якщо немає ключових слів. Значення аргументів "
"ключових слів зберігаються в масиві *args* після позиційних аргументів."

#: ../../c-api/structures.rst:286
msgid ""
"Extension of :const:`METH_FASTCALL | METH_KEYWORDS` supporting the *defining "
"class*, that is, the class that contains the method in question. The "
"defining class might be a superclass of ``Py_TYPE(self)``."
msgstr ""
"Розширення :const:`METH_FASTCALL | METH_KEYWORDS`, що підтримує "
"*визначальний клас*, тобто клас, який містить відповідний метод. "
"Визначальним класом може бути суперклас ``Py_TYPE(self)``."

#: ../../c-api/structures.rst:290
msgid ""
"The method needs to be of type :c:type:`PyCMethod`, the same as for "
"``METH_FASTCALL | METH_KEYWORDS`` with ``defining_class`` argument added "
"after ``self``."
msgstr ""
"Метод має мати тип :c:type:`PyCMethod`, такий самий, як і для "
"``METH_FASTCALL | METH_KEYWORDS`` з аргументом ``defining_class``, доданим "
"після ``self``."

#: ../../c-api/structures.rst:299
msgid ""
"Methods without parameters don't need to check whether arguments are given "
"if they are listed with the :const:`METH_NOARGS` flag.  They need to be of "
"type :c:type:`PyCFunction`.  The first parameter is typically named *self* "
"and will hold a reference to the module or object instance.  In all cases "
"the second parameter will be ``NULL``."
msgstr ""
"Методам без параметрів не потрібно перевіряти, чи надано аргументи, якщо "
"вони вказані з прапорцем :const:`METH_NOARGS`. Вони мають бути типу :c:type:"
"`PyCFunction`. Перший параметр зазвичай називається *self* і містить "
"посилання на екземпляр модуля або об’єкта. У всіх випадках другий параметр "
"буде ``NULL``."

#: ../../c-api/structures.rst:308
msgid ""
"Methods with a single object argument can be listed with the :const:`METH_O` "
"flag, instead of invoking :c:func:`PyArg_ParseTuple` with a ``\"O\"`` "
"argument. They have the type :c:type:`PyCFunction`, with the *self* "
"parameter, and a :c:type:`PyObject*` parameter representing the single "
"argument."
msgstr ""
"Методи з одним аргументом об’єкта можна вказати з прапорцем :const:`METH_O` "
"замість виклику :c:func:`PyArg_ParseTuple` з аргументом ``\"O\"``. Вони "
"мають тип :c:type:`PyCFunction` з параметром *self* і параметром :c:type:"
"`PyObject*`, що представляє єдиний аргумент."

#: ../../c-api/structures.rst:314
msgid ""
"These two constants are not used to indicate the calling convention but the "
"binding when use with methods of classes.  These may not be used for "
"functions defined for modules.  At most one of these flags may be set for "
"any given method."
msgstr ""
"Ці дві константи не використовуються для вказівки умов виклику, а для "
"прив’язки під час використання з методами класів. Їх не можна "
"використовувати для функцій, визначених для модулів. Щонайбільше один із цих "
"прапорів може бути встановлений для будь-якого методу."

#: ../../c-api/structures.rst:324
msgid ""
"The method will be passed the type object as the first parameter rather than "
"an instance of the type.  This is used to create *class methods*, similar to "
"what is created when using the :func:`classmethod` built-in function."
msgstr ""
"Методу буде передано об’єкт типу як перший параметр, а не екземпляр типу. Це "
"використовується для створення *методів класу*, подібних до того, що "
"створюється під час використання вбудованої функції :func:`classmethod`."

#: ../../c-api/structures.rst:334
msgid ""
"The method will be passed ``NULL`` as the first parameter rather than an "
"instance of the type.  This is used to create *static methods*, similar to "
"what is created when using the :func:`staticmethod` built-in function."
msgstr ""
"Методу буде передано ``NULL`` як перший параметр, а не екземпляр типу. Це "
"використовується для створення *статичних методів*, подібних до того, що "
"створюється під час використання вбудованої функції :func:`staticmethod`."

#: ../../c-api/structures.rst:338
msgid ""
"One other constant controls whether a method is loaded in place of another "
"definition with the same method name."
msgstr ""
"Ще одна константа контролює, чи завантажується метод замість іншого "
"визначення з таким же ім’ям методу."

#: ../../c-api/structures.rst:344
msgid ""
"The method will be loaded in place of existing definitions.  Without "
"*METH_COEXIST*, the default is to skip repeated definitions.  Since slot "
"wrappers are loaded before the method table, the existence of a "
"*sq_contains* slot, for example, would generate a wrapped method named :meth:"
"`__contains__` and preclude the loading of a corresponding PyCFunction with "
"the same name.  With the flag defined, the PyCFunction will be loaded in "
"place of the wrapper object and will co-exist with the slot.  This is "
"helpful because calls to PyCFunctions are optimized more than wrapper object "
"calls."
msgstr ""
"Метод буде завантажено замість існуючих визначень. Без *METH_COEXIST* за "
"замовчуванням повторювані визначення пропускаються. Оскільки обгортки слотів "
"завантажуються перед таблицею методів, існування слота *sq_contains*, "
"наприклад, створить обернутий метод під назвою :meth:`__contains__` і "
"завадить завантаженню відповідної функції PyCFunction з такою ж назвою. З "
"визначеним прапором PyCFunction буде завантажено замість об’єкта-огортки та "
"співіснуватиме зі слотом. Це корисно, оскільки виклики PyCFunctions "
"оптимізовані більше, ніж виклики об’єктів-огорток."

#: ../../c-api/structures.rst:356
msgid "Accessing attributes of extension types"
msgstr "Доступ до атрибутів типів розширень"

#: ../../c-api/structures.rst:360
msgid ""
"Structure which describes an attribute of a type which corresponds to a C "
"struct member.  Its fields are:"
msgstr ""
"Структура, яка описує атрибут типу, який відповідає члену структури C. Його "
"поля:"

#: ../../c-api/structures.rst:366
msgid ":attr:`name`"
msgstr ":attr:`name`"

#: ../../c-api/structures.rst:366
msgid "name of the member"
msgstr "ім'я учасника"

#: ../../c-api/structures.rst:368
msgid ":attr:`!type`"
msgstr ":attr:`!type`"

#: ../../c-api/structures.rst:368
msgid "the type of the member in the C struct"
msgstr "тип члена в структурі C"

#: ../../c-api/structures.rst:371
msgid ":attr:`offset`"
msgstr ":attr:`offset`"

#: ../../c-api/structures.rst:371 ../../c-api/structures.rst:407
msgid "Py_ssize_t"
msgstr "Py_ssize_t"

#: ../../c-api/structures.rst:371
msgid ""
"the offset in bytes that the member is located on the type's object struct"
msgstr "зсув у байтах, що член розташований у структурі об’єкта типу"

#: ../../c-api/structures.rst:375
msgid ":attr:`flags`"
msgstr ":attr:`flags`"

#: ../../c-api/structures.rst:375
msgid "flag bits indicating if the field should be read-only or writable"
msgstr ""
"біти прапорців, які вказують, чи має поле бути доступним лише для читання чи "
"доступним для запису"

#: ../../c-api/structures.rst:379
msgid ":attr:`doc`"
msgstr ":attr:`doc`"

#: ../../c-api/structures.rst:383
msgid ""
":attr:`!type` can be one of many ``T_`` macros corresponding to various C "
"types.  When the member is accessed in Python, it will be converted to the "
"equivalent Python type."
msgstr ""
":attr:`!type` може бути одним із багатьох макросів ``T_``, що відповідають "
"різним типам C. Коли до елемента звертаються в Python, його буде перетворено "
"на еквівалентний тип Python."

#: ../../c-api/structures.rst:388
msgid "Macro name"
msgstr "Назва макросу"

#: ../../c-api/structures.rst:388
msgid "C type"
msgstr "тип С"

#: ../../c-api/structures.rst:390
msgid "T_SHORT"
msgstr "T_SHORT"

#: ../../c-api/structures.rst:390
msgid "short"
msgstr "короткий"

#: ../../c-api/structures.rst:391
msgid "T_INT"
msgstr "T_INT"

#: ../../c-api/structures.rst:392
msgid "T_LONG"
msgstr "T_LONG"

#: ../../c-api/structures.rst:392
msgid "long"
msgstr "довгота"

#: ../../c-api/structures.rst:393
msgid "T_FLOAT"
msgstr "T_FLOAT"

#: ../../c-api/structures.rst:393
msgid "float"
msgstr "плавати"

#: ../../c-api/structures.rst:394
msgid "T_DOUBLE"
msgstr "T_DOUBLE"

#: ../../c-api/structures.rst:394
msgid "double"
msgstr "подвійний"

#: ../../c-api/structures.rst:395
msgid "T_STRING"
msgstr "T_STRING"

#: ../../c-api/structures.rst:396
msgid "T_OBJECT"
msgstr "T_OBJECT"

#: ../../c-api/structures.rst:396 ../../c-api/structures.rst:397
msgid "PyObject \\*"
msgstr "PyObject \\*"

#: ../../c-api/structures.rst:397
msgid "T_OBJECT_EX"
msgstr "T_OBJECT_EX"

#: ../../c-api/structures.rst:398
msgid "T_CHAR"
msgstr "T_CHAR"

#: ../../c-api/structures.rst:398 ../../c-api/structures.rst:399
#: ../../c-api/structures.rst:404
msgid "char"
msgstr "char"

#: ../../c-api/structures.rst:399
msgid "T_BYTE"
msgstr "T_BYTE"

#: ../../c-api/structures.rst:400
msgid "T_UBYTE"
msgstr "T_UBYTE"

#: ../../c-api/structures.rst:400
msgid "unsigned char"
msgstr "беззнаковий символ"

#: ../../c-api/structures.rst:401
msgid "T_UINT"
msgstr "T_UINT"

#: ../../c-api/structures.rst:401
msgid "unsigned int"
msgstr "unsigned int"

#: ../../c-api/structures.rst:402
msgid "T_USHORT"
msgstr "T_USHORT"

#: ../../c-api/structures.rst:402
msgid "unsigned short"
msgstr "непідписаний короткий"

#: ../../c-api/structures.rst:403
msgid "T_ULONG"
msgstr "T_ULONG"

#: ../../c-api/structures.rst:403
msgid "unsigned long"
msgstr "беззнаковий довгий"

#: ../../c-api/structures.rst:404
msgid "T_BOOL"
msgstr "T_BOOL"

#: ../../c-api/structures.rst:405
msgid "T_LONGLONG"
msgstr "T_LONGLONG"

#: ../../c-api/structures.rst:405
msgid "long long"
msgstr "довгий довгий"

#: ../../c-api/structures.rst:406
msgid "T_ULONGLONG"
msgstr "T_ULONGLONG"

#: ../../c-api/structures.rst:406
msgid "unsigned long long"
msgstr "без знака довгий довгий"

#: ../../c-api/structures.rst:407
msgid "T_PYSSIZET"
msgstr "T_PYSSIZET"

#: ../../c-api/structures.rst:410
msgid ""
":c:macro:`T_OBJECT` and :c:macro:`T_OBJECT_EX` differ in that :c:macro:"
"`T_OBJECT` returns ``None`` if the member is ``NULL`` and :c:macro:"
"`T_OBJECT_EX` raises an :exc:`AttributeError`.  Try to use :c:macro:"
"`T_OBJECT_EX` over :c:macro:`T_OBJECT` because :c:macro:`T_OBJECT_EX` "
"handles use of the :keyword:`del` statement on that attribute more correctly "
"than :c:macro:`T_OBJECT`."
msgstr ""
":c:macro:`T_OBJECT` і :c:macro:`T_OBJECT_EX` відрізняються тим, що :c:macro:"
"`T_OBJECT` повертає ``None``, якщо член має значення ``NULL`` і :c:macro:"
"`T_OBJECT_EX` викликає :exc:`AttributeError`. Спробуйте використовувати :c:"
"macro:`T_OBJECT_EX` замість :c:macro:`T_OBJECT`, оскільки :c:macro:"
"`T_OBJECT_EX` обробляє використання оператора :keyword:`del` для цього "
"атрибута правильніше, ніж :c:macro:`T_OBJECT`."

#: ../../c-api/structures.rst:417
msgid ""
":attr:`flags` can be ``0`` for write and read access or :c:macro:`READONLY` "
"for read-only access.  Using :c:macro:`T_STRING` for :attr:`type` implies :c:"
"macro:`READONLY`.  :c:macro:`T_STRING` data is interpreted as UTF-8. Only :c:"
"macro:`T_OBJECT` and :c:macro:`T_OBJECT_EX` members can be deleted.  (They "
"are set to ``NULL``)."
msgstr ""
":attr:`flags` може мати значення ``0`` для доступу до запису та читання або :"
"c:macro:`READONLY` для доступу лише для читання. Використання :c:macro:"
"`T_STRING` для :attr:`type` означає :c:macro:`READONLY`. Дані :c:macro:"
"`T_STRING` інтерпретуються як UTF-8. Можна видалити лише учасників :c:macro:"
"`T_OBJECT` і :c:macro:`T_OBJECT_EX`. (Їм встановлено значення ``NULL``)."

#: ../../c-api/structures.rst:425
msgid ""
"Heap allocated types (created using :c:func:`PyType_FromSpec` or similar), "
"``PyMemberDef`` may contain definitions for the special members "
"``__dictoffset__``, ``__weaklistoffset__`` and ``__vectorcalloffset__``, "
"corresponding to :c:member:`~PyTypeObject.tp_dictoffset`, :c:member:"
"`~PyTypeObject.tp_weaklistoffset` and :c:member:`~PyTypeObject."
"tp_vectorcall_offset` in type objects. These must be defined with "
"``T_PYSSIZET`` and ``READONLY``, for example::"
msgstr ""
"Виділені типи купи (створені за допомогою :c:func:`PyType_FromSpec` або "
"подібного), ``PyMemberDef`` може містити визначення для спеціальних членів "
"``__dictoffset__``, ``__weaklistoffset__`` та ``__vectorcalloffset__``, що "
"відповідають :c:member:`~PyTypeObject.tp_dictoffset`, :c:member:"
"`~PyTypeObject.tp_weaklistoffset` і :c:member:`~PyTypeObject."
"tp_vectorcall_offset` в об’єктах типу. Їх потрібно визначити за допомогою "
"``T_PYSSIZET`` і ``READONLY``, наприклад:"

#: ../../c-api/structures.rst:442
msgid ""
"Get an attribute belonging to the object at address *obj_addr*.  The "
"attribute is described by ``PyMemberDef`` *m*.  Returns ``NULL`` on error."
msgstr ""
"Отримати атрибут, що належить об’єкту за адресою *obj_addr*. Атрибут "
"описується ``PyMemberDef`` *m*. Повертає ``NULL`` у разі помилки."

#: ../../c-api/structures.rst:449
msgid ""
"Set an attribute belonging to the object at address *obj_addr* to object "
"*o*. The attribute to set is described by ``PyMemberDef`` *m*.  Returns "
"``0`` if successful and a negative value on failure."
msgstr ""
"Установіть атрибут, що належить об’єкту за адресою *obj_addr*, на об’єкт "
"*o*. Атрибут, який потрібно встановити, описується ``PyMemberDef`` *m*. "
"Повертає ``0`` у разі успіху та від'ємне значення у випадку невдачі."

#: ../../c-api/structures.rst:456
msgid ""
"Structure to define property-like access for a type. See also description of "
"the :c:member:`PyTypeObject.tp_getset` slot."
msgstr ""
"Структура для визначення доступу типу властивості. Дивіться також опис "
"слота :c:member:`PyTypeObject.tp_getset`."

#: ../../c-api/structures.rst:462
msgid "name"
msgstr "name"

#: ../../c-api/structures.rst:462
msgid "attribute name"
msgstr "назва атрибута"

#: ../../c-api/structures.rst:464
msgid "get"
msgstr "отримати"

#: ../../c-api/structures.rst:464
msgid "getter"
msgstr "добувач"

#: ../../c-api/structures.rst:464
msgid "C function to get the attribute"
msgstr "Функція C для отримання атрибута"

#: ../../c-api/structures.rst:466
msgid "set"
msgstr "встановити"

#: ../../c-api/structures.rst:466
msgid "setter"
msgstr "сетер"

#: ../../c-api/structures.rst:466
msgid ""
"optional C function to set or delete the attribute, if omitted the attribute "
"is readonly"
msgstr ""
"необов'язкова функція C для встановлення або видалення атрибута, якщо не "
"вказана, атрибут доступний лише для читання"

#: ../../c-api/structures.rst:470
msgid "doc"
msgstr "док"

#: ../../c-api/structures.rst:470
msgid "optional docstring"
msgstr "додатковий рядок документації"

#: ../../c-api/structures.rst:472
msgid "closure"
msgstr "закриття"

#: ../../c-api/structures.rst:472
msgid "void \\*"
msgstr "порожній \\*"

#: ../../c-api/structures.rst:472
msgid ""
"optional function pointer, providing additional data for getter and setter"
msgstr ""
"додатковий покажчик функції, що надає додаткові дані для геттера та сеттера"

#: ../../c-api/structures.rst:477
msgid ""
"The ``get`` function takes one :c:type:`PyObject*` parameter (the instance) "
"and a function pointer (the associated ``closure``)::"
msgstr ""
"Функція ``get`` приймає один параметр :c:type:`PyObject*` (екземпляр) і "
"покажчик на функцію (пов’язане ``closure``)::"

#: ../../c-api/structures.rst:482
msgid ""
"It should return a new reference on success or ``NULL`` with a set exception "
"on failure."
msgstr ""
"Він повинен повертати нове посилання в разі успіху або ``NULL`` із "
"встановленим винятком у випадку невдачі."

#: ../../c-api/structures.rst:485
msgid ""
"``set`` functions take two :c:type:`PyObject*` parameters (the instance and "
"the value to be set) and a function pointer (the associated ``closure``)::"
msgstr ""
"Функції ``set`` приймають два параметри :c:type:`PyObject*` (екземпляр і "
"значення, яке потрібно встановити) і покажчик на функцію (пов’язане "
"``closure``)::"

#: ../../c-api/structures.rst:490
msgid ""
"In case the attribute should be deleted the second parameter is ``NULL``. "
"Should return ``0`` on success or ``-1`` with a set exception on failure."
msgstr ""
"У випадку, якщо атрибут потрібно видалити, другим параметром є ``NULL``. Має "
"повертати ``0`` у разі успіху або ``-1`` із встановленим винятком у випадку "
"невдачі."
