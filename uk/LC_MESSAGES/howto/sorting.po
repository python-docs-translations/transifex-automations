# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2023
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-10 16:06+0000\n"
"PO-Revision-Date: 2022-11-05 17:21+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2023\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../howto/sorting.rst:4
msgid "Sorting HOW TO"
msgstr "Сортування ЯК"

#: ../../howto/sorting.rst:0
msgid "Author"
msgstr "Автор"

#: ../../howto/sorting.rst:6
msgid "Andrew Dalke and Raymond Hettinger"
msgstr "Andrew Dalke та Raymond Hettinger"

#: ../../howto/sorting.rst:0
msgid "Release"
msgstr "Реліз"

#: ../../howto/sorting.rst:7
msgid "0.1"
msgstr "0,1"

#: ../../howto/sorting.rst:10
msgid ""
"Python lists have a built-in :meth:`list.sort` method that modifies the list "
"in-place.  There is also a :func:`sorted` built-in function that builds a "
"new sorted list from an iterable."
msgstr ""
"Списки Python мають вбудований метод :meth:`list.sort`, який змінює список "
"на місці. Існує також вбудована функція :func:`sorted`, яка створює новий "
"відсортований список із ітерованого."

#: ../../howto/sorting.rst:14
msgid ""
"In this document, we explore the various techniques for sorting data using "
"Python."
msgstr ""
"У цьому документі ми досліджуємо різні техніки сортування даних за допомогою "
"Python."

#: ../../howto/sorting.rst:18
msgid "Sorting Basics"
msgstr "Основи сортування"

#: ../../howto/sorting.rst:20
msgid ""
"A simple ascending sort is very easy: just call the :func:`sorted` function. "
"It returns a new sorted list:"
msgstr ""
"Просте сортування за зростанням дуже просте: просто викличте функцію :func:"
"`sorted`. Він повертає новий відсортований список:"

#: ../../howto/sorting.rst:28
msgid ""
"You can also use the :meth:`list.sort` method. It modifies the list in-place "
"(and returns ``None`` to avoid confusion). Usually it's less convenient "
"than :func:`sorted` - but if you don't need the original list, it's slightly "
"more efficient."
msgstr ""
"Ви також можете використовувати метод :meth:`list.sort`. Він змінює список "
"на місці (і повертає ``None``, щоб уникнути плутанини). Зазвичай це менш "
"зручно, ніж :func:`sorted`, але якщо вам не потрібен оригінальний список, це "
"трохи ефективніше."

#: ../../howto/sorting.rst:40
msgid ""
"Another difference is that the :meth:`list.sort` method is only defined for "
"lists. In contrast, the :func:`sorted` function accepts any iterable."
msgstr ""
"Ще одна відмінність полягає в тому, що метод :meth:`list.sort` визначено "
"лише для списків. На відміну від цього, функція :func:`sorted` приймає будь-"
"яку ітерацію."

#: ../../howto/sorting.rst:49
msgid "Key Functions"
msgstr "Ключові функції"

#: ../../howto/sorting.rst:51
msgid ""
"Both :meth:`list.sort` and :func:`sorted` have a *key* parameter to specify "
"a function (or other callable) to be called on each list element prior to "
"making comparisons."
msgstr ""
"І :meth:`list.sort`, і :func:`sorted` мають параметр *key* для вказівки "
"функції (або іншого виклику), яка буде викликана для кожного елемента списку "
"перед проведенням порівнянь."

#: ../../howto/sorting.rst:55
msgid "For example, here's a case-insensitive string comparison:"
msgstr "Наприклад, ось порівняння рядків без урахування регістру:"

#: ../../howto/sorting.rst:62
msgid ""
"The value of the *key* parameter should be a function (or other callable) "
"that takes a single argument and returns a key to use for sorting purposes. "
"This technique is fast because the key function is called exactly once for "
"each input record."
msgstr ""
"Значення параметра *key* має бути функцією (або іншою можливістю виклику), "
"яка приймає один аргумент і повертає ключ для використання в цілях "
"сортування. Ця техніка є швидкою, оскільки ключова функція викликається "
"рівно один раз для кожного вхідного запису."

#: ../../howto/sorting.rst:67
msgid ""
"A common pattern is to sort complex objects using some of the object's "
"indices as keys. For example:"
msgstr ""
"Загальним шаблоном є сортування складних об’єктів за допомогою деяких "
"індексів об’єктів як ключів. Наприклад:"

#: ../../howto/sorting.rst:80
msgid ""
"The same technique works for objects with named attributes. For example:"
msgstr ""
"Така ж техніка працює для об’єктів з іменованими атрибутами. Наприклад:"

#: ../../howto/sorting.rst:101
msgid "Operator Module Functions"
msgstr "Функції модуля оператора"

#: ../../howto/sorting.rst:103
msgid ""
"The key-function patterns shown above are very common, so Python provides "
"convenience functions to make accessor functions easier and faster. The :mod:"
"`operator` module has :func:`~operator.itemgetter`, :func:`~operator."
"attrgetter`, and a :func:`~operator.methodcaller` function."
msgstr ""
"Наведені вище шаблони клавіш-функцій дуже поширені, тому Python надає зручні "
"функції, щоб зробити функції доступу простішими та швидшими. Модуль :mod:"
"`operator` має :func:`~operator.itemgetter`, :func:`~operator.attrgetter` і "
"функцію :func:`~operator.methodcaller`."

#: ../../howto/sorting.rst:108
msgid "Using those functions, the above examples become simpler and faster:"
msgstr ""
"Використовуючи ці функції, наведені вище приклади стають простішими та "
"швидшими:"

#: ../../howto/sorting.rst:120
msgid ""
"The operator module functions allow multiple levels of sorting. For example, "
"to sort by *grade* then by *age*:"
msgstr ""
"Функції модуля оператора дозволяють сортувати кілька рівнів. Наприклад, щоб "
"відсортувати за *класом*, а потім за *віком*:"

#: ../../howto/sorting.rst:132
msgid "Ascending and Descending"
msgstr "Висхідний і спадний"

#: ../../howto/sorting.rst:134
msgid ""
"Both :meth:`list.sort` and :func:`sorted` accept a *reverse* parameter with "
"a boolean value. This is used to flag descending sorts. For example, to get "
"the student data in reverse *age* order:"
msgstr ""
"І :meth:`list.sort`, і :func:`sorted` приймають параметр *reverse* із "
"логічним значенням. Це використовується для позначення сортування за "
"спаданням. Наприклад, щоб отримати дані про студентів у зворотному порядку "
"*віку*:"

#: ../../howto/sorting.rst:147
msgid "Sort Stability and Complex Sorts"
msgstr "Стійкість сортування та складні сорти"

#: ../../howto/sorting.rst:149
msgid ""
"Sorts are guaranteed to be `stable <https://en.wikipedia.org/wiki/"
"Sorting_algorithm#Stability>`_\\. That means that when multiple records have "
"the same key, their original order is preserved."
msgstr ""
"Сортування гарантовано буде `стабільним <https://en.wikipedia.org/wiki/"
"Sorting_algorithm#Stability>`_\\. Це означає, що коли кілька записів мають "
"однаковий ключ, їхній початковий порядок зберігається."

#: ../../howto/sorting.rst:159
msgid ""
"Notice how the two records for *blue* retain their original order so that "
"``('blue', 1)`` is guaranteed to precede ``('blue', 2)``."
msgstr ""
"Зверніть увагу, як два записи для *blue* зберігають свій початковий порядок, "
"тому ``('blue', 1)`` гарантовано передує ``('blue', 2)``."

#: ../../howto/sorting.rst:162
msgid ""
"This wonderful property lets you build complex sorts in a series of sorting "
"steps. For example, to sort the student data by descending *grade* and then "
"ascending *age*, do the *age* sort first and then sort again using *grade*:"
msgstr ""
"Ця чудова властивість дозволяє вам створювати складні сорти за допомогою "
"серії кроків сортування. Наприклад, щоб відсортувати дані студента за "
"зменшенням *оцінки*, а потім за зростанням *віку*, спочатку виконайте "
"сортування за *віком*, а потім знову за допомогою *оцінки*:"

#: ../../howto/sorting.rst:172
msgid ""
"This can be abstracted out into a wrapper function that can take a list and "
"tuples of field and order to sort them on multiple passes."
msgstr ""
"Це можна абстрагувати у функцію-обгортку, яка може брати список і кортежі "
"полів і впорядковувати їх, щоб сортувати їх за кілька проходів."

#: ../../howto/sorting.rst:185
msgid ""
"The `Timsort <https://en.wikipedia.org/wiki/Timsort>`_ algorithm used in "
"Python does multiple sorts efficiently because it can take advantage of any "
"ordering already present in a dataset."
msgstr ""
"Алгоритм `Timsort <https://en.wikipedia.org/wiki/Timsort>`_, що "
"використовується в Python, ефективно виконує багаторазове сортування, "
"оскільки він може використовувати будь-яке впорядкування, яке вже є в наборі "
"даних."

#: ../../howto/sorting.rst:190
msgid "The Old Way Using Decorate-Sort-Undecorate"
msgstr ""
"Старий спосіб за допомогою \"Прикрасити-Сортувати-Скасувати декорування\"."

#: ../../howto/sorting.rst:192
msgid "This idiom is called Decorate-Sort-Undecorate after its three steps:"
msgstr "Ця ідіома називається Decorate-Sort-Undecorate після трьох кроків:"

#: ../../howto/sorting.rst:194
msgid ""
"First, the initial list is decorated with new values that control the sort "
"order."
msgstr ""
"По-перше, початковий список прикрашається новими значеннями, які контролюють "
"порядок сортування."

#: ../../howto/sorting.rst:196
msgid "Second, the decorated list is sorted."
msgstr "По-друге, оформлений список сортується."

#: ../../howto/sorting.rst:198
msgid ""
"Finally, the decorations are removed, creating a list that contains only the "
"initial values in the new order."
msgstr ""
"Нарешті, декорації видаляються, створюючи список, який містить лише "
"початкові значення в новому порядку."

#: ../../howto/sorting.rst:201
msgid ""
"For example, to sort the student data by *grade* using the DSU approach:"
msgstr ""
"Наприклад, щоб відсортувати дані студента за *класом* за допомогою підходу "
"DSU:"

#: ../../howto/sorting.rst:208
msgid ""
"This idiom works because tuples are compared lexicographically; the first "
"items are compared; if they are the same then the second items are compared, "
"and so on."
msgstr ""
"Ця ідіома працює, тому що кортежі порівнюються лексикографічно; порівнюються "
"перші предмети; якщо вони однакові, то порівнюються другі елементи і так "
"далі."

#: ../../howto/sorting.rst:212
msgid ""
"It is not strictly necessary in all cases to include the index *i* in the "
"decorated list, but including it gives two benefits:"
msgstr ""
"Не обов’язково в усіх випадках включати індекс *i* в оформлений список, але "
"це дає дві переваги:"

#: ../../howto/sorting.rst:215
msgid ""
"The sort is stable -- if two items have the same key, their order will be "
"preserved in the sorted list."
msgstr ""
"Сортування є стабільним — якщо два елементи мають однаковий ключ, їхній "
"порядок буде збережено у відсортованому списку."

#: ../../howto/sorting.rst:218
msgid ""
"The original items do not have to be comparable because the ordering of the "
"decorated tuples will be determined by at most the first two items. So for "
"example the original list could contain complex numbers which cannot be "
"sorted directly."
msgstr ""
"Оригінальні елементи не обов’язково мають бути порівнянними, тому що порядок "
"оформлених кортежів визначатиметься щонайбільше першими двома елементами. "
"Так, наприклад, вихідний список може містити комплексні числа, які неможливо "
"відсортувати безпосередньо."

#: ../../howto/sorting.rst:223
msgid ""
"Another name for this idiom is `Schwartzian transform <https://en.wikipedia."
"org/wiki/Schwartzian_transform>`_\\, after Randal L. Schwartz, who "
"popularized it among Perl programmers."
msgstr ""
"Інша назва цієї ідіоми — `перетворення Шварца <https://en.wikipedia.org/wiki/"
"Schwartzian_transform>`_\\, на честь Рендала Л. Шварца, який популяризував "
"її серед програмістів на Perl."

#: ../../howto/sorting.rst:227
msgid ""
"Now that Python sorting provides key-functions, this technique is not often "
"needed."
msgstr ""
"Тепер, коли сортування Python надає ключові функції, ця техніка не часто "
"потрібна."

#: ../../howto/sorting.rst:231
msgid "The Old Way Using the *cmp* Parameter"
msgstr "Старий спосіб з використанням параметра *cmp*"

#: ../../howto/sorting.rst:233
msgid ""
"Many constructs given in this HOWTO assume Python 2.4 or later. Before that, "
"there was no :func:`sorted` builtin and :meth:`list.sort` took no keyword "
"arguments. Instead, all of the Py2.x versions supported a *cmp* parameter to "
"handle user specified comparison functions."
msgstr ""
"Багато конструкцій, наведених у цьому HOWTO, припускають Python 2.4 або "
"новішої версії. До цього не було вбудованого :func:`sorted`, а :meth:`list."
"sort` не приймав ключових аргументів. Замість цього всі версії Py2.x "
"підтримували параметр *cmp* для обробки визначених користувачем функцій "
"порівняння."

#: ../../howto/sorting.rst:238
msgid ""
"In Py3.0, the *cmp* parameter was removed entirely (as part of a larger "
"effort to simplify and unify the language, eliminating the conflict between "
"rich comparisons and the :meth:`__cmp__` magic method)."
msgstr ""
"У Py3.0 параметр *cmp* було повністю видалено (як частина більших зусиль зі "
"спрощення та уніфікації мови, усунення конфлікту між розширеними "
"порівняннями та магічним методом :meth:`__cmp__`)."

#: ../../howto/sorting.rst:242
msgid ""
"In Py2.x, sort allowed an optional function which can be called for doing "
"the comparisons. That function should take two arguments to be compared and "
"then return a negative value for less-than, return zero if they are equal, "
"or return a positive value for greater-than. For example, we can do:"
msgstr ""
"У Py2.x сортування допускає додаткову функцію, яку можна викликати для "
"порівняння. Ця функція має приймати два аргументи для порівняння, а потім "
"повертати від’ємне значення для меншого, повертати нуль, якщо вони рівні, "
"або повертати додатне значення для більшого. Наприклад, ми можемо зробити:"

#: ../../howto/sorting.rst:254
msgid "Or you can reverse the order of comparison with:"
msgstr "Або ви можете змінити порядок порівняння:"

#: ../../howto/sorting.rst:263
msgid ""
"When porting code from Python 2.x to 3.x, the situation can arise when you "
"have the user supplying a comparison function and you need to convert that "
"to a key function. The following wrapper makes that easy to do:"
msgstr ""
"Під час перенесення коду з Python 2.x на 3.x може виникнути ситуація, коли "
"користувач надає функцію порівняння, а вам потрібно перетворити її на "
"ключову функцію. Це легко зробити за допомогою наступної оболонки:"

#: ../../howto/sorting.rst:294
msgid "To convert to a key function, just wrap the old comparison function:"
msgstr ""
"Щоб перетворити на ключову функцію, просто оберніть стару функцію порівняння:"

#: ../../howto/sorting.rst:305
msgid ""
"In Python 3.2, the :func:`functools.cmp_to_key` function was added to the :"
"mod:`functools` module in the standard library."
msgstr ""
"У Python 3.2 функція :func:`functools.cmp_to_key` була додана до модуля :mod:"
"`functools` стандартної бібліотеки."

#: ../../howto/sorting.rst:309
msgid "Odd and Ends"
msgstr ""

#: ../../howto/sorting.rst:311
msgid ""
"For locale aware sorting, use :func:`locale.strxfrm` for a key function or :"
"func:`locale.strcoll` for a comparison function."
msgstr ""
"Для сортування з урахуванням локалі використовуйте :func:`locale.strxfrm` "
"для функції ключа або :func:`locale.strcoll` для функції порівняння."

#: ../../howto/sorting.rst:314
msgid ""
"The *reverse* parameter still maintains sort stability (so that records with "
"equal keys retain the original order). Interestingly, that effect can be "
"simulated without the parameter by using the builtin :func:`reversed` "
"function twice:"
msgstr ""
"Параметр *reverse* усе ще підтримує стабільність сортування (щоб записи з "
"однаковими ключами зберігали вихідний порядок). Цікаво, що цей ефект можна "
"моделювати без параметра, використовуючи двічі вбудовану функцію :func:"
"`reversed`:"

#: ../../howto/sorting.rst:328
msgid ""
"The sort routines use ``<`` when making comparisons between two objects. So, "
"it is easy to add a standard sort order to a class by defining an :meth:"
"`__lt__` method:"
msgstr ""
"Процедури сортування використовують ``<`` під час порівняння між двома "
"об’єктами. Отже, легко додати стандартний порядок сортування до класу, "
"визначивши метод :meth:`__lt__`:"

#: ../../howto/sorting.rst:338
msgid ""
"However, note that ``<`` can fall back to using :meth:`__gt__` if :meth:"
"`__lt__` is not implemented (see :func:`object.__lt__`)."
msgstr ""
"Однак зауважте, що ``<`` може повернутися до використання :meth:`__gt__`, "
"якщо :meth:`__lt__` не реалізовано (див. :func:`object.__lt__`)."

#: ../../howto/sorting.rst:341
msgid ""
"Key functions need not depend directly on the objects being sorted. A key "
"function can also access external resources. For instance, if the student "
"grades are stored in a dictionary, they can be used to sort a separate list "
"of student names:"
msgstr ""
"Ключові функції не повинні безпосередньо залежати від об’єктів, які "
"сортуються. Ключова функція також може отримувати доступ до зовнішніх "
"ресурсів. Наприклад, якщо оцінки студентів зберігаються в словнику, їх можна "
"використовувати для сортування окремого списку імен студентів:"
